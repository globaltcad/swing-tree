<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAbstractTextComponent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">com.globaltcad.swingtree</a> &gt; <span class="el_source">UIForAbstractTextComponent.java</span></div><h1>UIForAbstractTextComponent.java</h1><pre class="source lang-java linenums">package com.globaltcad.swingtree;


import com.globaltcad.swingtree.api.UIAction;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.*;
import java.awt.*;
import java.util.function.Consumer;

/**
 *  A swing tree builder node for {@link JTextComponent} instances.
 */
public abstract class UIForAbstractTextComponent&lt;I, C extends JTextComponent&gt; extends UIForAbstractSwing&lt;I, C&gt;
{
    private UIAction&lt;RemoveDelegate&gt; remove;
    private UIAction&lt;InsertDelegate&gt; insert;
    private UIAction&lt;ReplaceDelegate&gt; replace;

    /**
     *  A custom document filter which is simply a lambda-rization wrapper which ought to make
     *  the implementation of custom callbacks more convenient, because the user does not have to implement
     *  all the methods provided by the {@link DocumentFilter}, but can simply pass a lambda for either one
     *  of them.
     */
<span class="fc" id="L27">    private final DocumentFilter filter = new DocumentFilter()</span>
<span class="fc" id="L28">    {</span>
        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void remove(FilterBypass fb, int offset, int length) throws BadLocationException {
<span class="nc bnc" id="L33" title="All 2 branches missed.">            if ( remove != null ) remove.accept( new RemoveDelegate(_component, fb, offset, length) );</span>
<span class="nc" id="L34">            else fb.remove(offset, length);</span>
<span class="nc" id="L35">        }</span>
        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
<span class="nc bnc" id="L40" title="All 2 branches missed.">            if ( insert != null ) insert.accept( new InsertDelegate(_component, fb, offset, string.length(), string, attr) );</span>
<span class="nc" id="L41">            else fb.insertString(offset, string, attr);</span>
<span class="nc" id="L42">        }</span>
        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
<span class="nc bnc" id="L47" title="All 2 branches missed.">            if ( replace != null ) replace.accept(new ReplaceDelegate(_component, fb, offset, length, text, attrs));</span>
<span class="nc" id="L48">            else fb.replace(offset, length, text, attrs);</span>
<span class="nc" id="L49">        }</span>
    };

<span class="fc" id="L52">    protected UIForAbstractTextComponent(C component) { super(component); }</span>

    /**
     * Sets the text of the wrapped &lt;code&gt;{@link TextComponent}&lt;/code&gt;
     * to the specified text. If the text is &lt;code&gt;null&lt;/code&gt;
     * or empty, has the effect of simply deleting the old text.
     * When text has been inserted, the resulting caret location
     * is determined by the implementation of the caret class.
     *
     * &lt;p&gt;
     * Note that text is not a bound property, so no {@link java.beans.PropertyChangeEvent}
     * is fired when it changes. To listen for changes to the text,
     * register action lambdas through {@link #onTextChange(Consumer)} or
     * use {@link DocumentListener} directly.
     * &lt;/p&gt;
     *
     * @param text The new text to be set for the wrapped text component type.
     * @return This very builder to allow for method chaining.
     */
    public final I withText(String text) {
<span class="fc" id="L72">        _component.setText(text);</span>
<span class="fc" id="L73">        return (I) this;</span>
    }

    /**
     * The provided {@link UI.HorizontalDirection} translates to {@link ComponentOrientation}
     * instances which are used to align the elements or text within the wrapped {@link JTextComponent}.
     * {@link LayoutManager} and {@link Component}
     * subclasses will use this property to
     * determine how to lay out and draw components.
     * &lt;p&gt;
     * Note: This method indirectly changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param direction The text orientation type which should be used.
     * @return This very builder to allow for method chaining.
     */
    public final I withTextOrientation(UI.HorizontalDirection direction) {
<span class="fc" id="L90">        LogUtil.nullArgCheck(direction, &quot;direction&quot;, UI.HorizontalDirection.class);</span>
<span class="fc" id="L91">        _component.setComponentOrientation(direction.forTextOrientation());</span>
<span class="fc" id="L92">        return (I) this;</span>
    }

    /**
     *  Use this to modify the components' modifiability.
     *
     * @param isEditable The flag determining if the underlying {@link JTextComponent} should be editable or not.
     * @return This very builder to allow for method chaining.
     */
    public final I isEditableIf(boolean isEditable) {
<span class="fc" id="L102">        _component.setEditable(isEditable);</span>
<span class="fc" id="L103">        return (I) this;</span>
    }


    /**
     *  Use this to register any change in the contents of the text component including both
     *  the displayed text and its attributes.
     *
     * @param action An action which will be executed when the text or its attributes in the underlying {@link JTextComponent} changes.
     * @return This very builder to allow for method chaining.
     */
    public final I onContentChange(Consumer&lt;SimpleDelegate&lt;JTextComponent, DocumentEvent&gt;&gt; action) {
<span class="nc" id="L115">        _component.getDocument().addDocumentListener(new DocumentListener() {</span>
<span class="nc" id="L116">            @Override public void insertUpdate(DocumentEvent e) {action.accept(new SimpleDelegate&lt;&gt;(_component, e, ()-&gt;getSiblinghood()));}</span>
<span class="nc" id="L117">            @Override public void removeUpdate(DocumentEvent e) {action.accept(new SimpleDelegate&lt;&gt;(_component, e, ()-&gt;getSiblinghood()));}</span>
<span class="nc" id="L118">            @Override public void changedUpdate(DocumentEvent e) {action.accept(new SimpleDelegate&lt;&gt;(_component, e, ()-&gt;getSiblinghood()));}</span>
        });
<span class="nc" id="L120">        return (I) this;</span>
    }

    /**
     *  Use this to register if the text in this text component changes.
     *  This does not include style attributes like font size.
     *
     * @param action An action which will be executed when the text string in the underlying {@link JTextComponent} changes.
     * @return This very builder to allow for method chaining.
     */
    public final I onTextChange(Consumer&lt;SimpleDelegate&lt;JTextComponent, DocumentEvent&gt;&gt; action) {
<span class="nc" id="L131">        _component.getDocument().addDocumentListener(new DocumentListener() {</span>
<span class="nc" id="L132">            @Override public void insertUpdate(DocumentEvent e) {action.accept(new SimpleDelegate&lt;&gt;(_component, e, ()-&gt;getSiblinghood()));}</span>
<span class="nc" id="L133">            @Override public void removeUpdate(DocumentEvent e) {action.accept(new SimpleDelegate&lt;&gt;(_component, e, ()-&gt;getSiblinghood()));}</span>
<span class="nc" id="L134">            @Override public void changedUpdate(DocumentEvent e) {}</span>
        });
<span class="nc" id="L136">        return (I) this;</span>
    }

    /**
     * @param action An action which will be executed in case the underlying
     *               component supports text filtering (The underlying document is an {@link AbstractDocument}).
     */
    private void ifFilterable(Runnable action) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if ( _component.getDocument() instanceof AbstractDocument ) {</span>
<span class="nc" id="L145">            action.run();</span>
<span class="nc" id="L146">            AbstractDocument doc = (AbstractDocument)_component.getDocument();</span>
<span class="nc" id="L147">            doc.setDocumentFilter(filter);</span>
        }
<span class="nc" id="L149">    }</span>

    /**
     * @param action A {@link UIAction} lambda which will be called when parts (or all) of the text in
     *               the underlying text component gets removed.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextRemove(UIAction&lt;RemoveDelegate&gt; action) {
<span class="nc" id="L158">        ifFilterable( () -&gt; this.remove = action );</span>
<span class="nc" id="L159">        return (I) this;</span>
    }

    /**
     * @param action A {@link UIAction} lambda which will be called when new text gets inserted
     *               into the underlying text component.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextInsert(UIAction&lt;InsertDelegate&gt; action) {
<span class="nc" id="L169">        ifFilterable( () -&gt; this.insert = action );</span>
<span class="nc" id="L170">        return (I) this;</span>
    }

    /**
     * @param action A {@link UIAction} lambda which will be called when the text in
     *               the underlying text component gets replaced.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextReplace(UIAction&lt;ReplaceDelegate&gt; action) {
<span class="nc" id="L180">        ifFilterable( () -&gt; this.replace = action );</span>
<span class="nc" id="L181">        return (I) this;</span>
    }


    public static abstract class AbstractDelegate
    {
        private final JTextComponent textComponent;
        private final DocumentFilter.FilterBypass filterBypass;
        private final int offset;
        private final int length;

<span class="nc" id="L192">        protected AbstractDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length) {</span>
<span class="nc" id="L193">            this.textComponent = textComponent;</span>
<span class="nc" id="L194">            this.filterBypass = filterBypass;</span>
<span class="nc" id="L195">            this.offset = offset;</span>
<span class="nc" id="L196">            this.length = length;</span>
<span class="nc" id="L197">        }</span>

<span class="nc" id="L199">        public JTextComponent getTextComponent() { return textComponent; }</span>
<span class="nc" id="L200">        public DocumentFilter.FilterBypass getFilterBypass() { return filterBypass; }</span>
<span class="nc" id="L201">        public int getOffset() { return offset; }</span>
<span class="nc" id="L202">        public int getLength() { return length; }</span>
    }

    public static final class RemoveDelegate extends AbstractDelegate
    {
        private RemoveDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length) {
<span class="nc" id="L208">            super(textComponent, filterBypass, offset, length);</span>
<span class="nc" id="L209">        }</span>
    }

    public static final class InsertDelegate extends AbstractDelegate
    {
        private final String text;
        private final AttributeSet attributeSet;

        private InsertDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) {
<span class="nc" id="L218">            super(textComponent, filterBypass, offset, length);</span>
<span class="nc" id="L219">            this.text = text;</span>
<span class="nc" id="L220">            this.attributeSet = attributeSet;</span>
<span class="nc" id="L221">        }</span>
<span class="nc" id="L222">        public String text() { return text; }</span>
<span class="nc" id="L223">        public AttributeSet attributeSet() { return attributeSet; }</span>
    }

    public static final class ReplaceDelegate extends AbstractDelegate
    {
        private final String text;
        private final AttributeSet attributeSet;

        private ReplaceDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) {
<span class="nc" id="L232">            super(textComponent, filterBypass, offset, length);</span>
<span class="nc" id="L233">            this.text = text;</span>
<span class="nc" id="L234">            this.attributeSet = attributeSet;</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">        public String getText() { return text; }</span>
<span class="nc" id="L237">        public AttributeSet getAttributeSet() { return attributeSet; }</span>
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>