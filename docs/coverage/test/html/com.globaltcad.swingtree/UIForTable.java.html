<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">com.globaltcad.swingtree</a> &gt; <span class="el_source">UIForTable.java</span></div><h1>UIForTable.java</h1><pre class="source lang-java linenums">package com.globaltcad.swingtree;

import com.globaltcad.swingtree.api.Buildable;
import com.globaltcad.swingtree.api.model.BasicTableModel;
import com.globaltcad.swingtree.api.model.TableListDataSource;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;
import java.util.ArrayList;
import java.util.List;

public class UIForTable&lt;T extends JTable&gt; extends UIForAbstractSwing&lt;UIForTable&lt;T&gt;, T&gt;
{
    /**
     * Extensions of the {@link  UIForAbstractSwing} always wrap
     * a single component for which they are responsible.
     *
     * @param component The JComponent type which will be wrapped by this builder node.
     */
    public UIForTable(T component) {
<span class="fc" id="L24">        super(component);</span>
<span class="fc" id="L25">    }</span>

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts the builder API for a cell renderer.
     *
     * @param columnName The name of the column for which the cell renderer will be built.
     * @param renderBuilder The builder API for a cell renderer.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn(String columnName, Render.Builder&lt;JTable, ?&gt; renderBuilder) {
<span class="fc" id="L35">        LogUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, Render.Builder.class);</span>
<span class="fc" id="L36">        return withRendererForColumn(columnName, renderBuilder.getForTable());</span>
    }

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts the builder API for a cell renderer.
     *
     * @param columnIndex The index of the column for which the cell renderer will be built.
     * @param renderBuilder The builder API for a cell renderer.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn(int columnIndex, Render.Builder&lt;JTable, ?&gt; renderBuilder) {
<span class="fc" id="L47">        LogUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, Render.Builder.class);</span>
<span class="fc" id="L48">        return withRendererForColumn(columnIndex, renderBuilder.getForTable());</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column.
     * @param columnName The name of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn(String columnName, TableCellRenderer renderer) {
<span class="fc" id="L57">        LogUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="fc" id="L58">        LogUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L59">        _component.getColumn(columnName).setCellRenderer(renderer);</span>
<span class="fc" id="L60">        return this;</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column.
     * @param columnIndex The index of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn(int columnIndex, TableCellRenderer renderer) {
<span class="fc" id="L69">        LogUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L70">        _component.getColumnModel().getColumn(columnIndex).setCellRenderer(renderer);</span>
<span class="fc" id="L71">        return this;</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * @param columnName The name of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn(String columnName, TableCellEditor editor) {
<span class="nc" id="L80">        LogUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="nc" id="L81">        LogUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L82">        _component.getColumn(columnName).setCellEditor(editor);</span>
<span class="nc" id="L83">        return this;</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * @param columnIndex The index of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn(int columnIndex, TableCellEditor editor) {
<span class="nc" id="L92">        LogUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L93">        _component.getColumnModel().getColumn(columnIndex).setCellEditor(editor);</span>
<span class="nc" id="L94">        return this;</span>
    }

    /**
     *  Use this to set a table model.
     *  The provided argument is a builder object whose build method will be called
     *  for you instead of having to call the build method on the builder object yourself.
     * @param dataModelBuilder The builder object which will be used to build and then set the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel(Buildable&lt;BasicTableModel&gt; dataModelBuilder) {
<span class="fc" id="L105">        return this.withModel(dataModelBuilder.build());</span>
    }

    /**
     * Use this to set a table model.
     * @param model The model for the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel(BasicTableModel model) {
<span class="fc" id="L114">        LogUtil.nullArgCheck(model, &quot;model&quot;, BasicTableModel.class);</span>
<span class="fc" id="L115">        _component.setModel(model);</span>
<span class="fc" id="L116">        return this;</span>
    }

    /**
     *  Use this instead of {@link JTable#setModel(TableModel)} if your table data can be represented through
     *  either a row major {@link List} of {@link List}s of entry {@link Object}s (a list of rows)      &lt;br&gt;
     *  or a columns major {@link List} of {@link List}s of entry {@link Object}s (a list of columns).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *
     * @param model An enum which configures the layout as well as modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableListDataSource} returning a list matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; with(UI.TableData model, TableListDataSource&lt;E&gt; dataSource) {
<span class="fc" id="L131">        boolean isRowMajor = model.isRowMajor();</span>
<span class="fc" id="L132">        boolean isEditable = model.isEditable();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if ( isRowMajor ) {</span>
<span class="fc" id="L134">            _component.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L135">            {</span>
<span class="fc" id="L136">                @Override public int getRowCount() { return getData().size(); }</span>
                @Override public int getColumnCount() {
<span class="fc" id="L138">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                    return (data.isEmpty() ? 0 : data.get(0).size());</span>
                }
                @Override public Object getValueAt(int rowIndex, int columnIndex) {
<span class="fc" id="L142">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                    if (isNotWithinBounds(rowIndex, columnIndex)) return null;</span>
<span class="fc" id="L144">                    return data.get(rowIndex).get(columnIndex);</span>
                }
                @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L147">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L148" title="All 4 branches missed.">                    if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L149">                    data.get(rowIndex).set(columnIndex, (E)aValue);</span>
<span class="nc" id="L150">                }</span>
            });
        } else { // isColumnMajor
<span class="fc" id="L153">            _component.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L154">            {</span>
                @Override public int getRowCount() {
<span class="fc" id="L156">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">                    return (data.isEmpty() ? 0 : data.get(0).size());</span>
                }
<span class="fc" id="L159">                @Override public int getColumnCount() { return getData().size(); }</span>
                @Override public Object getValueAt(int rowIndex, int columnIndex) {
<span class="fc" id="L161">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                    if (isNotWithinBounds(rowIndex, columnIndex)) return null;</span>
<span class="fc" id="L163">                    return data.get(columnIndex).get(rowIndex);</span>
                }
                @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L166">                    List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">                    if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L168">                    data.get(columnIndex).set(rowIndex, (E)aValue);</span>
<span class="nc" id="L169">                }</span>
            });
        }
<span class="fc" id="L172">        return this;</span>
    }

    private static abstract class ListBasedTableModel&lt;E&gt; extends AbstractTableModel {

        private final TableListDataSource&lt;E&gt; dataSource;
        private final boolean isEditable;


<span class="fc" id="L181">        ListBasedTableModel(boolean isEditable, TableListDataSource&lt;E&gt; dataSource) {</span>
<span class="fc" id="L182">            this.isEditable = isEditable;</span>
<span class="fc" id="L183">            this.dataSource = dataSource;</span>
<span class="fc" id="L184">        }</span>

<span class="nc" id="L186">        @Override public boolean isCellEditable(int rowIndex, int columnIndex) { return this.isEditable; }</span>

        protected List&lt;List&lt;E&gt;&gt; getData() {
<span class="fc" id="L189">            List&lt;List&lt;E&gt;&gt; data = dataSource.get();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            if ( data == null ) return new ArrayList&lt;&gt;(); // We really don't want null pointer in UIs.</span>
<span class="fc" id="L191">            return data;</span>
        }
        protected boolean isNotWithinBounds(int rowIndex, int colIndex) {
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= getRowCount()     ) return true;</span>
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">            if ( colIndex &lt; 0 || colIndex &gt;= getColumnCount()  ) return true;</span>
<span class="fc" id="L196">            return false;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>