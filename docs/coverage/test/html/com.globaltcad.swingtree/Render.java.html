<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Render.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">com.globaltcad.swingtree</a> &gt; <span class="el_source">Render.java</span></div><h1>Render.java</h1><pre class="source lang-java linenums">package com.globaltcad.swingtree;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.*;

/**
 * 	An API for building extensions of the {@link DefaultTableCellRenderer} in a functional style.
 */
public final class Render&lt;C extends JComponent,E&gt; {

	private final Class&lt;C&gt; componentType;
	private final Class&lt;E&gt; elementType;
	private final Supplier&lt;Border&gt; borderSupplier;

	static &lt;E&gt; Render&lt;JList&lt;E&gt;,E&gt; forList(Class&lt;E&gt; elementType, Supplier&lt;Border&gt; borderSupplier) {
<span class="nc" id="L23">		Render r = new Render&lt;&gt;(JComboBox.class, elementType, borderSupplier);</span>
<span class="nc" id="L24">		return (Render&lt;JList&lt;E&gt;,E&gt;) r;</span>
	}
	static &lt;E&gt; Render&lt;JComboBox&lt;E&gt;,E&gt; forCombo(Class&lt;E&gt; elementType, Supplier&lt;Border&gt; borderSupplier) {
<span class="nc" id="L27">		Render r = new Render&lt;&gt;(JComboBox.class, elementType, borderSupplier);</span>
<span class="nc" id="L28">		return (Render&lt;JComboBox&lt;E&gt;,E&gt;) r;</span>
	}
	static &lt;E&gt; Render&lt;JTable,E&gt; forTable(Class&lt;E&gt; elementType, Supplier&lt;Border&gt; borderSupplier) {
<span class="fc" id="L31">		Render r = new Render&lt;&gt;(JTable.class, elementType, borderSupplier);</span>
<span class="fc" id="L32">		return (Render&lt;JTable,E&gt;) r;</span>
	}

<span class="fc" id="L35">	private Render(Class&lt;C&gt; componentType, Class&lt;E&gt; elementType, Supplier&lt;Border&gt; borderSupplier) {</span>
<span class="fc" id="L36">		this.componentType = componentType;</span>
<span class="fc" id="L37">		this.elementType = elementType;</span>
<span class="fc" id="L38">		this.borderSupplier = borderSupplier;</span>
<span class="fc" id="L39">	}</span>

	/**
	 * 	Use this to specify which type of values should have custom rendering.
	 *
	 * @param valueType The type of cell value, for which you want custom rendering.
	 * @param &lt;T&gt; The type parameter of the cell value, for which you want custom rendering.
	 * @return The {@link As} builder API step which expects you to provide a lambda for customizing how a cell is rendered.
	 */
	public &lt;T extends E&gt; As&lt;C,E,T&gt; when(Class&lt;T&gt; valueType) {
<span class="fc" id="L49">		LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L50">		return when( valueType, cell -&gt; true );</span>
	}

	/**
	 * 	Use this to specify which type of values should have custom rendering.
	 *
	 * @param valueType The type of cell value, for which you want custom rendering.
	 * @param valueValidator A condition which ought to be met for the custom rendering to be applied to the value.
	 * @param &lt;T&gt; The type parameter of the cell value, for which you want custom rendering.
	 * @return The {@link As} builder API step which expects you to provide a lambda for customizing how a cell is rendered.
	 */
	public &lt;T extends E&gt; As&lt;C,E,T&gt; when(
			Class&lt;T&gt; valueType,
			Predicate&lt;Cell&lt;C,T&gt;&gt; valueValidator
	) {
<span class="fc" id="L65">		LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L66">		LogUtil.nullArgCheck(valueValidator, &quot;valueValidator&quot;, Predicate.class);</span>
<span class="fc" id="L67">		return new As&lt;C,E,T&gt;() {</span>
			@Override
			public Builder&lt;C,E&gt; as(Cell.Interpreter&lt;C,T&gt; valueInterpreter) {
<span class="fc" id="L70">				LogUtil.nullArgCheck(valueInterpreter, &quot;valueInterpreter&quot;, Cell.Interpreter.class);</span>
<span class="fc" id="L71">				return new Builder(componentType,valueType, valueValidator, valueInterpreter, borderSupplier);</span>
			}
		};
	}

	/**
	 * 	This interface models an individual table cell alongside
	 * 	various properties that a cell should have, like for example
	 * 	the value of the cell, its position within the table
	 * 	as well as a renderer in the form of a AWT {@link Component}
	 * 	which may or not be replaced or modified.
	 *
	 * @param &lt;V&gt; The value type of the entry of this {@link Cell}.
	 */
	public interface Cell&lt;C extends JComponent, V&gt;
	{
		C           getComponent();
		V	    	getValue();
		boolean 	isSelected();
		boolean 	hasFocus();
		int     	getRow();
		int     	getColumn();
		Component   getRenderer();
		void        setRenderer(Component component);
		void        setToolTip(String toolTip);
		void        setDefaultRenderValue(Object newValue);
		default void setRenderer(Consumer&lt;Graphics2D&gt; painter) {
<span class="nc" id="L98">			setRenderer(new Component() {</span>
				@Override
				public void paint(Graphics g) {
<span class="nc" id="L101">					super.paint(g);</span>
<span class="nc" id="L102">					painter.accept((Graphics2D) g);</span>
<span class="nc" id="L103">				}</span>
			});
<span class="nc" id="L105">		}</span>

		@FunctionalInterface
		interface Interpreter&lt;C extends JComponent, V&gt; {

			void interpret(Cell&lt;C, V&gt; cell);

		}
	}


	public interface As&lt;C extends JComponent, E, T extends E&gt; {
		/**
		 * 	Specify a lambda which receives a {@link Cell} instance
		 * 	for you to customize its renderer.
		 *
		 * @param valueInterpreter A lambda which customizes the provided cell.
		 * @return The builder API allowing method chaining.
		 */
		Builder&lt;C, E&gt; as( Cell.Interpreter&lt;C,T&gt; valueInterpreter );

		default Builder&lt;C, E&gt; asComponent(Function&lt;Cell&lt;C,T&gt;, Component&gt; renderer) {
<span class="nc" id="L127">			return this.as( cell -&gt; cell.setRenderer(renderer.apply(cell)) );</span>
		}

		default Builder&lt;C, E&gt; asText(Function&lt;Cell&lt;C,T&gt;, String&gt; renderer) {
<span class="nc" id="L131">			return this.as( cell -&gt; cell.setRenderer(new JLabel(renderer.apply(cell))) );</span>
		}

		default Builder&lt;C, E&gt; render(BiConsumer&lt;Cell&lt;C,T&gt;, Graphics2D&gt; renderer) {
<span class="nc" id="L135">			return this.as( cell -&gt; cell.setRenderer(new JComponent(){</span>
				@Override public void paintComponent(Graphics g) {
					try {
<span class="nc" id="L138">						renderer.accept(cell, (Graphics2D) g);</span>
<span class="nc" id="L139">					} catch (Exception e) {</span>
<span class="nc" id="L140">						e.printStackTrace();</span>
<span class="nc" id="L141">					}</span>
<span class="nc" id="L142">				}</span>
			}) );
		}


	}

	/**
	 * 	A builder for building simple customized {@link javax.swing.table.TableCellRenderer}!
	 */
	public static class Builder&lt;C extends JComponent, E&gt; {

		private final Class&lt;C&gt; componentType;
		private final Supplier&lt;Border&gt; border;
<span class="fc" id="L156">		private final Map&lt;Class&lt;?&gt;, java.util.List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt;&gt; rendererLoopup = new LinkedHashMap&lt;&gt;(16);</span>

		public Builder(
				Class&lt;C&gt; componentType,
				Class&lt;E&gt; valueType,
				Predicate&lt;Cell&lt;C,E&gt;&gt; valueValidator,
				Cell.Interpreter&lt;C, E&gt; valueInterpreter,
				Supplier&lt;Border&gt; border
<span class="fc" id="L164">		) {</span>
<span class="fc" id="L165">			LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L166">			LogUtil.nullArgCheck(valueValidator, &quot;valueValidator&quot;, Predicate.class);</span>
<span class="fc" id="L167">			LogUtil.nullArgCheck(valueInterpreter, &quot;valueInterpreter&quot;, Cell.Interpreter.class);</span>
<span class="fc" id="L168">			this.componentType = componentType;</span>
<span class="fc" id="L169">			this.border = border;</span>
<span class="fc" id="L170">			when(valueType, valueValidator).as(valueInterpreter);</span>
<span class="fc" id="L171">		}</span>

		public &lt;T extends E&gt; As&lt;C,E,T&gt; when(Class&lt;T&gt; valueType) {
<span class="fc" id="L174">			LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L175">			return when( valueType, cell -&gt; true );</span>
		}

		public &lt;T extends E&gt; As&lt;C,E,T&gt; when(
				Class&lt;T&gt; valueType,
				Predicate&lt;Cell&lt;C,T&gt;&gt; valueValidator
		) {
<span class="fc" id="L182">			LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L183">			LogUtil.nullArgCheck(valueValidator, &quot;valueValidator&quot;, Predicate.class);</span>
<span class="fc" id="L184">			return new As&lt;C,E,T&gt;() {</span>
				@Override
				public Builder&lt;C,E&gt; as(Cell.Interpreter&lt;C,T&gt; valueInterpreter) {
<span class="fc" id="L187">					LogUtil.nullArgCheck(valueInterpreter, &quot;valueInterpreter&quot;, Cell.Interpreter.class);</span>
<span class="fc" id="L188">					store(valueType, valueValidator, valueInterpreter);</span>
<span class="fc" id="L189">					return (Builder&lt;C, E&gt;) Builder.this;</span>
				}
			};
		}

		private void store(
			Class valueType,
			Predicate predicate,
			Cell.Interpreter valueInterpreter
		) {
<span class="fc" id="L199">			LogUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L200">			LogUtil.nullArgCheck(predicate, &quot;predicate&quot;, Predicate.class);</span>
<span class="fc" id="L201">			LogUtil.nullArgCheck(valueInterpreter, &quot;valueInterpreter&quot;, Cell.Interpreter.class);</span>
<span class="fc" id="L202">			List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt; found = rendererLoopup.computeIfAbsent(valueType, k -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L203">			found.add( cell -&gt; {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">				if ( predicate.test(cell) )</span>
<span class="fc" id="L205">					valueInterpreter.interpret(cell);</span>
<span class="fc" id="L206">			} );</span>
<span class="fc" id="L207">		}</span>

<span class="fc" id="L209">		private class SimpleTableCellRenderer extends DefaultTableCellRenderer</span>
		{
			@Override
			public Component getTableCellRendererComponent(
					JTable table,
					Object value,
					boolean isSelected,
					boolean hasFocus,
					final int row,
					int column
			) {
<span class="fc" id="L220">				List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt; interpreter = find(value, rendererLoopup);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">				if ( interpreter.isEmpty() )</span>
<span class="nc" id="L222">					return super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);</span>
				else {
<span class="fc" id="L224">					Component[] componentRef = new Component[1];</span>
<span class="fc" id="L225">					Object[] defaultValueRef = new Object[1];</span>
<span class="fc" id="L226">					List&lt;String&gt; toolTips = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L227">					Cell&lt;JTable,Object&gt; cell = new Cell&lt;JTable,Object&gt;() {</span>
<span class="nc" id="L228">						@Override public JTable getComponent() {return table;}</span>
<span class="nc" id="L229">						@Override public Object getValue() {return value;}</span>
<span class="nc" id="L230">						@Override public boolean isSelected() {return isSelected;}</span>
<span class="nc" id="L231">						@Override public boolean hasFocus() {return hasFocus;}</span>
<span class="nc" id="L232">						@Override public int getRow() {return row;}</span>
<span class="nc" id="L233">						@Override public int getColumn() {return column;}</span>
<span class="nc" id="L234">						@Override public Component getRenderer() {return SimpleTableCellRenderer.super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);}</span>
<span class="nc" id="L235">						@Override public void setRenderer(Component component) {componentRef[0] = component;}</span>
<span class="nc" id="L236">						@Override public void setToolTip(String toolTip) { toolTips.add(toolTip);}</span>

<span class="nc" id="L238">						@Override public void setDefaultRenderValue(Object newValue) {defaultValueRef[0] = newValue;}</span>
					};
<span class="fc" id="L240">					interpreter.forEach(consumer -&gt; consumer.accept((Cell&lt;C,?&gt;)cell) );</span>
					Component choice;
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">					if ( componentRef[0] != null )</span>
<span class="nc" id="L243">						choice = componentRef[0];</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">					else if ( defaultValueRef[0] != null )</span>
<span class="nc" id="L245">						choice = super.getTableCellRendererComponent(table, defaultValueRef[0], isSelected, hasFocus, row, column);</span>
					else
<span class="fc" id="L247">						choice = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);</span>

<span class="pc bpc" id="L249" title="3 of 4 branches missed.">					if ( !toolTips.isEmpty() &amp;&amp; choice instanceof JComponent )</span>
<span class="nc" id="L250">						((JComponent)choice).setToolTipText(String.join(&quot;; &quot;, toolTips));</span>

<span class="fc" id="L252">					return choice;</span>
				}
			}

			@Override
			public Border getBorder() {
<span class="nc bnc" id="L258" title="All 2 branches missed.">				if ( border != null ) return border.get();</span>
				else
<span class="nc" id="L260">					return super.getBorder();</span>
			}
		}

<span class="nc" id="L264">		private class SimpleListCellRenderer&lt;T&gt; extends DefaultListCellRenderer {</span>
			@Override
			public Component getListCellRendererComponent(
					JList list,
					Object value,
					final int row,
					boolean isSelected,
					boolean hasFocus
			) {
<span class="nc" id="L273">				List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt; interpreter = find(value, rendererLoopup);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">				if ( interpreter.isEmpty() )</span>
<span class="nc" id="L275">					return super.getListCellRendererComponent(list, value, row, isSelected, hasFocus);</span>
				else {
<span class="nc" id="L277">					Component[] componentRef = new Component[1];</span>
<span class="nc" id="L278">					Object[] defaultValueRef = new Object[1];</span>
<span class="nc" id="L279">					List&lt;String&gt; toolTips = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L280">					Cell&lt;JList&lt;T&gt;,Object&gt; cell = new Cell&lt;JList&lt;T&gt;, Object&gt;() {</span>
<span class="nc" id="L281">						@Override public JList&lt;T&gt; getComponent() {return list;}</span>
<span class="nc" id="L282">						@Override public Object getValue() {return value;}</span>
<span class="nc" id="L283">						@Override public boolean isSelected() {return isSelected;}</span>
<span class="nc" id="L284">						@Override public boolean hasFocus() {return hasFocus;}</span>
<span class="nc" id="L285">						@Override public int getRow() {return row;}</span>
<span class="nc" id="L286">						@Override public int getColumn() {return 0;}</span>
<span class="nc" id="L287">						@Override public Component getRenderer() {return SimpleListCellRenderer.super.getListCellRendererComponent(list, value, row, isSelected, hasFocus);}</span>
<span class="nc" id="L288">						@Override public void setRenderer(Component component) {componentRef[0] = component;}</span>
<span class="nc" id="L289">						@Override public void setToolTip(String toolTip) { toolTips.add(toolTip);}</span>
<span class="nc" id="L290">						@Override public void setDefaultRenderValue(Object newValue) {defaultValueRef[0] = newValue;}</span>
					};
<span class="nc" id="L292">					interpreter.forEach(consumer -&gt; consumer.accept((Cell&lt;C,?&gt;)cell) );</span>
					Component choice;
<span class="nc bnc" id="L294" title="All 2 branches missed.">					if ( componentRef[0] != null )</span>
<span class="nc" id="L295">						choice = componentRef[0];</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">					else if ( defaultValueRef[0] != null )</span>
<span class="nc" id="L297">						choice = super.getListCellRendererComponent(list, defaultValueRef[0], row, isSelected, hasFocus);</span>
					else
<span class="nc" id="L299">						choice = super.getListCellRendererComponent(list, value, row, isSelected, hasFocus);</span>

<span class="nc bnc" id="L301" title="All 4 branches missed.">					if ( !toolTips.isEmpty() &amp;&amp; choice instanceof JComponent )</span>
<span class="nc" id="L302">						((JComponent)choice).setToolTipText(String.join(&quot;; &quot;, toolTips));</span>

<span class="nc" id="L304">					return choice;</span>
				}
			}
			@Override
			public Border getBorder() {
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if ( border != null ) return border.get();</span>
				else
<span class="nc" id="L311">					return super.getBorder();</span>
			}
		}

		private static &lt;C extends JComponent&gt; List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt; find(
				Object value, Map&lt;Class&lt;?&gt;, java.util.List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt;&gt; rendererLookup
		) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">			Class&lt;?&gt; type = ( value == null ? Object.class : value.getClass() );</span>
<span class="fc" id="L319">			List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt; cellRenderer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">			for (Map.Entry&lt;Class&lt;?&gt;, List&lt;Consumer&lt;Cell&lt;C,?&gt;&gt;&gt;&gt; e : rendererLookup.entrySet()) {</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">				if ( e.getKey().isAssignableFrom(type) )</span>
<span class="fc" id="L322">					cellRenderer.addAll(e.getValue());</span>
<span class="fc" id="L323">			}</span>
<span class="fc" id="L324">			return cellRenderer;</span>
		}

		DefaultTableCellRenderer getForTable() {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">			if ( JTable.class.isAssignableFrom(componentType) )</span>
<span class="fc" id="L329">				return new SimpleTableCellRenderer();</span>
			else
<span class="nc" id="L331">				throw new IllegalArgumentException(&quot;Renderer was set up to be used for a JTable!&quot;);</span>
		}

		ListCellRenderer&lt;E&gt; getForList() {
<span class="nc bnc" id="L335" title="All 4 branches missed.">			if ( JList.class.isAssignableFrom(componentType) || JComboBox.class.isAssignableFrom(componentType) )</span>
<span class="nc" id="L336">				return (ListCellRenderer&lt;E&gt;) new SimpleListCellRenderer&lt;Object&gt;();</span>
			else
<span class="nc" id="L338">				throw new IllegalArgumentException(&quot;Renderer was set up to be used for a JList or JComboBox! (not &quot;+componentType.getSimpleName()+&quot;)&quot;);</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>