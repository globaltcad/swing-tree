<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResponsiveGridFlowLayout.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.layout</a> &gt; <span class="el_source">ResponsiveGridFlowLayout.java</span></div><h1>ResponsiveGridFlowLayout.java</h1><pre class="source lang-java linenums">
package swingtree.layout;

import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import swingtree.UI;

import javax.swing.JComponent;
import java.awt.*;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * A flow layout arranges components in a directional flow, much
 * like lines of text in a paragraph.
 */
public final class ResponsiveGridFlowLayout implements LayoutManager2 {

    private static final int NUMBER_OF_COLUMNS = 12;
<span class="fc" id="L24">    private static final Logger log = LoggerFactory.getLogger(ResponsiveGridFlowLayout.class);</span>

    private UI.HorizontalAlignment _alignmentCode;
    private int                    _horizontalGapSize;
    private int                    _verticalGapSize;
    private boolean                _alignOnBaseline;

    /**
     * Constructs a new {@code FlowLayout} with a centered alignment and a
     * default 5-unit horizontal and vertical gap.
     */
    public ResponsiveGridFlowLayout() {
<span class="fc" id="L36">        this(UI.HorizontalAlignment.CENTER, 5, 5);</span>
<span class="fc" id="L37">    }</span>

    /**
     * Constructs a new {@code FlowLayout} with the specified
     * alignment and a default 5-unit horizontal and vertical gap.
     * The value of the alignment argument must be one of
     * {@code FlowLayout.LEFT}, {@code FlowLayout.RIGHT},
     * {@code FlowLayout.CENTER}, {@code FlowLayout.LEADING},
     * or {@code FlowLayout.TRAILING}.
     *
     * @param align the alignment value
     */
    public ResponsiveGridFlowLayout(UI.HorizontalAlignment align) {
<span class="nc" id="L50">        this(align, 5, 5);</span>
<span class="nc" id="L51">    }</span>

    /**
     * Creates a new flow layout manager with the indicated alignment
     * and the indicated horizontal and vertical gaps.
     * &lt;p&gt;
     * The value of the alignment argument must be one of
     * {@code FlowLayout.LEFT}, {@code FlowLayout.RIGHT},
     * {@code FlowLayout.CENTER}, {@code FlowLayout.LEADING},
     * or {@code FlowLayout.TRAILING}.
     *
     * @param align the alignment value
     * @param horizontalGapSize  the horizontal gap between components
     *              and between the components and the
     *              borders of the {@code Container}
     * @param verticalGapSize  the vertical gap between components
     *              and between the components and the
     *              borders of the {@code Container}
     */
    public ResponsiveGridFlowLayout(
        UI.HorizontalAlignment align,
        int horizontalGapSize,
        int verticalGapSize
<span class="fc" id="L74">    ) {</span>
<span class="fc" id="L75">        _alignmentCode     = align;</span>
<span class="fc" id="L76">        _horizontalGapSize = horizontalGapSize;</span>
<span class="fc" id="L77">        _verticalGapSize   = verticalGapSize;</span>
<span class="fc" id="L78">    }</span>

    /**
     * Gets the alignment for this layout.
     * Possible values are {@code UI.HorizontalAlignment.LEFT},
     * {@code UI.HorizontalAlignment.RIGHT}, {@code UI.HorizontalAlignment.CENTER},
     * {@code UI.HorizontalAlignment.LEADING},
     * or {@code UI.HorizontalAlignment.TRAILING}.
     *
     * @return the alignment value for this layout
     * @see #setAlignment
     */
    public UI.HorizontalAlignment getAlignment() {
<span class="fc" id="L91">        return _alignmentCode;</span>
    }

    /**
     * Sets the alignment for this layout.
     * Possible values are
     * &lt;ul&gt;
     * &lt;li&gt;{@code UI.HorizontalAlignment.LEFT}
     * &lt;li&gt;{@code UI.HorizontalAlignment.RIGHT}
     * &lt;li&gt;{@code UI.HorizontalAlignment.CENTER}
     * &lt;li&gt;{@code UI.HorizontalAlignment.LEADING}
     * &lt;li&gt;{@code UI.HorizontalAlignment.TRAILING}
     * &lt;/ul&gt;
     *
     * @param align one of the alignment values shown above
     * @see #getAlignment()
     */
    public void setAlignment(UI.HorizontalAlignment align) {
<span class="nc" id="L109">        _alignmentCode = align;</span>
<span class="nc" id="L110">    }</span>

    /**
     * Gets the horizontal gap between components
     * and between the components and the borders
     * of the {@code Container}
     *
     * @return the horizontal gap between components
     * and between the components and the borders
     * of the {@code Container}
     * @see ResponsiveGridFlowLayout#setHorizontalGapSize(int)
     */
    public int horizontalGapSize() {
<span class="fc" id="L123">        return UI.scale(_horizontalGapSize);</span>
    }

    /**
     * Sets the horizontal gap between components and
     * between the components and the borders of the
     * {@code Container}.
     *
     * @param size the horizontal gap between components
     *             and between the components and the borders
     *             of the {@code Container}
     * @see ResponsiveGridFlowLayout#horizontalGapSize()
     */
    public void setHorizontalGapSize(int size) {
<span class="nc" id="L137">        _horizontalGapSize = size;</span>
<span class="nc" id="L138">    }</span>

    /**
     * Gets the vertical gap between components and
     * between the components and the borders of the
     * {@code Container}.
     *
     * @return the vertical gap between components
     * and between the components and the borders
     * of the {@code Container}
     * @see ResponsiveGridFlowLayout#setVerticalGapSize(int)
     */
    public int verticalGapSize() {
<span class="fc" id="L151">        return UI.scale(_verticalGapSize);</span>
    }

    /**
     * Sets the vertical gap between components and between
     * the components and the borders of the {@code Container}.
     *
     * @param size the vertical gap between components
     *             and between the components and the borders
     *             of the {@code Container}
     * @see ResponsiveGridFlowLayout#verticalGapSize()
     */
    public void setVerticalGapSize(int size) {
<span class="nc" id="L164">        _verticalGapSize = size;</span>
<span class="nc" id="L165">    }</span>

    /**
     * Sets whether or not components should be vertically aligned along their
     * baseline.  Components that do not have a baseline will be centered.
     * The default is false.
     *
     * @param alignOnBaseline whether or not components should be
     *                        vertically aligned on their baseline
     */
    public void setAlignOnBaseline(boolean alignOnBaseline) {
<span class="nc" id="L176">        this._alignOnBaseline = alignOnBaseline;</span>
<span class="nc" id="L177">    }</span>

    /**
     * Returns true if components are to be vertically aligned along
     * their baseline.  The default is false.
     *
     * @return true if components are to be vertically aligned along
     * their baseline
     */
    public boolean getAlignOnBaseline() {
<span class="fc" id="L187">        return _alignOnBaseline;</span>
    }

    /**
     * Adds the specified component to the layout.
     * Not used by this class.
     *
     * @param name the name of the component
     * @param comp the component to be added
     */
    @Override
    public void addLayoutComponent( String name, Component comp ) {
<span class="nc" id="L199">    }</span>

    /**
     * Removes the specified component from the layout.
     * Not used by this class.
     *
     * @param comp the component to remove
     * @see java.awt.Container#removeAll
     */
    @Override
    public void removeLayoutComponent( Component comp ) {
<span class="nc" id="L210">    }</span>

    /**
     * Returns the preferred dimensions for this layout given the
     * &lt;i&gt;visible&lt;/i&gt; components in the specified target container.
     *
     * @param target the container that needs to be laid out
     * @return the preferred dimensions to lay out the
     * subcomponents of the specified container
     * @see java.awt.Container
     * @see #minimumLayoutSize
     * @see java.awt.Container#getPreferredSize
     */
    @Override
    public Dimension preferredLayoutSize( Container target ) {
<span class="nc" id="L225">        synchronized (target.getTreeLock()) {</span>
<span class="nc" id="L226">            Dimension dim = new Dimension(0, 0);</span>
<span class="nc" id="L227">            int nmembers = target.getComponentCount();</span>
<span class="nc" id="L228">            boolean firstVisibleComponent = true;</span>
<span class="nc" id="L229">            boolean useBaseline = getAlignOnBaseline();</span>
<span class="nc" id="L230">            int maxAscent = 0;</span>
<span class="nc" id="L231">            int maxDescent = 0;</span>
<span class="nc" id="L232">            int hgap = UI.scale(_horizontalGapSize);</span>
<span class="nc" id="L233">            int vgap = UI.scale(_verticalGapSize);</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (int i = 0; i &lt; nmembers; i++) {</span>
<span class="nc" id="L236">                Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                if (m.isVisible()) {</span>
<span class="nc" id="L238">                    Dimension d = m.getPreferredSize();</span>
<span class="nc" id="L239">                    dim.height = Math.max(dim.height, d.height);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    if (firstVisibleComponent) {</span>
<span class="nc" id="L241">                        firstVisibleComponent = false;</span>
                    } else {
<span class="nc" id="L243">                        dim.width += hgap;</span>
                    }
<span class="nc" id="L245">                    dim.width += d.width;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                    if (useBaseline) {</span>
<span class="nc" id="L247">                        int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                        if (baseline &gt;= 0) {</span>
<span class="nc" id="L249">                            maxAscent = Math.max(maxAscent, baseline);</span>
<span class="nc" id="L250">                            maxDescent = Math.max(maxDescent, d.height - baseline);</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (useBaseline) {</span>
<span class="nc" id="L256">                dim.height = Math.max(maxAscent + maxDescent, dim.height);</span>
            }
<span class="nc" id="L258">            Insets insets = target.getInsets();</span>
<span class="nc" id="L259">            dim.width += insets.left + insets.right + hgap * 2;</span>
<span class="nc" id="L260">            dim.height += insets.top + insets.bottom + vgap * 2;</span>
<span class="nc" id="L261">            return dim;</span>
        }
    }

    /**
     * Returns the minimum dimensions needed to layout the &lt;i&gt;visible&lt;/i&gt;
     * components contained in the specified target container.
     *
     * @param target the container that needs to be laid out
     * @return the minimum dimensions to lay out the
     * subcomponents of the specified container
     * @see #preferredLayoutSize
     * @see java.awt.Container
     * @see java.awt.Container#doLayout
     */
    @Override
    public Dimension minimumLayoutSize( Container target ) {
<span class="nc" id="L278">        synchronized (target.getTreeLock()) {</span>
<span class="nc" id="L279">            boolean useBaseline = getAlignOnBaseline();</span>
<span class="nc" id="L280">            Dimension dim = new Dimension(0, 0);</span>
<span class="nc" id="L281">            int nmembers = target.getComponentCount();</span>
<span class="nc" id="L282">            int maxAscent = 0;</span>
<span class="nc" id="L283">            int maxDescent = 0;</span>
<span class="nc" id="L284">            boolean firstVisibleComponent = true;</span>
<span class="nc" id="L285">            int hgap = UI.scale(_horizontalGapSize);</span>
<span class="nc" id="L286">            int vgap = UI.scale(_verticalGapSize);</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">            for (int i = 0; i &lt; nmembers; i++) {</span>
<span class="nc" id="L289">                Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (m.isVisible()) {</span>
<span class="nc" id="L291">                    Dimension d = m.getMinimumSize();</span>
<span class="nc" id="L292">                    dim.height = Math.max(dim.height, d.height);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                    if (firstVisibleComponent) {</span>
<span class="nc" id="L294">                        firstVisibleComponent = false;</span>
                    } else {
<span class="nc" id="L296">                        dim.width += hgap;</span>
                    }
<span class="nc" id="L298">                    dim.width += d.width;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                    if (useBaseline) {</span>
<span class="nc" id="L300">                        int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                        if (baseline &gt;= 0) {</span>
<span class="nc" id="L302">                            maxAscent = Math.max(maxAscent, baseline);</span>
<span class="nc" id="L303">                            maxDescent = Math.max(maxDescent,</span>
                                    dim.height - baseline);
                        }
                    }
                }
            }

<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (useBaseline) {</span>
<span class="nc" id="L311">                dim.height = Math.max(maxAscent + maxDescent, dim.height);</span>
            }

<span class="nc" id="L314">            Insets insets = target.getInsets();</span>
<span class="nc" id="L315">            dim.width += insets.left + insets.right + hgap * 2;</span>
<span class="nc" id="L316">            dim.height += insets.top + insets.bottom + vgap * 2;</span>
<span class="nc" id="L317">            return dim;</span>
        }
    }

    /**
     * Centers the elements in the specified row, if there is any slack.
     *
     * @param target      the component which needs to be moved
     * @param cells       an array of cells, one for each component of the target
     * @param x           the x coordinate
     * @param y           the y coordinate
     * @param width       the width dimensions
     * @param height      the height dimensions
     * @param rowStart    the beginning of the row
     * @param rowEnd      the ending of the row
     * @param useBaseline Whether or not to align on baseline.
     * @param ascent      Ascent for the components. This is only valid if
     *                    useBaseline is true.
     * @param descent     Ascent for the components. This is only valid if
     *                    useBaseline is true.
     * @return actual row height
     */
    private int moveComponents(
            Container target, Cell[] cells,
            int x, int y, int width, int height,
            int rowStart, int rowEnd, boolean ltr,
            boolean useBaseline, @Nullable int[] ascent,
            @Nullable int[] descent
    ) {
<span class="fc" id="L346">        int hgap = UI.scale(_horizontalGapSize);</span>
<span class="pc bpc" id="L347" title="3 of 6 branches missed.">        switch (_alignmentCode) {</span>
            case LEFT:
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                x += ltr ? 0 : width;</span>
<span class="fc" id="L350">                break;</span>
            case CENTER:
<span class="fc" id="L352">                x += width / 2;</span>
<span class="fc" id="L353">                break;</span>
            case RIGHT:
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">                x += ltr ? width : 0;</span>
<span class="fc" id="L356">                break;</span>
            case LEADING:
<span class="nc" id="L358">                break;</span>
            case TRAILING:
<span class="nc" id="L360">                x += width;</span>
                break;
        }
<span class="fc" id="L363">        int maxAscent = 0;</span>
<span class="fc" id="L364">        int nonbaselineHeight = 0;</span>
<span class="fc" id="L365">        int baselineOffset = 0;</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (useBaseline) {</span>
<span class="nc" id="L367">            Objects.requireNonNull(ascent);</span>
<span class="nc" id="L368">            Objects.requireNonNull(descent);</span>
<span class="nc" id="L369">            int maxDescent = 0;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            for (int i = rowStart; i &lt; rowEnd; i++) {</span>
<span class="nc" id="L371">                Component m = target.getComponent(i);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (m.isVisible()) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    if (ascent[i] &gt;= 0) {</span>
<span class="nc" id="L374">                        maxAscent = Math.max(maxAscent, ascent[i]);</span>
<span class="nc" id="L375">                        maxDescent = Math.max(maxDescent, descent[i]);</span>
                    } else {
<span class="nc" id="L377">                        nonbaselineHeight = Math.max(m.getHeight(),</span>
                                nonbaselineHeight);
                    }
                }
            }
<span class="nc" id="L382">            height = Math.max(maxAscent + maxDescent, nonbaselineHeight);</span>
<span class="nc" id="L383">            baselineOffset = (height - maxAscent - maxDescent) / 2;</span>
        }
<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (int i = rowStart; i &lt; rowEnd; i++) {</span>
<span class="fc" id="L386">            Component m = target.getComponent(i);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">            if (m.isVisible()) {</span>
<span class="fc" id="L388">                Optional&lt;FlowCellConf&gt; optionalFlowCellConf = cells[i].flowCell();</span>
<span class="fc" id="L389">                boolean fillHeight = optionalFlowCellConf.map(FlowCellConf::fill).orElse(false);</span>
<span class="fc" id="L390">                UI.VerticalAlignment verticalAlignment = optionalFlowCellConf.map(FlowCellConf::verticalAlignment).orElse(UI.VerticalAlignment.CENTER);</span>
                int cy;
<span class="pc bpc" id="L392" title="5 of 6 branches missed.">                if (ascent != null &amp;&amp; useBaseline &amp;&amp; ascent[i] &gt;= 0) {</span>
<span class="nc" id="L393">                    cy = y + baselineOffset + maxAscent - ascent[i];</span>
                } else {
<span class="fc bfc" id="L395" title="All 2 branches covered.">                    if (fillHeight) {</span>
<span class="fc" id="L396">                        cy = y;</span>
                    } else {
<span class="fc bfc" id="L398" title="All 2 branches covered.">                        if ( verticalAlignment == UI.VerticalAlignment.TOP )</span>
<span class="fc" id="L399">                            cy = y;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                        else if ( verticalAlignment == UI.VerticalAlignment.BOTTOM )</span>
<span class="fc" id="L401">                            cy = y + height - m.getHeight();</span>
                        else // centered:
<span class="fc" id="L403">                            cy = y + (height - m.getHeight()) / 2;</span>
                    }
                }
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                if (ltr) {</span>
<span class="fc" id="L407">                    m.setLocation(x, cy);</span>
                } else {
<span class="nc" id="L409">                    m.setLocation(target.getWidth() - x - m.getWidth(), cy);</span>
                }
<span class="fc" id="L411">                x += m.getWidth() + hgap;</span>

<span class="fc bfc" id="L413" title="All 2 branches covered.">                if ( fillHeight ) {</span>
<span class="fc" id="L414">                    m.setSize(m.getWidth(), height);</span>
                }
            }
        }
<span class="fc" id="L418">        return height;</span>
    }

    /**
     * Lays out the container. This method lets each
     * &lt;i&gt;visible&lt;/i&gt; component take
     * its preferred size by reshaping the components in the
     * target container in order to satisfy the alignment of
     * this layout manager.
     *
     * @param target the specified component being laid out
     * @see Container
     * @see java.awt.Container#doLayout
     */
    @Override
    public void layoutContainer(Container target) {
<span class="fc" id="L434">        synchronized (target.getTreeLock()) {</span>
<span class="fc" id="L435">            final int hgap = UI.scale(_horizontalGapSize);</span>
<span class="fc" id="L436">            final int vgap = UI.scale(_verticalGapSize);</span>
<span class="fc" id="L437">            final Insets insets = target.getInsets();</span>
<span class="fc" id="L438">            final int maxwidth = target.getWidth() - (insets.left + insets.right + hgap * 2);</span>
<span class="fc" id="L439">            final int generalMaxWidth = target.getPreferredSize().width - (insets.left + insets.right + hgap * 2);</span>
<span class="fc" id="L440">            final int nmembers = target.getComponentCount();</span>
<span class="fc" id="L441">            int x = 0, y = insets.top + vgap;</span>
<span class="fc" id="L442">            int rowh = 0, start = 0;</span>

<span class="fc" id="L444">            Cell[] cells = _createCells(target, nmembers, maxwidth, generalMaxWidth);</span>

<span class="fc" id="L446">            boolean ltr = target.getComponentOrientation().isLeftToRight();</span>
<span class="fc" id="L447">            boolean useBaseline = getAlignOnBaseline();</span>
<span class="fc" id="L448">            int[] ascent = null;</span>
<span class="fc" id="L449">            int[] descent = null;</span>

<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            if (useBaseline) {</span>
<span class="nc" id="L452">                ascent = new int[nmembers];</span>
<span class="nc" id="L453">                descent = new int[nmembers];</span>
            }

<span class="fc bfc" id="L456" title="All 2 branches covered.">            for (int i = 0; i &lt; nmembers; i++) {</span>
<span class="fc" id="L457">                Component m = cells[i].component();</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                if (m.isVisible()) {</span>
<span class="fc" id="L459">                    Dimension d = m.getPreferredSize();</span>
                    try {
<span class="fc" id="L461">                        d = _dimensionsFromCellConf(cells[i], maxwidth).orElse(d);</span>
<span class="nc" id="L462">                    } catch (Exception e) {</span>
<span class="nc" id="L463">                        log.error(&quot;Error applying cell configuration&quot;, e);</span>
<span class="fc" id="L464">                    }</span>
<span class="fc" id="L465">                    m.setSize(d.width, d.height);</span>

<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                    if (useBaseline ) {</span>
<span class="nc" id="L468">                        Objects.requireNonNull(ascent);</span>
<span class="nc" id="L469">                        Objects.requireNonNull(descent);</span>
<span class="nc" id="L470">                        int baseline = m.getBaseline(d.width, d.height);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                        if (baseline &gt;= 0) {</span>
<span class="nc" id="L472">                            ascent[i] = baseline;</span>
<span class="nc" id="L473">                            descent[i] = d.height - baseline;</span>
                        } else {
<span class="nc" id="L475">                            ascent[i] = -1;</span>
                        }
                    }
<span class="fc bfc" id="L478" title="All 4 branches covered.">                    if ((x == 0) || ((x + d.width) &lt;= maxwidth)) {</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                        if (x &gt; 0) {</span>
<span class="fc" id="L480">                            x += hgap;</span>
                        }
<span class="fc" id="L482">                        x += d.width;</span>
<span class="fc" id="L483">                        rowh = Math.max(rowh, d.height);</span>
                    } else {
<span class="fc" id="L485">                        rowh = moveComponents(</span>
                                target, cells,
                                insets.left + hgap, y,
                                maxwidth - x, rowh, start, i, ltr,
                                useBaseline, ascent, descent
                        );
<span class="fc" id="L491">                        x = d.width;</span>
<span class="fc" id="L492">                        y += vgap + rowh;</span>
<span class="fc" id="L493">                        rowh = d.height;</span>
<span class="fc" id="L494">                        start = i;</span>
                    }
                }
            }
<span class="fc" id="L498">            moveComponents(</span>
                    target, cells,
                    insets.left + hgap, y, maxwidth - x, rowh,
                    start, nmembers, ltr, useBaseline, ascent, descent
            );
<span class="fc" id="L503">        }</span>
<span class="fc" id="L504">    }</span>

    private Cell[] _createCells(
            Container target,
            int nmembers,
            int maxwidth,
            int generalMaxWidth
    ) {
<span class="fc" id="L512">        Cell[] cells = new Cell[nmembers];</span>
<span class="fc" id="L513">        AtomicInteger componentsInRow = new AtomicInteger(0);</span>
<span class="fc" id="L514">        double currentRowSize = 0;</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">        for (int i = 0; i &lt; nmembers; i++) {</span>
<span class="fc" id="L516">            Component m = target.getComponent(i);</span>
<span class="fc" id="L517">            Optional&lt;Cell&gt; optionalCell = Optional.empty();</span>
<span class="fc" id="L518">            double rowSizeIncrease = 0;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (m instanceof JComponent) {</span>
<span class="fc" id="L520">                JComponent jc = (JComponent) m;</span>
<span class="fc" id="L521">                AddConstraint addConstraint = (AddConstraint) jc.getClientProperty(AddConstraint.class);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">                if (addConstraint instanceof FlowCell) {</span>
<span class="fc" id="L523">                    FlowCell cell = (FlowCell) addConstraint;</span>
<span class="fc" id="L524">                    optionalCell = cellFromCellConf(target, cell, jc, componentsInRow, maxwidth, generalMaxWidth);</span>
<span class="fc" id="L525">                    rowSizeIncrease += optionalCell.flatMap(Cell::autoSpan)</span>
<span class="fc" id="L526">                                                    .map(FlowCellSpanPolicy::cellsToFill)</span>
<span class="fc" id="L527">                                                    .orElse(0);</span>
                }
            }
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if ( !optionalCell.isPresent() ) {</span>
<span class="fc" id="L531">                double prefComponentWidth = m.getPreferredSize().getWidth();</span>
<span class="pc bpc" id="L532" title="3 of 4 branches missed.">                if ( maxwidth &gt; 0 &amp;&amp; prefComponentWidth &gt; 0 ) {</span>
<span class="nc" id="L533">                    rowSizeIncrease += NUMBER_OF_COLUMNS * prefComponentWidth / maxwidth;</span>
                }
            }

<span class="fc" id="L537">            cells[i] = optionalCell.orElse(new Cell(m, componentsInRow, null, null));</span>

<span class="fc" id="L539">            double newRowSize = currentRowSize + rowSizeIncrease;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if ( newRowSize &lt; NUMBER_OF_COLUMNS ) {</span>
                // Still room in the row for new components...
<span class="fc" id="L542">                componentsInRow.set(componentsInRow.get() + 1);</span>
<span class="fc" id="L543">                currentRowSize += rowSizeIncrease;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            } else if ( Math.round(newRowSize) == NUMBER_OF_COLUMNS ) {</span>
                // We have a new row with no leftovers.
<span class="fc" id="L546">                componentsInRow.set(componentsInRow.get() + 1);</span>
<span class="fc" id="L547">                componentsInRow = new AtomicInteger(0);</span>
<span class="fc" id="L548">                currentRowSize = 0;</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">            } else if ( newRowSize &gt; NUMBER_OF_COLUMNS ) {</span>
                // The row does not fit the new component. We need to start a new row.
<span class="fc" id="L551">                componentsInRow = new AtomicInteger(1);</span>
<span class="fc" id="L552">                cells[i].setNumberOfComponents(componentsInRow);</span>
<span class="fc" id="L553">                currentRowSize = rowSizeIncrease; // We have a new row with the current component.</span>
            }
        }
<span class="fc" id="L556">        return cells;</span>
    }

    /**
     * Returns a string representation of this {@code FlowLayout}
     * object and its values.
     *
     * @return a string representation of this layout
     */
    public String toString() {
<span class="nc" id="L566">        String str = &quot;&quot;;</span>
<span class="nc" id="L567">        int hgap = UI.scale(_horizontalGapSize);</span>
<span class="nc" id="L568">        int vgap = UI.scale(_verticalGapSize);</span>
<span class="nc bnc" id="L569" title="All 7 branches missed.">        switch (_alignmentCode) {</span>
            case LEFT:
<span class="nc" id="L571">                str = &quot;,align=left&quot;;</span>
<span class="nc" id="L572">                break;</span>
            case CENTER:
<span class="nc" id="L574">                str = &quot;,align=center&quot;;</span>
<span class="nc" id="L575">                break;</span>
            case RIGHT:
<span class="nc" id="L577">                str = &quot;,align=right&quot;;</span>
<span class="nc" id="L578">                break;</span>
            case LEADING:
<span class="nc" id="L580">                str = &quot;,align=leading&quot;;</span>
<span class="nc" id="L581">                break;</span>
            case TRAILING:
<span class="nc" id="L583">                str = &quot;,align=trailing&quot;;</span>
<span class="nc" id="L584">                break;</span>
            case UNDEFINED:
<span class="nc" id="L586">                str = &quot;,align=?&quot;;</span>
                break;
        }
<span class="nc" id="L589">        return getClass().getName() + &quot;[horizontalGap=&quot; + hgap + &quot;,verticalGap=&quot; + vgap + str + &quot;]&quot;;</span>
    }

    @Override
    public void addLayoutComponent(Component comp, Object constraints) {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (constraints instanceof AddConstraint) {</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            if (comp instanceof JComponent) {</span>
<span class="fc" id="L596">                JComponent jc = (JComponent) comp;</span>
<span class="fc" id="L597">                jc.putClientProperty(AddConstraint.class, constraints);</span>
            }
        }
<span class="fc" id="L600">    }</span>

    @Override
    public Dimension maximumLayoutSize(Container target) {
<span class="nc" id="L604">        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);</span>
    }

    @Override
    public float getLayoutAlignmentX(Container target) {
<span class="nc" id="L609">        return 0;</span>
    }

    @Override
    public float getLayoutAlignmentY(Container target) {
<span class="nc" id="L614">        return 0;</span>
    }

    @Override
    public void invalidateLayout(Container target) {

<span class="nc" id="L620">    }</span>

    public Optional&lt;Cell&gt; cellFromCellConf(
            Component parent,
            FlowCell flowCell,
            Component child,
            AtomicInteger componentCounter,
            int maxWidth,
            int generalMaxWidth
    ) {
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">        if ( maxWidth &lt;= 0 ) {</span>
<span class="nc" id="L631">            return Optional.empty();</span>
        }
        // How much preferred width the parent actually fills:
<span class="fc" id="L634">        ParentSizeClass currentParentSizeCategory = ParentSizeClass.of(maxWidth, generalMaxWidth);</span>

<span class="fc" id="L636">        boolean shouldFillHeight = false;</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        LayoutManager childLayout = ( child instanceof JComponent ) ? ((JComponent) child).getLayout() : null;</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if ( childLayout instanceof MigLayout ) {</span>
<span class="fc" id="L639">            Object layoutConstraints = ((MigLayout) childLayout).getLayoutConstraints();</span>
            // If the child has the &quot;fill&quot; or &quot;filly&quot; constraint, we should fill the height.
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if ( layoutConstraints instanceof String ) {</span>
<span class="fc" id="L642">                String constraints = (String) layoutConstraints;</span>
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">                shouldFillHeight = constraints.contains(&quot;fill&quot;) || constraints.contains(&quot;filly&quot;);</span>
<span class="pc bnc" id="L644" title="All 2 branches missed.">            } else if ( layoutConstraints instanceof LC ) {</span>
<span class="nc" id="L645">                LC lc = (LC) layoutConstraints;</span>
<span class="nc" id="L646">                shouldFillHeight = lc.isFillY();</span>
            }
        }
<span class="fc" id="L649">        Size parentSize = Size.of(parent.getWidth(), parent.getHeight());</span>
<span class="fc" id="L650">        FlowCellConf cellConf = flowCell.fetchConfig(NUMBER_OF_COLUMNS, parentSize, currentParentSizeCategory, shouldFillHeight);</span>
<span class="fc" id="L651">        Optional&lt;FlowCellSpanPolicy&gt; autoSpan = _findNextBestAutoSpan(cellConf, currentParentSizeCategory);</span>
<span class="fc" id="L652">        return autoSpan.map(autoCellSpanPolicy -&gt; new Cell(child, componentCounter, autoCellSpanPolicy, cellConf));</span>
    }

    private Optional&lt;Dimension&gt; _dimensionsFromCellConf( Cell cell, int maxWidth ) {

<span class="fc bfc" id="L657" title="All 2 branches covered.">        if ( maxWidth &lt;= 0 ) {</span>
<span class="fc" id="L658">            return Optional.empty();</span>
        }

<span class="fc" id="L661">        Optional&lt;FlowCellSpanPolicy&gt; autoSpan = cell.autoSpan();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (!autoSpan.isPresent()) {</span>
<span class="nc" id="L663">            return Optional.empty();</span>
        }

<span class="fc" id="L666">        int cellsToFill = autoSpan.get().cellsToFill();</span>
<span class="fc" id="L667">        int unusableSpace = ((cell.numberOfComponentsInRow()-1) * UI.scale(_horizontalGapSize));</span>
<span class="fc" id="L668">        int width = ((maxWidth - unusableSpace) * cellsToFill) / NUMBER_OF_COLUMNS;</span>
<span class="fc" id="L669">        Dimension newSize = new Dimension(width, cell.component().getPreferredSize().height);</span>
<span class="fc" id="L670">        return Optional.of(newSize);</span>
    }

    private static Optional&lt;FlowCellSpanPolicy&gt; _findNextBestAutoSpan( FlowCellConf cell, ParentSizeClass targetSize ) {
<span class="fc" id="L674">        Optional&lt;FlowCellSpanPolicy&gt; autoSpan = _find(targetSize.ordinal(), cell);</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if ( autoSpan.isPresent() )</span>
<span class="fc" id="L676">            return autoSpan;</span>

        // We did not find the exact match. Let's try to find the closest match.

<span class="fc" id="L680">        int numberOfSizeClasses = ParentSizeClass.values().length;</span>
<span class="fc" id="L681">        int targetOrdinal = targetSize.ordinal();</span>
        /*
            We want to find the enum value which is closed to the target ordinal.
         */
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        int sign = ( targetSize.ordinal() &gt; numberOfSizeClasses / 2 ? 1 : -1 );</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        for ( int offset = 1; offset &lt; numberOfSizeClasses; offset++ ) {</span>
<span class="fc" id="L687">            sign = -sign;</span>
<span class="fc" id="L688">            autoSpan = _find(targetOrdinal + offset * sign, cell);</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">            if ( autoSpan.isPresent() )</span>
<span class="fc" id="L690">                return autoSpan;</span>

<span class="nc" id="L692">            sign = -sign;</span>
<span class="nc" id="L693">            autoSpan = _find(targetOrdinal + offset * sign, cell);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if ( autoSpan.isPresent() )</span>
<span class="nc" id="L695">                return autoSpan;</span>
        }
<span class="nc" id="L697">        return Optional.empty();</span>
    }

    private static Optional&lt;FlowCellSpanPolicy&gt; _find( int ordinal, FlowCellConf cell ) {
<span class="pc bpc" id="L701" title="2 of 4 branches missed.">        if ( ordinal &lt; 0 || ordinal &gt;= ParentSizeClass.values().length ) {</span>
<span class="nc" id="L702">            return Optional.empty();</span>
        }
<span class="fc" id="L704">        ParentSizeClass targetSize = ParentSizeClass.values()[ordinal];</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        for ( FlowCellSpanPolicy autoSpan : cell.autoSpans() ) {</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            if ( autoSpan.parentSize() == targetSize ) {</span>
<span class="fc" id="L707">                return Optional.of(autoSpan);</span>
            }
        }
<span class="fc" id="L710">        return Optional.empty();</span>
    }

    private static final class Cell {

        private final Component component;
        private final @Nullable FlowCellSpanPolicy autoSpan;
        private final @Nullable FlowCellConf cellConf;

        private AtomicInteger numberOfComponents;


        Cell(
                Component component,
                AtomicInteger componentCounter,
                @Nullable FlowCellSpanPolicy autoSpan,
                @Nullable FlowCellConf cellConf
<span class="fc" id="L727">        ) {</span>
<span class="fc" id="L728">            this.component          = component;</span>
<span class="fc" id="L729">            this.numberOfComponents = componentCounter;</span>
<span class="fc" id="L730">            this.autoSpan           = autoSpan;</span>
<span class="fc" id="L731">            this.cellConf           = cellConf;</span>
<span class="fc" id="L732">        }</span>

        public Component component() {
<span class="fc" id="L735">            return component;</span>
        }

        public Optional&lt;FlowCellSpanPolicy&gt; autoSpan() {
<span class="fc" id="L739">            return Optional.ofNullable(autoSpan);</span>
        }

        public Optional&lt;FlowCellConf&gt; flowCell() {
<span class="fc" id="L743">            return Optional.ofNullable(cellConf);</span>
        }

        public int numberOfComponentsInRow() {
<span class="fc" id="L747">            return numberOfComponents.get();</span>
        }

        public void setNumberOfComponents(AtomicInteger numberOfComponents) {
<span class="fc" id="L751">            this.numberOfComponents = numberOfComponents;</span>
<span class="fc" id="L752">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>