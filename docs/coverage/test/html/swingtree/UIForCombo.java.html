<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForCombo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForCombo.java</span></div><h1>UIForCombo.java</h1><pre class="source lang-java linenums">package swingtree;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.*;
import sprouts.Action;
import swingtree.api.Configurator;

import javax.swing.*;
import javax.swing.event.DocumentListener;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.Document;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.lang.ref.WeakReference;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 *  A SwingTree builder node designed for configuring {@link JComboBox} instances.
 *  &lt;p&gt;
 *  &lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 *  where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @param &lt;E&gt; The type of the items of the {@link JComboBox} that this {@link UIForCombo} is configuring.
 * @param &lt;C&gt; The type of the {@link JComboBox} that this {@link UIForCombo} is configuring.
 */
public final class UIForCombo&lt;E,C extends JComboBox&lt;E&gt;&gt; extends UIForAnySwing&lt;UIForCombo&lt;E,C&gt;, JComboBox&lt;E&gt;&gt;
{
<span class="fc" id="L34">    private static final Logger log = LoggerFactory.getLogger(UIForCombo.class);</span>
    private final BuilderState&lt;JComboBox&lt;E&gt;&gt; _state;

<span class="fc" id="L37">    UIForCombo( BuilderState&lt;JComboBox&lt;E&gt;&gt; state ) {</span>
<span class="fc" id="L38">        Objects.requireNonNull(state);</span>
<span class="fc" id="L39">        _state = state;</span>
<span class="fc" id="L40">    }</span>

    /**
     *  Builds and returns the configured {@link JComboBox} instance.
     *
     * @return The configured {@link JComboBox} instance.
     */
    public JComboBox&lt;E&gt; getComboBox() {
<span class="nc" id="L48">        return this.get(getType());</span>
    }

    @Override
    protected BuilderState&lt;JComboBox&lt;E&gt;&gt; _state() {
<span class="fc" id="L53">        return _state;</span>
    }
    
    @Override
    protected UIForCombo&lt;E,C&gt; _newBuilderWithState(BuilderState&lt;JComboBox&lt;E&gt;&gt; newState ) {
<span class="fc" id="L58">        return new UIForCombo&lt;&gt;(newState);</span>
    }

    /**
     *  Registers a listener to be notified when the combo box is opened,
     *  meaning its popup menu is shown after the user clicks on the combo box.
     *
     * @param action the action to be executed when the combo box is opened.
     * @return this
     */
    public UIForCombo&lt;E,C&gt; onOpen( Action&lt;ComponentDelegate&lt;C, PopupMenuEvent&gt;&gt; action ) {
<span class="fc" id="L69">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L70">        return _with( thisComponent -&gt; {</span>
<span class="pc" id="L71">                    _onPopupOpen(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
                        try {
<span class="nc" id="L73">                            action.accept(new ComponentDelegate&lt;&gt;((C) thisComponent, e));</span>
<span class="nc" id="L74">                        } catch (Exception ex) {</span>
<span class="nc" id="L75">                            log.error(&quot;Error while executing action on popup open!&quot;, ex);</span>
<span class="nc" id="L76">                        }</span>
<span class="nc" id="L77">                    }));</span>
<span class="fc" id="L78">                })</span>
<span class="fc" id="L79">                ._this();</span>
    }

    private void _onPopupOpen( JComboBox&lt;E&gt; thisComponent, Consumer&lt;PopupMenuEvent&gt; consumer ) {
<span class="fc" id="L83">        thisComponent.addPopupMenuListener(new PopupMenuListener() {</span>
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
                // This method is called before the popup menu becomes visible.
<span class="nc" id="L87">                consumer.accept(e);</span>
<span class="nc" id="L88">            }</span>
            @Override
<span class="nc" id="L90">            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {/* Not relevant here */}</span>
            @Override
<span class="nc" id="L92">            public void popupMenuCanceled(PopupMenuEvent e) {/* Not relevant here */}</span>
        });
<span class="fc" id="L94">    }</span>

    /**
     *  Registers a listener to be notified when the combo box is closed,
     *  meaning its popup menu is hidden after the user clicks on the combo box.
     *
     * @param action the action to be executed when the combo box is closed.
     * @return this
     */
    public UIForCombo&lt;E,C&gt; onClose( Action&lt;ComponentDelegate&lt;C, PopupMenuEvent&gt;&gt; action ) {
<span class="fc" id="L104">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L105">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L106">                    _onPopupClose(thisComponent,</span>
<span class="nc" id="L107">                        e -&gt; _runInApp(()-&gt;{</span>
                            try {
<span class="nc" id="L109">                                action.accept(new ComponentDelegate&lt;&gt;((C) thisComponent, e));</span>
<span class="nc" id="L110">                            } catch (Exception ex) {</span>
<span class="nc" id="L111">                                log.error(&quot;Error while executing action on popup close!&quot;, ex);</span>
<span class="nc" id="L112">                            }</span>
<span class="nc" id="L113">                        })</span>
                    );
<span class="fc" id="L115">                })</span>
<span class="fc" id="L116">                ._this();</span>
    }

    private void _onPopupClose( JComboBox&lt;E&gt; thisComponent, Consumer&lt;PopupMenuEvent&gt; consumer ) {
<span class="fc" id="L120">        thisComponent.addPopupMenuListener(new PopupMenuListener() {</span>
            @Override
<span class="nc" id="L122">            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {/* Not relevant here */}</span>
            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
<span class="nc" id="L125">                consumer.accept(e); // This method is called before the popup menu becomes invisible</span>
<span class="nc" id="L126">            }</span>
            @Override
<span class="nc" id="L128">            public void popupMenuCanceled(PopupMenuEvent e) {/* Not relevant here */}</span>
        });
<span class="fc" id="L130">    }</span>

    /**
     *  Registers a listener to be notified when the combo box is canceled,
     *  meaning its popup menu is hidden which
     *  typically happens when the user clicks outside the combo box.
     *
     * @param action the action to be executed when the combo box is canceled.
     * @return this
     */
    public UIForCombo&lt;E,C&gt; onCancel( Action&lt;ComponentDelegate&lt;C, PopupMenuEvent&gt;&gt; action ) {
<span class="fc" id="L141">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L142">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L143">                    _onPopupCancel(thisComponent,</span>
<span class="nc" id="L144">                        e -&gt; _runInApp(()-&gt;{</span>
                            try {
<span class="nc" id="L146">                                action.accept(new ComponentDelegate&lt;&gt;((C) thisComponent, e));</span>
<span class="nc" id="L147">                            } catch (Exception ex) {</span>
<span class="nc" id="L148">                                log.error(&quot;Error while executing action on popup cancel!&quot;, ex);</span>
<span class="nc" id="L149">                            }</span>
<span class="nc" id="L150">                        })</span>
                    );
<span class="fc" id="L152">                })</span>
<span class="fc" id="L153">                ._this();</span>
    }

    private void _onPopupCancel( JComboBox&lt;E&gt; thisComponent, Consumer&lt;PopupMenuEvent&gt; consumer ) {
<span class="fc" id="L157">        thisComponent.addPopupMenuListener(new PopupMenuListener() {</span>
            @Override
<span class="nc" id="L159">            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {/* Not relevant here */}</span>
            @Override
<span class="nc" id="L161">            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {/* Not relevant here */}</span>
            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {
<span class="nc" id="L164">                consumer.accept(e); // This method is called when the popup menu is canceled</span>
<span class="nc" id="L165">            }</span>
        });
<span class="fc" id="L167">    }</span>

    /**
     * Adds an {@link Action} to the underlying {@link JComboBox}
     * through an {@link java.awt.event.ActionListener},
     * which will be called when a selection has been made. If the combo box is editable, then
     * an {@link ActionEvent} will be fired when editing has stopped.
     * For more information see {@link JComboBox#addActionListener(ActionListener)}.
     *
     * @param action The {@link Action} that will be notified.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code action} is {@code null}.
     */
    public UIForCombo&lt;E,C&gt; onSelection( Action&lt;ComponentDelegate&lt;JComboBox&lt;E&gt;, ActionEvent&gt;&gt; action ) {
<span class="fc" id="L181">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L182">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L183">                   _onSelection(thisComponent,</span>
<span class="fc" id="L184">                       e -&gt; _runInApp(()-&gt;{</span>
                           try {
<span class="fc" id="L186">                               action.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L187">                           } catch (Exception ex) {</span>
<span class="nc" id="L188">                               log.error(&quot;Error while executing action on selection!&quot;, ex);</span>
<span class="fc" id="L189">                           }</span>
<span class="fc" id="L190">                       })</span>
                   );
<span class="fc" id="L192">               })</span>
<span class="fc" id="L193">               ._this();</span>
    }

    private void _onSelection( JComboBox&lt;E&gt; thisComponent, Consumer&lt;ActionEvent&gt; consumer ) {
        /*
            When an action event is fired, Swing will go through all the listeners
            from the most recently added to the first added. This means that if we simply add
            a listener through the &quot;addActionListener&quot; method, we will be the last to be notified.
            This is problematic because it is built on the assumption that the last listener
            added is more interested in the event than the first listener added.
            This however is an unintuitive assumption, meaning a user would expect
            the first listener added to be the most interested in the event
            simply because it was added first.
            This is especially true in the context of declarative UI design.
        */
<span class="fc" id="L208">        ActionListener[] listeners = thisComponent.getActionListeners();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (ActionListener listener : listeners)</span>
<span class="fc" id="L210">            thisComponent.removeActionListener(listener);</span>

<span class="fc" id="L212">        thisComponent.addActionListener(e -&gt; {</span>
            /*
                Unfortunately, this event is fired in all kinds of
                annoying situations, so we need to filter things that
                are only relevant to us...

                We know that when the action command is &quot;comboBoxEdited&quot;, then
                the user wrote into the text field.
                This is also fired when the user presses enter!
                So we filter the event:
            */
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if ( &quot;comboBoxEdited&quot;.equals(e.getActionCommand()) )</span>
<span class="nc" id="L224">                return;</span>

            /*
                Now another big problem is that when a user types
                something, the editor will inform our combo box model
                of the change and then the model will trigger item change listeners.
                Unfortunately, this will then cause a domino effect, because
                the combo box will consequently trigger an
                action event with the action command &quot;comboBoxChanged&quot;.
                We can filter the event by checking if it comes from
                our model:
            */
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">            if ( e.getSource() instanceof JComboBox ) {</span>
<span class="fc" id="L237">                ComboBoxModel&lt;?&gt; model = ((JComboBox&lt;?&gt;) e.getSource()).getModel();</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                if ( model instanceof AbstractComboModel ) {</span>
<span class="fc" id="L239">                    AbstractComboModel&lt;?&gt; swingTreeModel = (AbstractComboModel&lt;?&gt;) model;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                    if ( !swingTreeModel.acceptsEditorChanges() )</span>
<span class="nc" id="L241">                        return;</span>
                }
            }
<span class="fc" id="L244">            consumer.accept(e);</span>
<span class="fc" id="L245">        });</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">        for ( int i = listeners.length - 1; i &gt;= 0; i-- ) // reverse order because swing does not give us the listeners in the order they were added!</span>
<span class="fc" id="L248">            thisComponent.addActionListener(listeners[i]);</span>
<span class="fc" id="L249">    }</span>

    /**
     * Adds an {@link ActionListener} to the editor component of the underlying {@link JComboBox}
     * which will be called when a selection has been made. If the combo box is editable, then
     * an {@link ActionEvent} will be fired when editing has stopped.
     * For more information see {@link JComboBox#addActionListener(ActionListener)}.
     *
     * @param action The {@link Action} that will be notified.
     * @return This very builder instance, which allows for method chaining.
     **/
    public UIForCombo&lt;E,C&gt; onEnter( Action&lt;ComponentDelegate&lt;C, ActionEvent&gt;&gt; action ) {
<span class="nc" id="L261">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="nc" id="L262">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L263">                   _onEnter(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
                       try {
<span class="nc" id="L265">                           action.accept(new ComponentDelegate&lt;&gt;((C) thisComponent, e));</span>
<span class="nc" id="L266">                       } catch (Exception ex) {</span>
<span class="nc" id="L267">                           log.error(&quot;Error while executing action on enter!&quot;, ex);</span>
<span class="nc" id="L268">                       }</span>
<span class="nc" id="L269">                   }));</span>
<span class="nc" id="L270">               })</span>
<span class="nc" id="L271">               ._this();</span>
    }

    private void _onEnter( JComboBox&lt;E&gt; thisComponent, Consumer&lt;ActionEvent&gt; consumer ) {
<span class="nc" id="L275">        Component editor = thisComponent.getEditor().getEditorComponent();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if ( editor instanceof JTextField ) {</span>
<span class="nc" id="L277">            JTextField field = (JTextField) editor;</span>
<span class="nc" id="L278">            UI.of(field).onEnter( it -&gt; consumer.accept(it.getEvent()) );</span>
        }
<span class="nc" id="L280">    }</span>

    /**
     *  Use this to enable or disable editing for the wrapped UI component.
     *
     * @param isEditable The truth value determining if the UI component should be editable or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public UIForCombo&lt;E,C&gt; isEditableIf( boolean isEditable ) {
<span class="fc" id="L289">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L290">                   thisComponent.setEditable(isEditable);</span>
<span class="fc" id="L291">               })</span>
<span class="fc" id="L292">               ._this();</span>
    }

    /**
     *  Use this to enable or disable editing of the wrapped UI component
     *  through property binding dynamically.
     *
     * @param isEditable The boolean property determining if the UI component should be editable or not.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code isEditable} is {@code null}.
     */
    public UIForCombo&lt;E,C&gt; isEditableIf( Var&lt;Boolean&gt; isEditable ) {
<span class="nc" id="L304">        NullUtil.nullPropertyCheck(isEditable, &quot;isEditable&quot;, &quot;Null is not a valid state for modelling 'isEditable''.&quot;);</span>
<span class="nc" id="L305">        return _withOnShow( isEditable, (thisComponent, v) -&gt; {</span>
<span class="nc" id="L306">                    thisComponent.setEditable(v);</span>
<span class="nc" id="L307">                })</span>
<span class="nc" id="L308">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L309">                    thisComponent.setEditable(isEditable.get());</span>
<span class="nc" id="L310">                })</span>
<span class="nc" id="L311">                ._this();</span>
    }

    public final &lt;V extends E&gt; UIForCombo&lt;E,C&gt; _withRendererAndEditor(CellBuilder&lt;C,V&gt; cellBuilder) {
<span class="fc" id="L315">        NullUtil.nullArgCheck(cellBuilder, &quot;cellBuilder&quot;, CellBuilder.class);</span>
<span class="fc" id="L316">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L317">                    cellBuilder.buildForCombo((C)thisComponent, true);</span>
<span class="fc" id="L318">                })</span>
<span class="fc" id="L319">                ._this();</span>
    }

    /**
     *  Use this to set a helpful tool tip text for each menu item
     *  in the drop-down menu of the {@link JComboBox} UI declaration.
     *  The tool tip text will be displayed when the mouse hovers on a
     *  menu item for some time. &lt;br&gt;
     *  This is in essence a convenience method and abstraction over
     *  the {@link #withCell(Configurator)} method, which avoid dealing
     *  with the complexity of dealing with a more customized approach
     *  to configuring you combo-box cell renderer and cell editors...&lt;br&gt;
     *  &lt;p&gt;
     *  Here an example demonstrating how to configure a
     *  tooltip for each available option of a combo-box individually: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.comboBox(DayOfWeek.values())
     *  .withTooltips( day -&gt; {
     *    return switch (day) {
     *      case MONDAY -&gt; &quot;Monday&quot;;
     *      case TUESDAY -&gt; &quot;Tuesday&quot;;
     *      case WEDNESDAY -&gt; &quot;Wednesday&quot;;
     *      case THURSDAY -&gt; &quot;Thursday&quot;;
     *      case FRIDAY -&gt; &quot;Friday&quot;;
     *      case SATURDAY -&gt; &quot;Saturday&quot;;
     *      case SUNDAY -&gt; &quot;Sunday&quot;;
     *    };
     *  })
     *  }&lt;/pre&gt;
     *
     * @param tooltips A function which returns a tooltip for a specific item.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withTooltips(
        Function&lt;E, String&gt; tooltips
    ) {
<span class="fc" id="L355">        return withCell( it -&gt; it</span>
<span class="fc" id="L356">                .updateView(view -&gt; view</span>
<span class="fc" id="L357">                    .update( comp -&gt; {</span>
<span class="pc bpc" id="L358" title="2 of 4 branches missed.">                        if ( comp instanceof JComponent &amp;&amp; it.entry().isPresent() ) {</span>
<span class="fc" id="L359">                            JComponent jcomp =  (JComponent) comp;</span>
<span class="fc" id="L360">                            String toolTip = null;</span>
                            try {
<span class="fc" id="L362">                                Object result = tooltips.apply(it.entry().get());</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">                                toolTip = result == null ? null : result.toString();</span>
<span class="pc bpc" id="L364" title="2 of 4 branches missed.">                                toolTip = toolTip == null || &quot;&quot;.equals(toolTip) ? null : toolTip;</span>
<span class="nc" id="L365">                            } catch (Exception ex) {</span>
<span class="nc" id="L366">                                log.error(&quot;Error while fetching tooltip for cell '{}'.&quot;, it, ex);</span>
<span class="fc" id="L367">                            }</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                            if ( !Objects.equals(toolTip, jcomp.getToolTipText()) ) {</span>
<span class="fc" id="L369">                                jcomp.setToolTipText(toolTip);</span>
                            }
<span class="fc" id="L371">                            return jcomp;</span>
                        }
<span class="nc" id="L373">                        return comp;</span>
                    })
                 )
            );
    }

    /**
     *  Use this to define a generic combo box view/renderer for any type of item.
     *  You would typically want to use this method to render generic types where the only
     *  common type is {@link Object}, yet you still want to render the items
     *  in a specific way depending on their actual type. &lt;br&gt;
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(new Object[]{&quot;:-)&quot;, 42L, 'ยง'})
     *  .withCells( it -&gt; it
     *      .when(String.class).asText( cell -&gt; &quot;String: &quot;+cell.getValue() )
     *      .when(Character.class).asText( cell -&gt; &quot;Char: &quot;+cell.getValue() )
     *      .when(Number.class).asText( cell -&gt; &quot;Number: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *  Note that inside the lambda function, you can use the {@link CellBuilder} to define
     *  for what type of item you want to render the item in a specific way and the {@link RenderAs}
     *  to define how the item should be rendered.
     *  &lt;p&gt;
     *  You may want to know that a similar API is also available for the {@link javax.swing.JList}
     *  and {@link javax.swing.JTable} components, see {@link UIForList#withCells(Configurator)},
     *  {@link UIForTable#withCells(Configurator)} and {@link UI#table(Configurator)}
     *  for more information.
     * &lt;p&gt;
     * &lt;b&gt;Note that the preferred way of building a list cell view
     * is through the {@link #withCell(Configurator)} method, which is
     * way simpler as it does not assume the combobox has an item type ambiguity.&lt;/b&gt;
     *
     * @param renderBuilder A lambda function that configures the renderer for this combo box.
     * @return This combo box instance for further configuration.
     * @param &lt;V&gt; The type of the value that is being rendered in this combo box.
     */
    public final &lt;V extends E&gt; UIForCombo&lt;E,C&gt; withCells(
        Configurator&lt;CellBuilder&lt;C,V&gt;&gt; renderBuilder
    ) {
<span class="fc" id="L413">        Class&lt;Object&gt; commonType = Object.class;</span>
<span class="fc" id="L414">        Objects.requireNonNull(commonType);</span>
<span class="fc" id="L415">        CellBuilder render = CellBuilder.forCombo(commonType);</span>
        try {
<span class="fc" id="L417">            render = renderBuilder.configure(render);</span>
<span class="nc" id="L418">        } catch (Exception e) {</span>
<span class="nc" id="L419">            log.error(&quot;Error while building renderer.&quot;, e);</span>
<span class="nc" id="L420">            return this;</span>
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">        Objects.requireNonNull(render);</span>
<span class="fc" id="L423">        return _withRendererAndEditor(render);</span>
    }

    /**
     *  Use this method to configure how the combo box views should
     *  be rendered for a specific type of item. This is useful when you have a
     *  combo box with a single type of item, and you want to render the items
     *  according to your specific needs. &lt;br&gt;
     *  An example of how to use this method is as follows:
     *  &lt;pre&gt;{@code
     *      UI.comboBox(TimeUnit.values())
     *      .withCell( cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              .orGet(JLabel::new)
     *              .updateIf(JLabel.class, label -&gt; {
     *                  label.setText(cell.valueAsString().orElse(&quot;&quot;));
     *                  return label;
     *              })
     *          )
     *      );
     *  }&lt;/pre&gt;
     *
     * @param cellConfigurator The configurator for the cell, receiving a {@link CellConf} as input
     *                         and returning an updated CellDelegate.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;V&gt; The type of the value that is being rendered in this combo box.
     */
    public final &lt;V extends E&gt; UIForCombo&lt;E,C&gt; withCell(
        Configurator&lt;CellConf&lt;C,V&gt;&gt; cellConfigurator
    ) {
<span class="fc" id="L453">        return withCells(it -&gt; it.when((Class) Object.class).as(cellConfigurator));</span>
    }

    /**
     * Sets the {@link ListCellRenderer} for the {@link JComboBox}, which renders the combo box items
     * by supplying a custom component for each item through the
     * {@link ListCellRenderer#getListCellRendererComponent(JList, Object, int, boolean, boolean)} method.
     *
     * @param renderer The {@link ListCellRenderer} that will be used to paint each cell in the combo box.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withCellRenderer( ListCellRenderer&lt;E&gt; renderer ) {
<span class="nc" id="L465">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L466">                    thisComponent.setRenderer(renderer);</span>
<span class="nc" id="L467">                })</span>
<span class="nc" id="L468">                ._this();</span>
    }

    /**
     *  Use this to specify a custom text based cell renderer for each item in the combo box.
     *  The renderer is a function that takes a {@link CellConf} as input
     *  and returns a {@link String} which will be used as the text for the combo box item.
     *
     * @param renderer The function that will be used to render the combo box items.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withTextRenderer( Function&lt;CellConf&lt;C,E&gt;, String&gt; renderer ) {
<span class="fc" id="L480">        Objects.requireNonNull(renderer, &quot;renderer&quot;);</span>
<span class="fc" id="L481">        return withCells(it -&gt; it.when((Class&lt;E&gt;) Object.class).asText( renderer ) );</span>
    }

    /**
     *  Use this convenience method to specify the model for the combo box,
     *  which is used by the combo box component to determine the available options
     *  and the currently selected item.
     *
     * @param model The {@link ComboBoxModel} to be used for modelling the content data of the combo box.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withModel( ComboBoxModel&lt;E&gt; model ) {
<span class="fc" id="L493">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L494">                    _setModel(model, thisComponent);</span>
<span class="fc" id="L495">                })</span>
<span class="fc" id="L496">                ._this();</span>
    }

    private void _setModel( ComboBoxModel&lt;E&gt; model, JComboBox&lt;E&gt; thisComponent ) {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if ( model instanceof AbstractComboModel )</span>
<span class="fc" id="L501">            _bindComboModelToEditor(thisComponent, (AbstractComboModel&lt;E&gt;) model );</span>
<span class="fc" id="L502">        thisComponent.setModel(model);</span>
<span class="fc" id="L503">    }</span>

    /**
     *  Uses the given list of elements as a basis for a new combo box model
     *  and sets it as the model for the combo box.
     *  This means that whenever the list of elements changes,
     *  and the combo box is rendered, the combo box will be updated accordingly.
     *
     * @param options The list of elements to be used as the basis for the combo box model.
     * @return This builder node, which enables builder-style method chaining.
     * @throws NullPointerException if {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( java.util.List&lt;E&gt; options ) {
<span class="fc" id="L516">        Objects.requireNonNull(options, &quot;options&quot;);</span>
<span class="fc" id="L517">        return this.withModel(new ListBasedComboModel&lt;&gt;(options));</span>
    }

    /**
     *  Uses the provided selection property as well as a list of elements as a basis for a new combo box model.
     *  Whenever the selection or the list of elements changes,
     *  and the combo box is rendered, the combo box will be updated accordingly.
     *  Note that the use of the {@link Var} type for the selection property
     *  allows the combo box to listen for changes to the selection property,
     *  which ensures that the combo box is updated whenever the selection property changes.
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The list of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node, which enables builder-style method chaining.
     * @throws NullPointerException if {@code selection} or {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, java.util.List&lt;E&gt; options ) {
<span class="fc" id="L534">        Objects.requireNonNull(selection, &quot;selection&quot;);</span>
<span class="fc" id="L535">        Objects.requireNonNull(options, &quot;options&quot;);</span>
<span class="fc" id="L536">        return this.withModel(new ListBasedComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  Uses the given property list of elements as a basis for a new combo box model
     *  and sets it as the model for the combo box.
     *  The combo box will register a change listener and update itself whenever the list of elements changes.
     *
     * @param options The property list of elements to be used as the basis for a new combo box model.
     * @return This builder node, which enables builder-style method chaining.
     * @throws NullPointerException if {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Vars&lt;E&gt; options ) {
<span class="fc" id="L549">        Objects.requireNonNull(options, &quot;options&quot;);</span>
<span class="fc" id="L550">        return this.withModel(new VarsBasedComboModel&lt;&gt;(options));</span>
    }

    /**
     *  Uses a read only property list of elements as a basis for a new combo box model
     *  and sets it as the model for the combo box.
     *  The combo box will register a change listener and update itself whenever the list of elements changes.
     *  Due to the fact that the list of elements is read only,
     *  changes to the list of elements can only come from the view model.
     *
     * @param options The read only property list of elements to be used as the basis for a new combo box model.
     * @return This builder node, which enables builder-style method chaining.
     * @throws NullPointerException if {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Vals&lt;E&gt; options ) {
<span class="nc" id="L565">        Objects.requireNonNull(options, &quot;options&quot;);</span>
<span class="nc" id="L566">        return this.withModel(new ValsBasedComboModel&lt;&gt;(options));</span>
    }

    /**
     *  Uses the given selection property as well as a property list of elements as a basis
     *  for a new combo box model and sets it as the new model for the combo box state.
     *  This means that whenever the state of the selection property or the property list of elements changes,
     *  then combo box will be updated and rendered accordingly.&lt;br&gt;
     *  &lt;b&gt;
     *      Note that we recommend using the {@link Tuple} property based {@link #withItems(Var, Var)} method instead
     *      of this method, as it requires less state to be managed in your application and allows for a more
     *      data-oriented programming style.
     *  &lt;/b&gt;
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The property list of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node instance, which allows for builder-style method chaining.
     * @throws NullPointerException if either one of {@code selection} or {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, Vars&lt;E&gt; options ) {
<span class="fc" id="L586">        return this.withModel(new VarsBasedComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  Uses the given selection property as well as a read only property list of elements as a basis
     *  for a new combo box model and sets it as the new model for the combo box state.
     *  This means that whenever the state of the selection property or the read only property list of elements changes,
     *  then combo box will be updated and rendered according to said changes.
     *  Due to the list of options being read only, changes to it can only come from the view model.&lt;br&gt;
     *  &lt;b&gt;
     *      Note that we recommend using the {@link Tuple} property based {@link #withItems(Var, Val)} method instead
     *      of this method, as it requires less state to be managed in your application and allows for a more
     *      data-oriented programming style.
     *  &lt;/b&gt;
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The read only property list of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node, which allows for builder-style method chaining.
     * @throws NullPointerException if either one of {@code selection} or {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, Vals&lt;E&gt; options ) {
<span class="nc" id="L607">        return this.withModel(new ValsBasedComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  Uses the given selection property as well as an array of elements as a basis
     *  for a new combo box model and sets it as the new model for the combo box state.
     *  This means that whenever the state of the selection property or the array of elements changes,
     *  then combo box will be updated and rendered according to said changes.
     *  Note that the combo box can not register change listeners on the array of elements,
     *  which means that for the combo box to be updated whenever the array of elements changes,
     *  you must trigger the update manually.
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The array of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node, which allows for builder-style method chaining.
     * @throws NullPointerException if either one of {@code selection} or {@code options} is {@code null}.
     */
    @SafeVarargs
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, E... options ) {
<span class="fc" id="L626">        return this.withModel(new ArrayBasedComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  Uses the given selection property as well as a property of a {@link Tuple} of elements as a basis
     *  for a new combo box model and sets it as the new model for the combo box state.
     *  This means that whenever the state of the selection property or the property of tuple of elements changes,
     *  then combo box will be updated and rendered according to said changes.
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The property of a tuple of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node, which allows for builder-style method chaining.
     * @throws NullPointerException if either one of {@code selection} or {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, Var&lt;Tuple&lt;E&gt;&gt; options ) {
<span class="fc" id="L641">        return this.withModel(new TuplePropertyComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  Uses the given selection property as well as a read only property of a {@link Tuple} of elements as a basis
     *  for a new combo box model and sets it as the new model for the combo box state.
     *  This means that whenever the state of the selection property or the read only property of a tuple of elements changes,
     *  then combo box will be updated and rendered according to said changes.
     *  Due to the list of options being read only, changes to it can only come from the view model.
     *
     * @param selection The selection property to be used as the basis for modelling the currently selected item in a new combo box model.
     * @param options The read only property of a tuple of elements to be used as the basis for modelling the available options in a new combo box model.
     * @return This builder node, which allows for builder-style method chaining.
     * @throws NullPointerException if either one of {@code selection} or {@code options} is {@code null}.
     */
    public final UIForCombo&lt;E,C&gt; withItems( Var&lt;E&gt; selection, Val&lt;Tuple&lt;E&gt;&gt; options ) {
<span class="nc" id="L657">        return this.withModel(new TuplePropertyComboModel&lt;&gt;(selection, options));</span>
    }

    /**
     *  This method allows you to specify an initial selection for the combo box.
     *
     * @param item The item which should be set as the currently selected combo box item.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withSelectedItem( E item ) {
<span class="fc" id="L667">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L668">                    _setSelectedItem(thisComponent, item);</span>
<span class="fc" id="L669">               })</span>
<span class="fc" id="L670">               ._this();</span>
    }

    /**
     *  Use this to dynamically set the selected item of the combo box.
     *
     * @param item The item to be selected.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForCombo&lt;E,C&gt; withSelectedItem( Var&lt;E&gt; item ) {
<span class="fc" id="L680">        NullUtil.nullArgCheck(item, &quot;item&quot;, Var.class);</span>
<span class="fc" id="L681">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L682">                    ComboBoxModel&lt;E&gt; model = thisComponent.getModel();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                    if ( model instanceof AbstractComboModel )</span>
<span class="fc" id="L684">                        _setModel(((AbstractComboModel&lt;E&gt;)model).withVar(item), thisComponent);</span>
                    else {
                        // The user has a custom model AND wants to bind to a property:
<span class="nc" id="L687">                        _onShow( item, thisComponent, (c,v) -&gt; _setSelectedItem(c, v) );</span>
<span class="nc" id="L688">                        _onSelection(thisComponent,</span>
<span class="nc" id="L689">                            e -&gt; _runInApp( (E)thisComponent.getSelectedItem(), newItem -&gt; item.set(From.VIEW, newItem)  )</span>
                        );
                    }
<span class="fc" id="L692">                    _setSelectedItem(thisComponent, item.get());</span>
<span class="fc" id="L693">                })</span>
<span class="fc" id="L694">                ._this();</span>
    }

    private void _setSelectedItem( JComboBox&lt;E&gt; thisComponent, E item ) {
        // Ok, so a combo box fires an event when the selection is changed programmatically.
        // This is a problem, because we don't want to trigger the action listener.
        // So we temporarily remove the action listener(s), and then add them back.
        // 1. Get the action listener(s)
<span class="fc" id="L702">        Component editor = thisComponent.getEditor().getEditorComponent();</span>
<span class="fc" id="L703">        AbstractDocument abstractDocument = null;</span>
<span class="fc" id="L704">        ActionListener[]   listeners    = thisComponent.getActionListeners();</span>
<span class="fc" id="L705">        DocumentListener[] docListeners = {};</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">        if ( editor instanceof JTextField ) {</span>
<span class="fc" id="L707">            JTextField field = (JTextField) editor;</span>
<span class="fc" id="L708">            Document doc = field.getDocument();</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            if ( doc instanceof AbstractDocument ) {</span>
<span class="fc" id="L710">                abstractDocument = (AbstractDocument) doc;</span>
<span class="fc" id="L711">                docListeners = ((AbstractDocument)doc).getDocumentListeners();</span>
            }
        }

        // 2. Remove them
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">        for ( ActionListener listener : listeners )</span>
<span class="nc" id="L717">            thisComponent.removeActionListener(listener);</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">        if ( abstractDocument != null ) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            for (DocumentListener listener : docListeners) {</span>
<span class="fc" id="L720">                abstractDocument.removeDocumentListener(listener);</span>
            }
        }

        try {
            // 3. Set the selected item
<span class="fc" id="L726">            thisComponent.setSelectedItem(item);</span>
            // 3.1 We make sure the editor also gets an update!
<span class="fc" id="L728">            thisComponent.getEditor().setItem(item);</span>

<span class="nc" id="L730">        } catch ( Exception e ) {</span>
<span class="nc" id="L731">            throw new RuntimeException(e);</span>
<span class="fc" id="L732">        }</span>

        // 4. Add them back
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        for ( ActionListener listener : listeners )</span>
<span class="nc" id="L736">            thisComponent.addActionListener(listener);</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if ( abstractDocument != null ) {</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">            for (DocumentListener listener : docListeners) {</span>
<span class="fc" id="L739">                abstractDocument.addDocumentListener(listener);</span>
            }
        }
<span class="fc" id="L742">    }</span>

    private void _bindComboModelToEditor( JComboBox&lt;E&gt; thisComponent, AbstractComboModel&lt;E&gt; model ) {
<span class="fc" id="L745">        Component editor = thisComponent.getEditor().getEditorComponent();</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if ( editor instanceof JTextField ) {</span>
<span class="fc" id="L747">            JTextField field = (JTextField) editor;</span>
<span class="fc" id="L748">            MemSafeBinding&lt;E&gt; memSafeBinding = new MemSafeBinding&lt;&gt;(field, thisComponent, model);</span>

<span class="fc" id="L750">            UI.of(field).onTextChange( it -&gt; {</span>
<span class="fc" id="L751">                memSafeBinding.textChanged();</span>
<span class="fc" id="L752">            });</span>
<span class="fc" id="L753">            _onShow( model._getSelectedItemVar(), thisComponent, (c, v) -&gt; {</span>
<span class="fc" id="L754">                memSafeBinding.itemChanged(c, v);</span>
<span class="fc" id="L755">            });</span>
            // Adds a PopupMenu listener which will listen to notification
            // messages from the popup portion of the combo box.
<span class="fc" id="L758">            thisComponent.addPopupMenuListener(memSafeBinding);</span>
        }
<span class="fc" id="L760">    }</span>

    /**
     *  A popup menu listener for the combo box which synchronizes text field, model
     *  and combo box while at the same time keeping weak references on
     *  all involved components to ensure that no memory leaks occur.
     * @param &lt;E&gt; The type of the items in the combo box.
     */
    private static class MemSafeBinding&lt;E&gt; implements PopupMenuListener {

        private final WeakReference&lt;JTextField&gt; weakField;
        private final WeakReference&lt;JComboBox&lt;E&gt;&gt; weakCombo;
        private final WeakReference&lt;AbstractComboModel&lt;E&gt;&gt; weakModel;

<span class="fc" id="L774">        private boolean comboIsOpen = false;</span>

        private MemSafeBinding(
                JTextField field,
                JComboBox&lt;E&gt; combo,
                AbstractComboModel&lt;E&gt; model
<span class="fc" id="L780">        ) {</span>
<span class="fc" id="L781">            this.weakField = new WeakReference&lt;&gt;(field);</span>
<span class="fc" id="L782">            this.weakCombo = new WeakReference&lt;&gt;(combo);</span>
<span class="fc" id="L783">            this.weakModel = new WeakReference&lt;&gt;(model);</span>
<span class="fc" id="L784">        }</span>

        public void textChanged() {
<span class="fc" id="L787">            JTextField field = weakField.get();</span>
<span class="fc" id="L788">            AbstractComboModel&lt;E&gt; strongModel = weakModel.get();</span>
<span class="pc bpc" id="L789" title="2 of 4 branches missed.">            if ( strongModel != null &amp;&amp; field != null ) {</span>
<span class="fc" id="L790">                JComboBox&lt;E&gt; strongCombo = weakCombo.get();</span>
<span class="pc bpc" id="L791" title="2 of 6 branches missed.">                if (!comboIsOpen &amp;&amp; strongCombo != null &amp;&amp; strongCombo.isEditable())</span>
<span class="fc" id="L792">                    strongModel.setFromEditor(field.getText());</span>
            }
<span class="fc" id="L794">        }</span>

        public void itemChanged(JComboBox&lt;E&gt; combo, E newItem) {
<span class="fc" id="L797">            AbstractComboModel&lt;E&gt; strongModel = weakModel.get();</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">            if ( strongModel != null ) {</span>
<span class="fc" id="L799">                strongModel.doQuietly(() -&gt; {</span>
<span class="fc" id="L800">                    combo.getEditor().setItem(newItem);</span>
<span class="fc" id="L801">                    strongModel.fireListeners();</span>
<span class="fc" id="L802">                });</span>
            }
<span class="fc" id="L804">        }</span>

        @Override
        public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
            // This method is called before the popup menu becomes visible.
<span class="nc" id="L809">            comboIsOpen = true;</span>
<span class="nc" id="L810">        }</span>
        @Override
        public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
            // This method is called before the popup menu becomes invisible
<span class="nc" id="L814">            comboIsOpen = false;</span>
<span class="nc" id="L815">        }</span>
        @Override
        public void popupMenuCanceled(PopupMenuEvent e) {
            // This method is called when the popup menu is canceled
<span class="nc" id="L819">            comboIsOpen = false;</span>
<span class="nc" id="L820">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>