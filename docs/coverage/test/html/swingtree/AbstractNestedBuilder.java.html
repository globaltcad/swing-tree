<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNestedBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractNestedBuilder.java</span></div><h1>AbstractNestedBuilder.java</h1><pre class="source lang-java linenums">package swingtree;

import swingtree.style.ComponentExtension;
import swingtree.style.Style;
import swingtree.threading.EventProcessor;

import javax.swing.*;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *  This class is a conceptual extension of the {@link AbstractBuilder} which expects
 *  implementations to define how to compose {@link Component}s into a GUI tree.
 *  This is primarily expressed by the &quot;{@link #add(AbstractNestedBuilder[])}&quot; method which takes an arbitrary number of
 *  builder instances to form said GUI tree structure...
 *
 * @param &lt;I&gt; The concrete implementation type of this abstract class, &quot;I&quot; stands for &quot;Implementation&quot;.
 * @param &lt;C&gt; The component type parameter which ought to be built in some way.
 * @param &lt;E&gt; The component type parameter which ought to be built in some way.
 */
abstract class AbstractNestedBuilder&lt;I, C extends E, E extends Component&gt; extends AbstractBuilder&lt;I, C&gt;
{
    /**
     * Instances of the AbstractNestedBuilder as well as its sub types always wrap
     * a single component for which they are responsible.
     * In addition to the AbstractBuilder this builder also requires nesting.
     *
     * @param component The component type which will be wrapped by this builder node.
     */
<span class="fc" id="L34">    protected AbstractNestedBuilder( C component ) { super(component); }</span>

    /**
     *  A list of all the siblings of the component wrapped by this builder,
     *  which includes the current component itself.
     *
     * @return A list of all the siblings of the component wrapped by this builder.
     */
    protected final List&lt;E&gt; getSiblinghood() {
<span class="nc" id="L43">        return Optional.ofNullable(getComponent().getParent())</span>
<span class="nc" id="L44">               .map(Container::getComponents)</span>
<span class="nc" id="L45">               .map(Arrays::stream)</span>
<span class="nc" id="L46">               .orElseGet(Stream::empty)</span>
<span class="nc" id="L47">               .filter(c -&gt; c instanceof JComponent)</span>
<span class="nc" id="L48">               .map(c -&gt; (E) c)</span>
<span class="nc" id="L49">               .collect(Collectors.toList());</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components An array of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final I add( E... components ) {
<span class="fc" id="L63">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc" id="L64">        return _with( c -&gt; {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">                   for ( E other : components )</span>
<span class="fc" id="L66">                       _doAdd( UI.of((JComponent) other), null, c );</span>
<span class="fc" id="L67">               })</span>
<span class="fc" id="L68">               ._this();</span>
    }

    /**
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L77">        return (I) this.add(new AbstractNestedBuilder[]{builder});</span>
    }

    /**
     * This builder class expects its implementations to be builder types
     * for anything which can be built in a nested tree-like structure.
     * Implementations of this abstract method ought to enable support for nested building.
     * &lt;br&gt;&lt;br&gt;
     *
     * @param component A component instance which ought to be added to the wrapped component type.
     * @param conf      The layout constraint which ought to be used to add the component to the wrapped component type.
     * @param thisComponent The component which is wrapped by this builder.
     */
    protected abstract void _doAddComponent( E component, Object conf, C thisComponent );

    protected final void _doAdd( AbstractNestedBuilder&lt;?, ?, ?&gt; builder, Object conf, C thisComponent )
    {
<span class="fc" id="L94">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, AbstractNestedBuilder.class);</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">        boolean isCoupled       = _eventProcessor == EventProcessor.COUPLED;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        boolean isCoupledStrict = _eventProcessor == EventProcessor.COUPLED_STRICT;</span>

<span class="pc bpc" id="L99" title="1 of 6 branches missed.">        if ( !isCoupled &amp;&amp; !isCoupledStrict &amp;&amp; !UI.thisIsUIThread() )</span>
<span class="nc" id="L100">            throw new IllegalStateException(</span>
                    &quot;This UI is configured to be decoupled from the application thread, &quot; +
                    &quot;which means that it can only be modified from the EDT. &quot; +
                    &quot;Please use 'UI.run(()-&gt;...)' method to execute your modifications on the EDT.&quot;
                );

<span class="fc" id="L106">        E childComponent = (E) builder.getComponent();</span>

<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        if ( childComponent instanceof JComponent ) {</span>
<span class="fc" id="L109">            JComponent child = (JComponent) childComponent;</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">            Style style = ( conf != null ? null : ComponentExtension.from(child).calculateStyle() );</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L113">                conf = style.layout().constraint().orElse(null);</span>

<span class="fc" id="L115">            _doAddComponent( childComponent, conf, thisComponent );</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L118">                ComponentExtension.from(child).applyAndInstallStyle(style, true);</span>
            else
<span class="fc" id="L120">                ComponentExtension.from(child).calculateApplyAndInstallStyle(true);</span>
<span class="fc" id="L121">        }</span>
        else
<span class="nc" id="L123">            _doAddComponent( childComponent, conf, thisComponent );</span>

<span class="fc" id="L125">        builder._detachStrongRef(); // Detach strong reference to the component to allow it to be garbage collected.</span>
<span class="fc" id="L126">    }</span>

    /**
     *  This method provides the same functionality as the other &quot;add&quot; methods.
     *  However, it bypasses the necessity to call the &quot;get&quot; method by
     *  calling it internally for you. &lt;br&gt;
     *  This helps to improve readability, especially when the degree of nesting is very low.
     *
     * @param builders An array of builder instances whose JComponents ought to be added to the one wrapped by this builder.
     * @param &lt;B&gt; The type of the builder instances which are used to configure the components that will be added to the component wrapped by this builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public final &lt;B extends AbstractNestedBuilder&lt;?, ?, JComponent&gt;&gt; I add( B... builders )
    {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if ( builders == null )</span>
<span class="nc" id="L143">            throw new IllegalArgumentException(&quot;Swing tree builders may not be null!&quot;);</span>

<span class="fc" id="L145">        return _with( thisComponent -&gt; {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                    for ( AbstractNestedBuilder&lt;?, ?, ?&gt; b : builders )</span>
<span class="fc" id="L147">                        _doAdd( b, null, thisComponent );</span>
<span class="fc" id="L148">                })</span>
<span class="fc" id="L149">                ._this();</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components A list of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I add( List&lt;E&gt; components ) {
<span class="fc" id="L162">        return _with( thisComponent -&gt; {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                    for ( E component : components )</span>
<span class="fc" id="L164">                        _doAdd( UI.of((JComponent) component), null, thisComponent );</span>

<span class="fc" id="L166">                })</span>
<span class="fc" id="L167">                ._this();</span>
    }

    protected final int _childCount( C c ) {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        return  ( c instanceof Container ? ( (Container) c ).getComponentCount() : 0 );</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>