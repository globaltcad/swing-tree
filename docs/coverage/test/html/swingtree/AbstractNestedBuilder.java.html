<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNestedBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractNestedBuilder.java</span></div><h1>AbstractNestedBuilder.java</h1><pre class="source lang-java linenums">package swingtree;

import swingtree.style.ComponentExtension;
import swingtree.style.Style;
import swingtree.threading.EventProcessor;

import javax.swing.JComponent;
import java.awt.Component;
import java.awt.Container;
import java.util.List;

/**
 *  This class is a conceptual extension of the {@link AbstractBuilder} which expects
 *  implementations to define how to compose {@link Component}s into a GUI tree.
 *  This is primarily expressed by the &quot;{@link #add(AbstractNestedBuilder[])}&quot; method which takes an arbitrary number of
 *  builder instances to form said GUI tree structure...
 *
 * @param &lt;I&gt; The concrete implementation type of this abstract class, &quot;I&quot; stands for &quot;Implementation&quot;.
 * @param &lt;C&gt; The component type parameter which ought to be built in some way.
 * @param &lt;E&gt; The component type parameter which ought to be built in some way.
 */
<span class="fc" id="L22">abstract class AbstractNestedBuilder&lt;I, C extends E, E extends Component&gt; extends AbstractBuilder&lt;I, C&gt;</span>
{
    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components An array of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final I add( E... components ) {
<span class="fc" id="L35">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc" id="L36">        return _with( c -&gt; {</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">                   for ( E other : components )</span>
<span class="fc" id="L38">                       _doAdd( UI.of((JComponent) other), null, c );</span>
<span class="fc" id="L39">               })</span>
<span class="fc" id="L40">               ._this();</span>
    }

    /**
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L49">        return (I) this.add(new AbstractNestedBuilder[]{builder});</span>
    }

    /**
     * This builder class expects its implementations to be builder types
     * for anything which can be built in a nested tree-like structure.
     * Implementations of this abstract method ought to enable support for nested building.
     * &lt;br&gt;&lt;br&gt;
     *
     * @param component A component instance which ought to be added to the wrapped component type.
     * @param conf      The layout constraint which ought to be used to add the component to the wrapped component type.
     * @param thisComponent The component which is wrapped by this builder.
     */
    protected abstract void _doAddComponent( E component, Object conf, C thisComponent );

    protected final void _doAdd( AbstractNestedBuilder&lt;?, ?, ?&gt; builder, Object conf, C thisComponent )
    {
<span class="fc" id="L66">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, AbstractNestedBuilder.class);</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">        boolean isCoupled       = _state().eventProcessor() == EventProcessor.COUPLED;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        boolean isCoupledStrict = _state().eventProcessor() == EventProcessor.COUPLED_STRICT;</span>

<span class="pc bpc" id="L71" title="1 of 6 branches missed.">        if ( !isCoupled &amp;&amp; !isCoupledStrict &amp;&amp; !UI.thisIsUIThread() )</span>
<span class="nc" id="L72">            throw new IllegalStateException(</span>
                    &quot;This UI is configured to be decoupled from the application thread, &quot; +
                    &quot;which means that it can only be modified from the EDT. &quot; +
                    &quot;Please use 'UI.run(()-&gt;...)' method to execute your modifications on the EDT.&quot;
                );

<span class="fc" id="L78">        E childComponent = (E) builder.getComponent();</span>

<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if ( childComponent instanceof JComponent ) {</span>
<span class="fc" id="L81">            JComponent child = (JComponent) childComponent;</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">            Style style = ( conf != null ? null : ComponentExtension.from(child).calculateStyle() );</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L85">                conf = style.layout().constraint().orElse(null);</span>

<span class="fc" id="L87">            _doAddComponent( childComponent, conf, thisComponent );</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L90">                ComponentExtension.from(child).applyAndInstallStyle(style, true);</span>
            else
<span class="fc" id="L92">                ComponentExtension.from(child).calculateApplyAndInstallStyle(true);</span>
<span class="fc" id="L93">        }</span>
        else
<span class="nc" id="L95">            _doAddComponent( childComponent, conf, thisComponent );</span>

<span class="fc" id="L97">        builder._detachStrongRef(); // Detach strong reference to the component to allow it to be garbage collected.</span>
<span class="fc" id="L98">    }</span>

    /**
     *  This method provides the same functionality as the other &quot;add&quot; methods.
     *  However, it bypasses the necessity to call the &quot;get&quot; method by
     *  calling it internally for you. &lt;br&gt;
     *  This helps to improve readability, especially when the degree of nesting is very low.
     *
     * @param builders An array of builder instances whose JComponents ought to be added to the one wrapped by this builder.
     * @param &lt;B&gt; The type of the builder instances which are used to configure the components that will be added to the component wrapped by this builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public final &lt;B extends AbstractNestedBuilder&lt;?, ?, JComponent&gt;&gt; I add( B... builders )
    {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if ( builders == null )</span>
<span class="nc" id="L115">            throw new IllegalArgumentException(&quot;Swing tree builders may not be null!&quot;);</span>

<span class="fc" id="L117">        return _with( thisComponent -&gt; {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">                    for ( AbstractNestedBuilder&lt;?, ?, ?&gt; b : builders )</span>
<span class="fc" id="L119">                        _doAdd( b, null, thisComponent );</span>
<span class="fc" id="L120">                })</span>
<span class="fc" id="L121">                ._this();</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components A list of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I add( List&lt;E&gt; components ) {
<span class="fc" id="L134">        return _with( thisComponent -&gt; {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">                    for ( E component : components )</span>
<span class="fc" id="L136">                        _doAdd( UI.of((JComponent) component), null, thisComponent );</span>

<span class="fc" id="L138">                })</span>
<span class="fc" id="L139">                ._this();</span>
    }

    protected final int _childCount( C c ) {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        return  ( c instanceof Container ? ( (Container) c ).getComponentCount() : 0 );</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>