<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNestedBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractNestedBuilder.java</span></div><h1>AbstractNestedBuilder.java</h1><pre class="source lang-java linenums">package swingtree;

import swingtree.style.ComponentExtension;
import swingtree.style.Style;
import swingtree.threading.EventProcessor;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 *  This class is a conceptual extension of the {@link AbstractBuilder} which expects
 *  implementations to define how to compose {@link Component}s into a GUI tree.
 *  This is primarily expressed by the &quot;{@link #add(AbstractNestedBuilder[])}&quot; method which takes an arbitrary number of
 *  builder instances to form said GUI tree structure...
 *
 * @param &lt;I&gt; The concrete implementation type of this abstract class, &quot;I&quot; stands for &quot;Implementation&quot;.
 * @param &lt;C&gt; The component type parameter which ought to be built in some way.
 * @param &lt;E&gt; The component type parameter which ought to be built in some way.
 */
abstract class AbstractNestedBuilder&lt;I, C extends E, E extends Component&gt; extends AbstractBuilder&lt;I, C&gt;
{
    /**
     *  A list of all the child builders.
     */
<span class="fc" id="L28">    private final List&lt;AbstractNestedBuilder&lt;?,?,?&gt;&gt; _children = new ArrayList&lt;&gt;();</span>
    private AbstractNestedBuilder&lt;?,?,?&gt; _parent; // The parent builder (This may be null if no parent present or provided)

    /**
     * Instances of the AbstractNestedBuilder as well as its sub types always wrap
     * a single component for which they are responsible.
     * In addition to the AbstractBuilder this builder also requires nesting.
     *
     * @param component The component type which will be wrapped by this builder node.
     */
<span class="fc" id="L38">    protected AbstractNestedBuilder( C component ) { super(component); }</span>

    /**
     *  A list of all the siblings of the component wrapped by this builder,
     *  which includes the current component itself.
     *
     * @return A list of all the siblings of the component wrapped by this builder.
     */
    protected final List&lt;E&gt; getSiblinghood() {
<span class="fc bfc" id="L47" title="All 2 branches covered.">        if ( _parent == null ) return new ArrayList&lt;&gt;();</span>
<span class="fc" id="L48">        return _parent._children.stream().map(c -&gt; (E) c.getComponent()).collect(Collectors.toList());</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components An array of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final I add( E... components ) {
<span class="fc" id="L62">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">        for ( E c : components ) _doAdd(UI.of((JComponent) c), null);</span>
<span class="fc" id="L64">        return _this();</span>
    }

    /**
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L73">        this.add(new AbstractNestedBuilder[]{builder});</span>
<span class="fc" id="L74">        return _this();</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param component A component instance which ought to be added to the wrapped component type.
     * @param conf The layout constraint which ought to be used to add the component to the wrapped component type.
     */
    protected abstract void _add( E component, Object conf );

    protected final void _doAdd( AbstractNestedBuilder&lt;?, ?, ?&gt; builder, Object conf)
    {
<span class="fc" id="L90">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, AbstractNestedBuilder.class);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">        boolean isCoupled       = _eventProcessor == EventProcessor.COUPLED;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        boolean isCoupledStrict = _eventProcessor == EventProcessor.COUPLED_STRICT;</span>

<span class="pc bpc" id="L95" title="1 of 6 branches missed.">        if ( !isCoupled &amp;&amp; !isCoupledStrict &amp;&amp; !UI.thisIsUIThread() )</span>
<span class="nc" id="L96">            throw new IllegalStateException(</span>
                    &quot;This UI is configured to be decoupled from the application thread, &quot; +
                    &quot;which means that it can only be modified from the EDT. &quot; +
                    &quot;Please use 'UI.run(()-&gt;...)' method to execute your modifications on the EDT.&quot;
                );

<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if ( _children.contains(builder) )</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;Builder already used!&quot;);</span>

<span class="fc" id="L105">        _children.add(builder);</span>

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if ( builder._parent != null )</span>
<span class="nc" id="L108">            throw new IllegalArgumentException(&quot;Builder already used!&quot;);</span>

<span class="fc" id="L110">        E component = (E) builder.getComponent();</span>

<span class="fc" id="L112">        builder._parent = this;</span>

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if ( component instanceof JComponent ) {</span>
<span class="fc" id="L115">            JComponent c = (JComponent) component;</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">            Style style = ( conf != null ? null : ComponentExtension.from(c).calculateStyle() );</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L119">                conf = style.layout().constraint().orElse(null);</span>

<span class="fc" id="L121">            _add(component, conf);</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L124">                ComponentExtension.from(c).applyAndInstallStyle(style, true);</span>
            else
<span class="fc" id="L126">                ComponentExtension.from(c).calculateApplyAndInstallStyle(true);</span>
<span class="fc" id="L127">        }</span>
        else
<span class="nc" id="L129">            _add(component, conf);</span>

<span class="fc" id="L131">        _detachStrongRef(); // Detach strong reference to the component to allow it to be garbage collected.</span>
<span class="fc" id="L132">    }</span>

    /**
     *  This method provides the same functionality as the other &quot;add&quot; methods.
     *  However, it bypasses the necessity to call the &quot;get&quot; method by
     *  calling it internally for you. &lt;br&gt;
     *  This helps to improve readability, especially when the degree of nesting is very low.
     *
     * @param builders An array of builder instances whose JComponents ought to be added to the one wrapped by this builder.
     * @param &lt;B&gt; The type of the builder instances which are used to configure the components that will be added to the component wrapped by this builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public final &lt;B extends AbstractNestedBuilder&lt;?, ?, JComponent&gt;&gt; I add( B... builders ) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if ( builders == null )</span>
<span class="nc" id="L148">            throw new IllegalArgumentException(&quot;Swing tree builders may not be null!&quot;);</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        for ( AbstractNestedBuilder&lt;?, ?, ?&gt; b : builders )</span>
<span class="fc" id="L151">            _doAdd( b, null );</span>

<span class="fc" id="L153">        return _this();</span>
    }

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components A list of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I add( List&lt;E&gt; components ) {
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for ( E component : components )</span>
<span class="fc" id="L167">            _doAdd(UI.of((JComponent) component), null);</span>

<span class="fc" id="L169">        return _this();</span>
    }

<span class="fc" id="L172">    protected final int _childCount() { return _children.size(); }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>