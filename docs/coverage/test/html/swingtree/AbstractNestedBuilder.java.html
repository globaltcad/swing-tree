<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNestedBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractNestedBuilder.java</span></div><h1>AbstractNestedBuilder.java</h1><pre class="source lang-java linenums">package swingtree;

import swingtree.style.ComponentExtension;
import swingtree.style.Style;
import swingtree.threading.EventProcessor;

import javax.swing.JComponent;
import java.awt.Component;
import java.awt.Container;
import java.util.List;

/**
 *  This class is a conceptual extension of the {@link AbstractBuilder} which expects
 *  implementations to define how to compose {@link Component}s into a GUI tree.
 *  This is primarily expressed by the &quot;{@link #add(AbstractNestedBuilder[])}&quot; method which takes an arbitrary number of
 *  builder instances to form said GUI tree structure...
 *
 * @param &lt;I&gt; The type parameter representing the concrete subtype of this abstract class, &quot;I&quot; stands for &quot;Implementation&quot;.
 * @param &lt;C&gt; The type parameter representing the concrete component type which this builder is responsible for building.
 * @param &lt;E&gt; The component type parameter which ought to be built in some way.
 */
<span class="fc" id="L22">abstract class AbstractNestedBuilder&lt;I, C extends E, E extends Component&gt; extends AbstractBuilder&lt;I, C&gt;</span>
{
    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components An array of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final I add( E... components ) {
<span class="fc" id="L35">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc" id="L36">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L37">                    _addComponentsTo( thisComponent, components );</span>
<span class="fc" id="L38">               })</span>
<span class="fc" id="L39">               ._this();</span>
    }

    @SafeVarargs
    protected final void _addComponentsTo( C thisComponent, E... componentsToBeAdded ) {
<span class="fc bfc" id="L44" title="All 2 branches covered.">        for ( E other : componentsToBeAdded )</span>
<span class="fc" id="L45">            _addBuilderTo(thisComponent, UI.of((JComponent) other), null);</span>
<span class="fc" id="L46">    }</span>

    /**
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L54">        return (I) this.add( new AbstractNestedBuilder[]{builder} );</span>
    }

    /**
     * This builder class expects its implementations to be builder types
     * for anything which can be built in a nested tree-like structure.
     * Implementations of this abstract method ought to enable support for nested building.
     * &lt;br&gt;&lt;br&gt;
     *
     * @param thisComponent The component which is wrapped by this builder.
     * @param component     A component instance which ought to be added to the wrapped component type.
     * @param conf          The layout constraint which ought to be used to add the component to the wrapped component type.
     */
    protected abstract void _addComponentTo( C thisComponent, E component, Object conf );

    protected final void _addBuilderTo( C thisComponent, AbstractNestedBuilder&lt;?, ?, ?&gt; builder, Object conf )
    {
<span class="fc" id="L71">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, AbstractNestedBuilder.class);</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">        boolean isCoupled       = _state().eventProcessor() == EventProcessor.COUPLED;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        boolean isCoupledStrict = _state().eventProcessor() == EventProcessor.COUPLED_STRICT;</span>

<span class="pc bpc" id="L76" title="1 of 6 branches missed.">        if ( !isCoupled &amp;&amp; !isCoupledStrict &amp;&amp; !UI.thisIsUIThread() )</span>
<span class="nc" id="L77">            throw new IllegalStateException(</span>
                    &quot;This UI is configured to be decoupled from the application thread, &quot; +
                    &quot;which means that it can only be modified from the EDT. &quot; +
                    &quot;Please use 'UI.run(()-&gt;...)' method to execute your modifications on the EDT.&quot;
                );

<span class="fc" id="L83">        E childComponent = (E) builder.getComponent();</span>

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        if ( childComponent instanceof JComponent ) {</span>
<span class="fc" id="L86">            JComponent child = (JComponent) childComponent;</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">            Style style = ( conf != null ? null : ComponentExtension.from(child).gatherStyle() );</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L90">                conf = style.layoutConstraint().orElse(null);</span>

<span class="fc" id="L92">            _addComponentTo(thisComponent, childComponent, conf);</span>

<span class="fc bfc" id="L94" title="All 2 branches covered.">            if ( style != null )</span>
<span class="fc" id="L95">                ComponentExtension.from(child).applyAndInstallStyle(style, true);</span>
            else
<span class="fc" id="L97">                ComponentExtension.from(child).gatherApplyAndInstallStyle(true);</span>
<span class="fc" id="L98">        }</span>
        else
<span class="nc" id="L100">            _addComponentTo(thisComponent, childComponent, conf);</span>

<span class="fc" id="L102">        builder._detachStrongRef(); // Detach strong reference to the component to allow it to be garbage collected.</span>
<span class="fc" id="L103">    }</span>

    /**
     *  This method provides the same functionality as the other &quot;add&quot; methods.
     *  However, it bypasses the necessity to call the &quot;get&quot; method by
     *  calling it internally for you. &lt;br&gt;
     *  This helps to improve readability, especially when the degree of nesting is very low.
     *
     * @param builders An array of builder instances whose JComponents ought to be added to the one wrapped by this builder.
     * @param &lt;B&gt; The type of the builder instances which are used to configure the components that will be added to the component wrapped by this builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public final &lt;B extends AbstractNestedBuilder&lt;?, ?, JComponent&gt;&gt; I add( B... builders )
    {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if ( builders == null )</span>
<span class="nc" id="L120">            throw new IllegalArgumentException(&quot;Swing tree builders may not be null!&quot;);</span>

<span class="fc" id="L122">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L123">                    _addBuildersTo( thisComponent, builders );</span>
<span class="fc" id="L124">                })</span>
<span class="fc" id="L125">                ._this();</span>
    }

    @SafeVarargs
    protected final &lt;B extends AbstractNestedBuilder&lt;?, ?, JComponent&gt;&gt; void _addBuildersTo(
        C thisComponent,
        B... builders
    ) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for ( AbstractNestedBuilder&lt;?, ?, ?&gt; b : builders )</span>
<span class="fc" id="L134">            _addBuilderTo(thisComponent, b, null);</span>
<span class="fc" id="L135">    }</span>

    /**
     *  This builder class expects its implementations to be builder types
     *  for anything which can be built in a nested tree-like structure.
     *  Implementations of this abstract method ought to enable support for nested building.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param components A list of component instances which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I add( List&lt;E&gt; components ) {
<span class="fc" id="L147">        return _with( thisComponent -&gt; {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                    for ( E component : components )</span>
<span class="fc" id="L149">                        _addBuilderTo(thisComponent, UI.of((JComponent) component), null);</span>
<span class="fc" id="L150">                })</span>
<span class="fc" id="L151">                ._this();</span>
    }

    protected final int _childCount( C c ) {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        return  ( c instanceof Container ? ( (Container) c ).getComponentCount() : 0 );</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>