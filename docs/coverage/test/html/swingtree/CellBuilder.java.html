<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CellBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">CellBuilder.java</span></div><h1>CellBuilder.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.Association;
import sprouts.Pair;
import swingtree.api.Configurator;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.event.CellEditorListener;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.text.JTextComponent;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreeCellEditor;
import javax.swing.tree.TreeCellRenderer;
import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 *  A builder type for creating cell renderer for a list, combo box or table
 *  using a fluent API, typically through methods like {@link UIForList#withCells(Configurator)},
 *  {@link UIForCombo#withCells(Configurator)} or {@link UIForTable#withCells(Configurator)},
 *  where the builder is exposed to the configurator lambda. &lt;p&gt;
 *  A typical usage of this API may look something like this:
 *  &lt;pre&gt;{@code
 *      .withCells( it -&gt; it
 *          .when( Number.class )
 *          .asText( cell -&gt; cell.entryAsString()+&quot; km/h&quot; )
 *          .when( String.class )
 *          .as( cell -&gt; {
 *              // do component based rendering:
 *              return cell.view( new JLabel( cell.entryAsString() ) );
 *              // or do 2D graphics rendering directly:
 *              return cell.renderer(Size.of(200,100), g -&gt; {
 *              	// draw something
 *                  g.setColor( UI.color( cell.entryAsString() ) );
 *                  g.fillRect( 0, 0, 200, 100 );
 *              });
 *          })
 *      )
 *  }&lt;/pre&gt;
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @param &lt;C&gt; The type of the component which is used to render the cell.
 * @param &lt;E&gt; The type of the value of the cell.
 */
public final class CellBuilder&lt;C extends JComponent, E&gt; {

<span class="fc" id="L60">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(CellBuilder.class);</span>

    private BuiltCells&lt;C,E&gt; _state;

<span class="fc" id="L64">    static class CellView&lt;C extends JComponent&gt; {</span>
<span class="fc" id="L65">        @Nullable Component _renderer = null;</span>
<span class="fc" id="L66">        @Nullable Component _editor = null;</span>
<span class="fc" id="L67">        final List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; _configurators = new ArrayList&lt;&gt;();</span>
    }

    static &lt;E&gt; CellBuilder&lt;JList&lt;E&gt;,E&gt; forList(Class&lt;E&gt; elementType) {
<span class="fc" id="L71">        return (CellBuilder) new CellBuilder&lt;&gt;(JList.class, elementType);</span>
    }
    static &lt;C extends JComboBox&lt;E&gt;, E&gt; CellBuilder&lt;C,E&gt; forCombo(Class&lt;E&gt; elementType) {
<span class="fc" id="L74">        return (CellBuilder) new CellBuilder&lt;&gt;(JComboBox.class, elementType);</span>
    }
    static &lt;E&gt; CellBuilder&lt;JTable,E&gt; forTable(Class&lt;E&gt; elementType) {
<span class="fc" id="L77">        return (CellBuilder) new CellBuilder&lt;&gt;(JTable.class, elementType);</span>
    }

<span class="fc" id="L80">    private CellBuilder(Class&lt;C&gt; componentType, Class&lt;E&gt; elementType) {</span>
<span class="fc" id="L81">        _state = new BuiltCells&lt;&gt;(componentType, elementType);</span>
<span class="fc" id="L82">    }</span>

    /**
     * Use this to specify for which type of cell value you want custom rendering next.
     * The object returned by this method allows you to specify how to render the values.
     *
     * @param valueType The type of cell value, for which you want custom rendering.
     * @param &lt;T&gt;       The type parameter of the cell value, for which you want custom rendering.
     * @return The {@link RenderAs} builder API step which expects you to provide a lambda for customizing how a cell is rendered.
     */
    public &lt;T extends E&gt; RenderAs&lt;C, E, T&gt; when( Class&lt;T&gt; valueType ) {
<span class="fc" id="L93">        NullUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L94">        return when(valueType, cell -&gt; true);</span>
    }

    /**
     * Use this to specify a specific type for which you want custom rendering
     * as well as a predicate which tests if a cell value should be rendered.
     * The object returned by this method allows you to specify how to render the values
     * using methods like {@link RenderAs#as(Configurator)} or {@link RenderAs#asText(Function)}.
     *
     * @param valueType      The type of cell value, for which you want custom rendering.
     * @param valueValidator A predicate which should return true if the cell value should be rendered.
     * @param &lt;T&gt;            The type parameter of the cell value, for which you want custom rendering.
     * @return The {@link RenderAs} builder API step which expects you to provide a lambda for customizing how a cell is rendered.
     */
    public &lt;T extends E&gt; RenderAs&lt;C, E, T&gt; when(
        Class&lt;T&gt; valueType,
        Predicate&lt;CellConf&lt;C, T&gt;&gt; valueValidator
    ) {
<span class="fc" id="L112">        NullUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L113">        NullUtil.nullArgCheck(valueValidator, &quot;valueValidator&quot;, Predicate.class);</span>
<span class="fc" id="L114">        return new RenderAs&lt;&gt;(this, valueType, valueValidator);</span>
    }

    &lt;V&gt; void _store(
        Class valueType,
        Predicate predicate,
        Configurator&lt;CellConf&lt;C, V&gt;&gt; valueInterpreter
    ) {
<span class="fc" id="L122">        _state = _store(_state, valueType, predicate, valueInterpreter);</span>
<span class="fc" id="L123">    }</span>

    static &lt;C extends JComponent, E, V&gt; BuiltCells&lt;C,E&gt; _store(
            BuiltCells&lt;C,E&gt; state,
            Class valueType,
            Predicate predicate,
            Configurator&lt;CellConf&lt;C, V&gt;&gt; valueInterpreter
    ) {
<span class="fc" id="L131">        NullUtil.nullArgCheck(valueType, &quot;valueType&quot;, Class.class);</span>
<span class="fc" id="L132">        NullUtil.nullArgCheck(predicate, &quot;predicate&quot;, Predicate.class);</span>
<span class="fc" id="L133">        NullUtil.nullArgCheck(valueInterpreter, &quot;valueInterpreter&quot;, Configurator.class);</span>
<span class="fc" id="L134">        state = state.computeIfAbsent(valueType, CellView::new);</span>
<span class="fc" id="L135">        List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; found = state.rendererLookup().get(valueType).get()._configurators;</span>
<span class="fc" id="L136">        found.add(cell -&gt; {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (predicate.test(cell))</span>
<span class="fc" id="L138">                return valueInterpreter.configure((CellConf&lt;C, V&gt;) cell);</span>
            else
<span class="nc" id="L140">                return cell;</span>
        });
<span class="fc" id="L142">        return state;</span>
    }

    static &lt;C extends JComponent, E, T extends JComponent&gt; Component _updateAndGetComponent(
            BuiltCells&lt;C,E&gt; state,
            Function&lt;@Nullable Object, Component&gt; defaultRenderer,
            BiConsumer&lt;@Nullable Component, CellConf&lt;?,?&gt;&gt; saveComponent,
            CellConf&lt;T, Object&gt; cell
    ) {
<span class="fc" id="L151">        @Nullable Object value = cell.entry().orElse(null);</span>
<span class="fc" id="L152">        List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; interpreter = _find(value, state.rendererLookup());</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if ( interpreter.isEmpty() )</span>
<span class="nc" id="L154">            return defaultRenderer.apply(value);</span>
        else {
           /*
               If a view is persisted from previous rendering, initialize with what is most
               like what the user would expect. This is however mainly to avoid
               rendering state left over from previous rendering.
            */
<span class="fc" id="L161">            cell = _initializeViewIfPresent(cell);</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">            for ( Configurator&lt;CellConf&lt;C,?&gt;&gt; configurator : interpreter ) {</span>
<span class="fc" id="L164">                CellConf newCell = cell;</span>
                try {
<span class="fc" id="L166">                    newCell = configurator.configure(newCell);</span>
<span class="nc" id="L167">                } catch (Exception e) {</span>
<span class="nc" id="L168">                    log.error(</span>
                            &quot;Failed to configure cell renderer for &quot; +
<span class="nc" id="L170">                                    &quot;component '&quot;+cell.getHost().getClass().getSimpleName()+&quot;'.&quot;,</span>
                            e
                    );
<span class="fc" id="L173">                }</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                if ( newCell != null )</span>
<span class="fc" id="L175">                    cell = newCell;</span>
<span class="fc" id="L176">            }</span>
            Component choice;
<span class="fc" id="L178">            Optional&lt;Object&gt; presentationEntry = cell.presentationEntry();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">            if (cell.view().isPresent()) {</span>
<span class="fc" id="L180">                choice = cell.view().orElseThrow();</span>
<span class="fc" id="L181">                saveComponent.accept(choice, cell);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            } else if (presentationEntry.isPresent()) {</span>
<span class="nc" id="L183">                choice = defaultRenderer.apply(presentationEntry.get());</span>
<span class="nc" id="L184">                saveComponent.accept(null, cell);</span>
            } else {
<span class="nc" id="L186">                choice = defaultRenderer.apply(value);</span>
<span class="nc" id="L187">                saveComponent.accept(null, cell);</span>
            }

<span class="pc bpc" id="L190" title="3 of 4 branches missed.">            if (!cell.toolTips().isEmpty() &amp;&amp; choice instanceof JComponent)</span>
<span class="nc" id="L191">                ((JComponent) choice).setToolTipText(String.join(&quot;; &quot;, cell.toolTips()));</span>

<span class="fc" id="L193">            return choice;</span>
        }
    }

    private static CellConf _initializeViewIfPresent(CellConf&lt;?, Object&gt; cell) {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if ( cell.view().isPresent() ) {</span>
<span class="nc" id="L199">            Component view = cell.view().orElseThrow();</span>
<span class="nc" id="L200">            @Nullable Object value = cell.entry().orElse(null);</span>
<span class="nc" id="L201">            view.setEnabled(true);</span>
<span class="nc" id="L202">            view.setVisible(true);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if ( view instanceof AbstractButton ) {</span>
<span class="nc" id="L204">                AbstractButton button = (AbstractButton) view;</span>
<span class="nc" id="L205">                button.setSelected(false);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                if ( value instanceof Boolean )</span>
<span class="nc" id="L207">                    button.setSelected((Boolean) value);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                else if ( value instanceof String )</span>
<span class="nc" id="L209">                    button.setText((String) value);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                else if ( value instanceof Icon )</span>
<span class="nc" id="L211">                    button.setIcon((Icon) value);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            } else if ( view instanceof JComboBox ) {</span>
<span class="nc" id="L213">                JComboBox&lt;?&gt; comboBox = (JComboBox&lt;?&gt;) view;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                if ( value != null )</span>
<span class="nc" id="L215">                    comboBox.setSelectedItem(value);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            } else if ( view instanceof JTextComponent) {</span>
<span class="nc" id="L217">                JTextComponent textField = (JTextComponent) view;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                if ( value != null )</span>
<span class="nc" id="L219">                    textField.setText(value.toString());</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">            } else if ( view instanceof JLabel ) {</span>
<span class="nc" id="L221">                JLabel label = (JLabel) view;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if ( value != null )</span>
<span class="nc" id="L223">                    label.setText(value.toString());</span>
            }
        }
<span class="fc" id="L226">        return cell;</span>
    }

    static class SimpleTableCellRenderer implements TableCellRenderer, TableCellEditor, TreeCellRenderer, TreeCellEditor
    {
<span class="fc" id="L231">        private final DefaultTableCellRenderer _defaultRenderer = new DefaultTableCellRenderer();</span>
<span class="fc" id="L232">        private final DefaultTreeCellRenderer _defaultTreeRenderer = new DefaultTreeCellRenderer();</span>
        private final InternalCellEditor _basicEditor;
        private BuiltCells&lt;JTable,Object&gt; _state;

<span class="fc" id="L236">        SimpleTableCellRenderer(Class&lt;? extends JComponent&gt; hostType, BuiltCells&lt;JTable, Object&gt; state) {</span>
<span class="fc" id="L237">            _basicEditor = new InternalCellEditor(hostType);</span>
<span class="fc" id="L238">            _state = state;</span>
<span class="fc" id="L239">        }</span>

        BuiltCells&lt;JTable,Object&gt; getState(){
<span class="nc" id="L242">            return _state;</span>
        }

        private @Nullable Component findEditor(@Nullable Object value) {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L247">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L248">            return _state.rendererLookup().get(type).get()._editor;</span>
        }

        private void safeEditor(@Nullable Object value, @Nullable Component editor) {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L253">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L254">            _state.rendererLookup().get(type).get()._editor = editor;</span>
<span class="fc" id="L255">        }</span>

        private void safeRenderer(@Nullable Object value, @Nullable Component renderer) {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L259">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L260">            _state.rendererLookup().get(type).get()._renderer = renderer;</span>
<span class="fc" id="L261">        }</span>

        private @Nullable Component findRenderer(@Nullable Object value) {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L265">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L266">            return _state.rendererLookup().get(type).get()._renderer;</span>
        }

        public @Nullable Component getEditorComponent() {
<span class="fc" id="L270">            return _basicEditor.getComponent();</span>
        }

        private @Nullable Component _loadEditor(@Nullable Object value) {
<span class="fc" id="L274">            @Nullable Component editor = findEditor(value);</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if ( editor != null )</span>
<span class="nc" id="L276">                editor = _setEditorComponent(editor);</span>
<span class="fc" id="L277">            return editor;</span>
        }

        private @Nullable Component _setEditorComponent(@Nullable Component editor) {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if ( _basicEditor.getComponent() != editor ) {</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                if (editor instanceof JCheckBox) {</span>
<span class="nc" id="L283">                    _basicEditor.setEditor((JCheckBox) editor);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                } else if (editor instanceof JComboBox) {</span>
<span class="nc" id="L285">                    _basicEditor.setEditor((JComboBox&lt;?&gt;) editor);</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                } else if (editor instanceof JTextField) {</span>
<span class="fc" id="L287">                    _basicEditor.setEditor((JTextField) editor);</span>
                }
            }
<span class="fc" id="L290">            return _basicEditor.getComponent();</span>
        }

        private void _setEditor(
                @Nullable Component newEdior,
                @Nullable Object entryFromModel,
                CellConf&lt;?,?&gt; currentCell
        ) {
<span class="fc" id="L298">            newEdior = _setEditorComponent(newEdior);</span>
<span class="fc" id="L299">            safeEditor(entryFromModel, newEdior);</span>
            try {
                // Apply user values to editor:
<span class="fc" id="L302">                Optional&lt;Object&gt; presentationEntry = currentCell.presentationEntry();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">                if ( presentationEntry.isPresent() )</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    _basicEditor.setEntry(presentationEntry.orElse(null), entryFromModel, entryFromModel == null ? Object.class : entryFromModel.getClass());</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                else if ( currentCell.view().isEmpty() )</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                    _basicEditor.setEntry(currentCell.entry().orElse(null), entryFromModel, entryFromModel == null ? Object.class : entryFromModel.getClass());</span>
<span class="nc" id="L307">            } catch (Exception e) {</span>
<span class="nc" id="L308">                log.error(&quot;Failed to populate cell editor!&quot;, e);</span>
<span class="fc" id="L309">            }</span>
<span class="fc" id="L310">        }</span>

        private void _setRenderer(
            @Nullable Component newRenderer,
            @Nullable Object entryFromModel,
            CellConf&lt;?,?&gt; currentCell
        ) {
<span class="fc" id="L317">            safeRenderer(entryFromModel, newRenderer);</span>
            try {
<span class="fc" id="L319">                Optional&lt;Object&gt; presentationEntry = currentCell.presentationEntry();</span>

<span class="pc bpc" id="L321" title="2 of 4 branches missed.">                if ( presentationEntry.isPresent() || currentCell.view().isEmpty() ) {</span>
<span class="nc" id="L322">                    @Nullable Object toBePresented = presentationEntry.orElse(currentCell.entry().orElse(null));</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                    if ( newRenderer instanceof AbstractButton ) {</span>
<span class="nc" id="L324">                        AbstractButton button = (AbstractButton) newRenderer;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                        if ( toBePresented instanceof Boolean )</span>
<span class="nc" id="L326">                            button.setSelected((Boolean) toBePresented);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                        else if ( toBePresented instanceof String )</span>
<span class="nc" id="L328">                            button.setText((String) toBePresented);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">                        else if ( toBePresented instanceof Icon )</span>
<span class="nc" id="L330">                            button.setIcon((Icon) toBePresented);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                    } else if ( newRenderer instanceof JComboBox ) {</span>
<span class="nc" id="L332">                        JComboBox&lt;?&gt; comboBox = (JComboBox&lt;?&gt;) newRenderer;</span>
<span class="nc" id="L333">                        comboBox.setSelectedItem(toBePresented);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    } else if ( newRenderer instanceof JTextComponent ) {</span>
<span class="nc" id="L335">                        JTextComponent textField = (JTextComponent) newRenderer;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                        textField.setText(toBePresented == null ? &quot;&quot; : toBePresented.toString());</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    } else if ( newRenderer instanceof JLabel ) {</span>
<span class="nc" id="L338">                        JLabel label = (JLabel) newRenderer;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                        label.setText(toBePresented == null ? &quot;&quot; : toBePresented.toString());</span>
                    }
                }
<span class="nc" id="L342">            } catch (Exception e) {</span>
<span class="nc" id="L343">                log.error(&quot;Failed to populate cell editor!&quot;, e);</span>
<span class="fc" id="L344">            }</span>
<span class="fc" id="L345">        }</span>

        private Component _fit( JTable table, int row, int column, Component view ) {
            try {
<span class="pc bpc" id="L349" title="1 of 4 branches missed.">                boolean isDefaultEditor = _basicEditor.getComponent() == view &amp;&amp; _basicEditor.hasDefaultComponent();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                boolean isDefaultRenderer = view instanceof InternalLabelForRendering ||</span>
<span class="pc bpc" id="L351" title="3 of 6 branches missed.">                                            view.getClass() == DefaultListCellRenderer.class ||</span>
                                            view instanceof DefaultTableCellRenderer ||
                                            view instanceof DefaultTreeCellRenderer;

<span class="pc bpc" id="L355" title="1 of 4 branches missed.">                if ( !isDefaultRenderer &amp;&amp; !isDefaultEditor ) {</span>
                    /*
                        If you want the table to fit the cell size to the content,
                        then you have to use a custom view / editor!
                    */
<span class="fc" id="L360">                    Dimension minSize = view.getMinimumSize();</span>
<span class="fc" id="L361">                    TableColumn currentColumn = table.getColumnModel().getColumn(column);</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                    if (currentColumn.getMinWidth() &lt; minSize.width)</span>
<span class="nc" id="L363">                        currentColumn.setMinWidth(minSize.width);</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                    if (table.getRowHeight(row) &lt; minSize.height)</span>
<span class="fc" id="L365">                        table.setRowHeight(row, minSize.height);</span>
                }
<span class="nc" id="L367">            } catch (Exception e) {</span>
<span class="nc" id="L368">                log.error(&quot;Failed to fit cell size&quot;, e);</span>
<span class="fc" id="L369">            }</span>
<span class="fc" id="L370">            return view;</span>
        }

        @Override
        public Component getTableCellRendererComponent(
            final JTable           table,
            final @Nullable Object entryFromModel,
            final boolean          isSelected,
            final boolean          hasFocus,
            final int              row,
            final int              column
        ) {
<span class="fc" id="L382">            _state.checkTypeValidity(entryFromModel);</span>
<span class="fc" id="L383">            return _fit(table, row, column,</span>
<span class="fc" id="L384">                        _updateAndGetComponent(</span>
                            _state,
<span class="nc" id="L386">                             localEntry -&gt; _defaultRenderer.getTableCellRendererComponent(table, localEntry, isSelected, hasFocus, row, column),</span>
<span class="fc" id="L387">                             (choice, newRenderer) -&gt; _setRenderer(choice, entryFromModel, newRenderer),</span>
<span class="fc" id="L388">                             CellConf.of(</span>
<span class="fc" id="L389">                                 null, findRenderer(entryFromModel),</span>
                                 table, entryFromModel, isSelected, hasFocus, false, false, false, row, column,
<span class="nc" id="L391">                                 () -&gt; _defaultRenderer.getTableCellRendererComponent(table, entryFromModel, isSelected, hasFocus, row, column)</span>
                             )
                        )
                    );
        }

        @Override
        public Component getTableCellEditorComponent(
            final JTable           table,
            final @Nullable Object entryFromModel,
            final boolean          isSelected,
            final int              row,
            final int              column
        ) {
<span class="fc" id="L405">            _state.checkTypeValidity(entryFromModel);</span>
<span class="fc" id="L406">            _basicEditor.ini(table, row, column);</span>
<span class="fc" id="L407">            _basicEditor.updateForTable(table, column);</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            _basicEditor.setEntry(entryFromModel, entryFromModel, entryFromModel == null ? Object.class : entryFromModel.getClass());</span>
<span class="fc" id="L409">            return _fit(table, row, column,</span>
<span class="fc" id="L410">                        _updateAndGetComponent(</span>
                            _state,
<span class="nc" id="L412">                             localEntry -&gt; _basicEditor.getTableCellEditorComponent(table, localEntry, isSelected, row, column),</span>
<span class="fc" id="L413">                             (choice, newEditor) -&gt; _setEditor(choice, entryFromModel, newEditor),</span>
<span class="fc" id="L414">                             CellConf.of(</span>
<span class="fc" id="L415">                                 null, _loadEditor(entryFromModel),</span>
                                 table, entryFromModel, isSelected, true, true, false, false, row, column,
<span class="nc" id="L417">                                 () -&gt; _basicEditor.getTableCellEditorComponent(table, entryFromModel, isSelected, row, column)</span>
                             )
                        )
                    );
        }

        @Override
        public Component getTreeCellRendererComponent(
            final JTree            tree,
            final @Nullable Object entryFromModel,
            final boolean          selected,
            final boolean          expanded,
            final boolean          leaf,
            final int              row,
            final boolean          hasFocus
        ) {
<span class="nc" id="L433">            _state.checkTypeValidity(entryFromModel);</span>
<span class="nc" id="L434">            String entryAsString = tree.convertValueToText(entryFromModel, selected, expanded, leaf, row, false);</span>
<span class="nc" id="L435">            _basicEditor.ini(tree, row, 0);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            _basicEditor.setEntry(entryAsString, entryFromModel, entryFromModel == null ? Object.class : entryFromModel.getClass());</span>
<span class="nc" id="L437">            return _updateAndGetComponent(</span>
                         _state,
<span class="nc" id="L439">                         localValue -&gt; _defaultTreeRenderer.getTreeCellRendererComponent(tree, localValue, selected, expanded, leaf, row, hasFocus),</span>
<span class="nc" id="L440">                         (choice, newRenderer) -&gt; _setRenderer(choice, entryFromModel, newRenderer),</span>
<span class="nc" id="L441">                         CellConf.of(</span>
<span class="nc" id="L442">                             null, findRenderer(entryFromModel),</span>
                             tree, entryFromModel, selected, hasFocus, false, expanded, leaf, row, 0,
<span class="nc" id="L444">                             () -&gt; _defaultTreeRenderer.getTreeCellRendererComponent(tree, entryFromModel, selected, expanded, leaf, row, hasFocus)</span>
                         )
                    );
        }

        @Override
        public Component getTreeCellEditorComponent(
            final JTree            tree,
            final @Nullable Object entryFromModel,
            final boolean          isSelected,
            final boolean          expanded,
            final boolean          leaf,
            final int              row
        ) {
<span class="nc" id="L458">            _state.checkTypeValidity(entryFromModel);</span>
<span class="nc" id="L459">            _basicEditor.ini(tree, row, 0);</span>
<span class="nc" id="L460">            return _updateAndGetComponent(</span>
                         _state,
<span class="nc" id="L462">                         localEntry -&gt; _basicEditor.getTreeCellEditorComponent(tree, localEntry, isSelected, expanded, leaf, row),</span>
<span class="nc" id="L463">                        (choice, newEditor) -&gt; _setEditor(choice, entryFromModel, newEditor),</span>
<span class="nc" id="L464">                         CellConf.of(</span>
<span class="nc" id="L465">                             null, _loadEditor(entryFromModel),</span>
                             tree, entryFromModel, isSelected,
                             true, true, expanded, leaf, row, 0,
<span class="nc" id="L468">                             () -&gt; _basicEditor.getTreeCellEditorComponent(tree, entryFromModel, isSelected, expanded, leaf, row)</span>
                         )
                    );
        }

        @Override
        public @Nullable Object getCellEditorValue() {
<span class="nc" id="L475">            return _basicEditor.getCellEditorValue();</span>
        }

        @Override
        public boolean isCellEditable(EventObject anEvent) {
<span class="fc" id="L480">            return _basicEditor.isCellEditable(anEvent);</span>
        }

        @Override
        public boolean shouldSelectCell(EventObject anEvent) {
<span class="nc" id="L485">            return _basicEditor.shouldSelectCell(anEvent);</span>
        }

        @Override
        public boolean stopCellEditing() {
<span class="nc" id="L490">            return _basicEditor.stopCellEditing();</span>
        }

        @Override
        public void cancelCellEditing() {
<span class="nc" id="L495">            _basicEditor.cancelCellEditing();</span>
<span class="nc" id="L496">        }</span>

        @Override
        public void addCellEditorListener(CellEditorListener l) {
<span class="fc" id="L500">            _basicEditor.addCellEditorListener(l);</span>
<span class="fc" id="L501">        }</span>

        @Override
        public void removeCellEditorListener(CellEditorListener l) {
<span class="nc" id="L505">            _basicEditor.removeCellEditorListener(l);</span>
<span class="nc" id="L506">        }</span>
    }

    private static class SimpleListCellRenderer&lt;O extends JComponent, E&gt; implements ListCellRenderer&lt;Object&gt;
    {
        private final O _component;
        private final ListCellRenderer&lt;Object&gt; _defaultRenderer;
        private BuiltCells&lt;O, E&gt; _state;


<span class="fc" id="L516">        private SimpleListCellRenderer(O component, BuiltCells&lt;O, E&gt; state) {</span>
<span class="fc" id="L517">            _state = state;</span>
<span class="fc" id="L518">            _component = Objects.requireNonNull(component);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if ( component instanceof JComboBox )</span>
<span class="fc" id="L520">                _defaultRenderer = new BasicComboBoxRenderer.UIResource();</span>
            else
<span class="fc" id="L522">                _defaultRenderer = new DefaultListCellRenderer.UIResource();</span>
<span class="fc" id="L523">        }</span>

        BuiltCells&lt;O,E&gt; getState(){
<span class="fc" id="L526">            return _state;</span>
        }

        private @Nullable Component findRenderer(@Nullable Object value) {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L531">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L532">            return _state.rendererLookup().get(type).get()._renderer;</span>
        }

        private void safeRenderer(@Nullable Object value, @Nullable Component renderer) {
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            Class type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L537">            _state = _state.computeIfAbsent(type, CellView::new);</span>
<span class="fc" id="L538">            _state.rendererLookup().get(type).get()._renderer = renderer;</span>
<span class="fc" id="L539">        }</span>

        @Override
        public Component getListCellRendererComponent(
            final JList   list,
            final Object  value,
            final int     row,
            final boolean isSelected,
            final boolean hasFocus
        ) {
<span class="fc" id="L549">            _state.checkTypeValidity(value);</span>
<span class="fc" id="L550">            List&lt;Configurator&lt;CellConf&lt;O, ?&gt;&gt;&gt; interpreter = _find(value, _state.rendererLookup());</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">            if (interpreter.isEmpty())</span>
<span class="nc" id="L552">                return _defaultRenderer.getListCellRendererComponent(list, value, row, isSelected, hasFocus);</span>
            else {
<span class="fc" id="L554">                CellConf&lt;O, Object&gt; cell = CellConf.of(</span>
                                                        list,
<span class="fc" id="L556">                                                        findRenderer(value),</span>
                                                        _component, value, isSelected,
                                                        hasFocus, false, false, false, row, 0,
<span class="nc" id="L559">                                                        ()-&gt;_defaultRenderer.getListCellRendererComponent(list, value, row, isSelected, hasFocus)</span>
                                                    );

<span class="fc bfc" id="L562" title="All 2 branches covered.">                for ( Configurator&lt;CellConf&lt;O,?&gt;&gt; configurator : interpreter ) {</span>
<span class="fc" id="L563">                    CellConf newCell = cell;</span>
                    try {
<span class="fc" id="L565">                        newCell = configurator.configure(newCell);</span>
<span class="fc" id="L566">                    } catch (Exception e) {</span>
<span class="fc" id="L567">                        log.error(</span>
                                &quot;Failed to configure cell renderer for &quot; +
<span class="fc" id="L569">                                &quot;component '&quot;+_component.getClass().getSimpleName()+&quot;'.&quot;,</span>
                                e
                            );
<span class="fc" id="L572">                    }</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                    if ( newCell != null )</span>
<span class="fc" id="L574">                        cell = newCell;</span>
<span class="fc" id="L575">                }</span>
                Component choice;
<span class="fc" id="L577">                Optional&lt;Object&gt; presentationEntry = cell.presentationEntry();</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (cell.view().isPresent()) {</span>
<span class="fc" id="L579">                    choice = cell.view().orElseThrow();</span>
<span class="fc" id="L580">                    safeRenderer(value, choice);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                } else if (presentationEntry.isPresent()) {</span>
<span class="nc" id="L582">                    choice = _defaultRenderer.getListCellRendererComponent(list, presentationEntry.get(), row, isSelected, hasFocus);</span>
<span class="nc" id="L583">                    safeRenderer(value, null);</span>
                } else {
<span class="fc" id="L585">                    choice = _defaultRenderer.getListCellRendererComponent(list, value, row, isSelected, hasFocus);</span>
<span class="fc" id="L586">                    safeRenderer(value, null);</span>
                }

<span class="pc bpc" id="L589" title="3 of 4 branches missed.">                if (!cell.toolTips().isEmpty() &amp;&amp; choice instanceof JComponent)</span>
<span class="nc" id="L590">                    ((JComponent) choice).setToolTipText(String.join(&quot;; &quot;, cell.toolTips()));</span>

<span class="fc" id="L592">                return choice;</span>
            }
        }

        Optional&lt;ComboBoxEditor&gt; establishEditor() {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            if ( !( _component instanceof JComboBox ) )</span>
<span class="nc" id="L598">                return Optional.empty();</span>
<span class="fc" id="L599">            JComboBox&lt;?&gt; comboBox = (JComboBox&lt;?&gt;) _component;</span>

<span class="fc" id="L601">            CellConf&lt;JComboBox&lt;?&gt;, Object&gt; cell = CellConf.of(</span>
<span class="nc" id="L602">                null, null, comboBox, null, false, false, true, false, false, 0, 0, () -&gt; null</span>
            );
<span class="fc" id="L604">            List&lt;Configurator&lt;CellConf&lt;O, ?&gt;&gt;&gt; interpreter = _findAll(_state.rendererLookup());</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">            if (interpreter.isEmpty())</span>
<span class="nc" id="L606">                return Optional.empty();</span>
            else {
<span class="fc bfc" id="L608" title="All 2 branches covered.">                for ( Configurator&lt;CellConf&lt;O,?&gt;&gt; configurator : interpreter ) {</span>
<span class="fc" id="L609">                    CellConf&lt;JComboBox&lt;?&gt;,Object&gt; newCell = cell;</span>
                    try {
<span class="fc" id="L611">                        newCell = configurator.configure((CellConf)newCell);</span>
<span class="fc" id="L612">                    } catch (Exception e) {</span>
<span class="fc" id="L613">                        log.error(</span>
                                &quot;Failed to establish cell editor through cell configurator &quot; +
<span class="fc" id="L615">                                &quot;for component '&quot;+_component.getClass().getSimpleName()+&quot;'.&quot;,</span>
                                e
                            );
<span class="fc" id="L618">                    }</span>
                    try {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">                        if ( newCell != null )</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">                            cell = newCell.updateView(v -&gt; v.update(c -&gt; c instanceof JTextField ? c : null ) );</span>
<span class="fc" id="L622">                    } catch (Exception e) {</span>
<span class="fc" id="L623">                        log.error(</span>
                                &quot;Failed to establish cell editor through cell configurator &quot; +
<span class="fc" id="L625">                                &quot;for component '&quot;+_component.getClass().getSimpleName()+&quot;'.&quot;,</span>
                                e
                            );
<span class="fc" id="L628">                    }</span>
<span class="fc" id="L629">                }</span>

<span class="fc bfc" id="L631" title="All 2 branches covered.">                if (!cell.view().isPresent())</span>
<span class="fc" id="L632">                    return Optional.empty();</span>

<span class="fc" id="L634">                Component choice = cell.view().orElseThrow();</span>

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                if ( !(choice instanceof JTextField) )</span>
<span class="nc" id="L637">                    return Optional.empty();</span>

<span class="fc" id="L639">                JTextField textField = (JTextField) choice;</span>

<span class="fc" id="L641">                return Optional.of(new InternalComboBoxCellEditor(textField));</span>
            }
        }
    }

    private static &lt;C extends JComponent&gt; List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; _find(
        @Nullable Object value,
        Association&lt;Class&lt;?&gt;, CellView&lt;C&gt;&gt; rendererLookup
    ) {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        Class&lt;?&gt; type = (value == null ? Object.class : value.getClass());</span>
<span class="fc" id="L651">        List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; cellRenderer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        for (Pair&lt;Class&lt;?&gt;, CellView&lt;C&gt;&gt; e : rendererLookup.entrySet()) {</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (e.first().isAssignableFrom(type))</span>
<span class="fc" id="L654">                cellRenderer.addAll(e.second()._configurators);</span>
<span class="fc" id="L655">        }</span>
        // We reverse the cell renderers, so that the most un-specific one is first
<span class="fc" id="L657">        Collections.reverse(cellRenderer);</span>
<span class="fc" id="L658">        return cellRenderer;</span>
    }

    private static &lt;C extends JComponent&gt; List&lt;Configurator&lt;CellConf&lt;C,?&gt;&gt;&gt; _findAll(
        Association&lt;Class&lt;?&gt;, CellView&lt;C&gt;&gt; rendererLookup
    ) {
<span class="fc" id="L664">        List&lt;Configurator&lt;CellConf&lt;C, ?&gt;&gt;&gt; cellRenderer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (CellView&lt;C&gt; e : rendererLookup.values()) {</span>
<span class="fc" id="L666">            cellRenderer.addAll(e._configurators);</span>
<span class="fc" id="L667">        }</span>
        // We reverse the cell renderers, so that the most un-specific one is first
<span class="fc" id="L669">        Collections.reverse(cellRenderer);</span>
<span class="fc" id="L670">        return cellRenderer;</span>
    }

    SimpleTableCellRenderer getForTable(@Nullable TableCellRenderer oldTableRenderer) {
<span class="fc" id="L674">        BuiltCells&lt;C,E&gt; state = _state;</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        if (JTable.class.isAssignableFrom(state.componentType())) {</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if ( oldTableRenderer instanceof SimpleTableCellRenderer ) {</span>
<span class="nc" id="L677">                SimpleTableCellRenderer oldRenderer = (SimpleTableCellRenderer) oldTableRenderer;</span>
<span class="nc" id="L678">                BuiltCells&lt;JTable,Object&gt; oldState = oldRenderer.getState();</span>
<span class="nc" id="L679">                state = oldState.addRenderLookups((Association) state.rendererLookup());</span>
<span class="nc" id="L680">            } else {</span>
<span class="fc" id="L681">                state = _addDefaultRendering(state);</span>
            }
<span class="fc" id="L683">            SimpleTableCellRenderer renderer = new SimpleTableCellRenderer(state.componentType(), (BuiltCells) state);</span>
<span class="fc" id="L684">            return renderer;</span>
        } else
<span class="nc" id="L686">            throw new IllegalArgumentException(&quot;Renderer was set up to be used for a JTable!&quot;);</span>
    }

    TreeCellRenderer getForTree(@Nullable TableCellRenderer oldTableRenderer) {
<span class="nc" id="L690">        BuiltCells&lt;C,E&gt; state = _state;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (JTree.class.isAssignableFrom(state.componentType())) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if ( oldTableRenderer instanceof SimpleTableCellRenderer ) {</span>
<span class="nc" id="L693">                SimpleTableCellRenderer oldRenderer = (SimpleTableCellRenderer) oldTableRenderer;</span>
<span class="nc" id="L694">                BuiltCells&lt;JTable,Object&gt; oldState = oldRenderer.getState();</span>
<span class="nc" id="L695">                state = oldState.addRenderLookups((Association) state.rendererLookup());</span>
<span class="nc" id="L696">            } else {</span>
<span class="nc" id="L697">                state = _addDefaultRendering(state);</span>
            }
<span class="nc" id="L699">            return new SimpleTableCellRenderer(state.componentType(), (BuiltCells) state);</span>
        } else
<span class="nc" id="L701">            throw new IllegalArgumentException(&quot;Renderer was set up to be used for a JTree!&quot;);</span>
    }

    /**
     * Like many things in the SwingTree library, this class is
     * essentially a convenient builder for a {@link ListCellRenderer}.
     * This internal method actually builds the {@link ListCellRenderer} instance,
     * see {@link UIForList#withCell(swingtree.api.Configurator)} for more details
     * about how to use this class as pat of the main API.
     *
     * @param list The list for which the renderer is to be built.
     */
    void buildForList( C list ) {
<span class="fc" id="L714">        BuiltCells&lt;C,E&gt; state = _state;</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">        if (JList.class.isAssignableFrom(state.componentType())) {</span>
<span class="fc" id="L716">            JList&lt;E&gt; jList = (JList&lt;E&gt;) list;</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if ( jList.getCellRenderer() instanceof SimpleListCellRenderer ) {</span>
<span class="nc" id="L718">                SimpleListCellRenderer&lt;C,E&gt; oldRenderer = (SimpleListCellRenderer) jList.getCellRenderer();</span>
<span class="nc" id="L719">                BuiltCells&lt;C,E&gt; oldState = oldRenderer.getState();</span>
<span class="nc" id="L720">                state = oldState.addRenderLookups(state.rendererLookup());</span>
<span class="nc" id="L721">            } else {</span>
<span class="fc" id="L722">                state = _addDefaultRendering(state);</span>
            }
<span class="fc" id="L724">            SimpleListCellRenderer&lt;C,E&gt; renderer = new SimpleListCellRenderer&lt;&gt;(list, state);</span>
<span class="fc" id="L725">            jList.setCellRenderer(renderer);</span>
<span class="pc bnc" id="L726" title="All 2 branches missed.">        } else if (JComboBox.class.isAssignableFrom(state.componentType()))</span>
<span class="nc" id="L727">            throw new IllegalArgumentException(</span>
                &quot;Renderer was set up to be used for a JList! &quot; +
<span class="nc" id="L729">                &quot;(not &quot; + state.componentType().getSimpleName() + &quot;)&quot;</span>
            );
        else
<span class="nc" id="L732">            throw new IllegalArgumentException(</span>
                &quot;Renderer was set up to be used for an unknown component type! &quot; +
<span class="nc" id="L734">                &quot;(cannot handle '&quot; + state.componentType().getSimpleName() + &quot;')&quot;</span>
            );
<span class="fc" id="L736">    }</span>

    void buildForCombo(C comboBox, boolean establishEditorAlso) {
<span class="fc" id="L739">        BuiltCells&lt;C,E&gt; state = _state;</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (JComboBox.class.isAssignableFrom(state.componentType())) {</span>
<span class="fc" id="L741">            JComboBox&lt;E&gt; combo = (JComboBox&lt;E&gt;) comboBox;</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">            if ( combo.getRenderer() instanceof SimpleListCellRenderer ) {</span>
<span class="fc" id="L743">                SimpleListCellRenderer&lt;C,E&gt; oldRenderer = (SimpleListCellRenderer) combo.getRenderer();</span>
<span class="fc" id="L744">                BuiltCells&lt;C,E&gt; oldState = oldRenderer.getState();</span>
<span class="fc" id="L745">                state = oldState.addRenderLookups(state.rendererLookup());</span>
<span class="fc" id="L746">            } else {</span>
<span class="fc" id="L747">                state = _addDefaultRendering(state);</span>
            }
<span class="fc" id="L749">            SimpleListCellRenderer&lt;C, E&gt; renderer = new SimpleListCellRenderer&lt;&gt;(comboBox, state);</span>
<span class="fc" id="L750">            combo.setRenderer(renderer);</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">            if (establishEditorAlso) {</span>
<span class="fc" id="L752">                renderer.establishEditor().ifPresent(combo::setEditor);</span>
            }
<span class="fc" id="L754">        } else</span>
<span class="nc" id="L755">            throw new IllegalArgumentException(</span>
                &quot;Renderer was set up to be used for a JComboBox! &quot; +
<span class="nc" id="L757">                &quot;(not &quot; + state.componentType().getSimpleName() + &quot;)&quot;</span>
            );
<span class="fc" id="L759">    }</span>

    private static &lt;C extends JComponent,E&gt; BuiltCells&lt;C,E&gt; _addDefaultRendering(BuiltCells&lt;C,E&gt; state) {
        // We use the default text renderer for objects
<span class="fc" id="L763">        return _store(state, Object.class, cell -&gt; true, _createDefaultTextRenderer(cell -&gt; cell.entryAsString()));</span>
    }

    static class InternalLabelForRendering extends DefaultListCellRenderer {
<span class="fc" id="L767">        InternalLabelForRendering(String text) {</span>
<span class="fc" id="L768">            setText(text);</span>
<span class="fc" id="L769">            setOpaque(true);</span>
<span class="fc" id="L770">        }</span>
    }

    static &lt;C extends JComponent, V&gt; Configurator&lt;CellConf&lt;C, V&gt;&gt; _createDefaultTextRenderer(
            Function&lt;CellConf&lt;C, V&gt;, String&gt; renderer
    ) {
<span class="fc" id="L776">        Function&lt;CellConf&lt;C, V&gt;, String&gt; exceptionSafeRenderer = cell -&gt; {</span>
            try {
<span class="fc" id="L778">                return renderer.apply(cell);</span>
<span class="nc" id="L779">            } catch (Exception e) {</span>
<span class="nc" id="L780">                log.error(&quot;Failed to convert cell to displayable String!&quot;, e);</span>
<span class="nc" id="L781">                return &quot;&quot;;</span>
            }
        };
<span class="fc" id="L784">        return cell -&gt; {</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">            if ( cell.isEditing() )</span>
<span class="fc" id="L786">                return cell;</span>

<span class="fc" id="L788">            Component existing = cell.view().orElseNullable(null);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">            InternalLabelForRendering l = (existing instanceof InternalLabelForRendering) ? (InternalLabelForRendering) existing : null;</span>
<span class="pc bpc" id="L790" title="1 of 4 branches missed.">            if ( existing != null &amp;&amp; l == null )</span>
<span class="nc" id="L791">                return cell; // The user has defined a custom renderer, so we don't touch it.</span>

<span class="fc bfc" id="L793" title="All 2 branches covered.">            if ( l == null )</span>
<span class="fc" id="L794">                l = new InternalLabelForRendering(exceptionSafeRenderer.apply(cell));</span>
            else
<span class="fc" id="L796">                l.setText(exceptionSafeRenderer.apply(cell));</span>

<span class="fc" id="L798">            Color bg = null;</span>
<span class="fc" id="L799">            Color fg = null;</span>

<span class="fc bfc" id="L801" title="All 4 branches covered.">            if ( cell.getHost() instanceof JComboBox &amp;&amp; cell.getListView().isPresent() ) {</span>
<span class="fc" id="L802">                JList&lt;?&gt; list = cell.getListView().get();</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">                if (cell.isSelected()) {</span>
<span class="nc" id="L804">                    bg = list.getSelectionBackground();</span>
<span class="nc" id="L805">                    fg = list.getSelectionForeground();</span>
                }
                else {
<span class="fc" id="L808">                    bg = list.getBackground();</span>
<span class="fc" id="L809">                    fg = list.getForeground();</span>
                }
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">            } else if ( cell.getHost() instanceof JList ) {</span>
<span class="nc" id="L812">                JList&lt;?&gt; jList = (JList&lt;?&gt;) cell.getHost();</span>
<span class="nc" id="L813">                bg = jList.getSelectionBackground();</span>
<span class="nc" id="L814">                fg = jList.getSelectionForeground();</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                if ( bg == null )</span>
<span class="nc" id="L816">                    bg = UIManager.getColor(&quot;List.selectionBackground&quot;);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if ( fg == null )</span>
<span class="nc" id="L818">                    fg = UIManager.getColor(&quot;List.selectionForeground&quot;);</span>
<span class="pc bfc" id="L819" title="All 2 branches covered.">            } else if ( cell.getHost() instanceof JTable ) {</span>
<span class="fc" id="L820">                JTable jTable = (JTable) cell.getHost();</span>
<span class="fc" id="L821">                bg = jTable.getSelectionBackground();</span>
<span class="fc" id="L822">                fg = jTable.getSelectionForeground();</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">                if ( bg == null )</span>
<span class="nc" id="L824">                    bg = UIManager.getColor(&quot;Table.selectionBackground&quot;);</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">                if ( fg == null )</span>
<span class="nc" id="L826">                    fg = UIManager.getColor(&quot;Table.selectionForeground&quot;);</span>
            }

<span class="fc bfc" id="L829" title="All 2 branches covered.">            if ( bg == null )</span>
<span class="fc" id="L830">                bg = cell.getHost().getBackground();</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">            if ( fg == null )</span>
<span class="fc" id="L832">                fg = cell.getHost().getForeground();</span>

<span class="pc bpc" id="L834" title="1 of 2 branches missed.">            if ( bg == null )</span>
<span class="nc" id="L835">                bg = UIManager.getColor( &quot;ComboBox.selectionBackground&quot; );</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            if ( fg == null )</span>
<span class="nc" id="L837">                fg = UIManager.getColor( &quot;ComboBox.selectionForeground&quot; );</span>

<span class="pc bpc" id="L839" title="1 of 2 branches missed.">            if ( bg == null )</span>
<span class="nc" id="L840">                bg = UIManager.getColor( &quot;List.dropCellBackground&quot; );</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">            if ( fg == null )</span>
<span class="nc" id="L842">                fg = UIManager.getColor( &quot;List.dropCellForeground&quot; );</span>

<span class="pc bpc" id="L844" title="1 of 2 branches missed.">            if ( bg == null )</span>
<span class="nc" id="L845">                bg = UIManager.getColor( &quot;ComboBox.background&quot; );</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">            if ( fg == null )</span>
<span class="nc" id="L847">                fg = UIManager.getColor( &quot;ComboBox.foreground&quot; );</span>

            // Lastly we make sure the color is a user color, not a LaF color:
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">            if ( bg != null ) // This is because of a weired JDK bug it seems!</span>
<span class="fc" id="L851">                bg = new Color( bg.getRGB() );</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">            if ( fg != null )</span>
<span class="fc" id="L853">                fg = new Color( fg.getRGB() );</span>

<span class="pc bpc" id="L855" title="1 of 2 branches missed.">            if (cell.isSelected()) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if ( bg != null ) _setBackgroundColor(l, bg);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">                if ( fg != null ) _setForegroundColor(l, fg);</span>
            }
            else {
<span class="fc" id="L860">                Color normalBg = cell.getHost().getBackground();</span>

                // We need to make sure the color is a user color, not a LaF color:
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">                if ( normalBg != null )</span>
<span class="fc" id="L864">                    normalBg = new Color( normalBg.getRGB() ); // This is because of a weired JDK bug it seems!</span>

<span class="fc bfc" id="L866" title="All 2 branches covered.">                if ( cell.row() % 2 == 1 ) {</span>
                    // We determine if the base color is more bright or dark,
                    // and then we set the foreground color accordingly
<span class="fc" id="L869">                    double brightness = (0.299 * normalBg.getRed() + 0.587 * normalBg.getGreen() + 0.114 * normalBg.getBlue()) / 255;</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">                    if ( brightness &lt; 0.5 )</span>
<span class="nc" id="L871">                        normalBg = brighter(normalBg);</span>
                    else
<span class="fc" id="L873">                        normalBg = darker(normalBg);</span>
                }
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">                if ( bg != null )</span>
<span class="fc" id="L876">                    _setBackgroundColor( l, normalBg );</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">                if ( fg != null )</span>
<span class="fc" id="L878">                    _setForegroundColor( l, cell.getHost().getForeground() );</span>
            }

            // TODO:
            //l.setFont(cell.getHost().getFont()); // Is this a good idea?
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">            if ( l.isEnabled() != cell.getHost().isEnabled() )</span>
<span class="nc" id="L884">                l.setEnabled(cell.getHost().isEnabled());</span>

<span class="fc" id="L886">            Border border = null;</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">            if ( cell.hasFocus() ) {</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if ( cell.isSelected() )</span>
<span class="nc" id="L889">                    border = UIManager.getBorder( &quot;List.focusSelectedCellHighlightBorder&quot; );</span>

<span class="nc bnc" id="L891" title="All 2 branches missed.">                if ( border == null )</span>
<span class="nc" id="L892">                    border = UIManager.getBorder( &quot;List.focusCellHighlightBorder&quot; );</span>
            }
            else
<span class="fc" id="L895">                border = UIManager.getBorder( &quot;List.cellNoFocusBorder&quot; );</span>

<span class="pc bpc" id="L897" title="3 of 4 branches missed.">            if ( border != null &amp;&amp; border != l.getBorder() )</span>
<span class="nc" id="L898">                l.setBorder(border);</span>

<span class="fc" id="L900">            return cell.view(l);</span>
        };
    }

    private static void _setBackgroundColor( JComponent comp, @Nullable Color color ) {
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">        if ( color == null ) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if ( comp.isBackgroundSet() )</span>
<span class="nc" id="L907">                comp.setBackground(null);</span>
            else
<span class="nc" id="L909">                return; // Already null!</span>
        }
        else
<span class="fc bfc" id="L912" title="All 2 branches covered.">            if ( !Objects.equals(comp.getBackground(), color) )</span>
<span class="fc" id="L913">                comp.setBackground( color );</span>
<span class="fc" id="L914">    }</span>

    private static void _setForegroundColor( JComponent comp, @Nullable Color color ) {
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">        if ( color == null ) {</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if ( comp.isForegroundSet() )</span>
<span class="nc" id="L919">                comp.setForeground(null);</span>
            else
<span class="nc" id="L921">                return; // Already null!</span>
        }
        else
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            if ( !Objects.equals(comp.getForeground(), color) )</span>
<span class="nc" id="L925">                comp.setForeground( color );</span>
<span class="fc" id="L926">    }</span>


    private static Color darker( Color c ) {
<span class="fc" id="L930">        final double PERCENTAGE = (242*3.0)/(255*3.0);</span>
<span class="fc" id="L931">        return new Color(</span>
<span class="fc" id="L932">                (int)(c.getRed()*PERCENTAGE),</span>
<span class="fc" id="L933">                (int)(c.getGreen()*PERCENTAGE),</span>
<span class="fc" id="L934">                (int)(c.getBlue()*PERCENTAGE)</span>
        );
    }

    private static Color brighter( Color c ) {
<span class="nc" id="L939">        final double FACTOR = (242*3.0)/(255*3.0);</span>
<span class="nc" id="L940">        int r = c.getRed();</span>
<span class="nc" id="L941">        int g = c.getGreen();</span>
<span class="nc" id="L942">        int b = c.getBlue();</span>
<span class="nc" id="L943">        int alpha = c.getAlpha();</span>

<span class="nc" id="L945">        int i = (int)(1.0/(1.0-FACTOR));</span>
<span class="nc bnc" id="L946" title="All 6 branches missed.">        if ( r == 0 &amp;&amp; g == 0 &amp;&amp; b == 0) {</span>
<span class="nc" id="L947">            return new Color(i, i, i, alpha);</span>
        }
<span class="nc bnc" id="L949" title="All 4 branches missed.">        if ( r &gt; 0 &amp;&amp; r &lt; i ) r = i;</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">        if ( g &gt; 0 &amp;&amp; g &lt; i ) g = i;</span>
<span class="nc bnc" id="L951" title="All 4 branches missed.">        if ( b &gt; 0 &amp;&amp; b &lt; i ) b = i;</span>

<span class="nc" id="L953">        return new Color(Math.min((int)(r/FACTOR), 255),</span>
<span class="nc" id="L954">                Math.min((int)(g/FACTOR), 255),</span>
<span class="nc" id="L955">                Math.min((int)(b/FACTOR), 255),</span>
                alpha);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>