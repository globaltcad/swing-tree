<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAnySwing.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAnySwing.java</span></div><h1>UIForAnySwing.java</h1><pre class="source lang-java linenums">package swingtree;


import net.miginfocom.layout.AC;
import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.slf4j.Logger;
import sprouts.Action;
import sprouts.*;
import swingtree.animation.AnimationState;
import swingtree.animation.LifeTime;
import swingtree.api.AnimatedStyler;
import swingtree.api.Peeker;
import swingtree.api.Styler;
import swingtree.api.UIVerifier;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.input.Keyboard;
import swingtree.layout.AddConstraint;
import swingtree.layout.LayoutConstraint;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Function;


/**
 *  A generic SwingTree builder node designed as a basis for configuring any kind of {@link JComponent} instance.
 *  This is the most generic builder type and therefore abstract super-type for almost all other builders.
 *  This builder defines nested building for anything extending the {@link JComponent} class.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *  &lt;br&gt;&lt;br&gt;
 *
 * @param &lt;I&gt; The concrete extension of the {@link AbstractNestedBuilder}.
 * @param &lt;C&gt; The type parameter for the component type wrapped by an instance of this class.
 */
<span class="fc" id="L48">public abstract class UIForAnySwing&lt;I, C extends JComponent&gt; extends AbstractNestedBuilder&lt;I, C, JComponent&gt;</span>
{
<span class="fc" id="L50">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(UI.class);</span>

    private final static String _TIMERS_KEY = &quot;_swing-tree.timers&quot;;

    /**
     *  This method exposes a concise way to bind a {@link Observable} (usually a sprouts.Event to the
     *  {@link JComponent#repaint()} method of the component wrapped by this {@link UI}!
     *  This means that the component will be repainted whenever the event is fired.
     *  &lt;p&gt;
     * @param event The event to which the repaint method of the component will be bound.
     * @return The JComponent type which will be wrapped by this builder node.
     */
    public final I withRepaintIf( Observable event ) {
<span class="pc" id="L63">        return _with( c -&gt; event.subscribe( () -&gt; _runInUI(c::repaint) ) )._this();</span>
    }

    /**
     *  This method exposes a concise way to set an identifier for the component
     *  wrapped by this {@link UI}!
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *
     * @param id The identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be wrapped by this builder node.
     */
    public final I id( String id ) {
<span class="fc" id="L79">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method exposes a concise way to set an enum based identifier for the component
     *  wrapped by this {@link UI}!
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *  &lt;p&gt;
     *  The enum identifier will be translated to a string using {@link Enum#name()}.
     *
     * @param id The enum identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be wrapped by this builder node.
     * @param &lt;E&gt; The enum type.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I id( E id ) {
<span class="nc" id="L98">        Objects.requireNonNull(id);</span>
<span class="nc" id="L99">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to a style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *      {@literal @}Override
     *      protected void build() {
     *          add(group(&quot;A&quot;).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *              .backgroundColor(Color.RED)
     *          );
     *          add(group(&quot;B&quot;), it -&amp;gt; it
     *              .borderWidth(12)
     *          );
     *          add(group(&quot;C&quot;), it -&amp;gt; it
     *              .borderWidth(16)
     *              .borderColor(Color.YELLOW)
     *          );
     *      }
     *    }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(&quot;A&quot;)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;&lt;br&gt;
     *  &lt;b&gt;It is advised to use the {@link #group(Enum[])} method
     *  instead of this method, as the usage of enums for modelling
     *  group tags offers much better compile time type safety!&lt;/b&gt;
     *
     * @param groupTags The names of the style groups to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I group( String... groupTags ) {
<span class="fc" id="L141">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to an enum based style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *          {@literal @}Override
     *          protected void build() {
     *              add(group(MyGroups.A).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *                  .backgroundColor(Color.RED)
     *              );
     *              add(group(MyGroups.B), it -&amp;gt; it
     *                  .borderWidth(12)
     *              );
     *              add(group(MyGroups.C), it -&amp;gt; it
     *                  .borderWidth(16)
     *                  .borderColor(Color.YELLOW)
     *              );
     *          }
     *      }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(MyGroup.A)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;
     *
     * @param groupTags The enum based style group to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The enum type.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; I group( E... groupTags ) {
<span class="fc" id="L182">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type visible or invisible
     *  depending on the supplied boolean value.
     *
     * @param isVisible The truth value determining if the component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( boolean isVisible ) {
<span class="fc" id="L193">        return _with( c -&gt; c.setVisible(isVisible) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(boolean)}, and it is
     *  used to make the underlying {@link JComponent} type visible or invisible.
     *  &lt;p&gt;
     *  If the supplied boolean value is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied boolean value is {@code false}, the component will be visible.
     *
     * @param isVisible The truth value determining if the UI component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( boolean isVisible ) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        return _with( c -&gt; c.setVisible(!isVisible) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  through the supplied {@link Val} property, which is automatically bound
     *  to the {@link JComponent#setVisible(boolean)} method of the underlying {@link JComponent} type.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *           send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L227">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L228">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L229">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="fc" id="L230">                    c.setVisible(v);</span>
<span class="fc" id="L231">                })</span>
<span class="fc" id="L232">                ._with( c -&gt; {</span>
<span class="fc" id="L233">                    c.setVisible( isVisible.orElseThrow() );</span>
<span class="fc" id="L234">                })</span>
<span class="fc" id="L235">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     *  If the supplied {@link Val} property is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied {@link Val} property is {@code false}, the component will be visible.
     *  &lt;p&gt;
     *  &lt;i&gt;
     *      Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *            send the property value to this view component.
     *  &lt;/i&gt;
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L256">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L257">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component! A boolean should only be true or false!&quot;);</span>
<span class="fc" id="L258">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                    c.setVisible(!v);</span>
<span class="fc" id="L260">                })</span>
<span class="fc" id="L261">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">                    c.setVisible( !isVisible.orElseThrow() );</span>
<span class="fc" id="L263">                })</span>
<span class="fc" id="L264">                ._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be visible,
     *  otherwise it will be invisible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component visible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component visible.
     * @param &lt;E&gt; The enum type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L286">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L287">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L288">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L289">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                    c.setVisible( v == enumValue );</span>
<span class="fc" id="L291">                })</span>
<span class="fc" id="L292">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                    c.setVisible( enumValue == enumProperty.orElseThrow() );</span>
<span class="fc" id="L294">                })</span>
<span class="fc" id="L295">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Enum, Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be invisible,
     *  otherwise it will be visible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component invisible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component invisible.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L316">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L317">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L318">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L319">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">                    c.setVisible( v != enumValue );</span>
<span class="fc" id="L321">                })</span>
<span class="fc" id="L322">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">                    c.setVisible( enumValue != enumProperty.orElseThrow() );</span>
<span class="fc" id="L324">                })</span>
<span class="fc" id="L325">                ._this();</span>
    }

    /**
     *  Use this to enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( boolean isEnabled ) {
<span class="fc" id="L335">        return _with( c -&gt; _setEnabled(c, isEnabled) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(boolean)}.
     *  Use this to disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( boolean isEnabled ) {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        return _with( c -&gt; _setEnabled(c, !isEnabled) )._this();</span>
    }

    /**
     *  Use this to dynamically enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L356">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L357">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L358">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="fc" id="L359">                    c.setEnabled(v);</span>
<span class="fc" id="L360">                })</span>
<span class="fc" id="L361">                ._with( c -&gt; {</span>
<span class="fc" id="L362">                    _setEnabled(c,  isEnabled.orElseThrow() );</span>
<span class="fc" id="L363">                })</span>
<span class="fc" id="L364">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Val)}.
     *  Use this to dynamically disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L375">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L376">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L377">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    _setEnabled(c, !v);</span>
<span class="nc" id="L379">                })</span>
<span class="fc" id="L380">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">                    _setEnabled(c,  !isEnabled.orElseThrow() );</span>
<span class="fc" id="L382">                })</span>
<span class="fc" id="L383">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically enabled or disabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component enabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component enabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L397">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L398">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L399">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L400">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                    _setEnabled( c,  v == enumValue );</span>
<span class="fc" id="L402">                })</span>
<span class="fc" id="L403">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue == enumProperty.orElseThrow() );</span>
<span class="fc" id="L405">                })</span>
<span class="fc" id="L406">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically disabled or enabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component disabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component disabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L421">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L422">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L423">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L424">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                    _setEnabled( c,  v != enumValue );</span>
<span class="fc" id="L426">                })</span>
<span class="fc" id="L427">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue != enumProperty.orElseThrow() );</span>
<span class="fc" id="L429">                })</span>
<span class="fc" id="L430">                ._this();</span>
    }

<span class="fc" id="L433">    protected void _setEnabled(C c, boolean isEnabled ) { c.setEnabled( isEnabled ); }</span>

    /**
     *  Use this to make the wrapped UI component grab the input focus.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeFocused() {
<span class="fc" id="L440">        return _with( c -&gt; {</span>
<span class="fc" id="L441">                    UI.runLater(() -&gt; {</span>
<span class="fc" id="L442">                        c.grabFocus();</span>
                        // We do this later because in this point in time the UI is probably not
                        // yet fully built (swing-tree is using the builder-pattern).
<span class="fc" id="L445">                    });</span>
<span class="fc" id="L446">                })</span>
<span class="fc" id="L447">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable.
     *  @param isFocusable The truth value determining if the UI component should be focusable or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( boolean isFocusable ) {
<span class="nc" id="L456">        return _with( c -&gt; c.setFocusable(isFocusable) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L469">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L470">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L471">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="fc" id="L472">                    c.setFocusable(v);</span>
<span class="fc" id="L473">                })</span>
<span class="fc" id="L474">                ._with( c -&gt; {</span>
<span class="fc" id="L475">                    c.setFocusable( isFocusable.orElseThrow() );</span>
<span class="fc" id="L476">                })</span>
<span class="fc" id="L477">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable if a certain condition is not met.
     *  @param notFocusable The truth value determining if the UI component should be focusable or not.
     *                     If {@code false}, the component will be focusable.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIfNot( boolean notFocusable ) {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        return _with( c -&gt; c.setFocusable( !notFocusable ) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not, wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code isFocusable} is {@code null}.
     */
    public final I isFocusableIfNot( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L501">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L502">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L503">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                    c.setFocusable( !v );</span>
<span class="fc" id="L505">                })</span>
<span class="fc" id="L506">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                    c.setFocusable( !isFocusable.orElseThrow() );</span>
<span class="fc" id="L508">                })</span>
<span class="fc" id="L509">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L524">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L525">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L526">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L527">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                    c.setFocusable( v == enumValue );</span>
<span class="fc" id="L529">                })</span>
<span class="fc" id="L530">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                    c.setFocusable( enumValue == enumProperty.orElseThrow() );</span>
<span class="fc" id="L532">                })</span>
<span class="fc" id="L533">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isFocusableIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component non-focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component non-focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L549">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L550">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L551">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L552">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                    c.setFocusable( v != enumValue );</span>
<span class="fc" id="L554">                })</span>
<span class="fc" id="L555">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                    c.setFocusable( enumValue != enumProperty.orElseThrow() );</span>
<span class="fc" id="L557">                })</span>
<span class="fc" id="L558">                ._this();</span>
    }


    /**
     *  Use this to make the wrapped UI component opaque.
     *  This is the inverse of {@link #makeNonOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeOpaque() {
<span class="nc" id="L569">        return _with( c -&gt; c.setOpaque( true ) )._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component transparent.
     *  This is the inverse of {@link #makeOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeNonOpaque() {
<span class="fc" id="L579">        return _with( c -&gt; c.setOpaque( false ) )._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component opaque.
     *  @param isOpaque The truth value determining if the UI component should be opaque or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIf( boolean isOpaque ) {
<span class="nc" id="L588">        return _with( c -&gt; c.setOpaque( isOpaque ) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component opaque.
     *  This is useful if you want to make a component opaque only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isOpaque The truth value determining if the UI component should be opaque or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIf( Val&lt;Boolean&gt; isOpaque ) {
<span class="nc" id="L601">        NullUtil.nullArgCheck( isOpaque, &quot;isOpaque&quot;, Val.class );</span>
<span class="nc" id="L602">        NullUtil.nullPropertyCheck(isOpaque, &quot;isOpaque&quot;, &quot;Null value for isOpaque is not allowed! A boolean should only have the values true or false!&quot;);</span>
<span class="nc" id="L603">        return _withOnShow( isOpaque, (c,v) -&gt; {</span>
<span class="nc" id="L604">                    c.setOpaque(v);</span>
<span class="nc" id="L605">                })</span>
<span class="nc" id="L606">                ._with( c -&gt; {</span>
<span class="nc" id="L607">                    c.setOpaque( isOpaque.orElseThrow() );</span>
<span class="nc" id="L608">                })</span>
<span class="nc" id="L609">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component opaque if the given condition is not met.
     *  @param notOpaque The truth value determining if the UI component should be opaque or not, where false means opaque.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIfNot( boolean notOpaque ) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">        return _with( c -&gt; c.setOpaque( !notOpaque ) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component opaque if the boolean item of the given {@link Val} is false.
     *  This is useful if you want to make a component opaque only if a certain condition is not met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param notOpaque The truth value determining if the UI component should be opaque or not, wrapped in a {@link Val}, where false means opaque.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIfNot( Val&lt;Boolean&gt; notOpaque ) {
<span class="nc" id="L631">        NullUtil.nullArgCheck( notOpaque, &quot;notOpaque&quot;, Val.class );</span>
<span class="nc" id="L632">        NullUtil.nullPropertyCheck(notOpaque, &quot;notOpaque&quot;, &quot;Null value for isOpaque is not allowed! A boolean should only have the values true or false!&quot;);</span>
<span class="nc" id="L633">        return _withOnShow( notOpaque, (c,v) -&gt; {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                    c.setOpaque( !v );</span>
<span class="nc" id="L635">                })</span>
<span class="nc" id="L636">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                    c.setOpaque( !notOpaque.orElseThrow() );</span>
<span class="nc" id="L638">                })</span>
<span class="nc" id="L639">                ._this();</span>
    }

    /**
     *  This allows you to register validation logic for the wrapped UI component.
     *  Although the delegate exposed to the {@link UIVerifier} lambda
     *  indirectly exposes you to the UIs state, you should not access the UI directly
     *  from within the lambda, but modify the properties inside your view model instead.
     *
     * @param verifier The validation logic provided by your view model.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isValidIf( UIVerifier&lt;C&gt; verifier ) {
<span class="fc" id="L652">        return _with( c -&gt; {</span>
<span class="fc" id="L653">                    c.setInputVerifier(new InputVerifier() {</span>
                        @Override
                        public boolean verify( JComponent input ) {
<span class="nc" id="L656">                            return verifier.isValid(</span>
                                    new ComponentDelegate&lt;&gt;(
                                            c,
                                            new ComponentEvent(c, 0)
                                    )
                            );
                        /*
                            We expect the user to model the state of the UI components
                            using properties in the view model.
                         */
                        }
                    });
<span class="fc" id="L668">                })</span>
<span class="fc" id="L669">                ._this();</span>
    }

    /**
     * Adds {@link String} key/value &quot;client property&quot; pairs to the wrapped component.
     * &lt;p&gt;
     * The arguments will be passed to {@link JComponent#putClientProperty(Object, Object)}
     * which accesses
     * a small per-instance hashtable. Callers can use get/putClientProperty
     * to annotate components that were created by another module.
     * For example, a
     * layout manager might store per child constraints this way. &lt;br&gt;
     * This is in essence a more convenient way than the alternative usage pattern involving
     * the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     * &lt;pre&gt;{@code
     *     UI.button()
     *     .peek( button -&gt; button.putClientProperty(&quot;key&quot;, &quot;value&quot;) );
     * }&lt;/pre&gt;
     *
     * @param key the new client property key which may be used for styles or layout managers.
     * @param value the new client property value.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withProperty( String key, String value ) {
<span class="fc" id="L693">        return _with( c -&gt; c.putClientProperty(key, value) )._this();</span>
    }

    /**
     *  Use this to attach a border to the wrapped component.
     *
     * @param border The {@link Border} which should be set for the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Border border ) {
<span class="fc" id="L703">        Objects.requireNonNull(border, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L704">        return _with( c -&gt; c.setBorder(border) )._this();</span>
    }

    /**
     *  Use this to dynamically attach a border to the wrapped component. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param border The {@link Border} which should be set for the wrapped component wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Val&lt;Border&gt; border ) {
<span class="fc" id="L715">        NullUtil.nullArgCheck(border, &quot;border&quot;, Val.class);</span>
<span class="fc" id="L716">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L717">        return _withOnShow( border, (c,v) -&gt; {</span>
<span class="nc" id="L718">                    c.setBorder(v);</span>
<span class="nc" id="L719">                })</span>
<span class="fc" id="L720">                ._with( c -&gt; {</span>
<span class="fc" id="L721">                    c.setBorder( border.orElseThrow() );</span>
<span class="fc" id="L722">                })</span>
<span class="fc" id="L723">                ._this();</span>
    }


    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int top, int left, int bottom, int right ) {
<span class="nc" id="L737">        return _with( c -&gt; c.setBorder(BorderFactory.createEmptyBorder(top, left, bottom, right)) )._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int top, int left, int bottom, int right ) {
<span class="fc" id="L751">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L752">        return _with( c -&gt; c.setBorder(</span>
<span class="fc" id="L753">                        BorderFactory.createTitledBorder(</span>
<span class="fc" id="L754">                            BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                            title
                        )
                    )
                )
<span class="fc" id="L759">                ._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val},
     *              which will update the border title dynamically when changed.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int top, int left, int bottom, int right ) {
<span class="nc" id="L775">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L776">        NullUtil.nullPropertyCheck( title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot; );</span>
<span class="nc" id="L777">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L778">                    c.setBorder(</span>
<span class="nc" id="L779">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L780">                                BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                                v
                            )
                        );
<span class="nc" id="L784">                })</span>
<span class="nc" id="L785">                ._with( c -&gt; {</span>
<span class="nc" id="L786">                    c.setBorder(</span>
<span class="nc" id="L787">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L788">                                    BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
<span class="nc" id="L789">                                    title.orElseThrow()</span>
                            )
                    );
<span class="nc" id="L792">                })</span>
<span class="nc" id="L793">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int topBottom, int leftRight ) {
<span class="nc" id="L804">        return withEmptyBorder( topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int topBottom, int leftRight ) {
<span class="nc" id="L816">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L817">        return withEmptyBorderTitled( title, topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val}. When the value changes, the border title will be updated.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int topBottom, int leftRight ) {
<span class="nc" id="L830">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L831">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L832">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L833">                    c.setBorder(</span>
<span class="nc" id="L834">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L835">                                BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
                                v
                            )
                        );
<span class="nc" id="L839">                })</span>
<span class="nc" id="L840">                ._with( c -&gt; {</span>
<span class="nc" id="L841">                    c.setBorder(</span>
<span class="nc" id="L842">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L843">                                    BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
<span class="nc" id="L844">                                    title.orElseThrow()</span>
                            )
                    );
<span class="nc" id="L847">                })</span>
<span class="nc" id="L848">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L857">    public final I withEmptyBorder( int all ) { return withEmptyBorder(all, all, all, all); }</span>

    /**
     *  Creates an empty and un-titled {@link Border} with the provided insets
     *  property bound to all insets of said border.
     *  &lt;p&gt;
     *  An empty and un-titled {@link Border} is basically just a way to add some
     *  space around the component. It is not visible by default.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( Val&lt;Integer&gt; all ) {
<span class="nc" id="L870">        NullUtil.nullArgCheck( all, &quot;all&quot;, Val.class );</span>
<span class="nc" id="L871">        NullUtil.nullPropertyCheck(all, &quot;all&quot;, &quot;Null value for all is not allowed! Use an empty border instead!&quot;);</span>
<span class="nc" id="L872">        return _withOnShow( all, (c,v) -&gt; {</span>
<span class="nc" id="L873">                    c.setBorder(BorderFactory.createEmptyBorder(v, v, v, v));</span>
<span class="nc" id="L874">                })</span>
<span class="nc" id="L875">                ._with( c -&gt; {</span>
<span class="nc" id="L876">                    c.setBorder(BorderFactory.createEmptyBorder(all.orElseThrow(), all.orElseThrow(), all.orElseThrow(), all.orElseThrow()));</span>
<span class="nc" id="L877">                })</span>
<span class="nc" id="L878">                ._this();</span>
    }

            /**
             *  Use this to define a titled empty {@link Border} with the provided insets.
             *
             * @param title The title of the border.
             * @param all The insets for all sides.
             * @return This very instance, which enables builder-style method chaining.
             */
    public final I withEmptyBorderTitled( String title, int all ) {
<span class="fc" id="L889">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L890">        return withEmptyBorderTitled(title, all, all, all, all);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property and the provided insets.
     * @param title The title of the border in the form of a {@link Val} property.
     * @param all The insets size for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int all ) {
<span class="nc" id="L900">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L901">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L902">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L903">                    c.setBorder(</span>
<span class="nc" id="L904">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L905">                                BorderFactory.createEmptyBorder(all, all, all, all),</span>
                                v
                            )
                        );
<span class="nc" id="L909">                })</span>
<span class="nc" id="L910">                ._with( c -&gt; {</span>
<span class="nc" id="L911">                    c.setBorder(</span>
<span class="nc" id="L912">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L913">                                    BorderFactory.createEmptyBorder(all, all, all, all),</span>
<span class="nc" id="L914">                                    title.orElseThrow()</span>
                            )
                    );
<span class="nc" id="L917">                })</span>
<span class="nc" id="L918">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with a title
     *  and a default insets size of 5.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title ) {
<span class="nc" id="L929">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L930">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property
     *  and a default insets size of 5.
     *
     * @param title The title of the border in the form of a {@link Val} property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L941">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and insets.
     *
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color, int thickness ) {
<span class="fc" id="L952">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="fc" id="L953">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness)) )._this();</span>
    }

    /**
     *  Creates a line border bound to a {@link Color} property.
     *  When the color changes, the border will be updated with the new color.
     * @param color The color of the border in the form of a {@link Val} property.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L964">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L965">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L966">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L967">                    c.setBorder(BorderFactory.createLineBorder(v, thickness));</span>
<span class="nc" id="L968">                })</span>
<span class="nc" id="L969">                ._with( c -&gt; {</span>
<span class="nc" id="L970">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrow(), thickness));</span>
<span class="nc" id="L971">                })</span>
<span class="nc" id="L972">                ._this();</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and insets.
     *
     * @param title The title of the border.
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L984">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L985">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L986">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L987">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L988">                            BorderFactory.createLineBorder(color, thickness),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L993">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property.
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1004">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1005">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1006">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1007">                    c.setBorder(</span>
<span class="nc" id="L1008">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1009">                                BorderFactory.createLineBorder(color, thickness),</span>
                                v
                            )
                        );
<span class="nc" id="L1013">                })</span>
<span class="nc" id="L1014">                ._with( c -&gt; {</span>
<span class="nc" id="L1015">                    c.setBorder(</span>
<span class="nc" id="L1016">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1017">                                    BorderFactory.createLineBorder(color, thickness),</span>
<span class="nc" id="L1018">                                    title.orElseThrow()</span>
                            )
                    );
<span class="nc" id="L1021">                })</span>
<span class="nc" id="L1022">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property
     * and a {@link Color} property.
     * When any of the properties change, the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1036">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1037">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1038">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1039">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1040">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1041">                    c.setBorder(</span>
<span class="nc" id="L1042">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1043">                            BorderFactory.createLineBorder(color.orElseThrow(), thickness),</span>
                            v
                        )
                    );
<span class="nc" id="L1047">                })</span>
<span class="nc" id="L1048">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1049">                    c.setBorder(</span>
<span class="nc" id="L1050">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1051">                            BorderFactory.createLineBorder(v, thickness),</span>
<span class="nc" id="L1052">                            title.orElseThrow()</span>
                        )
                    );
<span class="nc" id="L1055">                })</span>
<span class="nc" id="L1056">                ._with( c -&gt; {</span>
<span class="nc" id="L1057">                    c.setBorder(</span>
<span class="nc" id="L1058">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1059">                            BorderFactory.createLineBorder(color.orElseThrow(), thickness),</span>
<span class="nc" id="L1060">                            title.orElseThrow()</span>
                        )
                    );
<span class="nc" id="L1063">                })</span>
<span class="nc" id="L1064">                ._this();</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color ) {
<span class="nc" id="L1074">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1075">        return withLineBorder(color, 1);</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1086">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1087">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1088">        return withLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color, int thickness ) {
<span class="nc" id="L1100">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1101">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness, true)) )._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L1114">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1115">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1116">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1117">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1118">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1123">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title property.
     *  When the title property changes, the border will be updated with the new value.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1138">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1139">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1140">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1141">                    c.setBorder(</span>
<span class="nc" id="L1142">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1143">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1147">                })</span>
<span class="nc" id="L1148">                ._with( c -&gt; {</span>
<span class="nc" id="L1149">                    c.setBorder(</span>
<span class="nc" id="L1150">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1151">                            BorderFactory.createLineBorder(color, thickness, true),</span>
<span class="nc" id="L1152">                            title.orElseThrow()</span>
                        )
                    );
<span class="nc" id="L1155">                })</span>
<span class="nc" id="L1156">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title and color properties.
     *  When the title or color properties change, 
     *  then the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1172">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1173">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1174">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1175">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1176">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1177">                    c.setBorder(</span>
<span class="nc" id="L1178">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1179">                            BorderFactory.createLineBorder(color.orElseThrow(), thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1183">                })</span>
<span class="nc" id="L1184">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1185">                    c.setBorder(</span>
<span class="nc" id="L1186">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1187">                            BorderFactory.createLineBorder(v, thickness, true),</span>
<span class="nc" id="L1188">                            title.orElseThrow()</span>
                        )
                    );
<span class="nc" id="L1191">                })</span>
<span class="nc" id="L1192">                ._with( c -&gt; {</span>
<span class="nc" id="L1193">                    c.setBorder(</span>
<span class="nc" id="L1194">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1195">                            BorderFactory.createLineBorder(color.orElseThrow(), thickness, true),</span>
<span class="nc" id="L1196">                            title.orElseThrow()</span>
                        )
                    );
<span class="nc" id="L1199">                })</span>
<span class="nc" id="L1200">                ._this();</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color ) {
<span class="nc" id="L1211">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1212">        return withRoundedLineBorder(color, 1);</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color property and a custom thickness to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1224">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1225">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1226">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1227">                    c.setBorder(BorderFactory.createLineBorder(v, thickness, true));</span>
<span class="nc" id="L1228">                })</span>
<span class="nc" id="L1229">                ._with( c -&gt; {</span>
<span class="nc" id="L1230">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrow(), thickness, true));</span>
<span class="nc" id="L1231">                })</span>
<span class="nc" id="L1232">                ._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title, color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1244">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1245">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1246">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title and color to the {@link JComponent}, as well as a default thickness of {@code 1}.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @param color The color property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color ) {
<span class="nc" id="L1258">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1259">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1260">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1261">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1270">    public final I withRoundedLineBorder() { return withRoundedLineBorder(Color.BLACK, 1); }</span>

    /**
     *  Use this to attach a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title ) {
<span class="nc" id="L1280">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1281">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Creates a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent} and binds it to the provided 
     *  title property.
     *  When the property changes, the border will be updated.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1294">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1295">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1296">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1311">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1312">        return _with( c -&gt; c.setBorder(BorderFactory.createMatteBorder(top, left, bottom, right, color)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1328">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1329">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1330">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1331">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1332">                            BorderFactory.createMatteBorder(top, left, bottom, right, color),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1337">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1350">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1351">        return withMatteBorder(color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1365">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1366">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1367">        return withMatteBorderTitled(title, color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int all ) {
<span class="nc" id="L1379">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1380">        return withMatteBorder(color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int all ) {
<span class="nc" id="L1393">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1394">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1395">        return withMatteBorderTitled(title, color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.CompoundBorder} with the provided
     *  borders to the {@link JComponent}.
     *
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorder( Border first, Border second ) {
<span class="nc" id="L1407">        NullUtil.nullArgCheck( first, &quot;first&quot;, Border.class );</span>
<span class="nc" id="L1408">        NullUtil.nullArgCheck( second, &quot;second&quot;, Border.class );</span>
<span class="nc" id="L1409">        return _with( c -&gt; c.setBorder(BorderFactory.createCompoundBorder(first, second)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.CompoundBorder} with the
     *  provided borders to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorderTitled( String title, Border first, Border second ) {
<span class="nc" id="L1422">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1423">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1424">                            BorderFactory.createCompoundBorder(first, second),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1429">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the provided title.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( String title ) {
<span class="fc" id="L1439">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1440">        return _with( c -&gt; c.setBorder(BorderFactory.createTitledBorder(title)) )._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the
     *  provided title property dynamically setting the title String.
     *
     * @param title The title property for the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( Val&lt;String&gt; title ) {
<span class="fc" id="L1451">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1452">        return _withOnShow( title, (c,t) -&gt; {</span>
<span class="fc" id="L1453">                    Border foundBorder = c.getBorder();</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">                    if ( foundBorder instanceof TitledBorder )</span>
<span class="fc" id="L1455">                        ((TitledBorder)foundBorder).setTitle(t);</span>
                    else
<span class="nc" id="L1457">                        c.setBorder(BorderFactory.createTitledBorder(t));</span>
<span class="fc" id="L1458">                })</span>
<span class="fc" id="L1459">                ._with( c -&gt; {</span>
<span class="fc" id="L1460">                    c.setBorder(BorderFactory.createTitledBorder(title.orElseThrow()));</span>
<span class="fc" id="L1461">                })</span>
<span class="fc" id="L1462">                ._this();</span>
    }

    /**
     *  Use this set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder.
     *  &lt;br&gt;
     *  Here an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me!&quot;).withCursor(UI.Cursor.HAND);
     *  }&lt;/pre&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( UI.Cursor type ) {
<span class="fc" id="L1478">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="fc" id="L1479">        return _with( c -&gt; c.setCursor( new java.awt.Cursor( type.type ) ) )._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( Val&lt;UI.Cursor&gt; type ) {
<span class="fc" id="L1491">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="fc" id="L1492">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="fc" id="L1493">        return _withOnShow( type, (c,t) -&gt; {</span>
<span class="fc" id="L1494">                    c.setCursor( new java.awt.Cursor( t.type ) );</span>
<span class="fc" id="L1495">                })</span>
<span class="fc" id="L1496">                ._with( c -&gt; {</span>
<span class="fc" id="L1497">                    c.setCursor( new java.awt.Cursor( type.orElseThrow().type ) );</span>
<span class="fc" id="L1498">                })</span>
<span class="fc" id="L1499">                ._this();</span>
    }

    /**
     *  Use this to set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, UI.Cursor type ) {
<span class="nc" id="L1513">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1514">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="nc" id="L1515">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1516">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( v ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1518">                })</span>
<span class="nc" id="L1519">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrow() ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1521">                })</span>
<span class="nc" id="L1522">                ._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type property defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, Val&lt;UI.Cursor&gt; type ) {
<span class="nc" id="L1536">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1537">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="nc" id="L1538">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1539">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="nc" id="L1540">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L1541">                    Cursor[] baseCursor = new Cursor[1];</span>
<span class="nc" id="L1542">                    _onShow( condition, thisComponent, (c,v) -&gt; type.fireChange(From.VIEW_MODEL) );</span>
<span class="nc" id="L1543">                    _onShow( type, thisComponent, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">                        if ( baseCursor[0] == null ) baseCursor[0] = c.getCursor();</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                        c.setCursor( new java.awt.Cursor( condition.orElseThrow() ? v.type : baseCursor[0].getType() ) );</span>
<span class="nc" id="L1546">                    });</span>
<span class="nc" id="L1547">                })</span>
<span class="nc" id="L1548">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrow() ? type.orElseThrow().type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1550">                })</span>
<span class="nc" id="L1551">                ._this();</span>
    }

    /**
     *  Use this to set the {@link LayoutManager} of the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FavouriteLayoutManager()) );
     *  }&lt;/pre&gt;
     *
     * @param layout The {@link LayoutManager} which should be supplied to the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutManager layout ) {
<span class="fc" id="L1567">        return _with( c -&gt; c.setLayout(layout) )._this();</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1581">    public final I withFlowLayout() { return this.withLayout(new FlowLayout()); }</span>

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment ) {
<span class="nc" id="L1596">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="nc" id="L1597">        return this.withLayout(new FlowLayout(alignment.forFlowLayout()));</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout(), hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @param hgap The horizontal gap between components.
     * @param vgap The vertical gap between components.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment, int hgap, int vgap ) {
<span class="nc" id="L1615">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="nc" id="L1616">        return this.withLayout(new FlowLayout(alignment.forFlowLayout(), hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1630">    public final I withGridLayout() { return this.withLayout(new GridLayout()); }</span>

    /**
     *  Use this to set a new {@link GridBagLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridBagLayout()) );
     *  }&lt;/pre&gt;
     *  ...or specifying the layout manager like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.panel().withLayout( new GridBagLayout() );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1647">    public final I withGridBagLayout() { return this.withLayout(new GridBagLayout()); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1662">    public final I withGridLayout( int rows, int cols ) { return this.withLayout(new GridLayout(rows, cols)); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols, hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @param hgap The horizontal gap between cells.
     * @param vgap The vertical gap between cells.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withGridLayout( int rows, int cols, int hgap, int vgap ) {
<span class="nc" id="L1680">        return this.withLayout(new GridLayout(rows, cols, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link BoxLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new BoxLayout(panel, axis.forBoxLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param axis The axis for the box layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If the provided axis is {@code null}.
     * @see UI.Axis
     * @see BoxLayout
     */
    public final I withBoxLayout( UI.Axis axis ) {
<span class="nc" id="L1699">        NullUtil.nullArgCheck( axis, &quot;axis&quot;, UI.Axis.class );</span>
<span class="nc" id="L1700">        return _with( c -&gt; c.setLayout(new BoxLayout(c, axis.forBoxLayout())) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-constraints in the form of a simple string
     *  which is parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;fill wrap 2&quot;);
     *    .add( UI.button(&quot;Name:&quot;) )
     *    .add( UI.textArea() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns
     *  and fill the entire available space of the parent container.
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param attr The constraints concerning the entire layout.
     *             Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr ) {
<span class="fc" id="L1749">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, String.class );</span>
<span class="fc" id="L1750">        return withLayout(attr, &quot;&quot;);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LC} instance,
     *  which is a builder for the layout constraints.
     *
     * @param attr A string defining the constraints concerning the entire layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr ) {
<span class="nc" id="L1764">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LC.class );</span>
<span class="nc" id="L1765">        return withLayout(attr, (AC) null, (AC) null);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LayoutConstraint} instance,
     *  which is an immutable string wrapper for the layout constraints.
     *  Instances of this are usually obtained from the {@link UI} namespace like
     *  {@link UI#FILL} or {@link UI#FILL_X}...
     *
     * @param attr Essentially an immutable string wrapper defining the mig layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     */
    public final I withLayout( LayoutConstraint attr ) {
<span class="fc" id="L1780">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LayoutConstraint.class );</span>
<span class="fc" id="L1781">        return withLayout(attr.toString(), &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder
     *  based on the provided layout constraints in the form of a string.
     *
     * @param attr A string defining constraints for the entire layout.
     * @param colConstrains The layout constraints for the columns int the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr, String colConstrains ) {
<span class="fc" id="L1795">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1796">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1797">        return withLayout(attr, colConstrains, &quot;&quot;);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a {@link AC} instance.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a {@link AC} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, AC colConstrains ) {
<span class="nc" id="L1812">        return withLayout(attr, colConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains ) {
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains == null ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc" id="L1828">        return withLayout(attr, parsedColConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column and row constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @param rowConstraints The row layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains, String rowConstraints ) {
<span class="nc" id="L1844">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1845">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc" id="L1846">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains.isEmpty() ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">        AC parsedRowConstrains = rowConstraints.isEmpty() ? null : ConstraintParser.parseRowConstraints(rowConstraints);</span>
<span class="nc" id="L1849">        return withLayout(attr, parsedColConstrains, parsedRowConstrains);</span>
    }

    /**
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains ) {
<span class="fc" id="L1860">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1861">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1862">        return withLayout(attr.toString(), colConstrains, &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout in the form of a {@link LayoutConstraint} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains, String rowConstraints ) {
<span class="fc" id="L1874">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1875">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1876">        return withLayout(attr.toString(), colConstrains, rowConstraints);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-, column- and row-constraints in the form of simple strings,
     *  which are parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;wrap 2&quot;, &quot;[]6[]&quot;, &quot;[]8[]&quot;);
     *    .add( UI.label(&quot;Name:&quot;) )
     *    .add( UI.textField() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns,
     *  where the 2 columns are separated by a 6 pixel gap and the rows
     *  are separated by an 8 pixel gap. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param constraints The constraints concerning the entire layout.
     *                    Passing {@code null} will result in an exception, use an empty string instead.
     * @param colConstrains The column layout for the {@link MigLayout} instance,
     *                      which concern the columns in the layout grid.
     *                      Passing {@code null} will result in an exception, use an empty string instead.
     * @param rowConstraints The row layout for the {@link MigLayout} instance,
     *                       which concern the rows in the layout grid.
     *                       Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     *
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String constraints, String colConstrains, String rowConstraints ) {
<span class="fc" id="L1933">        NullUtil.nullArgCheck(constraints, &quot;constraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1934">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1935">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>

        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="pc bpc" id="L1938" title="1 of 2 branches missed.">        if ( constraints.isEmpty() )</span>
<span class="nc" id="L1939">            constraints = &quot;hidemode 2&quot;;</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">        else if ( !constraints.contains(&quot;hidemode&quot;) )</span>
<span class="fc" id="L1941">            constraints += &quot;, hidemode 2&quot;;</span>

<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">        constraints    = ( constraints.isEmpty() ? null : constraints );</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">        colConstrains  = ( colConstrains.isEmpty() ? null : colConstrains );</span>
<span class="fc bfc" id="L1945" title="All 2 branches covered.">        rowConstraints = ( rowConstraints.isEmpty() ? null : rowConstraints );</span>

<span class="fc" id="L1947">        MigLayout migLayout = new MigLayout(constraints, colConstrains, rowConstraints);</span>
<span class="fc" id="L1948">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LC attr, AC colConstrains, AC rowConstraints ) {
        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        if ( attr == null )</span>
<span class="nc" id="L1962">            attr = new LC().hideMode(2);</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">        else if ( attr.getHideMode() == 0 )</span>
<span class="nc" id="L1964">            attr = attr.hideMode(2);</span>

<span class="nc" id="L1966">        MigLayout migLayout = new MigLayout(attr, colConstrains, rowConstraints);</span>
<span class="nc" id="L1967">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  Use this to set a helpful tool tip text for this UI component.
     *  The tool tip text will be displayed when the mouse hovers on the
     *  UI component for some time. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; button.setToolTipText(&quot;Can be clicked!&quot;) );
     *  }&lt;/pre&gt;
     *
     * @param tooltip The tool tip text which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withTooltip( String tooltip ) {
<span class="fc" id="L1985">        NullUtil.nullArgCheck(tooltip, &quot;tooltip&quot;, String.class, &quot;Use the empty string to clear the tooltip text!&quot;);</span>
<span class="pc bpc" id="L1986" title="1 of 2 branches missed.">        return _with( c -&gt; c.setToolTipText(tooltip.isEmpty() ? null : tooltip) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a tooltip string.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          tip.onSetItem(JButton::setToolTipText);
     *          button.setToolTipText(tip.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param tip The tooltip which should be displayed when hovering over the tab header.
     * @return A new {@link Tab} instance with the provided argument, which enables builder-style method chaining.
     */
    public final I withTooltip( Val&lt;String&gt; tip ) {
<span class="fc" id="L2007">        NullUtil.nullArgCheck(tip, &quot;tip&quot;, Val.class);</span>
<span class="fc" id="L2008">        NullUtil.nullPropertyCheck(tip, &quot;tip&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2009">        return _withOnShow( tip, (c,v) -&gt; {</span>
<span class="fc bfc" id="L2010" title="All 2 branches covered.">                    c.setToolTipText(v.isEmpty() ? null : v);</span>
<span class="fc" id="L2011">                })</span>
<span class="fc" id="L2012">                ._with( c -&gt; {</span>
<span class="fc" id="L2013">                    c.setToolTipText( tip.orElseNull() );</span>
<span class="fc" id="L2014">                })</span>
<span class="fc" id="L2015">                ._this();</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  wrapped by this builder.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(Color.CYAN) );
     *  }&lt;/pre&gt;
     *
     * @param color The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Color color ) {
<span class="fc" id="L2032">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">        return _with( c -&gt; c.setBackground( color == UI.COLOR_UNDEFINED ? null : color) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a background color.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          bg.onSetItem(JButton::setBackground);
     *          button.setBackground(bg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param bg The background color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Val&lt;Color&gt; bg ) {
<span class="fc" id="L2054">        NullUtil.nullArgCheck(bg, &quot;bg&quot;, Val.class);</span>
<span class="fc" id="L2055">        NullUtil.nullPropertyCheck(bg, &quot;bg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2056">        return _withOnShow( bg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2057" title="1 of 2 branches missed.">                    c.setBackground( v == UI.COLOR_UNDEFINED ? null : v );</span>
<span class="fc" id="L2058">                })</span>
<span class="fc" id="L2059">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2060" title="1 of 2 branches missed.">                    c.setBackground( bg.get() == UI.COLOR_UNDEFINED ? null : bg.get() );</span>
<span class="fc" id="L2061">                })</span>
<span class="fc" id="L2062">                ._this();</span>
    }

    /**
     *  Use this to bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue ) {
<span class="fc" id="L2075">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2076">        NullUtil.nullArgCheck(colorIfTrue, &quot;bg&quot;, Color.class);</span>
<span class="fc" id="L2077">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2078">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2079">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2080">                    Var&lt;Color&gt; color = Var.of( colorIfTrue );</span>
<span class="fc" id="L2081">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2082">                })</span>
<span class="fc" id="L2083">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">                    Color newColor =  condition.get() ? colorIfTrue : c.getBackground();</span>
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">                    c.setBackground( newColor == UI.COLOR_UNDEFINED ? null : newColor );</span>
<span class="fc" id="L2086">                })</span>
<span class="fc" id="L2087">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The background color property which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2100">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2101">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2102">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2103">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided background color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2104">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2105">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2106">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2107">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2108">                })</span>
<span class="fc" id="L2109">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getBackground();</span>
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">                    c.setBackground( newColor == UI.COLOR_UNDEFINED ? null : newColor );</span>
<span class="fc" id="L2112">                })</span>
<span class="fc" id="L2113">                ._this();</span>
    }

    /**
     *  Use this to bind to 2 colors to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2127">        return this.withBackgroundIf( condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
    }

    /**
     *  Use this to bind to 2 color properties to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2141">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2142">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2143">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2144">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2145">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2146">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2147">               })</span>
<span class="fc" id="L2148">               ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="nc" id="L2149">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2150">               })</span>
<span class="fc" id="L2151">               ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="nc" id="L2152">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2153">               })</span>
<span class="fc" id="L2154">               ._with( c -&gt; {</span>
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">                   Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">                   c.setBackground( newColor == UI.COLOR_UNDEFINED ? null : newColor );</span>
<span class="fc" id="L2157">               })</span>
<span class="fc" id="L2158">               ._this();</span>
    }

    /**
     *    Allows you to configure how the component wrapped by this builder
     *    looks and behaves, by passing a {@link Styler} lambda to this method
     *    which receiving a {@link swingtree.style.ComponentStyleDelegate} and returns
     *    an updated version with the desired style rules applied.
     *    &lt;p&gt;
     *    Here a typical example of how to style a button
     *    using the style API:
     *    &lt;pre&gt;{@code
     *        UI.button(&quot;Click Me!&quot;)
     *        .withStyle( it -&gt; it
     *            .borderColor(Color.CYAN)
     *            .borderWidthAt(Edge.BOTTOM, 3)
     *            .borderRadius(10)
     *        )
     *    }&lt;/pre&gt;
     *    &lt;p&gt;
     *    Here the {@code it} variable is the {@link swingtree.style.ComponentStyleDelegate} which
     *    exposes an extensive API for configuring how a particular component
     *    looks and behaves.
     *    &lt;p&gt;
     *    If you want to define style rules for an entire GUI or a part of it,
     *    take a look at the {@link swingtree.style.StyleSheet} class,
     *    which exposes an API for defining style rules similar to CSS
     *    but based on declarative source code instead of a text file.
     *
     * @param styler A {@link Styler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withStyle( Styler&lt;C&gt; styler ) {
<span class="fc" id="L2194">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, Styler.class);</span>
<span class="fc" id="L2195">        return _with( c -&gt; {</span>
<span class="fc" id="L2196">                    ComponentExtension.from(c).addStyler( styler );</span>
<span class="fc" id="L2197">                })</span>
<span class="fc" id="L2198">                ._this();</span>
    }

    /**
     *    Here an example demonstrating how a transitional style can be applied
     *    to make a border which can transition between 2 colors based on a boolean property:
     *    &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me!&quot;)
     *      .withTransitionalStyle(vm.isError(), LifeTime.of(1, TimeUnit.SECONDS), (state, it) -&gt; it
     *          .backgroundColor(Color.CYAN)
     *          .border(3, new Color((int)(state.progress() * 255), 0, 0))
     *      )
     *    }&lt;/pre&gt;
     *
     *
     * @param transitionToggle The boolean {@link Val} property which determines the state to which the style should transition.
     *                         When the value of this property is {@code true}, the style will transition to a {@link AnimationState#progress()}
     *                         of {@code 1.0} over the provided {@link LifeTime}.
     *                         And when the value of this property is {@code false}, the style will transition to a {@link AnimationState#progress()}
     *                         of {@code 0.0} over the provided {@link LifeTime}.
     *
     * @param transitionLifeTime The {@link LifeTime} of the transition animation.
     *                           It defines for ow long the {@link AnimationState#progress()} will transition from {@code 0} to {@code 1} or vice versa.
     *
     * @param styler An {@link AnimatedStyler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving an {@link AnimationState} and a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *               The {@link AnimatedStyler} may apply the style properties according to the {@link AnimationState}
     *               and its {@link AnimationState#progress()} method (or other methods) to create a smooth
     *               transition between the 2 states.
     *
     * @return This builder instance, which enables fluent method chaining.
     */
    public final I withTransitionalStyle(
        Val&lt;Boolean&gt; transitionToggle,
        LifeTime transitionLifeTime,
        AnimatedStyler&lt;C&gt; styler
    ) {
<span class="nc" id="L2236">        NullUtil.nullArgCheck(transitionToggle, &quot;transitionToggle&quot;, Val.class);</span>
<span class="nc" id="L2237">        NullUtil.nullArgCheck(transitionLifeTime, &quot;transitionLifeTime&quot;, LifeTime.class);</span>
<span class="nc" id="L2238">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, AnimatedStyler.class);</span>
<span class="nc" id="L2239">        return _with( c -&gt; {</span>
<span class="nc" id="L2240">                    FlipFlopStyler&lt;C&gt; flipFlopStyler = new FlipFlopStyler&lt;&gt;(c, transitionLifeTime, styler);</span>
<span class="nc" id="L2241">                    ComponentExtension.from(c).addStyler(flipFlopStyler::style);</span>
<span class="nc" id="L2242">                    _onShow( transitionToggle, c, (comp, v) -&gt; flipFlopStyler.set(v) );</span>
<span class="nc" id="L2243">                })</span>
<span class="nc" id="L2244">                ._this();</span>
    }

    /**
     *  Set the color of this {@link JComponent}. (This is usually the font color for components displaying text) &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(Color.GRAY) );
     *  }&lt;/pre&gt;
     *
     * @param color The color of the foreground (usually text).
     * @return This very builder to allow for method chaining.
     */
    public final I withForeground( Color color ) {
<span class="fc" id="L2260">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">        return _with( c -&gt; c.setForeground( color == UI.COLOR_UNDEFINED ? null : color ) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a foreground color.
     *  This is a convenience method, which works
     *  similar to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          fg.onChange(From.VIEW_MODEL,  v -&gt; button.setForeground(v.get()) );
     *          button.setForeground(fg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForeground( Val&lt;Color&gt; fg ) {
<span class="fc" id="L2282">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Val.class);</span>
<span class="fc" id="L2283">        NullUtil.nullPropertyCheck(fg, &quot;fg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2284">        return _withOnShow( fg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">                    c.setForeground( v == UI.COLOR_UNDEFINED ? null : v );</span>
<span class="fc" id="L2286">                })</span>
<span class="fc" id="L2287">                ._with( c -&gt; {</span>
<span class="fc" id="L2288">                    Color newColor = fg.get();</span>
<span class="pc bpc" id="L2289" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2290">                        newColor = null;</span>
<span class="fc" id="L2291">                    c.setForeground( newColor );</span>
<span class="fc" id="L2292">                })</span>
<span class="fc" id="L2293">                ._this();</span>
    }
    
    /**
     *  Use this to bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color fg ) {
<span class="fc" id="L2306">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2307">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Color.class);</span>
<span class="fc" id="L2308">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2309">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2310">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2311">                    Var&lt;Color&gt; newColor = Var.of( fg );</span>
<span class="fc" id="L2312">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, newColor, baseColor ) );</span>
<span class="fc" id="L2313">                })</span>
<span class="fc" id="L2314">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2315" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? fg : c.getForeground();</span>
<span class="pc bpc" id="L2316" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2317">                        newColor = null;</span>
<span class="fc" id="L2318">                    c.setForeground( newColor );</span>
<span class="fc" id="L2319">                })</span>
<span class="fc" id="L2320">                ._this();</span>
    }
    
    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The foreground color property which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2333">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2334">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2335">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2336">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2337">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2338">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2339">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2340">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2341">                })</span>
<span class="fc" id="L2342">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getForeground();</span>
<span class="pc bpc" id="L2344" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2345">                        newColor = null;</span>
<span class="fc" id="L2346">                    c.setForeground( newColor );</span>
<span class="fc" id="L2347">                })</span>
<span class="fc" id="L2348">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color which should be set for the UI component.
     * @param colorIfFalse The foreground color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2362">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2363">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Color.class);</span>
<span class="fc" id="L2364">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Color.class);</span>
<span class="fc" id="L2365">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2366">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2367">                    _updateForeground( c, condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
<span class="fc" id="L2368">                })</span>
<span class="fc" id="L2369">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2370" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue : colorIfFalse;</span>
<span class="pc bpc" id="L2371" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2372">                        newColor = null;</span>
<span class="fc" id="L2373">                    c.setForeground( newColor );</span>
<span class="fc" id="L2374">                })</span>
<span class="fc" id="L2375">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color property which should be set for the UI component.
     * @param colorIfFalse The foreground color property which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2389">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2390">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2391">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2392">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2393">        NullUtil.nullPropertyCheck(colorIfTrue, &quot;colorIfTrue&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2394">        NullUtil.nullPropertyCheck(colorIfFalse, &quot;colorIfFalse&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2395">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2396">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2397">                })</span>
<span class="fc" id="L2398">                ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="fc" id="L2399">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2400">                })</span>
<span class="fc" id="L2401">                ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="fc" id="L2402">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2403">                })</span>
<span class="fc" id="L2404">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2405" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2406" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2407">                        newColor = null;</span>
<span class="fc" id="L2408">                    c.setForeground( newColor );</span>
<span class="fc" id="L2409">                })</span>
<span class="fc" id="L2410">                ._this();</span>
    }

    private void _updateForeground(
        C component,
        Val&lt;Boolean&gt; condition,
        Val&lt;Color&gt;   color,
        Val&lt;Color&gt;   baseColor
    ) {
<span class="fc bfc" id="L2419" title="All 2 branches covered.">        Color newColor = condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2420" title="1 of 2 branches missed.">        if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2421">            newColor = null;</span>

<span class="fc" id="L2423">        component.setForeground(newColor);</span>
<span class="fc" id="L2424">    }</span>

    private void _updateBackground(
            C component,
            Val&lt;Boolean&gt; condition,
            Val&lt;Color&gt; color,
            Val&lt;Color&gt; baseColor
    ) {
<span class="fc bfc" id="L2432" title="All 2 branches covered.">        Color newColor =  condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2433" title="1 of 2 branches missed.">        if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L2434">            newColor = null;</span>

<span class="fc" id="L2436">        component.setBackground(newColor);</span>
<span class="fc" id="L2437">    }</span>

    /**
     *  Set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Dimension size ) {
<span class="fc" id="L2446">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2447">        return _with( c -&gt; c.setMinimumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} (Dimension)} on the underlying component. &lt;br&gt;
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click Me&quot;)
     *    .peek( button -&gt; {
     *      size.onSetItem(JButton::setMinimumSize);
     *      button.setMinimumSize(size.get());
     *    });
     *  }&lt;/pre&gt;
     *
     * @param size The minimum {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2468">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2469">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the minimum size of this component!&quot;);</span>
<span class="fc" id="L2470">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2471">                    c.setMinimumSize(UI.scale(v));</span>
<span class="fc" id="L2472">                    _revalidate(c);</span>
<span class="fc" id="L2473">                })</span>
<span class="fc" id="L2474">                ._with( c -&gt; {</span>
<span class="fc" id="L2475">                    c.setMinimumSize( UI.scale(size.get()) );</span>
<span class="fc" id="L2476">                })</span>
<span class="fc" id="L2477">                ._this();</span>
    }

    /**
     *  Set the minimum width and heigh ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( int width, int height ) {
<span class="fc" id="L2488">        return _with( c -&gt; c.setMinimumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2500">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2501">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2502">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2503">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2504">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2505">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2506">                    _revalidate(c);</span>
<span class="fc" id="L2507">                })</span>
<span class="fc" id="L2508">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2509">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2510">                    _revalidate(c);</span>
<span class="fc" id="L2511">                })</span>
<span class="fc" id="L2512">                ._with( c -&gt; {</span>
<span class="fc" id="L2513">                    c.setMinimumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2514">                })</span>
<span class="fc" id="L2515">                ._this();</span>
    }

    /**
     *  Use this to only set the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( int width ) {
<span class="fc" id="L2525">        return _with( c -&gt; {</span>
<span class="fc" id="L2526">                    _setMinWidth(c, width);</span>
<span class="fc" id="L2527">               })</span>
<span class="fc" id="L2528">               ._this();</span>
    }

    protected final void _setMinWidth( C component, int width ) {
<span class="fc" id="L2532">        int currentHeight = component.getMinimumSize().height;</span>
<span class="pc bpc" id="L2533" title="1 of 4 branches missed.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2534">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2535">        component.setMinimumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2536">    }</span>

    /**
     *  Use this to dynamically set only the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2545">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2546">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2547">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2548">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2549">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2550">                })</span>
<span class="fc" id="L2551">                ._with( c -&gt; {</span>
<span class="fc" id="L2552">                    _setMinWidth(c, width.get());</span>
<span class="fc" id="L2553">                })</span>
<span class="fc" id="L2554">                ._this();</span>
    }


    /**
     *  Use this to only set the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( int height ) {
<span class="fc" id="L2565">        return _with( c -&gt; {</span>
<span class="fc" id="L2566">                    _setMinHeight(c, height);</span>
<span class="fc" id="L2567">                })</span>
<span class="fc" id="L2568">                ._this();</span>
    }

    protected final void _setMinHeight( C component, int height ) {
<span class="fc" id="L2572">        int currentWidth = component.getMinimumSize().width;</span>
<span class="fc bfc" id="L2573" title="All 4 branches covered.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2574">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2575">        component.setMinimumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2576">    }</span>

    /**
     *  Use this to dynamically set only the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2585">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2586">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2587">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2588">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2589">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2590">                })</span>
<span class="fc" id="L2591">                ._with( c -&gt; {</span>
<span class="fc" id="L2592">                    _setMinHeight(c, height.get());</span>
<span class="fc" id="L2593">                })</span>
<span class="fc" id="L2594">                ._this();</span>
    }

    /**
     *  Set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Dimension size ) {
<span class="fc" id="L2604">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2605">        return _with( c -&gt; c.setMaximumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2616">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2617">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the maximum size of this component!&quot;);</span>
<span class="fc" id="L2618">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2619">                    c.setMaximumSize(UI.scale(v));</span>
<span class="fc" id="L2620">                    _revalidate(c); // For some reason this is needed to make the change visible.</span>
<span class="fc" id="L2621">                })</span>
<span class="fc" id="L2622">                ._with( c -&gt; {</span>
<span class="fc" id="L2623">                    c.setMaximumSize( UI.scale(size.get()) );</span>
<span class="fc" id="L2624">                })</span>
<span class="fc" id="L2625">                ._this();</span>
    }

    /**
     *  Set the maximum width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( int width, int height ) {
<span class="fc" id="L2636">        return _with( c -&gt; c.setMaximumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2648">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2649">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2650">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2651">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2652">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2653">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2654">                    _revalidate(c); // Raw Swing is not smart enough to do this automatically :(</span>
<span class="fc" id="L2655">                })</span>
<span class="fc" id="L2656">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2657">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2658">                    _revalidate(c); // Still not smart enough to do this automatically :(</span>
<span class="fc" id="L2659">                })</span>
<span class="fc" id="L2660">                ._with( c -&gt; {</span>
<span class="fc" id="L2661">                    c.setMaximumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2662">                })</span>
<span class="fc" id="L2663">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( int width ) {
<span class="fc" id="L2673">        return _with( c -&gt; {</span>
<span class="fc" id="L2674">                    _setMaxWidth(c, width);</span>
<span class="fc" id="L2675">                })</span>
<span class="fc" id="L2676">                ._this();</span>
    }

    private void _setMaxWidth( C component, int width ) {
<span class="fc" id="L2680">        int currentHeight = component.getMaximumSize().height;</span>
<span class="pc bpc" id="L2681" title="1 of 4 branches missed.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2682">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2683">        component.setMaximumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2684">    }</span>

    /**
     *  Use this to dynamically set only the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2693">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2694">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2695">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2696">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2697">                    _revalidate(c); // When the size changes, the layout manager needs to be informed.</span>
<span class="fc" id="L2698">                })</span>
<span class="fc" id="L2699">                ._with( c -&gt; {</span>
<span class="fc" id="L2700">                    _setMaxWidth(c, width.get());</span>
<span class="fc" id="L2701">                })</span>
<span class="fc" id="L2702">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( int height ) {
<span class="fc" id="L2712">        return _with( c -&gt; {</span>
<span class="fc" id="L2713">                    _setMaxHeight(c, height);</span>
<span class="fc" id="L2714">                })</span>
<span class="fc" id="L2715">                ._this();</span>
    }

    private void _setMaxHeight( C component, int height ) {
<span class="fc" id="L2719">        int currentWidth = component.getMaximumSize().width;</span>
<span class="fc bfc" id="L2720" title="All 4 branches covered.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2721">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2722">        component.setMaximumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2723">    }</span>

    /**
     *  Use this to dynamically set only the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2732">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2733">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2734">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2735">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2736">                    _revalidate(c); // The revalidate is necessary to make the change visible, this makes sure the layout is recalculated.</span>
<span class="fc" id="L2737">                })</span>
<span class="fc" id="L2738">                ._with( c -&gt; {</span>
<span class="fc" id="L2739">                    _setMaxHeight(c, height.get());</span>
<span class="fc" id="L2740">                })</span>
<span class="fc" id="L2741">                ._this();</span>
    }

    /**
     *  Set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Dimension size ) {
<span class="fc" id="L2751">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2752">        return _with( c -&gt; c.setPreferredSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2763">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2764">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the preferred size of this component!&quot;);</span>
<span class="fc" id="L2765">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2766">                    c.setPreferredSize(UI.scale(v));</span>
<span class="fc" id="L2767">                    _revalidate(c);</span>
<span class="fc" id="L2768">                })</span>
<span class="fc" id="L2769">                ._with( c -&gt; {</span>
<span class="fc" id="L2770">                    c.setPreferredSize( UI.scale(size.get()) );</span>
<span class="fc" id="L2771">                })</span>
<span class="fc" id="L2772">                ._this();</span>
    }

    /**
     *  Set the preferred width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( int width, int height ) {
<span class="fc" id="L2783">        return _with( c -&gt; c.setPreferredSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2795">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2796">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2797">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L2798">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L2799">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2800">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L2801">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L2802">                })</span>
<span class="fc" id="L2803">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2804">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L2805">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L2806">                })</span>
<span class="fc" id="L2807">                ._with( c -&gt; {</span>
<span class="fc" id="L2808">                    c.setPreferredSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2809">                })</span>
<span class="fc" id="L2810">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( int width ) {
<span class="fc" id="L2820">        return _with( c -&gt; {</span>
<span class="fc" id="L2821">                    _setPrefWidth(c, width);</span>
<span class="fc" id="L2822">                })</span>
<span class="fc" id="L2823">                ._this();</span>
    }

    protected final void _setPrefWidth( C component, int width ) {
<span class="fc" id="L2827">        int currentHeight = component.getPreferredSize().height;</span>
<span class="fc bfc" id="L2828" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2829">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2830">        component.setPreferredSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2831">    }</span>

    /**
     *  Use this to dynamically set only the preferred width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2840">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2841">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L2842">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2843">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L2844">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L2845">                })</span>
<span class="fc" id="L2846">                ._with( c -&gt; {</span>
<span class="fc" id="L2847">                    _setPrefWidth(c, width.get());</span>
<span class="fc" id="L2848">                })</span>
<span class="fc" id="L2849">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( int height ) {
<span class="fc" id="L2859">        return _with( c -&gt; {</span>
<span class="fc" id="L2860">                    _setPrefHeight(c, height);</span>
<span class="fc" id="L2861">                })</span>
<span class="fc" id="L2862">                ._this();</span>
    }

    private void _setPrefHeight( C component, int height ) {
<span class="fc" id="L2866">        int currentWidth = component.getPreferredSize().width;</span>
<span class="fc bfc" id="L2867" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2868">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2869">        component.setPreferredSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2870">    }</span>

    /**
     *  Use this to dynamically set only the preferred height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2879">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2880">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L2881">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2882">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L2883">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L2884">                })</span>
<span class="fc" id="L2885">                ._with( c -&gt; {</span>
<span class="fc" id="L2886">                    _setPrefHeight(c, height.get());</span>
<span class="fc" id="L2887">                })</span>
<span class="fc" id="L2888">                ._this();</span>
    }

    /**
     *  Set the current {@link Dimension})/size (width and height) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Dimension size ) {
<span class="fc" id="L2898">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2899">        return _with( c -&gt; c.setSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2910">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2911">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L2912">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2913">                    c.setSize(UI.scale(v));</span>
<span class="fc" id="L2914">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2915">                })</span>
<span class="fc" id="L2916">                ._with( c -&gt; {</span>
<span class="fc" id="L2917">                    c.setSize( UI.scale(size.get()) );</span>
<span class="fc" id="L2918">                })</span>
<span class="fc" id="L2919">                ._this();</span>
    }

    /**
     *  Set the current width and height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( int width, int height ) {
<span class="fc" id="L2930">        return this.withSize( new Dimension(width, height) );</span>
    }

    /**
     *  Set the current width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( int width ) {
<span class="fc" id="L2940">        return _with( c -&gt; {</span>
<span class="fc" id="L2941">                    c.setSize(new Dimension(UI.scale(width), c.getSize().height));</span>
<span class="fc" id="L2942">                })</span>
<span class="fc" id="L2943">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2954">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2955">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L2956">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2957">                    c.setSize(new Dimension(UI.scale(w), c.getSize().height));</span>
<span class="fc" id="L2958">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2959">                })</span>
<span class="fc" id="L2960">                ._with( c -&gt; {</span>
<span class="fc" id="L2961">                    c.setSize(new Dimension(UI.scale(width.get()), c.getSize().height));</span>
<span class="fc" id="L2962">                })</span>
<span class="fc" id="L2963">                ._this();</span>
    }

    /**
     *  Set the current height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( int height ) {
<span class="fc" id="L2973">        return _with( c -&gt; {</span>
<span class="fc" id="L2974">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height)));</span>
<span class="fc" id="L2975">                })</span>
<span class="fc" id="L2976">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2987">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2988">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L2989">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2990">                    c.setSize(new Dimension(c.getSize().width, UI.scale(h)));</span>
<span class="fc" id="L2991">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2992">                })</span>
<span class="fc" id="L2993">                ._with( c -&gt; {</span>
<span class="fc" id="L2994">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height.get())));</span>
<span class="fc" id="L2995">                })</span>
<span class="fc" id="L2996">                ._this();</span>
    }

    private static void _revalidate( Component comp ) {
<span class="fc" id="L3000">        comp.revalidate();</span>
<span class="pc bpc" id="L3001" title="1 of 2 branches missed.">        if ( comp instanceof JScrollPane )</span>
<span class="nc" id="L3002">            Optional.ofNullable(comp.getParent())</span>
<span class="nc" id="L3003">                    .ifPresent(Component::revalidate); // For some reason, JScrollPane does not revalidate its parent when its preferred size changes.</span>
<span class="fc" id="L3004">    }</span>

    /**
     *  Calls the provided action event handler when the mouse gets pressed and then released.
     *  This delegates to a {@link MouseListener} based mouse click event listener registered in the UI component.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that a click is defined as the combination of the &lt;b&gt;mouse being pressed
     *  and then released on the same position as it was pressed.&lt;/b&gt;
     *  If the mouse moves between the press and the release events, then the
     *  event is considered a drag event instead of a mouse click! (see {@link #onMouseDrag(Action)})
     *
     * @param onClick The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseClick( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onClick ) {
<span class="fc" id="L3019">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L3020">        return _with( c -&gt; {</span>
<span class="fc" id="L3021">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseClicked(MouseEvent e) {
<span class="fc" id="L3023">                            _runInApp(() -&gt; onClick.accept(new ComponentMouseEventDelegate&lt;&gt;( c, e )));</span>
<span class="fc" id="L3024">                        }</span>
                    });
<span class="fc" id="L3026">                })</span>
<span class="fc" id="L3027">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse release events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onRelease The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseRelease( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onRelease ) {
<span class="nc" id="L3040">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="nc" id="L3041">        return _with( c -&gt; {</span>
<span class="nc" id="L3042">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3044">                            _runInApp(() -&gt; onRelease.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e )));</span>
<span class="nc" id="L3045">                        }</span>
                    });
<span class="nc" id="L3047">                })</span>
<span class="nc" id="L3048">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse press events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onPress The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMousePress( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onPress ) {
<span class="nc" id="L3061">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="nc" id="L3062">        return _with( c -&gt; {</span>
<span class="nc" id="L3063">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3065">                            _runInApp(() -&gt; onPress.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e )));</span>
<span class="nc" id="L3066">                        }</span>
                    });
<span class="nc" id="L3068">                })</span>
<span class="nc" id="L3069">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse enter events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3082">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3083">        return _with( c -&gt; {</span>
<span class="fc" id="L3084">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="nc" id="L3086">                            _runInApp(() -&gt; onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e )));</span>
<span class="nc" id="L3087">                        }</span>
                    });
<span class="fc" id="L3089">                })</span>
<span class="fc" id="L3090">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse exit events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3103">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3104">        return _with( c -&gt; {</span>
<span class="fc" id="L3105">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L3107">                            _runInApp(() -&gt; onExit.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e )));</span>
<span class="nc" id="L3108">                        }</span>
                    });
<span class="fc" id="L3110">                })</span>
<span class="fc" id="L3111">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse drag events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The {@link ComponentDragEventDelegate} received by the {@link Action} lambda
     *  exposes both component and drag event
     *  context information, including a list of all the {@link MouseEvent}s involved
     *  in one continuous dragging motion (see {@link ComponentDragEventDelegate#dragEvents()} for more information).
     *
     * @param onDrag The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseDrag( Action&lt;ComponentDragEventDelegate&lt;C&gt;&gt; onDrag ) {
<span class="nc" id="L3128">        NullUtil.nullArgCheck(onDrag, &quot;onDrag&quot;, Action.class);</span>
<span class="nc" id="L3129">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3130">                   java.util.List&lt;MouseEvent&gt; dragEventHistory = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3131">                   MouseAdapter listener = new MouseAdapter() {</span>
                       @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3133">                           dragEventHistory.clear();</span>
<span class="nc" id="L3134">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3135">                       }</span>
                       @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3137">                           dragEventHistory.clear();</span>
<span class="nc" id="L3138">                       }</span>
                       @Override public void mouseDragged(MouseEvent e) {
<span class="nc" id="L3140">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3141">                           _runInApp(() -&gt; onDrag.accept(new ComponentDragEventDelegate&lt;&gt;(thisComponent, e, dragEventHistory)));</span>
<span class="nc" id="L3142">                       }</span>
                   };
<span class="nc" id="L3144">                   thisComponent.addMouseListener(listener);</span>
<span class="nc" id="L3145">                   thisComponent.addMouseMotionListener(listener);</span>
<span class="nc" id="L3146">               })</span>
<span class="nc" id="L3147">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse move events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onMove The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseMove( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onMove ) {
<span class="fc" id="L3160">        NullUtil.nullArgCheck(onMove, &quot;onMove&quot;, Action.class);</span>
<span class="fc" id="L3161">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3162">                   thisComponent.addMouseListener(new MouseAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3164">                           _runInApp(() -&gt; onMove.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e )));</span>
<span class="nc" id="L3165">                       }</span>
                   });
<span class="fc" id="L3167">                   thisComponent.addMouseMotionListener(new MouseMotionAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3169">                           _runInApp(() -&gt; onMove.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e )));</span>
<span class="nc" id="L3170">                       }</span>
                   });
<span class="fc" id="L3172">               })</span>
<span class="fc" id="L3173">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse wheel events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onWheel The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelMove( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheel ) {
<span class="nc" id="L3186">        NullUtil.nullArgCheck(onWheel, &quot;onWheel&quot;, Action.class);</span>
<span class="nc" id="L3187">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3188">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc" id="L3189">                       _runInApp(() -&gt; onWheel.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3190">                   });</span>
<span class="nc" id="L3191">               })</span>
<span class="nc" id="L3192">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel up movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelUp The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelUp( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelUp ) {
<span class="nc" id="L3204">        NullUtil.nullArgCheck(onWheelUp, &quot;onWheelUp&quot;, Action.class);</span>
<span class="nc" id="L3205">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3206">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3207" title="All 2 branches missed.">                       if ( e.getWheelRotation() &lt; 0 )</span>
<span class="nc" id="L3208">                           _runInApp(() -&gt; onWheelUp.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3209">                   });</span>
<span class="nc" id="L3210">               })</span>
<span class="nc" id="L3211">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel down movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelDown The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelDown( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelDown ) {
<span class="nc" id="L3223">        NullUtil.nullArgCheck(onWheelDown, &quot;onWheelDown&quot;, Action.class);</span>
<span class="nc" id="L3224">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3225">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">                       if ( e.getWheelRotation() &gt; 0 )</span>
<span class="nc" id="L3227">                               _runInApp(() -&gt; onWheelDown.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3228">                   });</span>
<span class="nc" id="L3229">               })</span>
<span class="nc" id="L3230">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component's size changes.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *  Passing null to this method will cause an exception to be thrown.
     *
     * @param onResize The resize action which will be called when the underlying component changes size.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onResize( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onResize ) {
<span class="fc" id="L3242">        NullUtil.nullArgCheck(onResize, &quot;onResize&quot;, Action.class);</span>
<span class="fc" id="L3243">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3244">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentResized(ComponentEvent e) {
<span class="fc" id="L3246">                           _runInApp(()-&gt;onResize.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="fc" id="L3247">                       }</span>
                   });
<span class="fc" id="L3249">               })</span>
<span class="fc" id="L3250">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component was moved.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *
     * @param onMoved The action lambda which will be executed once the component was moved / its position canged.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMoved( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onMoved ) {
<span class="fc" id="L3261">        NullUtil.nullArgCheck(onMoved, &quot;onMoved&quot;, Action.class);</span>
<span class="fc" id="L3262">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3263">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentMoved(ComponentEvent e) {

<span class="nc" id="L3266">                           _runInApp(()-&gt;onMoved.accept(new ComponentDelegate&lt;&gt;( thisComponent, e )));</span>
<span class="nc" id="L3267">                       }</span>
                   });
<span class="fc" id="L3269">               })</span>
<span class="fc" id="L3270">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link ComponentListener}
     *  to the component, to receive those component events where the wrapped component becomes visible.
     *
     * @param onShown The {@link Action} which gets invoked when the component has been made visible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onShown( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onShown ) {
<span class="fc" id="L3281">        NullUtil.nullArgCheck(onShown, &quot;onShown&quot;, Action.class);</span>
<span class="fc" id="L3282">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3283">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentShown(ComponentEvent e) {
<span class="fc" id="L3285">                           _runInApp(()-&gt;onShown.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="fc" id="L3286">                       }</span>
                   });
<span class="fc" id="L3288">               })</span>
<span class="fc" id="L3289">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link ComponentListener}
     *  to the component, to receive those component events where the wrapped component becomes invisible.
     *
     * @param onHidden The {@link Action} which gets invoked when the component has been made invisible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onHidden( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onHidden ) {
<span class="fc" id="L3300">        NullUtil.nullArgCheck(onHidden, &quot;onHidden&quot;, Action.class);</span>
<span class="fc" id="L3301">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3302">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentHidden(ComponentEvent e) {
<span class="nc" id="L3304">                           _runInApp(()-&gt;onHidden.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3305">                       }</span>
                   });
<span class="fc" id="L3307">               })</span>
<span class="fc" id="L3308">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link FocusListener}
     * to the component, to receive those focus events where the wrapped component gains input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was gained on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusGain( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L3319">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L3320">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3321">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusGained(FocusEvent e) {
<span class="nc" id="L3323">                           _runInApp(()-&gt;onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3324">                       }</span>
                   });
<span class="fc" id="L3326">               })</span>
<span class="fc" id="L3327">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a focus listener
     * to receive those focus events where the wrapped component loses input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was lost on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusLoss( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L3338">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L3339">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3340">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusLost(FocusEvent e) {
<span class="nc" id="L3342">                           _runInApp(()-&gt;onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3343">                       }</span>
                   });
<span class="fc" id="L3345">               })</span>
<span class="fc" id="L3346">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received a key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onKeyPress( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L3357">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L3358">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3359">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed(KeyEvent e) {
<span class="nc" id="L3361">                           _runInApp(()-&gt;onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3362">                       }</span>
                   });
<span class="fc" id="L3364">               })</span>
<span class="fc" id="L3365">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received the targeted key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onPressed( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L3378">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L3379">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L3380">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3381">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed( KeyEvent e ) {
<span class="nc bnc" id="L3383" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L3384">                               _runInApp(()-&gt;onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3385">                       }</span>
                   });
<span class="fc" id="L3387">               })</span>
<span class="fc" id="L3388">               ._this();</span>
    }

                             /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received a key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     */
    public final I onKeyRelease( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L3400">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L3401">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3402">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased(KeyEvent e) {
<span class="nc" id="L3404">                           _runInApp(()-&gt;onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e ))); }</span>
                   });
<span class="fc" id="L3406">               })</span>
<span class="fc" id="L3407">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received the targeted key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onRelease( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L3422">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L3423">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L3424">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3425">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased( KeyEvent e ) {
<span class="nc bnc" id="L3427" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L3428">                               _runInApp(()-&gt;onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3429">                       }</span>
                   });
<span class="fc" id="L3431">               })</span>
<span class="fc" id="L3432">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received a key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onKeyTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L3445">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L3446">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3447">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc" id="L3448">                       _runInApp(() -&gt; onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3449">                   });</span>
<span class="fc" id="L3450">               })</span>
<span class="fc" id="L3451">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received the targeted key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     * @see #onKeyTyped(Action)
     */
    public final I onTyped( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L3467">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L3468">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L3469">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3470">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc bnc" id="L3471" title="All 2 branches missed.">                       if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L3472">                           _runInApp(()-&gt;onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
<span class="nc" id="L3473">                   });</span>
<span class="fc" id="L3474">               })</span>
<span class="fc" id="L3475">               ._this();</span>
    }

    protected void _onKeyTyped(C component, BiConsumer&lt;KeyEvent, KeyAdapter&gt; action ) {
<span class="fc" id="L3479">        component.addKeyListener(new KeyAdapter() {</span>
            @Override public void keyTyped(KeyEvent e) {
<span class="nc" id="L3481">                action.accept(e, this);</span>
<span class="nc" id="L3482">            }</span>
        });
<span class="fc" id="L3484">    }</span>

    /**
     *  Use this to register a {@link Observable} event handler which will be called
     *  on the UI thread when the {@link Observable} event is fired and irrespective of
     *  what thread the {@link Observable} event is fired on.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *  UI.label(&quot;I have a color animation!&quot;)
     *  .on(viewModel.someEvent(), it -&gt;
     *    it.animateFor(3, TimeUnit.SECONDS, state -&gt; {
     *      double r = state.progress();
     *      double g = 1 - state.progress();
     *      double b = state.pulse();
     *      it.setBackgroundColor(r, g, b);
     *    })
     *  )
     *  }&lt;/pre&gt;
     *
     * @param noticeableEvent The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the UI thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     */
    public final &lt;E extends Observable&gt; I onView( E noticeableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L3510">        return this.on(noticeableEvent, it -&gt; _runInUI(() -&gt; action.accept(it)));</span>
    }

    /**
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event.
     *  The action is executed on the application thread when the {@link Observable} event is fired and
     *  irrespective of the thread that {@link Observable} fired the event.
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(CustomEventSystem.touchGesture(), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a touch gesture event handler
     *  which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *
     * @param noticeableEvent The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     */
    public final &lt;E extends Observable&gt; I on( E noticeableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L3535">        NullUtil.nullArgCheck(noticeableEvent, &quot;noticeableEvent&quot;, Observable.class);</span>
<span class="fc" id="L3536">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L3537">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3538">                   noticeableEvent.subscribe(() -&gt; {</span>
<span class="fc" id="L3539">                       _runInApp(() -&gt; action.accept(new ComponentDelegate&lt;&gt;(thisComponent, noticeableEvent )));</span>
<span class="fc" id="L3540">                   });</span>
<span class="fc" id="L3541">               })</span>
<span class="fc" id="L3542">               ._this();</span>
    }

    /**
     *  This is a logical extension of the {@link #on(Observable, Action)} method.
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event.
     *  The handler will be called on the application thread when the {@link Observable} event
     *  is fired and irrespective of the thread that fired the {@link Observable} event.
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(c -&gt; CustomEventSystem.touchGesture(c), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  Which may also be written as:
     *  &lt;pre&gt;{@code
     *    UI.label(&quot;&quot;)
     *    .on(CustomEventSystem::touchGesture, it -&gt; ..some App update.. )
     * }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a component specific
     *  touch gesture event handler which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *
     * @param eventSource The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     */
    public final &lt;E extends Observable&gt; I on( Function&lt;C, E&gt; eventSource, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="nc" id="L3573">        NullUtil.nullArgCheck(eventSource, &quot;noticeableEvent&quot;, Observable.class);</span>
<span class="nc" id="L3574">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="nc" id="L3575">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3576">                   E observableEvent = eventSource.apply(thisComponent);</span>
<span class="nc" id="L3577">                   observableEvent.subscribe(() -&gt; {</span>
<span class="nc" id="L3578">                       _runInApp(() -&gt; action.accept(new ComponentDelegate&lt;&gt;( thisComponent, observableEvent )));</span>
<span class="nc" id="L3579">                   });</span>
<span class="nc" id="L3580">               })</span>
<span class="nc" id="L3581">               ._this();</span>
    }

    /**
     *  Use this to register periodic update actions which should be called
     *  based on the provided {@code delay}! &lt;br&gt;
     *  The following example produces a label which will display the current date.
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .doUpdates( 100, it -&gt; it.getComponent().setText(new Date().toString()) )
     *  }&lt;/pre&gt;
     *
     * @param delay The delay in milliseconds between calling the provided {@link Action}.
     * @param onUpdate The {@link Action} which should be called periodically.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I doUpdates( int delay, Action&lt;ComponentDelegate&lt;C, ActionEvent&gt;&gt; onUpdate ) {
<span class="fc" id="L3598">        NullUtil.nullArgCheck(onUpdate, &quot;onUpdate&quot;, Action.class);</span>
<span class="fc" id="L3599">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3600">                   Timer timer = new Timer(delay, e -&gt; onUpdate.accept(new ComponentDelegate&lt;&gt;(thisComponent, e )));</span>
                   {
<span class="fc" id="L3602">                       java.util.List&lt;Timer&gt; timers = (java.util.List&lt;Timer&gt;) thisComponent.getClientProperty(_TIMERS_KEY);</span>
<span class="pc bpc" id="L3603" title="1 of 2 branches missed.">                       if ( timers == null ) {</span>
<span class="fc" id="L3604">                           timers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3605">                           thisComponent.putClientProperty(_TIMERS_KEY, timers);</span>
                       }
<span class="fc" id="L3607">                       timers.add(timer);</span>
                   }
<span class="fc" id="L3609">                   timer.start();</span>
<span class="fc" id="L3610">               })</span>
<span class="fc" id="L3611">               ._this();</span>
    }

    @Override
    protected void _addComponentTo(C thisComponent, JComponent newComponent, Object conf ) {
<span class="fc" id="L3616">        NullUtil.nullArgCheck(newComponent, &quot;component&quot;, JComponent.class);</span>
<span class="fc bfc" id="L3617" title="All 2 branches covered.">        if ( conf == null )</span>
<span class="fc" id="L3618">            thisComponent.add(newComponent);</span>
        else
<span class="fc" id="L3620">            thisComponent.add(newComponent, conf);</span>
<span class="fc" id="L3621">    }</span>

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument is expected to contain layout information for the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( String attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L3637">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The mig-layout attribute.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( AddConstraint attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L3654">        return this.add(attr.toString(), new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s 
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be passed to the {@link LayoutManager} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent} 
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( String attr, B... builders ) {
<span class="fc" id="L3673">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3674">                   _addBuildersTo(thisComponent, attr, builders);</span>
<span class="fc" id="L3675">               })</span>
<span class="fc" id="L3676">               ._this();</span>
    }

    private void _addBuildersTo( C thisComponent, String attr, UIForAnySwing&lt;?, ?&gt;... builders ) {
<span class="fc" id="L3680">        LayoutManager layout = thisComponent.getLayout();</span>
<span class="fc bfc" id="L3681" title="All 4 branches covered.">        if ( _isBorderLayout(attr) &amp;&amp; !(layout instanceof BorderLayout) ) {</span>
<span class="pc bpc" id="L3682" title="1 of 2 branches missed.">            if ( layout instanceof MigLayout )</span>
<span class="fc" id="L3683">                log.warn(&quot;Layout ambiguity detected! Border layout constraint cannot be added to 'MigLayout'.&quot;);</span>
<span class="fc" id="L3684">            thisComponent.setLayout(new BorderLayout()); // The UI Maker tries to fill in the blanks!</span>
        }
<span class="fc bfc" id="L3686" title="All 2 branches covered.">        for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="fc" id="L3687">            _addBuilderTo(thisComponent, b, attr);</span>
<span class="fc" id="L3688">    }</span>

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( AddConstraint attr, B... builders ) {
<span class="fc" id="L3706">        return this.add( attr.toString(), builders );</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the {@link JComponent}s
     *  wrapped by the provided builders
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents placement constraints for the provided components which will
     *  be passed to the {@link MigLayout} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( CC attr, B... builders ) {
<span class="nc" id="L3726">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3727">                   LayoutManager layout = thisComponent.getLayout();</span>
<span class="nc bnc" id="L3728" title="All 2 branches missed.">                   if ( !(layout instanceof MigLayout) )</span>
<span class="nc" id="L3729">                       log.warn(&quot;Layout ambiguity detected! Mig layout constraint cannot be added to '{}'.&quot;, layout.getClass().getSimpleName());</span>

<span class="nc bnc" id="L3731" title="All 2 branches missed.">                   for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="nc" id="L3732">                       _addBuilderTo(thisComponent, b, attr);</span>
<span class="nc" id="L3733">               })</span>
<span class="nc" id="L3734">               ._this();</span>
    }

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be applied to the subsequently provided {@link JComponent} types.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( String attr, E... components ) {
<span class="fc" id="L3751">        NullUtil.nullArgCheck(attr, &quot;conf&quot;, Object.class);</span>
<span class="fc" id="L3752">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc" id="L3753">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3754">                   _addComponentsTo( thisComponent, attr, components );</span>
<span class="fc" id="L3755">               })</span>
<span class="fc" id="L3756">               ._this();</span>
    }

    @SafeVarargs
    private final &lt;E extends JComponent&gt; void _addComponentsTo( C thisComponent, String attr, E... components ) {
<span class="fc bfc" id="L3761" title="All 2 branches covered.">        for ( E component : components ) {</span>
<span class="fc" id="L3762">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L3763">            _addBuildersTo( thisComponent, attr, new UIForSwing[]{UI.of(component)} );</span>
        }
<span class="fc" id="L3765">    }</span>

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first 2 arguments will be joined by a comma and passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( AddConstraint attr, E... components ) {
<span class="nc" id="L3781">        return this.add(attr.toString(), components);</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L3798">        NullUtil.nullArgCheck(viewable, &quot;viewable&quot;, Val.class);</span>
<span class="fc" id="L3799">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3800">                   _addViewablePropTo(thisComponent, viewable, null, viewSupplier);</span>
<span class="fc" id="L3801">               })</span>
<span class="fc" id="L3802">               ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L3820">        NullUtil.nullArgCheck(viewables, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L3821">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3822">                    _addViewableProps( viewables, null, viewSupplier, thisComponent );</span>
<span class="fc" id="L3823">                })</span>
<span class="fc" id="L3824">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( String attr, Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L3842">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="fc" id="L3843">        NullUtil.nullArgCheck(viewable, &quot;viewable&quot;, Val.class);</span>
<span class="fc" id="L3844">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3845">                   _addViewablePropTo(thisComponent, viewable, attr, viewSupplier);</span>
<span class="fc" id="L3846">               })</span>
<span class="fc" id="L3847">               ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( String attr, Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L3866">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="nc" id="L3867">        NullUtil.nullArgCheck(viewables, &quot;viewables&quot;, Vals.class);</span>
<span class="nc" id="L3868">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3869">                    _addViewableProps( viewables, attr, viewSupplier, thisComponent );</span>
<span class="nc" id="L3870">                })</span>
<span class="nc" id="L3871">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( AddConstraint attr, Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L3889">        return this.add(attr.toString(), viewable, viewSupplier);</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( AddConstraint attr, Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L3908">        return this.add(attr.toString(), viewables, viewSupplier);</span>
    }

    protected &lt;M&gt; void _addViewableProps( Vals&lt;M&gt; viewables, String attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L3912">        _onShow( viewables, thisComponent, (c, delegate) -&gt; {</span>
            // we simply redo all the components.
<span class="pc bpc" id="L3914" title="3 of 6 branches missed.">            switch ( delegate.changeType() ) {</span>
<span class="nc" id="L3915">                case SET: _updateComponentAt(delegate.index(), delegate.newValue().get(), viewSupplier, attr, c); break;</span>
                case ADD:
<span class="pc bpc" id="L3917" title="3 of 4 branches missed.">                    if ( delegate.index() &lt; 0 &amp;&amp; delegate.newValue().isEmpty() ) {</span>
                        // This is basically a add all operation, so we clear the components first.
<span class="nc" id="L3919">                        _clearComponentsOf(c);</span>
                        // and then we add all the components.
<span class="nc bnc" id="L3921" title="All 2 branches missed.">                        for ( int i = 0; i &lt; delegate.vals().size(); i++ )</span>
<span class="nc" id="L3922">                            _addComponentAt( i, delegate.vals().at(i).get(), viewSupplier, attr, c );</span>
                    }
                    else
<span class="fc" id="L3925">                        _addComponentAt( delegate.index(), delegate.newValue().get(), viewSupplier, attr, c );</span>
<span class="fc" id="L3926">                    break;</span>
<span class="fc" id="L3927">                case REMOVE: _removeComponentAt(delegate.index(), c); break;</span>
<span class="fc" id="L3928">                case CLEAR: _clearComponentsOf(c); break;</span>
<span class="nc" id="L3929">                case NONE: break;</span>
<span class="nc" id="L3930">                default: throw new IllegalStateException(&quot;Unknown type: &quot;+delegate.changeType());</span>
            }
<span class="fc" id="L3932">        });</span>
<span class="fc" id="L3933">        viewables.forEach( v -&gt; {</span>
<span class="fc" id="L3934">            _addBuildersTo( thisComponent, new AbstractNestedBuilder[]{viewSupplier.createViewFor(v)} );</span>
<span class="fc" id="L3935">        });</span>
<span class="fc" id="L3936">    }</span>

    private &lt;M&gt; void _addViewablePropTo(
        C thisComponent, Val&lt;M&gt; viewable, String attr, ViewSupplier&lt;M&gt; viewSupplier
    ) {
        // First we remember the index of the component which will be provided by the viewable dynamically.
<span class="fc" id="L3942">        final int index = _childCount( thisComponent );</span>
        // Then we add the component provided by the viewable to the list of children.
<span class="fc bfc" id="L3944" title="All 2 branches covered.">        if ( attr == null ) {</span>
<span class="fc bfc" id="L3945" title="All 2 branches covered.">            if ( viewable.isPresent() )</span>
<span class="fc" id="L3946">                _addBuildersTo(thisComponent, viewSupplier.createViewFor(viewable.get()));</span>
            else
<span class="fc" id="L3948">                _addComponentsTo(thisComponent, new JPanel()); // We add a dummy component to the list of children.</span>
        } else {
<span class="pc bpc" id="L3950" title="1 of 2 branches missed.">            if ( viewable.isPresent() )</span>
<span class="fc" id="L3951">                _addBuildersTo(thisComponent, attr, viewSupplier.createViewFor(viewable.get()));</span>
            else
<span class="nc" id="L3953">                _addComponentsTo(thisComponent, attr, new JPanel()); // We add a dummy component to the list of children.</span>
        }
        // Finally we add a listener to the viewable which will update the component when the viewable changes.
<span class="fc" id="L3956">        _onShow( viewable, thisComponent, (c,v) -&gt; _updateComponentAt(index, v, viewSupplier, attr, c) );</span>
<span class="fc" id="L3957">    }</span>

    private &lt;M&gt; void _updateComponentAt(
        int index, M v, ViewSupplier&lt;M&gt; viewSupplier, String attr, C c
    ) {
<span class="pc bpc" id="L3962" title="1 of 2 branches missed.">        JComponent newComponent = v == null ? new JPanel() : UI.use(_state().eventProcessor(), () -&gt; viewSupplier.createViewFor(v).getComponent() );</span>
        // We remove the old component.
<span class="fc" id="L3964">        c.remove(c.getComponent(index));</span>
        // We add the new component.
<span class="pc bpc" id="L3966" title="1 of 2 branches missed.">        if ( attr == null )</span>
<span class="fc" id="L3967">            c.add(newComponent, index);</span>
        else
<span class="nc" id="L3969">            c.add(newComponent, attr, index);</span>
        // We update the layout.
<span class="fc" id="L3971">        c.revalidate();</span>
<span class="fc" id="L3972">        c.repaint();</span>
<span class="fc" id="L3973">    }</span>

    private &lt;M&gt; void _addComponentAt(
        int index, M v, ViewSupplier&lt;M&gt; viewSupplier, String attr, C thisComponent
    ) {
        // We add the new component.
<span class="pc bpc" id="L3979" title="1 of 2 branches missed.">        if ( attr == null )</span>
<span class="fc" id="L3980">            thisComponent.add(UI.use(_state().eventProcessor(), () -&gt; viewSupplier.createViewFor(v).getComponent()), index);</span>
        else
<span class="nc" id="L3982">            thisComponent.add(UI.use(_state().eventProcessor(), () -&gt; viewSupplier.createViewFor(v).getComponent()), attr, index);</span>
        // We update the layout.
<span class="fc" id="L3984">        thisComponent.revalidate();</span>
<span class="fc" id="L3985">        thisComponent.repaint();</span>
<span class="fc" id="L3986">    }</span>

    private void _removeComponentAt( int index, C thisComponent ) {
        // We remove the old component.
<span class="fc" id="L3990">        thisComponent.remove(thisComponent.getComponent(index));</span>
        // We update the layout.
<span class="fc" id="L3992">        thisComponent.revalidate();</span>
<span class="fc" id="L3993">        thisComponent.repaint();</span>
<span class="fc" id="L3994">    }</span>

    private void _clearComponentsOf( C thisComponent ) {
        // We remove all components.
<span class="fc" id="L3998">        thisComponent.removeAll();</span>
        // We update the layout.
<span class="fc" id="L4000">        thisComponent.revalidate();</span>
<span class="fc" id="L4001">        thisComponent.repaint();</span>
<span class="fc" id="L4002">    }</span>

    private static boolean _isBorderLayout( Object o ) {
<span class="fc bfc" id="L4005" title="All 2 branches covered.">        return BorderLayout.CENTER.equals(o)     ||</span>
<span class="fc bfc" id="L4006" title="All 2 branches covered.">               BorderLayout.PAGE_START.equals(o) ||</span>
<span class="fc bfc" id="L4007" title="All 2 branches covered.">               BorderLayout.PAGE_END.equals(o)   ||</span>
<span class="fc bfc" id="L4008" title="All 2 branches covered.">               BorderLayout.LINE_END.equals(o)   ||</span>
<span class="fc bfc" id="L4009" title="All 2 branches covered.">               BorderLayout.LINE_START.equals(o) ||</span>
<span class="pc bpc" id="L4010" title="1 of 2 branches missed.">               BorderLayout.EAST.equals(o)       ||</span>
<span class="pc bpc" id="L4011" title="1 of 2 branches missed.">               BorderLayout.WEST.equals(o)       ||</span>
<span class="pc bpc" id="L4012" title="1 of 2 branches missed.">               BorderLayout.NORTH.equals(o)      ||</span>
<span class="pc bpc" id="L4013" title="1 of 2 branches missed.">               BorderLayout.SOUTH.equals(o);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>