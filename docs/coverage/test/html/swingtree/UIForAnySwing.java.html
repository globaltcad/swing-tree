<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAnySwing.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAnySwing.java</span></div><h1>UIForAnySwing.java</h1><pre class="source lang-java linenums">package swingtree;


import net.miginfocom.layout.AC;
import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.*;
import sprouts.Action;
import sprouts.Event;
import sprouts.Observable;
import sprouts.impl.SequenceDiff;
import sprouts.impl.SequenceDiffOwner;
import swingtree.animation.AnimationDispatcher;
import swingtree.animation.AnimationStatus;
import swingtree.animation.LifeTime;
import swingtree.api.*;
import swingtree.api.mvvm.BoundViewSupplier;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.components.JBox;
import swingtree.components.JScrollPanels;
import swingtree.input.Keyboard;
import swingtree.layout.AddConstraint;
import swingtree.layout.LayoutConstraint;
import swingtree.layout.ResponsiveGridFlowLayout;
import swingtree.layout.Size;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import java.awt.*;
import java.awt.dnd.DragSource;
import java.awt.dnd.DropTarget;
import java.awt.event.*;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;


/**
 *  A generic SwingTree builder node designed as a basis for configuring any kind of {@link JComponent} instance.
 *  This is the most generic builder type and therefore abstract super-type for almost all other builders.
 *  This builder defines nested building for anything extending the {@link JComponent} class.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *  &lt;br&gt;&lt;br&gt;
 *
 * @param &lt;I&gt; The concrete extension of the {@link UIForAnything}.
 * @param &lt;C&gt; The type parameter for the component type wrapped by an instance of this class.
 */
<span class="fc" id="L64">public abstract class UIForAnySwing&lt;I, C extends JComponent&gt; extends UIForAnything&lt;I, C, JComponent&gt;</span>
{
<span class="fc" id="L66">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(UIForAnySwing.class);</span>

    private final static String _TIMERS_KEY = &quot;_swing-tree.timers&quot;;


    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedFont( Font font ) {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        return font == UI.Font.UNDEFINED;</span>
    }

    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedColor( Color color ) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        return color == UI.Color.UNDEFINED;</span>
    }

    private void _bindRepaintOn( JComponent thisComponent, Observable event ) {
<span class="nc" id="L82">        ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="nc" id="L83">                event.subscribe( () -&gt; _runInUI( thisComponent::repaint ) )</span>
            );
<span class="nc" id="L85">    }</span>

    private void _bindRepaintOn( JComponent thisComponent, Event event ) {
<span class="fc" id="L88">        ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="pc" id="L89">                event.observable().subscribe( () -&gt; _runInUI(thisComponent::repaint) )</span>
            );
<span class="fc" id="L91">    }</span>

    private void _bindRepaintOn( JComponent thisComponent, Val&lt;?&gt; event ) {
<span class="fc" id="L94">        ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="pc" id="L95">                event.view().subscribe( () -&gt; _runInUI(thisComponent::repaint) )</span>
            );
<span class="fc" id="L97">    }</span>

    /**
     *  Use this to bind an {@link Observable} (usually from a sprouts.Event)
     *  to the {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever
     *  the source of the observable is fired or changed.
     *
     * @param observable The observable to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Observable observable ) {
<span class="nc" id="L109">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, observable) )._this();</span>
    }

    /**
     *  This method exposes a concise way to bind multiple {@link Observable}s (usually sprouts.Event instances)
     *  to the {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever the source of any one of the
     *  observables is fired or changed.
     *
     * @param first The first observable to which the repaint method of the component will be bound.
     * @param second The second observable to which the repaint method of the component will be bound.
     * @param rest The rest of the observables to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Observable first, Observable second, Observable... rest ) {
<span class="nc" id="L124">        return _with( c -&gt; {</span>
<span class="nc" id="L125">                    _bindRepaintOn(c, first);</span>
<span class="nc" id="L126">                    _bindRepaintOn(c, second);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                    for ( Observable o : rest ) {</span>
<span class="nc" id="L128">                        _bindRepaintOn(c, o);</span>
                    }
<span class="nc" id="L130">                })._this();</span>
    }

    /**
     *  Allows you to bind an {@link Event} to the {@link JComponent#repaint()} method of
     *  the component represented by this builder. &lt;br&gt;
     *  This means that the component will be repainted whenever the event is fired
     *  through the {@link Event#fire()} method.
     *
     * @param event The event to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Event event ) {
<span class="fc" id="L143">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, event) )._this();</span>
    }

    /**
     *  This method exposes a concise way to bind multiple {@link Event}s to the
     *  {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever any one of the events is fired
     *  through the {@link Event#fire()} method.
     *
     * @param first The first event to which the repaint method of the component will be bound.
     * @param second The second event to which the repaint method of the component will be bound.
     * @param rest The rest of the events to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Event first, Event second, Event... rest ) {
<span class="nc" id="L158">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L159">                    _bindRepaintOn(thisComponent, first);</span>
<span class="nc" id="L160">                    _bindRepaintOn(thisComponent, second);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                    for ( Event e : rest ) {</span>
<span class="nc" id="L162">                        _bindRepaintOn(thisComponent, e);</span>
                    }
<span class="nc" id="L164">                })</span>
<span class="nc" id="L165">                ._this();</span>
    }

    /**
     *  Allows you to bind a {@link Val} to the {@link JComponent#repaint()} method
     *  of the component represented by this builder. &lt;br&gt;
     *  This means that the component will be repainted whenever the value of the {@link Val}
     *  changes. If the {@link Val} is a mutable {@link Var} property,
     *  then this event is usually triggered through the {@link Var#set(Object)} method.&lt;br&gt;
     *  &lt;p&gt;
     *      A typical use case is to use {@link Var} properties in the
     *      {@link Styler} of the style API exposed by {@link UIForAnySwing#withStyle(Styler)},
     *      and then also pass these properties to the this {@code withRepaintOn}
     *      method to ensure that the style gets re-evaluated and then repainted.
     *  &lt;/p&gt;
     *
     * @param event The {@link Val} to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Val&lt;?&gt; event ) {
<span class="fc" id="L185">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, event) )._this();</span>
    }

    /**
     *  Use this method to bind multiple {@link Val}s to the
     *  {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever the value of any one of the
     *  {@link Val}s changes. If the {@link Val} is a mutable {@link Var} property,
     *  then this event is usually triggered through the {@link Var#set(Object)} method.&lt;br&gt;
     *  &lt;p&gt;
     *      A typical use case is to use {@link Var} properties in the
     *      {@link Styler} of the style API exposed by {@link UIForAnySwing#withStyle(Styler)},
     *      and then also pass these properties to the this {@code withRepaintOn}
     *      method to ensure that the style gets re-evaluated and then repainted.
     *  &lt;/p&gt;
     *
     * @param first The first {@link Val} to which the repaint method of the component will be bound.
     * @param second The second {@link Val} to which the repaint method of the component will be bound.
     * @param rest The rest of the {@link Val}s to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Val&lt;?&gt; first, Val&lt;?&gt; second, Val&lt;?&gt;... rest ) {
<span class="nc" id="L207">        return _with( c -&gt; {</span>
<span class="nc" id="L208">                    _bindRepaintOn(c, first);</span>
<span class="nc" id="L209">                    _bindRepaintOn(c, second);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                    for ( Val&lt;?&gt; o : rest ) {</span>
<span class="nc" id="L211">                        _bindRepaintOn(c, o);</span>
                    }
<span class="nc" id="L213">                })._this();</span>
    }

    /**
     *  This method exposes a concise way to set an identifier for the component
     *  represented by this builder chain.
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *
     * @param id The identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be managed by this builder.
     */
    public final I id( String id ) {
<span class="fc" id="L229">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method exposes a concise way to set an enum based identifier for the component
     *  represented by this builder chain.
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *  &lt;p&gt;
     *  The enum identifier will be translated to a string using {@link Enum#name()}.
     *
     * @param id The enum identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be managed by this builder.
     * @param &lt;E&gt; The enum type.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I id( E id ) {
<span class="fc" id="L248">        Objects.requireNonNull(id);</span>
<span class="fc" id="L249">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to a style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *      {@literal @}Override
     *      protected void build() {
     *          add(group(&quot;A&quot;).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *              .backgroundColor(Color.RED)
     *          );
     *          add(group(&quot;B&quot;), it -&amp;gt; it
     *              .borderWidth(12)
     *          );
     *          add(group(&quot;C&quot;), it -&amp;gt; it
     *              .borderWidth(16)
     *              .borderColor(Color.YELLOW)
     *          );
     *      }
     *    }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(&quot;A&quot;)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;&lt;br&gt;
     *  &lt;b&gt;It is advised to use the {@link #group(Enum[])} method
     *  instead of this method, as the usage of enums for modelling
     *  group tags offers much better compile time type safety!&lt;/b&gt;
     *
     * @param groupTags The names of the style groups to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I group( String... groupTags ) {
<span class="fc" id="L291">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to an enum based style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *          {@literal @}Override
     *          protected void build() {
     *              add(group(MyGroups.A).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *                  .backgroundColor(Color.RED)
     *              );
     *              add(group(MyGroups.B), it -&amp;gt; it
     *                  .borderWidth(12)
     *              );
     *              add(group(MyGroups.C), it -&amp;gt; it
     *                  .borderWidth(16)
     *                  .borderColor(Color.YELLOW)
     *              );
     *          }
     *      }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(MyGroup.A)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;
     *
     * @param groupTags The enum based style group to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The enum type.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; I group( E... groupTags ) {
<span class="fc" id="L332">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type visible or invisible
     *  depending on the supplied boolean value.
     *
     * @param isVisible The truth value determining if the component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( boolean isVisible ) {
<span class="fc" id="L343">        return _with( c -&gt; c.setVisible(isVisible) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(boolean)}, and it is
     *  used to make the underlying {@link JComponent} type visible or invisible.
     *  &lt;p&gt;
     *  If the supplied boolean value is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied boolean value is {@code false}, the component will be visible.
     *
     * @param isVisible The truth value determining if the UI component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( boolean isVisible ) {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        return _with( c -&gt; c.setVisible(!isVisible) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  through the supplied {@link Val} property, which is automatically bound
     *  to the {@link JComponent#setVisible(boolean)} method of the underlying {@link JComponent} type.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *           send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L377">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L378">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L379">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="fc" id="L380">                    c.setVisible(v);</span>
<span class="fc" id="L381">                })</span>
<span class="fc" id="L382">                ._with( c -&gt; {</span>
<span class="fc" id="L383">                    c.setVisible( isVisible.orElseThrowUnchecked() );</span>
<span class="fc" id="L384">                })</span>
<span class="fc" id="L385">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     *  If the supplied {@link Val} property is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied {@link Val} property is {@code false}, the component will be visible.
     *  &lt;p&gt;
     *  &lt;i&gt;
     *      Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *            send the property value to this view component.
     *  &lt;/i&gt;
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L406">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L407">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component! A boolean should only be true or false!&quot;);</span>
<span class="fc" id="L408">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">                    c.setVisible(!v);</span>
<span class="fc" id="L410">                })</span>
<span class="fc" id="L411">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">                    c.setVisible( !isVisible.orElseThrowUnchecked() );</span>
<span class="fc" id="L413">                })</span>
<span class="fc" id="L414">                ._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be visible,
     *  otherwise it will be invisible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component visible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component visible.
     * @param &lt;E&gt; The enum type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L436">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L437">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L438">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L439">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">                    c.setVisible( v == enumValue );</span>
<span class="fc" id="L441">                })</span>
<span class="fc" id="L442">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                    c.setVisible( enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L444">                })</span>
<span class="fc" id="L445">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Enum, Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be invisible,
     *  otherwise it will be visible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component invisible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component invisible.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L466">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L467">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L468">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L469">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                    c.setVisible( v != enumValue );</span>
<span class="fc" id="L471">                })</span>
<span class="fc" id="L472">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                    c.setVisible( enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L474">                })</span>
<span class="fc" id="L475">                ._this();</span>
    }

    /**
     *  Use this to enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( boolean isEnabled ) {
<span class="fc" id="L485">        return _with( c -&gt; _setEnabled(c, isEnabled) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(boolean)}.
     *  Use this to disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( boolean isEnabled ) {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        return _with( c -&gt; _setEnabled(c, !isEnabled) )._this();</span>
    }

    /**
     *  Use this to dynamically enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L506">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L507">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L508">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="fc" id="L509">                    c.setEnabled(v);</span>
<span class="fc" id="L510">                })</span>
<span class="fc" id="L511">                ._with( c -&gt; {</span>
<span class="fc" id="L512">                    _setEnabled(c,  isEnabled.orElseThrowUnchecked() );</span>
<span class="fc" id="L513">                })</span>
<span class="fc" id="L514">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Val)}.
     *  Use this to dynamically disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L525">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L526">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L527">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                    _setEnabled(c, !v);</span>
<span class="nc" id="L529">                })</span>
<span class="fc" id="L530">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                    _setEnabled(c,  !isEnabled.orElseThrowUnchecked() );</span>
<span class="fc" id="L532">                })</span>
<span class="fc" id="L533">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically enabled or disabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component enabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component enabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L547">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L548">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L549">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L550">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                    _setEnabled( c,  v == enumValue );</span>
<span class="fc" id="L552">                })</span>
<span class="fc" id="L553">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L555">                })</span>
<span class="fc" id="L556">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically disabled or enabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component disabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component disabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L571">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L572">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L573">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L574">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                    _setEnabled( c,  v != enumValue );</span>
<span class="fc" id="L576">                })</span>
<span class="fc" id="L577">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L579">                })</span>
<span class="fc" id="L580">                ._this();</span>
    }

    protected void _setEnabled( C c, boolean isEnabled ) { 
<span class="fc" id="L584">        c.setEnabled( isEnabled ); </span>
<span class="fc" id="L585">    }</span>

    /**
     *  Use this to make the wrapped UI component grab the input focus.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeFocused() {
<span class="fc" id="L592">        return _with( c -&gt; {</span>
<span class="fc" id="L593">                    UI.runLater(() -&gt; {</span>
<span class="fc" id="L594">                        c.grabFocus();</span>
                        // We do this later because in this point in time the UI is probably not
                        // yet fully built (swing-tree is using the builder-pattern).
<span class="fc" id="L597">                    });</span>
<span class="fc" id="L598">                })</span>
<span class="fc" id="L599">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable.
     *  @param isFocusable The truth value determining if the UI component should be focusable or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( boolean isFocusable ) {
<span class="nc" id="L608">        return _with( c -&gt; c.setFocusable(isFocusable) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L621">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L622">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L623">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="fc" id="L624">                    c.setFocusable(v);</span>
<span class="fc" id="L625">                })</span>
<span class="fc" id="L626">                ._with( c -&gt; {</span>
<span class="fc" id="L627">                    c.setFocusable( isFocusable.orElseThrowUnchecked() );</span>
<span class="fc" id="L628">                })</span>
<span class="fc" id="L629">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable if a certain condition is not met.
     *  @param notFocusable The truth value determining if the UI component should be focusable or not.
     *                     If {@code false}, the component will be focusable.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIfNot( boolean notFocusable ) {
<span class="nc bnc" id="L639" title="All 2 branches missed.">        return _with( c -&gt; c.setFocusable( !notFocusable ) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not, wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code isFocusable} is {@code null}.
     */
    public final I isFocusableIfNot( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L653">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L654">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L655">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">                    c.setFocusable( !v );</span>
<span class="fc" id="L657">                })</span>
<span class="fc" id="L658">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                    c.setFocusable( !isFocusable.orElseThrowUnchecked() );</span>
<span class="fc" id="L660">                })</span>
<span class="fc" id="L661">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L676">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L677">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L678">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L679">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    c.setFocusable( v == enumValue );</span>
<span class="fc" id="L681">                })</span>
<span class="fc" id="L682">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                    c.setFocusable( enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L684">                })</span>
<span class="fc" id="L685">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isFocusableIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component non-focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component non-focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L701">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L702">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L703">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L704">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                    c.setFocusable( v != enumValue );</span>
<span class="fc" id="L706">                })</span>
<span class="fc" id="L707">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                    c.setFocusable( enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L709">                })</span>
<span class="fc" id="L710">                ._this();</span>
    }


    /**
     *  Use this to make the wrapped UI component opaque.
     *  This is the inverse of {@link #makeNonOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     *  @deprecated SwingTree considers the opaqueness a property which emerges from the
     *              style configuration of the component. Therefore, it is not recommended
     *              to set the opaqueness directly. Instead, use the {@link #withBackground(Color)}
     *              method to set the style of the component so that it becomes opaque.
     */
    @Deprecated
    public final I makeOpaque() {
<span class="nc" id="L726">        return _with( c -&gt; c.setOpaque( true ) )._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component transparent.
     *  This is the inverse of {@link #makeOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     *  @deprecated Use {@link #withBackground(Color)} instead, by passing
     *             it the {@link UI.Color#TRANSPARENT} constant.&lt;br&gt;
     *             Alternatively, you may use the {@link #peek(Peeker)}
     *             method to peek into the builder's component
     *             and set the flag directly.
     */
    @Deprecated
    public final I makeNonOpaque() {
<span class="fc" id="L742">        return _with( c -&gt; c.setOpaque( false ) )._this();</span>
    }

    /**
     *  This allows you to register validation logic for the wrapped UI component.
     *  Although the delegate exposed to the {@link UIVerifier} lambda
     *  indirectly exposes you to the UIs state, you should not access the UI directly
     *  from within the lambda, but modify the properties inside your view model instead.
     *
     * @param verifier The validation logic provided by your view model.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isValidIf( UIVerifier&lt;C&gt; verifier ) {
<span class="fc" id="L755">        return _with( c -&gt; {</span>
<span class="fc" id="L756">                    c.setInputVerifier(new InputVerifier() {</span>
                        @Override
                        public boolean verify( JComponent input ) {
<span class="nc" id="L759">                            return verifier.isValid(</span>
                                    new ComponentDelegate&lt;&gt;(
                                            c,
                                            new ComponentEvent(c, 0)
                                    )
                            );
                        /*
                            We expect the user to model the state of the UI components
                            using properties in the view model.
                         */
                        }
                    });
<span class="fc" id="L771">                })</span>
<span class="fc" id="L772">                ._this();</span>
    }

    /**
     * Adds {@link String} key/value &quot;client property&quot; pairs to the wrapped component.
     * &lt;p&gt;
     * The arguments will be passed to {@link JComponent#putClientProperty(Object, Object)}
     * which accesses
     * a small per-instance hashtable. Callers can use get/putClientProperty
     * to annotate components that were created by another module.
     * For example, a
     * layout manager might store per child constraints this way. &lt;br&gt;
     * This is in essence a more convenient way than the alternative usage pattern involving
     * the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     * &lt;pre&gt;{@code
     *     UI.button()
     *     .peek( button -&gt; button.putClientProperty(&quot;key&quot;, &quot;value&quot;) );
     * }&lt;/pre&gt;
     *
     * @param key the new client property key which may be used for styles or layout managers.
     * @param value the new client property value.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withProperty( String key, String value ) {
<span class="fc" id="L796">        return _with( c -&gt; c.putClientProperty(key, value) )._this();</span>
    }

    /**
     *  Use this to attach a border to the wrapped component.
     *
     * @param border The {@link Border} which should be set for the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Border border ) {
<span class="fc" id="L806">        Objects.requireNonNull(border, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L807">        return _with( c -&gt; c.setBorder(border) )._this();</span>
    }

    /**
     *  Use this to dynamically attach a border to the wrapped component. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param border The {@link Border} which should be set for the wrapped component wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     * @deprecated Because changing the {@link Border} of a component dynamically after
     *             the component was initialized through the declarative SwingTree API,
     *             causes issues with the style engine of a component.
     *             (Which itself is based on using a custom border for style rendering)
     */
    @Deprecated
    public final I withBorder( Val&lt;Border&gt; border ) {
<span class="fc" id="L823">        NullUtil.nullArgCheck(border, &quot;border&quot;, Val.class);</span>
<span class="fc" id="L824">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L825">        return _withOnShow( border, (c,v) -&gt; {</span>
<span class="nc" id="L826">                    c.setBorder(v);</span>
<span class="nc" id="L827">                })</span>
<span class="fc" id="L828">                ._with( c -&gt; {</span>
<span class="fc" id="L829">                    c.setBorder( border.orElseThrowUnchecked() );</span>
<span class="fc" id="L830">                })</span>
<span class="fc" id="L831">                ._this();</span>
    }


    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int top, int left, int bottom, int right ) {
<span class="fc" id="L845">        return _with( c -&gt; c.setBorder(BorderFactory.createEmptyBorder(top, left, bottom, right)) )._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int top, int left, int bottom, int right ) {
<span class="fc" id="L859">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L860">        return _with( c -&gt; c.setBorder(</span>
<span class="fc" id="L861">                        BorderFactory.createTitledBorder(</span>
<span class="fc" id="L862">                            BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                            title
                        )
                    )
                )
<span class="fc" id="L867">                ._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val},
     *              which will update the border title dynamically when changed.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int top, int left, int bottom, int right ) {
<span class="nc" id="L883">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L884">        NullUtil.nullPropertyCheck( title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot; );</span>
<span class="nc" id="L885">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L886">                    c.setBorder(</span>
<span class="nc" id="L887">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L888">                                BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                                v
                            )
                        );
<span class="nc" id="L892">                })</span>
<span class="nc" id="L893">                ._with( c -&gt; {</span>
<span class="nc" id="L894">                    c.setBorder(</span>
<span class="nc" id="L895">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L896">                                    BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
<span class="nc" id="L897">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L900">                })</span>
<span class="nc" id="L901">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int topBottom, int leftRight ) {
<span class="nc" id="L912">        return withEmptyBorder( topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int topBottom, int leftRight ) {
<span class="nc" id="L924">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L925">        return withEmptyBorderTitled( title, topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val}. When the value changes, the border title will be updated.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int topBottom, int leftRight ) {
<span class="nc" id="L938">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L939">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L940">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L941">                    c.setBorder(</span>
<span class="nc" id="L942">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L943">                                BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
                                v
                            )
                        );
<span class="nc" id="L947">                })</span>
<span class="nc" id="L948">                ._with( c -&gt; {</span>
<span class="nc" id="L949">                    c.setBorder(</span>
<span class="nc" id="L950">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L951">                                    BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
<span class="nc" id="L952">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L955">                })</span>
<span class="nc" id="L956">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L965">    public final I withEmptyBorder( int all ) { return withEmptyBorder(all, all, all, all); }</span>

    /**
     *  Creates an empty and un-titled {@link Border} with the provided insets
     *  property bound to all insets of said border.
     *  &lt;p&gt;
     *  An empty and un-titled {@link Border} is basically just a way to add some
     *  space around the component. It is not visible by default.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( Val&lt;Integer&gt; all ) {
<span class="nc" id="L978">        NullUtil.nullArgCheck( all, &quot;all&quot;, Val.class );</span>
<span class="nc" id="L979">        NullUtil.nullPropertyCheck(all, &quot;all&quot;, &quot;Null value for all is not allowed! Use an empty border instead!&quot;);</span>
<span class="nc" id="L980">        return _withOnShow( all, (c,v) -&gt; {</span>
<span class="nc" id="L981">                    c.setBorder(BorderFactory.createEmptyBorder(v, v, v, v));</span>
<span class="nc" id="L982">                })</span>
<span class="nc" id="L983">                ._with( c -&gt; {</span>
<span class="nc" id="L984">                    c.setBorder(BorderFactory.createEmptyBorder(all.orElseThrowUnchecked(), all.orElseThrowUnchecked(), all.orElseThrowUnchecked(), all.orElseThrowUnchecked()));</span>
<span class="nc" id="L985">                })</span>
<span class="nc" id="L986">                ._this();</span>
    }

            /**
             *  Use this to define a titled empty {@link Border} with the provided insets.
             *
             * @param title The title of the border.
             * @param all The insets for all sides.
             * @return This very instance, which enables builder-style method chaining.
             */
    public final I withEmptyBorderTitled( String title, int all ) {
<span class="fc" id="L997">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L998">        return withEmptyBorderTitled(title, all, all, all, all);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property and the provided insets.
     * @param title The title of the border in the form of a {@link Val} property.
     * @param all The insets size for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int all ) {
<span class="nc" id="L1008">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1009">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1010">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1011">                    c.setBorder(</span>
<span class="nc" id="L1012">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1013">                                BorderFactory.createEmptyBorder(all, all, all, all),</span>
                                v
                            )
                        );
<span class="nc" id="L1017">                })</span>
<span class="nc" id="L1018">                ._with( c -&gt; {</span>
<span class="nc" id="L1019">                    c.setBorder(</span>
<span class="nc" id="L1020">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1021">                                    BorderFactory.createEmptyBorder(all, all, all, all),</span>
<span class="nc" id="L1022">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L1025">                })</span>
<span class="nc" id="L1026">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with a title
     *  and a default insets size of 5.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title ) {
<span class="nc" id="L1037">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1038">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property
     *  and a default insets size of 5.
     *
     * @param title The title of the border in the form of a {@link Val} property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1049">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and insets.
     *
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color, int thickness ) {
<span class="fc" id="L1060">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="fc" id="L1061">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness)) )._this();</span>
    }

    /**
     *  Creates a line border bound to a {@link Color} property.
     *  When the color changes, the border will be updated with the new color.
     * @param color The color of the border in the form of a {@link Val} property.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1072">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1073">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1074">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1075">                    c.setBorder(BorderFactory.createLineBorder(v, thickness));</span>
<span class="nc" id="L1076">                })</span>
<span class="nc" id="L1077">                ._with( c -&gt; {</span>
<span class="nc" id="L1078">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness));</span>
<span class="nc" id="L1079">                })</span>
<span class="nc" id="L1080">                ._this();</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and insets.
     *
     * @param title The title of the border.
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L1092">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1093">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1094">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1095">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1096">                            BorderFactory.createLineBorder(color, thickness),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1101">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property.
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1112">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1113">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1114">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1115">                    c.setBorder(</span>
<span class="nc" id="L1116">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1117">                                BorderFactory.createLineBorder(color, thickness),</span>
                                v
                            )
                        );
<span class="nc" id="L1121">                })</span>
<span class="nc" id="L1122">                ._with( c -&gt; {</span>
<span class="nc" id="L1123">                    c.setBorder(</span>
<span class="nc" id="L1124">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1125">                                    BorderFactory.createLineBorder(color, thickness),</span>
<span class="nc" id="L1126">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L1129">                })</span>
<span class="nc" id="L1130">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property
     * and a {@link Color} property.
     * When any of the properties change, the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1144">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1145">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1146">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1147">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1148">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1149">                    c.setBorder(</span>
<span class="nc" id="L1150">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1151">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness),</span>
                            v
                        )
                    );
<span class="nc" id="L1155">                })</span>
<span class="nc" id="L1156">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1157">                    c.setBorder(</span>
<span class="nc" id="L1158">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1159">                            BorderFactory.createLineBorder(v, thickness),</span>
<span class="nc" id="L1160">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1163">                })</span>
<span class="nc" id="L1164">                ._with( c -&gt; {</span>
<span class="nc" id="L1165">                    c.setBorder(</span>
<span class="nc" id="L1166">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1167">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness),</span>
<span class="nc" id="L1168">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1171">                })</span>
<span class="nc" id="L1172">                ._this();</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color ) {
<span class="nc" id="L1182">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1183">        return withLineBorder(color, 1);</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1194">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1195">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1196">        return withLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color, int thickness ) {
<span class="nc" id="L1208">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1209">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness, true)) )._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L1222">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1223">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1224">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1225">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1226">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1231">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title property.
     *  When the title property changes, the border will be updated with the new value.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1246">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1247">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1248">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1249">                    c.setBorder(</span>
<span class="nc" id="L1250">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1251">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1255">                })</span>
<span class="nc" id="L1256">                ._with( c -&gt; {</span>
<span class="nc" id="L1257">                    c.setBorder(</span>
<span class="nc" id="L1258">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1259">                            BorderFactory.createLineBorder(color, thickness, true),</span>
<span class="nc" id="L1260">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1263">                })</span>
<span class="nc" id="L1264">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title and color properties.
     *  When the title or color properties change,
     *  then the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1280">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1281">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1282">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1283">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1284">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1285">                    c.setBorder(</span>
<span class="nc" id="L1286">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1287">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1291">                })</span>
<span class="nc" id="L1292">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1293">                    c.setBorder(</span>
<span class="nc" id="L1294">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1295">                            BorderFactory.createLineBorder(v, thickness, true),</span>
<span class="nc" id="L1296">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1299">                })</span>
<span class="nc" id="L1300">                ._with( c -&gt; {</span>
<span class="nc" id="L1301">                    c.setBorder(</span>
<span class="nc" id="L1302">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1303">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true),</span>
<span class="nc" id="L1304">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1307">                })</span>
<span class="nc" id="L1308">                ._this();</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color ) {
<span class="nc" id="L1319">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1320">        return withRoundedLineBorder(color, 1);</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color property and a custom thickness to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1332">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1333">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1334">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1335">                    c.setBorder(BorderFactory.createLineBorder(v, thickness, true));</span>
<span class="nc" id="L1336">                })</span>
<span class="nc" id="L1337">                ._with( c -&gt; {</span>
<span class="nc" id="L1338">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true));</span>
<span class="nc" id="L1339">                })</span>
<span class="nc" id="L1340">                ._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title, color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1352">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1353">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1354">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title and color to the {@link JComponent}, as well as a default thickness of {@code 1}.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @param color The color property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color ) {
<span class="nc" id="L1366">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1367">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1368">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1369">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1378">    public final I withRoundedLineBorder() { return withRoundedLineBorder(Color.BLACK, 1); }</span>

    /**
     *  Use this to attach a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title ) {
<span class="nc" id="L1388">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1389">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Creates a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent} and binds it to the provided
     *  title property.
     *  When the property changes, the border will be updated.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1402">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1403">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1404">        return withRoundedLineBorderTitled( title, java.awt.Color.BLACK, 1 );</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1419">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1420">        return _with( c -&gt; c.setBorder(BorderFactory.createMatteBorder(top, left, bottom, right, color)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1436">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1437">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1438">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1439">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1440">                            BorderFactory.createMatteBorder(top, left, bottom, right, color),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1445">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1458">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1459">        return withMatteBorder(color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1473">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1474">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1475">        return withMatteBorderTitled(title, color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int all ) {
<span class="nc" id="L1487">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1488">        return withMatteBorder(color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int all ) {
<span class="nc" id="L1501">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1502">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1503">        return withMatteBorderTitled(title, color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.CompoundBorder} with the provided
     *  borders to the {@link JComponent}.
     *
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorder( Border first, Border second ) {
<span class="nc" id="L1515">        NullUtil.nullArgCheck( first, &quot;first&quot;, Border.class );</span>
<span class="nc" id="L1516">        NullUtil.nullArgCheck( second, &quot;second&quot;, Border.class );</span>
<span class="nc" id="L1517">        return _with( c -&gt; c.setBorder(BorderFactory.createCompoundBorder(first, second)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.CompoundBorder} with the
     *  provided borders to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorderTitled( String title, Border first, Border second ) {
<span class="nc" id="L1530">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1531">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1532">                            BorderFactory.createCompoundBorder(first, second),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1537">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the provided title.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( String title ) {
<span class="fc" id="L1547">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1548">        return _with( c -&gt; c.setBorder(BorderFactory.createTitledBorder(title)) )._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the
     *  provided title property dynamically setting the title String.
     *
     * @param title The title property for the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( Val&lt;String&gt; title ) {
<span class="fc" id="L1559">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1560">        return _withOnShow( title, (c,t) -&gt; {</span>
<span class="fc" id="L1561">                    Border foundBorder = c.getBorder();</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">                    if ( foundBorder instanceof TitledBorder )</span>
<span class="fc" id="L1563">                        ((TitledBorder)foundBorder).setTitle(t);</span>
                    else
<span class="nc" id="L1565">                        c.setBorder(BorderFactory.createTitledBorder(t));</span>
<span class="fc" id="L1566">                })</span>
<span class="fc" id="L1567">                ._with( c -&gt; {</span>
<span class="fc" id="L1568">                    c.setBorder(BorderFactory.createTitledBorder(title.orElseThrowUnchecked()));</span>
<span class="fc" id="L1569">                })</span>
<span class="fc" id="L1570">                ._this();</span>
    }

    /**
     *  Use this set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder.
     *  &lt;br&gt;
     *  Here an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me!&quot;).withCursor(UI.Cursor.HAND);
     *  }&lt;/pre&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( UI.Cursor type ) {
<span class="fc" id="L1586">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="fc" id="L1587">        return _with( c -&gt; c.setCursor( new java.awt.Cursor( type.type ) ) )._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( Val&lt;UI.Cursor&gt; type ) {
<span class="fc" id="L1599">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="fc" id="L1600">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="fc" id="L1601">        return _withOnShow( type, (c,t) -&gt; {</span>
<span class="fc" id="L1602">                    c.setCursor( new java.awt.Cursor( t.type ) );</span>
<span class="fc" id="L1603">                })</span>
<span class="fc" id="L1604">                ._with( c -&gt; {</span>
<span class="fc" id="L1605">                    c.setCursor( new java.awt.Cursor( type.orElseThrowUnchecked().type ) );</span>
<span class="fc" id="L1606">                })</span>
<span class="fc" id="L1607">                ._this();</span>
    }

    /**
     *  Use this to set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, UI.Cursor type ) {
<span class="nc" id="L1621">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1622">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="nc" id="L1623">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1624">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( v ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1626">                })</span>
<span class="nc" id="L1627">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1629">                })</span>
<span class="nc" id="L1630">                ._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type property defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, Val&lt;UI.Cursor&gt; type ) {
<span class="nc" id="L1644">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1645">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="nc" id="L1646">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1647">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="nc" id="L1648">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L1649">                    Cursor[] baseCursor = new Cursor[1];</span>
<span class="nc" id="L1650">                    _onShow( condition, thisComponent, (c,v) -&gt; type.fireChange(From.VIEW_MODEL) );</span>
<span class="nc" id="L1651">                    _onShow( type, thisComponent, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                        if ( baseCursor[0] == null ) baseCursor[0] = c.getCursor();</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">                        c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? v.type : baseCursor[0].getType() ) );</span>
<span class="nc" id="L1654">                    });</span>
<span class="nc" id="L1655">                })</span>
<span class="nc" id="L1656">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? type.orElseThrowUnchecked().type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1658">                })</span>
<span class="nc" id="L1659">                ._this();</span>
    }

    /**
     *  Use this to set the {@link LayoutManager} of the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FavouriteLayoutManager()) );
     *  }&lt;/pre&gt;
     *
     * @param layout The {@link LayoutManager} which should be supplied to the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutManager layout ) {
<span class="fc" id="L1675">        return _with( c -&gt; c.setLayout(layout) )._this();</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1689">    public final I withFlowLayout() { return this.withLayout(new ResponsiveGridFlowLayout()); }</span>

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment ) {
<span class="nc" id="L1704">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="nc" id="L1705">        return this.withLayout(new ResponsiveGridFlowLayout(alignment));</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout(), hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @param hgap The horizontal gap between components.
     * @param vgap The vertical gap between components.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment, int hgap, int vgap ) {
<span class="fc" id="L1723">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="fc" id="L1724">        return this.withLayout(new ResponsiveGridFlowLayout(alignment, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1738">    public final I withGridLayout() { return this.withLayout(new GridLayout()); }</span>

    /**
     *  Use this to set a new {@link GridBagLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridBagLayout()) );
     *  }&lt;/pre&gt;
     *  ...or specifying the layout manager like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.panel().withLayout( new GridBagLayout() );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1755">    public final I withGridBagLayout() { return this.withLayout(new GridBagLayout()); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1770">    public final I withGridLayout( int rows, int cols ) { return this.withLayout(new GridLayout(rows, cols)); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols, hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @param hgap The horizontal gap between cells.
     * @param vgap The vertical gap between cells.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withGridLayout( int rows, int cols, int hgap, int vgap ) {
<span class="nc" id="L1788">        return this.withLayout(new GridLayout(rows, cols, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link BoxLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new BoxLayout(panel, axis.forBoxLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param axis The axis for the box layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If the provided axis is {@code null}.
     * @see UI.Axis
     * @see BoxLayout
     */
    public final I withBoxLayout( UI.Axis axis ) {
<span class="nc" id="L1807">        NullUtil.nullArgCheck( axis, &quot;axis&quot;, UI.Axis.class );</span>
<span class="nc" id="L1808">        return _with( c -&gt; c.setLayout(new BoxLayout(c, axis.forBoxLayout())) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-constraints in the form of a simple string
     *  which is parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;fill wrap 2&quot;);
     *    .add( UI.button(&quot;Name:&quot;) )
     *    .add( UI.textArea() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns
     *  and fill the entire available space of the parent container.
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param attr The constraints concerning the entire layout.
     *             Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr ) {
<span class="fc" id="L1857">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, String.class );</span>
<span class="fc" id="L1858">        return withLayout(attr, &quot;&quot;);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LC} instance,
     *  which is a builder for the layout constraints.
     *
     * @param attr A string defining the constraints concerning the entire layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr ) {
<span class="nc" id="L1872">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LC.class );</span>
<span class="nc" id="L1873">        return withLayout(attr, (AC) null, (AC) null);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LayoutConstraint} instance,
     *  which is an immutable string wrapper for the layout constraints.
     *  Instances of this are usually obtained from the {@link UI} namespace like
     *  {@link UI#FILL} or {@link UI#FILL_X}...
     *
     * @param attr Essentially an immutable string wrapper defining the mig layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     */
    public final I withLayout( LayoutConstraint attr ) {
<span class="fc" id="L1888">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LayoutConstraint.class );</span>
<span class="fc" id="L1889">        return withLayout(attr.toString(), &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder
     *  based on the provided layout constraints in the form of a string.
     *
     * @param attr A string defining constraints for the entire layout.
     * @param colConstrains The layout constraints for the columns int the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr, String colConstrains ) {
<span class="fc" id="L1903">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1904">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1905">        return withLayout(attr, colConstrains, &quot;&quot;);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a {@link AC} instance.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a {@link AC} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, AC colConstrains ) {
<span class="nc" id="L1920">        return withLayout(attr, colConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains ) {
<span class="nc bnc" id="L1935" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains == null ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc" id="L1936">        return withLayout(attr, parsedColConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column and row constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @param rowConstraints The row layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains, String rowConstraints ) {
<span class="nc" id="L1952">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1953">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc" id="L1954">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains.isEmpty() ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">        AC parsedRowConstrains = rowConstraints.isEmpty() ? null : ConstraintParser.parseRowConstraints(rowConstraints);</span>
<span class="nc" id="L1957">        return withLayout(attr, parsedColConstrains, parsedRowConstrains);</span>
    }

    /**
     *  Takes the supplied layout constraints and column constraints
     *  uses them to construct a new {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains ) {
<span class="fc" id="L1971">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1972">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1973">        return withLayout(attr.toString(), colConstrains, &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout in the form of a {@link LayoutConstraint} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains, String rowConstraints ) {
<span class="fc" id="L1985">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1986">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1987">        return withLayout(attr.toString(), colConstrains, rowConstraints);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-, column- and row-constraints in the form of simple strings,
     *  which are parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;wrap 2&quot;, &quot;[]6[]&quot;, &quot;[]8[]&quot;);
     *    .add( UI.label(&quot;Name:&quot;) )
     *    .add( UI.textField() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns,
     *  where the 2 columns are separated by a 6 pixel gap and the rows
     *  are separated by an 8 pixel gap. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param constraints The constraints concerning the entire layout.
     *                    Passing {@code null} will result in an exception, use an empty string instead.
     * @param colConstrains The column layout for the {@link MigLayout} instance,
     *                      which concern the columns in the layout grid.
     *                      Passing {@code null} will result in an exception, use an empty string instead.
     * @param rowConstraints The row layout for the {@link MigLayout} instance,
     *                       which concern the rows in the layout grid.
     *                       Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     *
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String constraints, String colConstrains, String rowConstraints ) {
<span class="fc" id="L2044">        NullUtil.nullArgCheck(constraints, &quot;constraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L2045">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L2046">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>

        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">        if ( constraints.isEmpty() )</span>
<span class="nc" id="L2050">            constraints = &quot;hidemode 2&quot;;</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        else if ( !constraints.contains(&quot;hidemode&quot;) )</span>
<span class="fc" id="L2052">            constraints += &quot;, hidemode 2&quot;;</span>

<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">        constraints    = ( constraints.isEmpty() ? null : constraints );</span>
<span class="fc bfc" id="L2055" title="All 2 branches covered.">        colConstrains  = ( colConstrains.isEmpty() ? null : colConstrains );</span>
<span class="fc bfc" id="L2056" title="All 2 branches covered.">        rowConstraints = ( rowConstraints.isEmpty() ? null : rowConstraints );</span>

<span class="fc" id="L2058">        MigLayout migLayout = new MigLayout(constraints, colConstrains, rowConstraints);</span>
<span class="fc" id="L2059">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( @Nullable LC attr, @Nullable AC colConstrains, @Nullable AC rowConstraints ) {
        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="nc bnc" id="L2072" title="All 2 branches missed.">        if ( attr == null )</span>
<span class="nc" id="L2073">            attr = new LC().hideMode(2);</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">        else if ( attr.getHideMode() == 0 )</span>
<span class="nc" id="L2075">            attr = attr.hideMode(2);</span>

<span class="nc" id="L2077">        MigLayout migLayout = new MigLayout(attr, colConstrains, rowConstraints);</span>
<span class="nc" id="L2078">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  Use this to set a helpful tool tip text for this UI component.
     *  The tool tip text will be displayed when the mouse hovers on the
     *  UI component for some time. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; button.setToolTipText(&quot;Can be clicked!&quot;) );
     *  }&lt;/pre&gt;
     *
     * @param tooltip The tool tip text which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withTooltip( String tooltip ) {
<span class="fc" id="L2096">        NullUtil.nullArgCheck(tooltip, &quot;tooltip&quot;, String.class, &quot;Use the empty string to clear the tooltip text!&quot;);</span>
<span class="pc bpc" id="L2097" title="1 of 2 branches missed.">        return _with( c -&gt; c.setToolTipText(tooltip.isEmpty() ? null : tooltip) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a tooltip string.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          tip.onSetItem(JButton::setToolTipText);
     *          button.setToolTipText(tip.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param tip The tooltip which should be displayed when hovering over the tab header.
     * @return A new {@link Tab} instance with the provided argument, which enables builder-style method chaining.
     */
    public final I withTooltip( Val&lt;String&gt; tip ) {
<span class="fc" id="L2118">        NullUtil.nullArgCheck(tip, &quot;tip&quot;, Val.class);</span>
<span class="fc" id="L2119">        NullUtil.nullPropertyCheck(tip, &quot;tip&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2120">        return _withOnShow( tip, (c,v) -&gt; {</span>
<span class="fc bfc" id="L2121" title="All 2 branches covered.">                    c.setToolTipText( v.isEmpty() ? null : v );</span>
<span class="fc" id="L2122">                })</span>
<span class="fc" id="L2123">                ._with( c -&gt; {</span>
<span class="fc" id="L2124">                    String tipString = tip.orElse(&quot;&quot;);</span>
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">                    c.setToolTipText( tipString.isEmpty() ? null : tipString );</span>
<span class="fc" id="L2126">                })</span>
<span class="fc" id="L2127">                ._this();</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  wrapped by this builder.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(Color.CYAN) );
     *  }&lt;/pre&gt;
     *
     * @param color The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Color color ) {
<span class="fc" id="L2144">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="fc" id="L2145">        return _with( c -&gt; _setBackground(c, color) )</span>
<span class="fc" id="L2146">                ._this();</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  of this declarative builder using a color String.
     *  The supplied {@link String} is parsed to a {@link UI.Color}
     *  through the {@link UI#color(String)} method.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(UI.color(&quot;cyan&quot;)) );
     *  }&lt;/pre&gt;
     *
     * @param color A color string which should be parsed to a {@link UI.Color} instance
     *              and then set as the background color of the UI component.
     * @return A new reference to this type of builder, to allow for fluent method chaining.
     */
    public final I withBackgroundColor( String color ) {
<span class="fc" id="L2166">        NullUtil.nullArgCheck(color, &quot;color&quot;, String.class);</span>
<span class="fc" id="L2167">        return this.withBackground(UI.color(color));</span>
    }

    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected void _setBackground( JComponent thisComponent, Color color ) {
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">        color = _isUndefinedColor(color) ? null : color;</span>
<span class="fc" id="L2173">        thisComponent.setBackground( color );</span>
<span class="fc" id="L2174">        color = thisComponent.getBackground();</span>
        // ^ If the provided color is null the component may inherit the color from its parent!
<span class="fc bfc" id="L2176" title="All 2 branches covered.">        if ( color == UI.Color.TRANSPARENT ) {</span>
<span class="fc" id="L2177">            thisComponent.setOpaque(false);</span>
        }
<span class="fc" id="L2179">    }</span>

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a background color.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          bg.onSetItem(JButton::setBackground);
     *          button.setBackground(bg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param bg The background color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Val&lt;Color&gt; bg ) {
<span class="fc" id="L2199">        NullUtil.nullArgCheck(bg, &quot;bg&quot;, Val.class);</span>
<span class="fc" id="L2200">        NullUtil.nullPropertyCheck(bg, &quot;bg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2201">        return _withOnShow( bg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(v) ? null : v );</span>
<span class="fc" id="L2203">                })</span>
<span class="fc" id="L2204">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(bg.get()) ? null : bg.get() );</span>
<span class="fc" id="L2206">                })</span>
<span class="fc" id="L2207">                ._this();</span>
    }

    /**
     *  Use this to bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue ) {
<span class="fc" id="L2220">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2221">        NullUtil.nullArgCheck(colorIfTrue, &quot;bg&quot;, Color.class);</span>
<span class="fc" id="L2222">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2223">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2224">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2225">                    Var&lt;Color&gt; color = Var.of( colorIfTrue );</span>
<span class="fc" id="L2226">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2227">                })</span>
<span class="fc" id="L2228">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2229" title="1 of 2 branches missed.">                    Color newColor =  condition.get() ? colorIfTrue : c.getBackground();</span>
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2231">                })</span>
<span class="fc" id="L2232">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The background color property which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2245">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2246">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2247">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2248">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided background color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2249">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2250">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2251">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2252">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2253">                })</span>
<span class="fc" id="L2254">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2255" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getBackground();</span>
<span class="pc bpc" id="L2256" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2257">                })</span>
<span class="fc" id="L2258">                ._this();</span>
    }

    /**
     *  Use this to bind to 2 colors to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2272">        return this.withBackgroundIf( condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
    }

    /**
     *  Use this to bind to 2 color properties to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2286">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2287">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2288">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2289">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2290">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2291">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2292">               })</span>
<span class="fc" id="L2293">               ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="nc" id="L2294">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2295">               })</span>
<span class="fc" id="L2296">               ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="nc" id="L2297">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2298">               })</span>
<span class="fc" id="L2299">               ._with( c -&gt; {</span>
<span class="pc bpc" id="L2300" title="1 of 2 branches missed.">                   Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">                   c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2302">               })</span>
<span class="fc" id="L2303">               ._this();</span>
    }

    /**
     *    Allows you to configure how the component wrapped by this builder
     *    looks and behaves, by passing a {@link Styler} lambda to this method
     *    which receiving a {@link swingtree.style.ComponentStyleDelegate} and returns
     *    an updated version with the desired style rules applied.
     *    &lt;p&gt;
     *    Here a typical example of how to style a button
     *    using the style API:
     *    &lt;pre&gt;{@code
     *        UI.button(&quot;Click Me!&quot;)
     *        .withStyle( it -&gt; it
     *            .borderColor(Color.CYAN)
     *            .borderWidthAt(Edge.BOTTOM, 3)
     *            .borderRadius(10)
     *        )
     *    }&lt;/pre&gt;
     *    &lt;p&gt;
     *    Here the {@code it} variable is the {@link swingtree.style.ComponentStyleDelegate} which
     *    exposes an extensive API for configuring how a particular component
     *    looks and behaves.
     *    &lt;p&gt;
     *    If you want to define style rules for an entire GUI or a part of it,
     *    take a look at the {@link swingtree.style.StyleSheet} class,
     *    which exposes an API for defining style rules similar to CSS
     *    but based on declarative source code instead of a text file.
     *
     * @param styler A {@link Styler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withStyle( Styler&lt;C&gt; styler ) {
<span class="fc" id="L2339">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, Styler.class);</span>
<span class="fc" id="L2340">        return _with( c -&gt; {</span>
<span class="fc" id="L2341">                    ComponentExtension.from(c).addStyler( styler );</span>
<span class="fc" id="L2342">                })</span>
<span class="fc" id="L2343">                ._this();</span>
    }

    /**
     *    Here an example demonstrating how a transitional style can be applied
     *    to make a border which can transition between 2 colors based on a boolean property:
     *    &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me!&quot;)
     *      .withTransitionalStyle(vm.isError(), LifeTime.of(1, TimeUnit.SECONDS), (state, it) -&gt; it
     *          .backgroundColor(Color.CYAN)
     *          .border(3, new Color((int)(state.progress() * 255), 0, 0))
     *      )
     *    }&lt;/pre&gt;
     *
     *
     * @param transitionToggle The boolean {@link Val} property which determines the state to which the style should transition.
     *                         When the value of this property is {@code true}, the style will transition to a {@link AnimationStatus#progress()}
     *                         of {@code 1.0} over the provided {@link LifeTime}.
     *                         And when the value of this property is {@code false}, the style will transition to a {@link AnimationStatus#progress()}
     *                         of {@code 0.0} over the provided {@link LifeTime}.
     *
     * @param transitionLifeTime The {@link LifeTime} of the transition animation.
     *                           It defines for ow long the {@link AnimationStatus#progress()} will transition from {@code 0} to {@code 1} or vice versa.
     *
     * @param styler An {@link AnimatedStyler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving an {@link AnimationStatus} and a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *               The {@link AnimatedStyler} may apply the style properties according to the {@link AnimationStatus}
     *               and its {@link AnimationStatus#progress()} method (or other methods) to create a smooth
     *               transition between the 2 states.
     *
     * @return This builder instance, which enables fluent method chaining.
     * @see #withTransitoryStyle(Observable, LifeTime, AnimatedStyler)
     */
    public final I withTransitionalStyle(
        Val&lt;Boolean&gt;      transitionToggle,
        LifeTime          transitionLifeTime,
        AnimatedStyler&lt;C&gt; styler
    ) {
<span class="fc" id="L2382">        NullUtil.nullArgCheck(transitionToggle, &quot;transitionToggle&quot;, Val.class);</span>
<span class="fc" id="L2383">        NullUtil.nullArgCheck(transitionLifeTime, &quot;transitionLifeTime&quot;, LifeTime.class);</span>
<span class="fc" id="L2384">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, AnimatedStyler.class);</span>
<span class="fc" id="L2385">        return _with( c -&gt; {</span>
<span class="fc" id="L2386">                    FlipFlopStyler&lt;C&gt; flipFlopStyler = new FlipFlopStyler&lt;&gt;(transitionToggle.get(), c, transitionLifeTime, styler);</span>
<span class="fc" id="L2387">                    ComponentExtension.from(c).addStyler(flipFlopStyler::style);</span>
<span class="fc" id="L2388">                    _onShow( transitionToggle, c, (comp, v) -&gt; flipFlopStyler.set(v) );</span>
<span class="fc" id="L2389">                })</span>
<span class="fc" id="L2390">                ._this();</span>
    }

    /**
     *    Allows you to configure a style which will be applied to the component temporarily
     *    when the provided {@link Observable} reports a state change. This {@link Observable}
     *    may be a {@link Event#observable()}, {@link Var#view()} or {@link Vars#view()} among
     *    other things which can be observed reactively.&lt;br&gt;
     *    &lt;p&gt;
     *    The desired style, defined by the supplied {@link AnimatedStyler}, will be applied
     *    according to the specified {@link LifeTime} and then removed afterward.
     *    Here an example demonstrating how an event based style animation temporarily
     *    defines a custom background and border color on a label:
     *    &lt;pre&gt;{@code
     *      UI.label(&quot;I have a highlight animation!&quot;)
     *      .withTransitoryStyle(vm.highlightEvent().observable(), LifeTime.of(0.5, TimeUnit.SECONDS), (state, it) -&gt; it
     *          .backgroundColor(new Color(0, 0, 0, (int)(state.progress() * 255)))
     *          .borderColor(new Color(255, 255, 255, (int)(state.progress() * 255)))
     *      )
     *    }&lt;/pre&gt;
     *
     * @param styleTrigger The {@link Observable} which should trigger the style animation.
     * @param styleLifeTime The {@link LifeTime} of the style animation.
     * @param styler An {@link AnimatedStyler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving an {@link AnimationStatus} and a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *               The {@link AnimatedStyler} may apply the style properties according to the {@link AnimationStatus}
     *               and its {@link AnimationStatus#progress()} method (or other methods) to create a smooth
     *               transition between the 2 states.
     *
     * @return This builder instance, which enables fluent method chaining.
     * @see #withTransitionalStyle(Val, LifeTime, AnimatedStyler)
     */
    public final I withTransitoryStyle(
        Observable        styleTrigger,
        LifeTime          styleLifeTime,
        AnimatedStyler&lt;C&gt; styler
    ){
<span class="fc" id="L2428">        NullUtil.nullArgCheck(styleTrigger, &quot;styleTrigger&quot;, Observable.class);</span>
<span class="fc" id="L2429">        NullUtil.nullArgCheck(styleLifeTime, &quot;styleLifeTime&quot;, LifeTime.class);</span>
<span class="fc" id="L2430">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, AnimatedStyler.class);</span>
<span class="fc" id="L2431">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2432">                    WeakReference&lt;C&gt; thisComponentRef = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L2433">                    ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="fc" id="L2434">                            styleTrigger.subscribe(()-&gt;{</span>
<span class="fc" id="L2435">                                C innerComponent = thisComponentRef.get();</span>
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">                                if (innerComponent == null)</span>
<span class="nc" id="L2437">                                    return;</span>
<span class="fc" id="L2438">                                AnimationDispatcher.animateFor(styleLifeTime, thisComponent).go(status -&gt;</span>
<span class="fc" id="L2439">                                        ComponentExtension.from(thisComponent)</span>
<span class="fc" id="L2440">                                                .addAnimatedStyler(status, conf -&gt; styler.style(status, conf))</span>
                                );
<span class="fc" id="L2442">                            })</span>
                    );
<span class="fc" id="L2444">                })</span>
<span class="fc" id="L2445">                ._this();</span>
    }

    /**
     *  Set the color of this {@link JComponent}. (This is usually the font color for components displaying text) &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(Color.GRAY) );
     *  }&lt;/pre&gt;
     *
     * @param color The color of the foreground (usually text).
     * @return This very builder to allow for method chaining.
     */
    public final I withForeground( Color color ) {
<span class="fc" id="L2461">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="pc bpc" id="L2462" title="1 of 2 branches missed.">        return _with( c -&gt; c.setForeground( _isUndefinedColor(color) ? null : color ) )._this();</span>
    }

    /**
     *  Allows you to define the {@link JComponent#getForeground()} color of
     *  the underlying {@link JComponent} using a color string.
     *  The supplied {@link String} is parsed to a {@link UI.Color}
     *  through the {@link UI#color(String)} method for you. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(UI.color(&quot;oak&quot;)) );
     *  }&lt;/pre&gt;
     *
     * @param color A color string which should be parsed to a {@link UI.Color} instance
     *              and then set as the foreground color of the UI component.
     * @return A new reference to this type of builder, to allow for fluent method chaining.
     */
    public final I withForegroundColor( String color ) {
<span class="fc" id="L2482">        NullUtil.nullArgCheck(color, &quot;color&quot;, String.class);</span>
<span class="fc" id="L2483">        return this.withForeground(UI.color(color));</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a foreground color.
     *  This is a convenience method, which works
     *  similar to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          fg.onChange(From.VIEW_MODEL,  v -&gt; button.setForeground(v.get()) );
     *          button.setForeground(fg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForeground( Val&lt;Color&gt; fg ) {
<span class="fc" id="L2504">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Val.class);</span>
<span class="fc" id="L2505">        NullUtil.nullPropertyCheck(fg, &quot;fg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2506">        return _withOnShow( fg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2507" title="1 of 2 branches missed.">                    c.setForeground( _isUndefinedColor(v) ? null : v );</span>
<span class="fc" id="L2508">                })</span>
<span class="fc" id="L2509">                ._with( c -&gt; {</span>
<span class="fc" id="L2510">                    Color newColor = fg.get();</span>
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2512">                        newColor = null;</span>
<span class="fc" id="L2513">                    c.setForeground( newColor );</span>
<span class="fc" id="L2514">                })</span>
<span class="fc" id="L2515">                ._this();</span>
    }

    /**
     *  Use this to bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color fg ) {
<span class="fc" id="L2528">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2529">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Color.class);</span>
<span class="fc" id="L2530">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2531">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2532">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2533">                    Var&lt;Color&gt; newColor = Var.of( fg );</span>
<span class="fc" id="L2534">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, newColor, baseColor ) );</span>
<span class="fc" id="L2535">                })</span>
<span class="fc" id="L2536">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? fg : c.getForeground();</span>
<span class="pc bpc" id="L2538" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2539">                        newColor = null;</span>
<span class="fc" id="L2540">                    c.setForeground( newColor );</span>
<span class="fc" id="L2541">                })</span>
<span class="fc" id="L2542">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The foreground color property which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2555">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2556">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2557">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2558">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2559">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2560">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2561">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2562">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2563">                })</span>
<span class="fc" id="L2564">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getForeground();</span>
<span class="pc bpc" id="L2566" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2567">                        newColor = null;</span>
<span class="fc" id="L2568">                    c.setForeground( newColor );</span>
<span class="fc" id="L2569">                })</span>
<span class="fc" id="L2570">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color which should be set for the UI component.
     * @param colorIfFalse The foreground color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2584">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2585">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Color.class);</span>
<span class="fc" id="L2586">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Color.class);</span>
<span class="fc" id="L2587">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2588">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2589">                    _updateForeground( c, condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
<span class="fc" id="L2590">                })</span>
<span class="fc" id="L2591">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue : colorIfFalse;</span>
<span class="pc bpc" id="L2593" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor) )</span>
<span class="nc" id="L2594">                        newColor = null;</span>
<span class="fc" id="L2595">                    c.setForeground( newColor );</span>
<span class="fc" id="L2596">                })</span>
<span class="fc" id="L2597">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color property which should be set for the UI component.
     * @param colorIfFalse The foreground color property which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2611">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2612">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2613">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2614">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2615">        NullUtil.nullPropertyCheck(colorIfTrue, &quot;colorIfTrue&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2616">        NullUtil.nullPropertyCheck(colorIfFalse, &quot;colorIfFalse&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2617">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2618">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2619">                })</span>
<span class="fc" id="L2620">                ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="fc" id="L2621">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2622">                })</span>
<span class="fc" id="L2623">                ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="fc" id="L2624">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2625">                })</span>
<span class="fc" id="L2626">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2627" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2628" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2629">                        newColor = null;</span>
<span class="fc" id="L2630">                    c.setForeground( newColor );</span>
<span class="fc" id="L2631">                })</span>
<span class="fc" id="L2632">                ._this();</span>
    }

    private void _updateForeground(
        C component,
        Val&lt;Boolean&gt; condition,
        Val&lt;Color&gt;   color,
        Val&lt;Color&gt;   baseColor
    ) {
<span class="fc bfc" id="L2641" title="All 2 branches covered.">        Color newColor = condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2642" title="1 of 2 branches missed.">        if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2643">            newColor = null;</span>

<span class="fc" id="L2645">        component.setForeground(newColor);</span>
<span class="fc" id="L2646">    }</span>

    private void _updateBackground(
            C component,
            Val&lt;Boolean&gt; condition,
            Val&lt;Color&gt; color,
            Val&lt;Color&gt; baseColor
    ) {
<span class="fc bfc" id="L2654" title="All 2 branches covered.">        Color newColor =  condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">        if ( _isUndefinedColor(newColor) )</span>
<span class="nc" id="L2656">            newColor = null;</span>

<span class="fc" id="L2658">        component.setBackground(newColor);</span>
<span class="fc" id="L2659">    }</span>

    /**
     *  Set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Use {@link #withMinSize(Size)} instead.
     */
    @Deprecated
    public final I withMinSize( Dimension size ) {
<span class="fc" id="L2671">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2672">        return _with( c -&gt; c.setMinimumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the minimum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Size size ) {
<span class="fc" id="L2682">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2683">        return _with( c -&gt; c.setMinimumSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} (Dimension)} on the underlying component. &lt;br&gt;
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click Me&quot;)
     *    .peek( button -&gt; {
     *      size.onSetItem(JButton::setMinimumSize);
     *      button.setMinimumSize(size.get());
     *    });
     *  }&lt;/pre&gt;
     *
     * @param size The minimum {@link Size} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L2703">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2704">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the minimum size of this component!&quot;);</span>
<span class="fc" id="L2705">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2706">                    c.setMinimumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L2707">                    _revalidate(c);</span>
<span class="fc" id="L2708">                })</span>
<span class="fc" id="L2709">                ._with( c -&gt; {</span>
<span class="fc" id="L2710">                    c.setMinimumSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L2711">                })</span>
<span class="fc" id="L2712">                ._this();</span>
    }

    /**
     *  Set the minimum width and heigh ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( int width, int height ) {
<span class="fc" id="L2723">        return _with( c -&gt; c.setMinimumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2735">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2736">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2737">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2738">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2739">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2740">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2741">                    _revalidate(c);</span>
<span class="fc" id="L2742">                })</span>
<span class="fc" id="L2743">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2744">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2745">                    _revalidate(c);</span>
<span class="fc" id="L2746">                })</span>
<span class="fc" id="L2747">                ._with( c -&gt; {</span>
<span class="fc" id="L2748">                    c.setMinimumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2749">                })</span>
<span class="fc" id="L2750">                ._this();</span>
    }

    /**
     *  Use this to only set the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( int width ) {
<span class="fc" id="L2760">        return _with( c -&gt; {</span>
<span class="fc" id="L2761">                    _setMinWidth(c, width);</span>
<span class="fc" id="L2762">               })</span>
<span class="fc" id="L2763">               ._this();</span>
    }

    protected final void _setMinWidth( C component, int width ) {
<span class="fc" id="L2767">        int currentHeight = component.getMinimumSize().height;</span>
<span class="pc bpc" id="L2768" title="1 of 4 branches missed.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2769">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2770">        component.setMinimumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2771">    }</span>

    /**
     *  Use this to dynamically set only the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2780">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2781">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2782">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2783">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2784">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2785">                })</span>
<span class="fc" id="L2786">                ._with( c -&gt; {</span>
<span class="fc" id="L2787">                    _setMinWidth(c, width.get());</span>
<span class="fc" id="L2788">                })</span>
<span class="fc" id="L2789">                ._this();</span>
    }


    /**
     *  Use this to only set the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( int height ) {
<span class="fc" id="L2800">        return _with( c -&gt; {</span>
<span class="fc" id="L2801">                    _setMinHeight(c, height);</span>
<span class="fc" id="L2802">                })</span>
<span class="fc" id="L2803">                ._this();</span>
    }

    protected final void _setMinHeight( C component, int height ) {
<span class="fc" id="L2807">        int currentWidth = component.getMinimumSize().width;</span>
<span class="fc bfc" id="L2808" title="All 4 branches covered.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2809">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2810">        component.setMinimumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2811">    }</span>

    /**
     *  Use this to dynamically set only the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2820">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2821">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2822">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2823">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2824">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2825">                })</span>
<span class="fc" id="L2826">                ._with( c -&gt; {</span>
<span class="fc" id="L2827">                    _setMinHeight(c, height.get());</span>
<span class="fc" id="L2828">                })</span>
<span class="fc" id="L2829">                ._this();</span>
    }

    /**
     *  Set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Use {@link #withMaxSize(Size)} instead.
     */
    @Deprecated
    public final I withMaxSize( Dimension size ) {
<span class="fc" id="L2842">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2843">        return _with( c -&gt; c.setMaximumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Size size ) {
<span class="fc" id="L2853">        NullUtil.nullArgCheck(size, &quot;size&quot;, Size.class);</span>
<span class="fc" id="L2854">        return _with( c -&gt; c.setMaximumSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Size} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L2865">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2866">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the maximum size of this component!&quot;);</span>
<span class="fc" id="L2867">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2868">                    c.setMaximumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L2869">                    _revalidate(c); // For some reason this is needed to make the change visible.</span>
<span class="fc" id="L2870">                })</span>
<span class="fc" id="L2871">                ._with( c -&gt; {</span>
<span class="fc" id="L2872">                    c.setMaximumSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L2873">                })</span>
<span class="fc" id="L2874">                ._this();</span>
    }

    /**
     *  Set the maximum width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( int width, int height ) {
<span class="fc" id="L2885">        return _with( c -&gt; c.setMaximumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the maximum size of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2896">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2897">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2898">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2899">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2900">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2901">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2902">                    _revalidate(c); // Raw Swing is not smart enough to do this automatically :(</span>
<span class="fc" id="L2903">                })</span>
<span class="fc" id="L2904">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2905">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2906">                    _revalidate(c); // Still not smart enough to do this automatically :(</span>
<span class="fc" id="L2907">                })</span>
<span class="fc" id="L2908">                ._with( c -&gt; {</span>
<span class="fc" id="L2909">                    c.setMaximumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2910">                })</span>
<span class="fc" id="L2911">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( int width ) {
<span class="fc" id="L2921">        return _with( c -&gt; {</span>
<span class="fc" id="L2922">                    _setMaxWidth(c, width);</span>
<span class="fc" id="L2923">                })</span>
<span class="fc" id="L2924">                ._this();</span>
    }

    private void _setMaxWidth( C component, int width ) {
<span class="fc" id="L2928">        int currentHeight = component.getMaximumSize().height;</span>
<span class="pc bpc" id="L2929" title="1 of 4 branches missed.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2930">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2931">        component.setMaximumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2932">    }</span>

    /**
     *  Use this to dynamically set only the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2941">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2942">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2943">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2944">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2945">                    _revalidate(c); // When the size changes, the layout manager needs to be informed.</span>
<span class="fc" id="L2946">                })</span>
<span class="fc" id="L2947">                ._with( c -&gt; {</span>
<span class="fc" id="L2948">                    _setMaxWidth(c, width.get());</span>
<span class="fc" id="L2949">                })</span>
<span class="fc" id="L2950">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( int height ) {
<span class="fc" id="L2960">        return _with( c -&gt; {</span>
<span class="fc" id="L2961">                    _setMaxHeight(c, height);</span>
<span class="fc" id="L2962">                })</span>
<span class="fc" id="L2963">                ._this();</span>
    }

    private void _setMaxHeight( C component, int height ) {
<span class="fc" id="L2967">        int currentWidth = component.getMaximumSize().width;</span>
<span class="fc bfc" id="L2968" title="All 4 branches covered.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2969">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2970">        component.setMaximumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2971">    }</span>

    /**
     *  Use this to dynamically set only the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2980">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2981">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2982">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2983">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2984">                    _revalidate(c); // The revalidate is necessary to make the change visible, this makes sure the layout is recalculated.</span>
<span class="fc" id="L2985">                })</span>
<span class="fc" id="L2986">                ._with( c -&gt; {</span>
<span class="fc" id="L2987">                    _setMaxHeight(c, height.get());</span>
<span class="fc" id="L2988">                })</span>
<span class="fc" id="L2989">                ._this();</span>
    }

    /**
     *  Set the preferred {@link Dimension} of this {@link JComponent}, which consists
     *  of a width and a height used as a suggestion to the {@link LayoutManager} of the
     *  parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The preferred {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Please use {@link #withPrefSize(Size)} instead.
     */
    @Deprecated
    public final I withPrefSize( Dimension size ) {
<span class="fc" id="L3005">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L3006">        return _with( c -&gt; c.setPreferredSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the preferred {@link Size} of this {@link JComponent}, which consists
     *  of a width and a height used as a suggestion to the {@link LayoutManager} of the
     *  parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Size size ) {
<span class="fc" id="L3018">        NullUtil.nullArgCheck(size, &quot;size&quot;, Size.class);</span>
<span class="fc" id="L3019">        return _with( c -&gt; c.setPreferredSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the preferred {@link Size} of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size A property holding the preferred {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L3032">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3033">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the preferred size of this component!&quot;);</span>
<span class="fc" id="L3034">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3035">                    c.setPreferredSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3036">                    _revalidate(c);</span>
<span class="fc" id="L3037">                })</span>
<span class="fc" id="L3038">                ._with( c -&gt; {</span>
<span class="fc" id="L3039">                    c.setPreferredSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L3040">                })</span>
<span class="fc" id="L3041">                ._this();</span>
    }

    /**
     *  Set the preferred width and height ({@link Dimension}) of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( int width, int height ) {
<span class="fc" id="L3054">        return _with( c -&gt; c.setPreferredSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the preferred {@link Dimension} of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L3067">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3068">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3069">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L3070">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L3071">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3072">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L3073">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L3074">                })</span>
<span class="fc" id="L3075">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3076">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L3077">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L3078">                })</span>
<span class="fc" id="L3079">                ._with( c -&gt; {</span>
<span class="fc" id="L3080">                    c.setPreferredSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L3081">                })</span>
<span class="fc" id="L3082">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred width of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( int width ) {
<span class="fc" id="L3093">        return _with( c -&gt; {</span>
<span class="fc" id="L3094">                    _setPrefWidth(c, width);</span>
<span class="fc" id="L3095">                })</span>
<span class="fc" id="L3096">                ._this();</span>
    }

    protected final void _setPrefWidth( C component, int width ) {
<span class="fc" id="L3100">        int currentHeight = component.getPreferredSize().height;</span>
<span class="fc bfc" id="L3101" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L3102">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L3103">        component.setPreferredSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L3104">    }</span>

    /**
     *  Use this to dynamically set only the preferred width of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3114">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3115">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L3116">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3117">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L3118">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L3119">                })</span>
<span class="fc" id="L3120">                ._with( c -&gt; {</span>
<span class="fc" id="L3121">                    _setPrefWidth(c, width.get());</span>
<span class="fc" id="L3122">                })</span>
<span class="fc" id="L3123">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred height of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( int height ) {
<span class="fc" id="L3134">        return _with( c -&gt; {</span>
<span class="fc" id="L3135">                    _setPrefHeight(c, height);</span>
<span class="fc" id="L3136">                })</span>
<span class="fc" id="L3137">                ._this();</span>
    }

    private void _setPrefHeight( C component, int height ) {
<span class="fc" id="L3141">        int currentWidth = component.getPreferredSize().width;</span>
<span class="fc bfc" id="L3142" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L3143">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L3144">        component.setPreferredSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L3145">    }</span>

    /**
     *  Use this to dynamically set only the preferred height of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3155">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3156">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L3157">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3158">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L3159">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L3160">                })</span>
<span class="fc" id="L3161">                ._with( c -&gt; {</span>
<span class="fc" id="L3162">                    _setPrefHeight(c, height.get());</span>
<span class="fc" id="L3163">                })</span>
<span class="fc" id="L3164">                ._this();</span>
    }

    /**
     *  Set the current {@link Dimension})/size (width and height) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Please use {@link #withSize(Size)} instead.
     */
    @Deprecated
    public final I withSize( Dimension size ) {
<span class="fc" id="L3177">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L3178">        return _with( c -&gt; c.setSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Sets the current {@link Size}) (width and height) of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(Size)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The current {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Size size ) {
<span class="fc" id="L3193">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L3194">        return _with( c -&gt; c.setSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current {@link Dimension} of this {@link JComponent}
     *  using a {@link Size} object. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(Val)} method instead. &lt;br&gt;
     *  The {@link Size} is automatically translated to a call to
     *  {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The current {@link Size} of the component wrapped by a {@link Val} property.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L3211">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3212">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L3213">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3214">                    c.setSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3215">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3216">                })</span>
<span class="fc" id="L3217">                ._with( c -&gt; {</span>
<span class="fc" id="L3218">                    c.setSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L3219">                })</span>
<span class="fc" id="L3220">                ._this();</span>
    }

    /**
     *  Allows you to directly set the width and height of the current component
     *  directly instead of through the layout manager. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(int, int)} method instead. &lt;br&gt;
     *  Also note that this method translates to invoking
     *  {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param width The width of the component.
     * @param height The height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( int width, int height ) {
<span class="fc" id="L3238">        return this.withSize( new Dimension(width, height) );</span>
    }

    /**
     *  Set the current width of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the set width of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefWidth(int)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( int width ) {
<span class="fc" id="L3252">        return _with( c -&gt; {</span>
<span class="fc" id="L3253">                    c.setSize(new Dimension(UI.scale(width), c.getSize().height));</span>
<span class="fc" id="L3254">                })</span>
<span class="fc" id="L3255">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current width of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the width of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefWidth(Val)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3269">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3270">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3271">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3272">                    c.setSize(new Dimension(UI.scale(w), c.getSize().height));</span>
<span class="fc" id="L3273">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3274">                })</span>
<span class="fc" id="L3275">                ._with( c -&gt; {</span>
<span class="fc" id="L3276">                    c.setSize(new Dimension(UI.scale(width.get()), c.getSize().height));</span>
<span class="fc" id="L3277">                })</span>
<span class="fc" id="L3278">                ._this();</span>
    }

    /**
     *  Set the current height of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the height of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefHeight(int)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( int height ) {
<span class="fc" id="L3292">        return _with( c -&gt; {</span>
<span class="fc" id="L3293">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height)));</span>
<span class="fc" id="L3294">                })</span>
<span class="fc" id="L3295">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current height of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the height of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefHeight(Val)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3309">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3310">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3311">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3312">                    c.setSize(new Dimension(c.getSize().width, UI.scale(h)));</span>
<span class="fc" id="L3313">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3314">                })</span>
<span class="fc" id="L3315">                ._with( c -&gt; {</span>
<span class="fc" id="L3316">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height.get())));</span>
<span class="fc" id="L3317">                })</span>
<span class="fc" id="L3318">                ._this();</span>
    }

    private static void _revalidate( Component comp ) {
<span class="fc" id="L3322">        comp.revalidate();</span>
<span class="pc bpc" id="L3323" title="1 of 2 branches missed.">        if ( comp instanceof JScrollPane )</span>
<span class="nc" id="L3324">            Optional.ofNullable(comp.getParent())</span>
<span class="nc" id="L3325">                    .ifPresent(Component::revalidate); // For some reason, JScrollPane does not revalidate its parent when its preferred size changes.</span>
<span class="fc" id="L3326">    }</span>

    /**
     *   Allows you to define a common width and height for the minimum, maximum, and preferred size of this component.
     *   This is a convenience method, which is equivalent to:
     *   &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *   }&lt;/pre&gt;
     *   This method call translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *   {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *   on the underlying component.
     *
     * @param width The min-, max- and preferred with of the component.
     * @param height The min-, max- and preferred height of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( int width, int height ) {
<span class="fc" id="L3345">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3346">        self = UIForAnySwing.class.cast(self.withMinSize(width, height));</span>
<span class="fc" id="L3347">        self = UIForAnySwing.class.cast(self.withMaxSize(width, height));</span>
<span class="fc" id="L3348">        self = UIForAnySwing.class.cast(self.withPrefSize(width, height));</span>
<span class="fc" id="L3349">        return self._this();</span>
    }

    /**
     *  Allows you to define a common width and height for the minimum, maximum, and preferred size of this component
     *  in the form of the supplied {@link Size} object.
     *  This is in essence a convenience method equivalent to:
     *  &lt;pre&gt;{@code
     *      .withMinSize(size)
     *      .withMaxSize(size)
     *      .withPrefSize(size)
     *  }&lt;/pre&gt;
     *  Underneath, this method call translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param size The min-, max- and preferred {@link Size} of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( Size size ) {
<span class="fc" id="L3369">        Objects.requireNonNull(size, &quot;size&quot;);</span>
<span class="pc bpc" id="L3370" title="1 of 2 branches missed.">        if ( size.equals(Size.unknown()) )</span>
<span class="nc" id="L3371">            return _this();</span>

<span class="pc bpc" id="L3373" title="1 of 2 branches missed.">        if ( !size.hasPositiveHeight() ) // Width only!</span>
<span class="nc" id="L3374">            return withWidthExactly(size.width().map(Number::intValue).orElse(0));</span>
<span class="pc bpc" id="L3375" title="1 of 2 branches missed.">         else if ( !size.hasPositiveWidth() ) // Height only!</span>
<span class="nc" id="L3376">            return withHeightExactly(size.height().map(Number::intValue).orElse(0));</span>
        else
<span class="fc" id="L3378">            return withSizeExactly(</span>
<span class="fc" id="L3379">                    size.width().map(Number::intValue).orElse(0),</span>
<span class="fc" id="L3380">                    size.height().map(Number::intValue).orElse(0)</span>
                );
    }

    /**
     *  Bind to a {@link Size} object to dynamically update the common
     *  width and height for the minimum, maximum, and preferred size of this component.
     *  This is in essence a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *  }&lt;/pre&gt;
     *  This method translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param size A property wrapping the min-, max- and preferred {@link Size} of the component.
     *             When the property item changes, the size of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( Val&lt;Size&gt; size ) {
<span class="fc" id="L3402">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3403">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L3404">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3405">                    c.setMinimumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3406">                    c.setMaximumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3407">                    c.setPreferredSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3408">                    _revalidate(c);</span>
<span class="fc" id="L3409">                })</span>
<span class="fc" id="L3410">                ._with( c -&gt; {</span>
<span class="fc" id="L3411">                    c.setMinimumSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3412">                    c.setMaximumSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3413">                    c.setPreferredSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3414">                })</span>
<span class="fc" id="L3415">                ._this();</span>
    }

    /**
     *  Allows you to bind to two {@link Val} properties to dynamically update the common width and height
     *  for the minimum, maximum, and preferred size of this component.
     *  This is in essence a convenience method, which is equivalent to:
     *  &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *  }&lt;/pre&gt;
     *  This method will translate the property updates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component in the form of an integer property.
     *              When the property item changes, the width of the component will be updated accordingly.
     * @param height The min-, max- and preferred height of the component in the form of an integer property.
     *               When the property item changes, the height of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     * @throws NullPointerException If any of the provided properties is {@code null}.
     */
    public final I withSizeExactly( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L3439">        Objects.requireNonNull(width, &quot;width&quot;);</span>
<span class="fc" id="L3440">        Objects.requireNonNull(height, &quot;height&quot;);</span>
<span class="fc" id="L3441">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3442">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3443">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3444">        self = UIForAnySwing.class.cast(self.withMinSize(width, height));</span>
<span class="fc" id="L3445">        self = UIForAnySwing.class.cast(self.withMaxSize(width, height));</span>
<span class="fc" id="L3446">        self = UIForAnySwing.class.cast(self.withPrefSize(width, height));</span>
<span class="fc" id="L3447">        return self._this();</span>
    }

    /**
     *  Use this to set the min-, max- and preferred width of this {@link JComponent} to the same value. &lt;br&gt;
     *  This is a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinWidth(width)
     *      .withMaxWidth(width)
     *      .withPrefWidth(width)
     *  }&lt;/pre&gt;
     *  An invocation to this method translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withWidthExactly( int width ) {
<span class="nc" id="L3466">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="nc" id="L3467">        self = UIForAnySwing.class.cast(self.withMinWidth(width));</span>
<span class="nc" id="L3468">        self = UIForAnySwing.class.cast(self.withMaxWidth(width));</span>
<span class="nc" id="L3469">        self = UIForAnySwing.class.cast(self.withPrefWidth(width));</span>
<span class="nc" id="L3470">        return self._this();</span>
    }

    /**
     *  Use this to bind to a {@link Val} property to dynamically update the min-, max- and preferred width
     *  of this {@link JComponent} to the same value. &lt;br&gt;
     *  So whenever the item of the property changes, all these widths will
     *  be updated automatically for you.
     *  This is a convenience method, which is equivalent to calling {@link #withMinWidth(Val)},
     *  {@link #withMaxWidth(Val)} and {@link #withPrefWidth(Val)} on the underlying component.
     *  &lt;pre&gt;{@code
     *      .withMinWidth(width)
     *      .withMaxWidth(width)
     *      .withPrefWidth(width)
     *  }&lt;/pre&gt;
     *  Eventually, all of this ultimately translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component wrapped by a {@link Val}.
     *              When the property item changes, the width of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withWidthExactly( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3494">        Objects.requireNonNull(width, &quot;width&quot;);</span>
<span class="fc" id="L3495">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3496">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3497">        self = UIForAnySwing.class.cast(self.withMinWidth(width));</span>
<span class="fc" id="L3498">        self = UIForAnySwing.class.cast(self.withMaxWidth(width));</span>
<span class="fc" id="L3499">        self = UIForAnySwing.class.cast(self.withPrefWidth(width));</span>
<span class="fc" id="L3500">        return self._this();</span>
    }

    /**
     *  Use this to set the min-, max- and preferred height of this {@link JComponent} to the same value. &lt;br&gt;
     *  This is a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinHeight(height)
     *      .withMaxHeight(height)
     *      .withPrefHeight(height)
     *  }&lt;/pre&gt;
     *  An invocation to this method translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param height The min-, max- and preferred height of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withHeightExactly( int height ) {
<span class="nc" id="L3519">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="nc" id="L3520">        self = UIForAnySwing.class.cast(self.withMinHeight(height));</span>
<span class="nc" id="L3521">        self = UIForAnySwing.class.cast(self.withMaxHeight(height));</span>
<span class="nc" id="L3522">        self = UIForAnySwing.class.cast(self.withPrefHeight(height));</span>
<span class="nc" id="L3523">        return self._this();</span>
    }

    /**
     *  Use this to bind to a {@link Val} property to dynamically update the min-, max- and preferred height
     *  of this {@link JComponent} to the same value. &lt;br&gt;
     *  So whenever the item of the property changes, all these heights will
     *  be updated automatically for you.
     *  This is a convenience method, which is equivalent to calling {@link #withMinHeight(Val)},
     *  {@link #withMaxHeight(Val)} and {@link #withPrefHeight(Val)} on the underlying component.
     *  &lt;pre&gt;{@code
     *      .withMinHeight(height)
     *      .withMaxHeight(height)
     *      .withPrefHeight(height)
     *  }&lt;/pre&gt;
     *  Eventually, all of this ultimately translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param height The min-, max- and preferred height of the component wrapped by a {@link Val}.
     *               When the property item changes, the height of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withHeightExactly( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3547">        Objects.requireNonNull(height, &quot;height&quot;);</span>
<span class="fc" id="L3548">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3549">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3550">        self = UIForAnySwing.class.cast(self.withMinHeight(height));</span>
<span class="fc" id="L3551">        self = UIForAnySwing.class.cast(self.withMaxHeight(height));</span>
<span class="fc" id="L3552">        self = UIForAnySwing.class.cast(self.withPrefHeight(height));</span>
<span class="fc" id="L3553">        return self._this();</span>
    }

    /**
     *  Calls the provided action event handler when the mouse gets pressed and then released.
     *  This delegates to a {@link MouseListener} based mouse click event listener registered in the UI component.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that a click is defined as the combination of the &lt;b&gt;mouse being pressed
     *  and then released on the same position as it was pressed.&lt;/b&gt;
     *  If the mouse moves between the press and the release events, then the
     *  event is considered a drag event instead of a mouse click! (see {@link #onMouseDrag(Action)})
     *
     * @param onClick The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseClick( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onClick ) {
<span class="fc" id="L3569">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L3570">        return _with( c -&gt; {</span>
<span class="fc" id="L3571">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseClicked(MouseEvent e) {
<span class="fc" id="L3573">                            _runInApp(() -&gt; {</span>
                                try {
<span class="fc" id="L3575">                                    onClick.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e));</span>
<span class="nc" id="L3576">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3577">                                    log.error(&quot;Error in mouse click event action handler!&quot;, ex);</span>
<span class="fc" id="L3578">                                }</span>
<span class="fc" id="L3579">                            });</span>
<span class="fc" id="L3580">                        }</span>
                    });
<span class="fc" id="L3582">                })</span>
<span class="fc" id="L3583">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse release events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onRelease The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseRelease( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onRelease ) {
<span class="fc" id="L3596">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="fc" id="L3597">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3598">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3600">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3602">                                    onRelease.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e ));</span>
<span class="nc" id="L3603">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3604">                                    log.error(&quot;Error in mouse release event action handler!&quot;, ex);</span>
<span class="nc" id="L3605">                                }</span>
<span class="nc" id="L3606">                            });</span>
<span class="nc" id="L3607">                        }</span>
                    });
<span class="fc" id="L3609">                })</span>
<span class="fc" id="L3610">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse press events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onPress The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMousePress( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onPress ) {
<span class="fc" id="L3623">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="fc" id="L3624">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3625">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3627">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3629">                                    onPress.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3630">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3631">                                    log.error(&quot;Error in mouse press event action handler!&quot;, ex);</span>
<span class="nc" id="L3632">                                }</span>
<span class="nc" id="L3633">                            });</span>
<span class="nc" id="L3634">                        }</span>
                    });
<span class="fc" id="L3636">                })</span>
<span class="fc" id="L3637">                ._this();</span>
    }

    /**
     *  Use this to register and catch mouse enter events on
     *  the {@link UI.ComponentArea#BODY} of this UI component, &lt;br&gt;
     *  which consists of the full component boundaries except for the surrounding
     *  margins and corner rounding areas. &lt;br&gt;
     *  &lt;p&gt;
     *  If you want to catch mouse enter events on a different area of the component, use
     *  {@link #onMouseEnter(UI.ComponentArea, Action)} instead.
     *  Internally, this method adds the supplied {@link Action} lambda to a custom event dispatcher
     *  which ensures that the mouse enter event is only triggered when the mouse enters the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3657">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3658">        return onMouseEnter(UI.ComponentArea.BODY, onEnter);</span>
    }

    /**
     *  Use this to register and catch mouse enter events on a specific area of this UI component,
     *  defined by the first argument, a {@link UI.ComponentArea} enum value, and the second argument,
     *  a lambda instance which will be invoked when the mouse enters the specified area.
     *  Internally, the provided {@link Action} lambda is handled by a custom event dispatcher
     *  which ensures that the mouse enter event is only triggered when the mouse enters the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse enter event is different from the native Swing mouse enter event,
     *  which also considers child components with mouse listeners as enter/exit boundaries.&lt;br&gt;
     *  If you want to rely on this the Swing behavior, use {@link #onMouseEnterGreedy(Action)} instead.&lt;br&gt;
     *  &lt;b&gt;
     *      We do however recommended to rely on this method, to avoid bugs due to the unexpected side effect
     *      of enter events being fired at the boundary to child components.
     *  &lt;/b&gt;
     *
     * @param area The specific area of the component where the mouse enter event should be caught.
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( UI.ComponentArea area, Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3682">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3683">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3684">                    WeakReference&lt;@Nullable C&gt; source = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L3685">                    MouseListener listener = new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="fc" id="L3687">                            @Nullable C localComponent = source.get();</span>
<span class="pc bpc" id="L3688" title="1 of 2 branches missed.">                            if ( localComponent != null )</span>
<span class="fc" id="L3689">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L3691">                                        onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(localComponent, e));</span>
<span class="nc" id="L3692">                                    } catch ( Exception ex ) {</span>
<span class="nc" id="L3693">                                        log.error(&quot;Error in mouse enter event action handler!&quot;, ex);</span>
<span class="fc" id="L3694">                                    }</span>
<span class="fc" id="L3695">                                });</span>
<span class="fc" id="L3696">                        }</span>
                    };
<span class="fc" id="L3698">                    EnterExitComponentBoundsEventDispatcher.addMouseEnterListener(area, thisComponent, listener);</span>
<span class="fc" id="L3699">                })</span>
<span class="fc" id="L3700">                ._this();</span>
    }

    /**
     *  Use this to register and catch simple {@link MouseListener} based mouse enter events on this UI component.
     *  This method adds the supplied {@link Action} lambda in a {@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  This method is greedy in the sense that in case of the parent of this component
     *  also having a mouse listener, then a mouse cursor transition on top of this component
     *  will be considered an exit from the parent component and an enter into this component. &lt;br&gt;
     *  If you want to catch mouse enter events strictly in terms of the cursor being inside
     *  the component boundaries, or one of its areas, use {@link #onMouseEnter(Action)}, or
     *  {@link #onMouseEnter(UI.ComponentArea, Action)} instead.&lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *      To avoid bugs due to the unexpected side effect of enter events being fired at the surface
     *      boundaries to child components, we recommend to use {@link #onMouseEnter(Action)} instead of this method!&lt;br&gt;
     *      Also note that this method is different from {@link #onMouseEnter(Action)}, in that it reports enter events at
     *      the boundaries of {@link swingtree.UI.ComponentArea#ALL} instead of {@link swingtree.UI.ComponentArea#BODY}.
     *  &lt;/b&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnterGreedy( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3724">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3725">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3726">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="nc" id="L3728">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3730">                                    onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3731">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3732">                                    log.error(&quot;Error in greedy mouse enter event action handler!&quot;, ex);</span>
<span class="nc" id="L3733">                                }</span>
<span class="nc" id="L3734">                            });</span>
<span class="nc" id="L3735">                        }</span>
                    });
<span class="fc" id="L3737">                })</span>
<span class="fc" id="L3738">                ._this();</span>
    }

    /**
     *  Use this to register and catch mouse exit events on
     *  the {@link UI.ComponentArea#BODY} of this UI component, &lt;br&gt;
     *  which consists of the full component boundaries except for the surrounding
     *  margins and corner rounding areas. &lt;br&gt;
     *  &lt;p&gt;
     *  If you want to catch mouse exit events on a different area than the body of the component, use
     *  {@link #onMouseExit(UI.ComponentArea, Action)} instead.
     *  Internally, this method adds the supplied {@link Action} lambda to a custom event dispatcher
     *  which ensures that the mouse exit event is only triggered when the mouse exits the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse enter event is different from the native Swing mouse enter event,
     *  which also considers child components with mouse listeners as enter/exit event boundaries.&lt;br&gt;
     *  If you want to rely on this the Swing behavior, use {@link #onMouseExitGreedy(Action)} instead.&lt;br&gt;
     *  &lt;b&gt;
     *      We do however recommended to rely on this method, to avoid bugs due to the unexpected side effect
     *      of exit events being fired at the boundary to child components.
     *  &lt;/b&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3765">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3766">        return onMouseExit(UI.ComponentArea.BODY, onExit);</span>
    }

    /**
     *  Use this to register and catch mouse exit events on a specific area of this UI component,
     *  by supplying a {@link UI.ComponentArea} enum value to define the area, and a {@link Action}
     *  lambda which will be invoked when the mouse exits the specified area, so that you can
     *  react to the event accordingly.&lt;br&gt;
     *  &lt;p&gt;
     *  Internally, the provided {@link Action} lambda is handled by a custom event dispatcher
     *  which ensures that the mouse exit event is only triggered when the mouse exits the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse exit event is different from the native Swing mouse exit event,
     *  which also considers child components with mouse listeners as enter/exit boundaries.
     *  If you want to rely on the native Swing behavior, use {@link #onMouseExitGreedy(Action)}
     *  instead of this method.
     *
     * @param area The specific area of the component where the mouse exit event should be caught.
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( UI.ComponentArea area, Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3789">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3790">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3791">                    WeakReference&lt;@Nullable C&gt; source = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L3792">                    MouseListener listener = new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L3794">                            @Nullable C localComponent = source.get();</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">                            if ( localComponent != null )</span>
<span class="nc" id="L3796">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="nc" id="L3798">                                        onExit.accept(new ComponentMouseEventDelegate&lt;&gt;(localComponent, e));</span>
<span class="nc" id="L3799">                                    } catch ( Exception ex ) {</span>
<span class="nc" id="L3800">                                        log.error(&quot;Error in mouse exit event action handler!&quot;, ex);</span>
<span class="nc" id="L3801">                                    }</span>
<span class="nc" id="L3802">                                });</span>
<span class="nc" id="L3803">                        }</span>
                    };
<span class="fc" id="L3805">                    EnterExitComponentBoundsEventDispatcher.addMouseExitListener(area, thisComponent, listener);</span>
<span class="fc" id="L3806">                })</span>
<span class="fc" id="L3807">                ._this();</span>
    }

    /**
     *  Use this to register and catch simple {@link MouseListener} based mouse exit events on this UI component.
     *  This method adds the supplied {@link Action} lambda in a {@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The method is considered greedy in the sense that in case of the parent of this component
     *  also having a mouse listener, then a mouse cursor transition over to be on top of this component
     *  will be considered an exit from the parent components and an enter into this component. &lt;br&gt;
     *  If you want to catch mouse exit events strictly in terms of the cursor being inside
     *  the component boundaries, or one of its areas, use {@link #onMouseExit(Action)}, or
     *  {@link #onMouseExit(UI.ComponentArea, Action)} instead.&lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *      To avoid bugs due to the unexpected side effect of exit events being fired at the surface
     *      boundaries to child components, we recommend to use {@link #onMouseExit(Action)} instead of this method!&lt;br&gt;
     *      Also note that this method is different from {@link #onMouseExit(Action)}, in that it reports exit events at
     *      the boundaries of {@link swingtree.UI.ComponentArea#ALL} instead of {@link swingtree.UI.ComponentArea#BODY}.
     *  &lt;/b&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExitGreedy( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3831">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3832">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3833">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L3835">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3837">                                onExit.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e ));</span>
<span class="nc" id="L3838">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3839">                                    log.error(&quot;Error in greedy mouse exit event action handler!&quot;, ex);</span>
<span class="nc" id="L3840">                                }</span>
<span class="nc" id="L3841">                            });</span>
<span class="nc" id="L3842">                        }</span>
                    });
<span class="fc" id="L3844">                })</span>
<span class="fc" id="L3845">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse drag events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The {@link ComponentDragEventDelegate} received by the {@link Action} lambda
     *  exposes both component and drag event
     *  context information, including a list of all the {@link MouseEvent}s involved
     *  in one continuous dragging motion (see {@link ComponentDragEventDelegate#dragEvents()} for more information).
     *
     * @param onDrag The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseDrag( Action&lt;ComponentDragEventDelegate&lt;C&gt;&gt; onDrag ) {
<span class="nc" id="L3862">        NullUtil.nullArgCheck(onDrag, &quot;onDrag&quot;, Action.class);</span>
<span class="nc" id="L3863">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3864">                   java.util.List&lt;MouseEvent&gt; dragEventHistory = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3865">                   MouseAdapter listener = new MouseAdapter() {</span>
                       @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3867">                           dragEventHistory.clear();</span>
<span class="nc" id="L3868">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3869">                       }</span>
                       @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3871">                           dragEventHistory.clear();</span>
<span class="nc" id="L3872">                       }</span>
                       @Override public void mouseDragged(MouseEvent e) {
<span class="nc" id="L3874">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3875">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3877">                                   onDrag.accept(new ComponentDragEventDelegate&lt;&gt;(thisComponent, e, dragEventHistory));</span>
<span class="nc" id="L3878">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3879">                                   log.error(&quot;Error in mouse drag event action handler!&quot;, ex);</span>
<span class="nc" id="L3880">                               }</span>
<span class="nc" id="L3881">                           });</span>
<span class="nc" id="L3882">                       }</span>
                   };
<span class="nc" id="L3884">                   thisComponent.addMouseListener(listener);</span>
<span class="nc" id="L3885">                   thisComponent.addMouseMotionListener(listener);</span>
<span class="nc" id="L3886">               })</span>
<span class="nc" id="L3887">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse move events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onMove The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseMove( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onMove ) {
<span class="fc" id="L3900">        NullUtil.nullArgCheck(onMove, &quot;onMove&quot;, Action.class);</span>
<span class="fc" id="L3901">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3902">                   thisComponent.addMouseListener(new MouseAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3904">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3906">                                   onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3907">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3908">                                   log.error(&quot;Error in mouse move event action handler!&quot;, ex);</span>
<span class="nc" id="L3909">                               }</span>
<span class="nc" id="L3910">                           });</span>
<span class="nc" id="L3911">                       }</span>
                   });
<span class="fc" id="L3913">                   thisComponent.addMouseMotionListener(new MouseMotionAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3915">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3917">                                   onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3918">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3919">                                   log.error(&quot;Error in mouse move event action handler!&quot;, ex);</span>
<span class="nc" id="L3920">                               }</span>
<span class="nc" id="L3921">                           });</span>
<span class="nc" id="L3922">                       }</span>
                   });
<span class="fc" id="L3924">               })</span>
<span class="fc" id="L3925">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse wheel events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onWheel The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelMove( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheel ) {
<span class="nc" id="L3938">        NullUtil.nullArgCheck(onWheel, &quot;onWheel&quot;, Action.class);</span>
<span class="nc" id="L3939">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3940">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc" id="L3941">                       _runInApp(() -&gt; {</span>
                           try {
<span class="nc" id="L3943">                               onWheel.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3944">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L3945">                               log.error(&quot;Error in mouse wheel event action handler!&quot;, ex);</span>
<span class="nc" id="L3946">                           }</span>
<span class="nc" id="L3947">                       });</span>
<span class="nc" id="L3948">                   });</span>
<span class="nc" id="L3949">               })</span>
<span class="nc" id="L3950">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel up movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelUp The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelUp( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelUp ) {
<span class="nc" id="L3962">        NullUtil.nullArgCheck(onWheelUp, &quot;onWheelUp&quot;, Action.class);</span>
<span class="nc" id="L3963">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3964">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3965" title="All 2 branches missed.">                       if ( e.getWheelRotation() &lt; 0 )</span>
<span class="nc" id="L3966">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3968">                                   onWheelUp.accept(new ComponentDelegate&lt;&gt;(thisComponent, e ));</span>
<span class="nc" id="L3969">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3970">                                   log.error(&quot;Error in mouse wheel up event action handler!&quot;, ex);</span>
<span class="nc" id="L3971">                               }</span>
<span class="nc" id="L3972">                           });</span>
<span class="nc" id="L3973">                   });</span>
<span class="nc" id="L3974">               })</span>
<span class="nc" id="L3975">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel down movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelDown The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelDown( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelDown ) {
<span class="nc" id="L3987">        NullUtil.nullArgCheck(onWheelDown, &quot;onWheelDown&quot;, Action.class);</span>
<span class="nc" id="L3988">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3989">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3990" title="All 2 branches missed.">                       if ( e.getWheelRotation() &gt; 0 )</span>
<span class="nc" id="L3991">                               _runInApp(() -&gt; {</span>
                                   try {
<span class="nc" id="L3993">                                       onWheelDown.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3994">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L3995">                                       log.error(&quot;Error in mouse wheel down event action handler!&quot;, ex);</span>
<span class="nc" id="L3996">                                   }</span>
<span class="nc" id="L3997">                               });</span>
<span class="nc" id="L3998">                   });</span>
<span class="nc" id="L3999">               })</span>
<span class="nc" id="L4000">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component's size changes.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *  Passing null to this method will cause an exception to be thrown.
     *
     * @param onResize The resize action which will be called when the underlying component changes size.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onResize( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onResize ) {
<span class="fc" id="L4012">        NullUtil.nullArgCheck(onResize, &quot;onResize&quot;, Action.class);</span>
<span class="fc" id="L4013">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4014">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentResized(ComponentEvent e) {
<span class="fc" id="L4016">                           _runInApp(()-&gt;{</span>
                               try {
<span class="fc" id="L4018">                                   onResize.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4019">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4020">                                   log.error(&quot;Error in resize event action handler!&quot;, ex);</span>
<span class="fc" id="L4021">                               }</span>
<span class="fc" id="L4022">                           });</span>
<span class="fc" id="L4023">                       }</span>
                   });
<span class="fc" id="L4025">               })</span>
<span class="fc" id="L4026">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component was moved.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *
     * @param onMoved The action lambda which will be executed once the component was moved / its position canged.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMoved( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onMoved ) {
<span class="fc" id="L4037">        NullUtil.nullArgCheck(onMoved, &quot;onMoved&quot;, Action.class);</span>
<span class="fc" id="L4038">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4039">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentMoved(ComponentEvent e) {
<span class="nc" id="L4041">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4043">                                   onMoved.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4044">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4045">                                   log.error(&quot;Error in move event action handler!&quot;, ex);</span>
<span class="nc" id="L4046">                               }</span>
<span class="nc" id="L4047">                           });</span>
<span class="nc" id="L4048">                       }</span>
                   });
<span class="fc" id="L4050">               })</span>
<span class="fc" id="L4051">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link AncestorListener}
     *  to the component, to receive calls when the wrapped component becomes visible
     *  on the screen. &lt;br&gt;
     *  &lt;p&gt;
     *  Note that this does not correlate 1:1 with the {@link Component#isVisible()} flag,
     *  because a component may also be invisible when it is not part of the component hierarchy
     *  with a visible root component (window) or one of its ancestors (parent components)
     *  is not visible.
     *
     * @param onShown The {@link Action} which gets invoked when the component has been made visible
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onShown( Action&lt;ComponentDelegate&lt;C, AncestorEvent&gt;&gt; onShown ) {
<span class="fc" id="L4068">        NullUtil.nullArgCheck(onShown, &quot;onShown&quot;, Action.class);</span>
<span class="fc" id="L4069">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4070">                   _prependAncestorListenerTo(thisComponent, new AncestorListener() {</span>
                       @Override public void ancestorAdded(AncestorEvent event) {
<span class="fc" id="L4072">                           _runInApp(()-&gt;{</span>
                               try {
<span class="fc" id="L4074">                                   onShown.accept(new ComponentDelegate&lt;&gt;(thisComponent, event));</span>
<span class="nc" id="L4075">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4076">                                   log.error(&quot;Error in show event action handler!&quot;, ex);</span>
<span class="fc" id="L4077">                               }</span>
<span class="fc" id="L4078">                           });</span>
<span class="fc" id="L4079">                       }</span>
<span class="nc" id="L4080">                       @Override public void ancestorRemoved(AncestorEvent event) {}</span>
<span class="fc" id="L4081">                       @Override public void ancestorMoved(AncestorEvent event) {}</span>
                   });
<span class="fc" id="L4083">               })</span>
<span class="fc" id="L4084">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link AncestorListener}
     *  to the component, to receive calls when the wrapped component becomes invisible
     *  on the users screen. &lt;br&gt;
     *  &lt;p&gt;
     *  Note that this does not correlate 1:1 with the {@link Component#isVisible()} flag,
     *  because a component may also be invisible when it is not part of the component hierarchy
     *  with a visible root component (window) or one of its ancestors (parent components)
     *  is not visible.
     *
     * @param onHidden The {@link Action} which gets invoked when the component has been made invisible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onHidden( Action&lt;ComponentDelegate&lt;C, AncestorEvent&gt;&gt; onHidden ) {
<span class="fc" id="L4101">        NullUtil.nullArgCheck(onHidden, &quot;onHidden&quot;, Action.class);</span>
<span class="fc" id="L4102">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4103">                    _prependAncestorListenerTo(thisComponent, new AncestorListener() {</span>
<span class="fc" id="L4104">                          @Override public void ancestorAdded(AncestorEvent event) {}</span>
                          @Override public void ancestorRemoved(AncestorEvent event) {
<span class="fc" id="L4106">                            _runInApp(()-&gt;{</span>
                                 try {
<span class="fc" id="L4108">                                      onHidden.accept(new ComponentDelegate&lt;&gt;(thisComponent, event));</span>
<span class="nc" id="L4109">                                 } catch ( Exception ex ) {</span>
<span class="nc" id="L4110">                                      log.error(&quot;Error in hide event action handler!&quot;, ex);</span>
<span class="fc" id="L4111">                                 }</span>
<span class="fc" id="L4112">                            });</span>
<span class="fc" id="L4113">                          }</span>
<span class="fc" id="L4114">                          @Override public void ancestorMoved(AncestorEvent event) {}</span>
                     });
<span class="fc" id="L4116">               })</span>
<span class="fc" id="L4117">               ._this();</span>
    }

    /**
     *  Adds {@link AncestorListener} to the component so that it will
     *  be called after the previously added ancestor listener was called.&lt;br&gt;
     *  The default behavior of Swing is to call the listeners from the most recently added to the oldest.
     *  This method will prepend the listener to the list of listeners, so that it will be called first.
     * @param component The component to which the listener should be added.
     * @param listener The listener to be added.
     */
    private static void _prependAncestorListenerTo( JComponent component, AncestorListener listener ) {
<span class="fc" id="L4129">        java.util.List&lt;AncestorListener&gt; listeners = new ArrayList&lt;&gt;(Arrays.asList(component.getAncestorListeners()));</span>
<span class="fc bfc" id="L4130" title="All 2 branches covered.">        for ( AncestorListener l : listeners )</span>
<span class="fc" id="L4131">            component.removeAncestorListener(l);</span>

<span class="fc" id="L4133">        listeners.add(listener);</span>
<span class="fc" id="L4134">        Collections.reverse(listeners);// revert the order of the listeners</span>

<span class="fc bfc" id="L4136" title="All 2 branches covered.">        for ( AncestorListener l : listeners )</span>
<span class="fc" id="L4137">            component.addAncestorListener(l);</span>
<span class="fc" id="L4138">    }</span>

    /**
     * Adds the supplied {@link Action} wrapped in a {@link FocusListener}
     * to the component, to receive those focus events where the wrapped component gains input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was gained on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusGain( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L4148">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L4149">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4150">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusGained(FocusEvent e) {
<span class="nc" id="L4152">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4154">                                   onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4155">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4156">                                   log.error(&quot;Error in focus gain event action handler!&quot;, ex);</span>
<span class="nc" id="L4157">                               }</span>
<span class="nc" id="L4158">                           });</span>
<span class="nc" id="L4159">                       }</span>
                   });
<span class="fc" id="L4161">               })</span>
<span class="fc" id="L4162">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a focus listener
     * to receive those focus events where the wrapped component loses input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was lost on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusLoss( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L4173">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L4174">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4175">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusLost(FocusEvent e) {
<span class="nc" id="L4177">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4179">                                   onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4180">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4181">                                   log.error(&quot;Error in focus loss event action handler!&quot;, ex);</span>
<span class="nc" id="L4182">                               }</span>
<span class="nc" id="L4183">                           });</span>
<span class="nc" id="L4184">                       }</span>
                   });
<span class="fc" id="L4186">               })</span>
<span class="fc" id="L4187">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received a key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onKeyPress( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L4198">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L4199">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4200">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed(KeyEvent e) {
<span class="nc" id="L4202">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4204">                                   onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4205">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4206">                                   log.error(&quot;Error in key press event action handler!&quot;, ex);</span>
<span class="nc" id="L4207">                               }</span>
<span class="nc" id="L4208">                           });</span>
<span class="nc" id="L4209">                       }</span>
                   });
<span class="fc" id="L4211">               })</span>
<span class="fc" id="L4212">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received the targeted key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onPressed( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L4225">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4226">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L4227">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4228">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed( KeyEvent e ) {
<span class="nc bnc" id="L4230" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4231">                               _runInApp(()-&gt;{</span>
                                   try {
<span class="nc" id="L4233">                                       onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4234">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L4235">                                       log.error(&quot;Error in key press event action handler!&quot;, ex);</span>
<span class="nc" id="L4236">                                   }</span>
<span class="nc" id="L4237">                               });</span>
<span class="nc" id="L4238">                       }</span>
                   });
<span class="fc" id="L4240">               })</span>
<span class="fc" id="L4241">               ._this();</span>
    }

                             /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received a key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     */
    public final I onKeyRelease( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L4253">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L4254">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4255">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased(KeyEvent e) {
<span class="nc" id="L4257">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4259">                                   onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4260">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4261">                                   log.error(&quot;Error in key release event action handler!&quot;, ex);</span>
<span class="nc" id="L4262">                               }</span>
<span class="nc" id="L4263">                           });</span>
<span class="nc" id="L4264">                       }</span>
                   });
<span class="fc" id="L4266">               })</span>
<span class="fc" id="L4267">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the built component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received the targeted key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onRelease( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L4282">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4283">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L4284">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4285">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased( KeyEvent e ) {
<span class="nc bnc" id="L4287" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4288">                               _runInApp(()-&gt;{</span>
                                   try {
<span class="nc" id="L4290">                                       onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4291">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L4292">                                       log.error(&quot;Error in key release event action handler!&quot;, ex);</span>
<span class="nc" id="L4293">                                   }</span>
<span class="nc" id="L4294">                               });</span>
<span class="nc" id="L4295">                       }</span>
                   });
<span class="fc" id="L4297">               })</span>
<span class="fc" id="L4298">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received a key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onKeyTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L4311">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L4312">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4313">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc" id="L4314">                       _runInApp(() -&gt; {</span>
                           try {
<span class="nc" id="L4316">                               onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4317">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4318">                               log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4319">                           }</span>
<span class="nc" id="L4320">                       });</span>
<span class="nc" id="L4321">                   });</span>
<span class="fc" id="L4322">               })</span>
<span class="fc" id="L4323">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received the targeted key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     * @see #onKeyTyped(Action)
     */
    public final I onTyped( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L4339">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4340">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L4341">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4342">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc bnc" id="L4343" title="All 2 branches missed.">                       if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4344">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4346">                                   onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4347">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4348">                                   log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4349">                               }</span>
<span class="nc" id="L4350">                           });</span>
<span class="nc" id="L4351">                   });</span>
<span class="fc" id="L4352">               })</span>
<span class="fc" id="L4353">               ._this();</span>
    }

    private void _onKeyTyped(C component, BiConsumer&lt;KeyEvent, KeyAdapter&gt; action ) {
<span class="fc" id="L4357">        component.addKeyListener(new KeyAdapter() {</span>
            private @Nullable KeyEvent lastEvent;

            @Override
            public void keyPressed(KeyEvent e) {
<span class="nc" id="L4362">                lastEvent = e;</span>
<span class="nc" id="L4363">            }</span>
            @Override
            public void keyReleased(KeyEvent e) {
<span class="nc bnc" id="L4366" title="All 4 branches missed.">                if ( lastEvent != null &amp;&amp; lastEvent.getKeyCode() == e.getKeyCode() ) {</span>
<span class="nc" id="L4367">                    action.accept(lastEvent, this);</span>
<span class="nc" id="L4368">                    lastEvent = null;</span>
                }
<span class="nc" id="L4370">            }</span>
        });
<span class="fc" id="L4372">    }</span>

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     *  to receive key events triggered when the wrapped component receives a particular
     *  keyboard input matching the provided character. &lt;br&gt;
     *  This method is a logical extension of the {@link #onTyped(Keyboard.Key, Action)} method,
     *  with the difference that it listens for any character instead of a specific key code.
     *  This also works with special characters which are typed using the combination
     *  of multiple keys (e.g. shift + number keys).
     *  &lt;br&gt;&lt;br&gt;
     * @param character The character to listen for.
     * @param onKeyTyped The action to execute when the character is typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyTyped(Action)
     * @see #onTyped(Keyboard.Key, Action)
     */
    public final I onTyped( char character, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="nc" id="L4390">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="nc" id="L4391">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4392">                   _onCharTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc bnc" id="L4393" title="All 2 branches missed.">                       if ( e.getKeyChar() == character )</span>
<span class="nc" id="L4394">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4396">                                   onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4397">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4398">                                   log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4399">                               }</span>
<span class="nc" id="L4400">                           });</span>
<span class="nc" id="L4401">                   });</span>
<span class="nc" id="L4402">               })</span>
<span class="nc" id="L4403">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     *  to receive key events triggered when the wrapped component receives a particular
     *  keyboard input matching the provided character. &lt;br&gt;
     *  This method is a logical extension of the {@link #onTyped(Keyboard.Key, Action)} method,
     *  with the difference that it listens for any character instead of a specific key code.
     *  This also works with special characters which are typed using the combination
     *  of multiple keys (e.g. shift + number keys).
     *  &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The action to execute when the character is typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyTyped(Action)
     * @see #onKeyTyped(Action)
     * @see #onTyped(Keyboard.Key, Action)
     */
    public final I onCharTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="nc" id="L4422">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="nc" id="L4423">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4424">                   _onCharTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc" id="L4425">                       _runInApp(()-&gt;{</span>
                           try {
<span class="nc" id="L4427">                               onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4428">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4429">                               log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4430">                           }</span>
<span class="nc" id="L4431">                       });</span>
<span class="nc" id="L4432">                   });</span>
<span class="nc" id="L4433">               })</span>
<span class="nc" id="L4434">               ._this();</span>
    }

    private void _onCharTyped( C component, BiConsumer&lt;KeyEvent, KeyAdapter&gt; action ) {
<span class="nc" id="L4438">        component.addKeyListener(new KeyAdapter() {</span>
            @Override
            public void keyTyped(KeyEvent e) {
<span class="nc" id="L4441">                action.accept(e, this);</span>
<span class="nc" id="L4442">            }</span>
        });
<span class="nc" id="L4444">    }</span>

    /**
     *  Exposes a functional {@link Configurator} API for turning the component into a drag source site
     *  with the given configuration. This method is a convenience method which internally
     *  creates and configures an AWT native {@link DragSource} instance for the component.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Drag me!&quot;)
     *      .withDragAway( conf -&gt; conf
     *          .enabled(true)
     *          .opacity(0.25)
     *          .payload(&quot;IT WORKS&quot;)
     *          .onDragMove( it -&gt; {...})
     *      )
     *  }&lt;/pre&gt;
     *  The example above creates a draggable label which will be dragged with an opacity of 0.25
     *  and carries the payload &quot;IT WORKS&quot; when dragged. The drag move event handler
     *  is attached to the drag source site and will be called when the label is dragged.&lt;br&gt;
     *  &lt;p&gt;
     *  If you want to create a drop site instead of a drag source site, use {@link #withDropSite(Configurator)}.
     *
     * @param configurator The {@link Configurator} which allows you to configure the drag source site
     *                     by receiving a {@link DragAwayComponentConf} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withDragAway( Configurator&lt;DragAwayComponentConf&lt;C&gt;&gt; configurator ) {
<span class="fc" id="L4472">        NullUtil.nullArgCheck(configurator, &quot;configurator&quot;, Configurator.class);</span>
<span class="fc" id="L4473">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4474">                    ComponentExtension.from(thisComponent).addDragAwayConf(mousePosition -&gt; {</span>
<span class="nc" id="L4475">                        DragAwayComponentConf&lt;C&gt; conf = DragAwayComponentConf.of(thisComponent, mousePosition);</span>
                        try {
<span class="nc" id="L4477">                            return configurator.configure(conf);</span>
<span class="nc" id="L4478">                        } catch (Exception e) {</span>
<span class="nc" id="L4479">                            log.error(&quot;Failed to configure drag away!&quot;, e);</span>
                        }
<span class="nc" id="L4481">                        return conf;</span>
                    });
<span class="fc" id="L4483">               })</span>
<span class="fc" id="L4484">               ._this();</span>
    }

    /**
     *  Exposes a functional {@link Configurator} API for turning the component into a drag drop
     *  receiver site with the given configuration.
     *  This method is a convenience method which internally
     *  creates and configures an AWT native {@link DropTarget} instance for the component.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Drop here!&quot;)
     *      .withDropSite( conf -&gt; conf
     *          .onDragOver( it -&gt; {
     *              it.animateFor(1, TimeUnit.SECONDS, status -&gt; {
     *                  double r = 30 * status.fadeIn() * it.getScale();
     *                  double x = it.getEvent().getLocation().x - r / 2.0;
     *                  double y = it.getEvent().getLocation().y - r / 2.0;
     *                  it.paint(status, g -&gt; {
     *                      g.setColor(new Color(0f, 1f, 1f, (float) status.fadeOut()));
     *                      g.fillOval((int) x, (int) y, (int) r, (int) r);
     *                  });
     *              });
     *          })
     *          .onDrop(it -&gt; {
     *              it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *                  double r = 480 * status.fadeIn() * it.getScale();
     *                  double x = it.getEvent().getLocation().x - r / 2.0;
     *                  double y = it.getEvent().getLocation().y - r / 2.0;
     *                  it.paint(status, g -&gt; {
     *                      g.setColor(UI.color(0.5+status.fadeOut()/2, status.fadeOut(), status.fadeIn(), status.fadeOut()));
     *                      g.fillOval((int) x, (int) y, (int) r, (int) r);
     *                  });
     *              });
     *          })
     *      )
     *  }&lt;/pre&gt;
     *  The example above creates a drop site label which will animate an expanding circle when a drag is over it
     *  and another circle when a drop is performed on it. The drag over event handler
     *  is attached to the drop site and will be called when the label is dragged over it.
     *  &lt;p&gt;
     *  If you want to create a drag source site instead of a drop site, use {@link #withDragAway(Configurator)}.
     *
     * @param configurator The {@link Configurator} which allows you to configure the drop site
     *                     by receiving a {@link DragDropComponentConf} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withDropSite( Configurator&lt;DragDropComponentConf&lt;C&gt;&gt; configurator ) {
<span class="fc" id="L4532">        NullUtil.nullArgCheck(configurator, &quot;configurator&quot;, Configurator.class);</span>
<span class="fc" id="L4533">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4534">                    _runInApp(() -&gt; {</span>
                        try {
<span class="fc" id="L4536">                            DragDropComponentConf&lt;C&gt; conf = configurator.configure(DragDropComponentConf.of(thisComponent));</span>
<span class="fc" id="L4537">                            DropTarget target = conf.toNewDropTarget();</span>
<span class="fc" id="L4538">                            thisComponent.setDropTarget(target);</span>
<span class="nc" id="L4539">                        } catch (Exception e) {</span>
<span class="nc" id="L4540">                            throw new RuntimeException(&quot;Failed to configure drop site!&quot;, e);</span>
<span class="fc" id="L4541">                        }</span>
<span class="fc" id="L4542">                    });</span>
<span class="fc" id="L4543">               })</span>
<span class="fc" id="L4544">               ._this();</span>
    }

    /**
     *  Allows you to cause an effect inside your UI when an observable event is fired.
     *  The provided {@link Action} event handler will be called
     *  on the UI thread when the {@link Observable} event is fired, irrespective of
     *  what thread the {@link Observable} event is fired on.
     *  However, it is expected that the {@link Observable} event is fired on the application thread
     *  and &lt;b&gt;the concrete implementation of the {@link Observable} is intended to
     *  be part of your view model&lt;/b&gt;.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *  UI.label(&quot;I have a color animation!&quot;)
     *  .onView(viewModel.someEvent(), it -&gt;
     *    it.animateFor(3, TimeUnit.SECONDS, status -&gt; {
     *      double r = status.progress();
     *      double g = 1 - status.progress();
     *      double b = status.pulse();
     *      it.setBackgroundColor(r, g, b);
     *    })
     *  )
     *  }&lt;/pre&gt;
     *  Use {@link #on(Observable, Action)} if you want to bind to a custom event system
     *  executed on the application thread, instead of this method, which runs on the UI thread.
     *
     * @param observableEvent The {@link Observable} event to which the {@link Action} should be attached
     *                        and called on the UI thread when the event is fired in the view model.
     * @param action The {@link Action} which is invoked by the UI thread after the {@link Observable} event was fired
     *               by the business logic of the view model.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     */
    public final &lt;E extends Observable&gt; I onView( E observableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L4579">        NullUtil.nullArgCheck(observableEvent, &quot;observableEvent&quot;, Observable.class);</span>
<span class="fc" id="L4580">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L4581">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4582">                    ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="fc" id="L4583">                        observableEvent.subscribe(() -&gt; {</span>
<span class="fc" id="L4584">                            _runInUI(() -&gt; {</span>
                                try {
<span class="fc" id="L4586">                                    action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4587">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L4588">                                    log.error(&quot;Error in view event action handler!&quot;, ex);</span>
<span class="fc" id="L4589">                                }</span>
<span class="fc" id="L4590">                            });</span>
<span class="fc" id="L4591">                        })</span>
                    );
<span class="fc" id="L4593">               })</span>
<span class="fc" id="L4594">               ._this();</span>
    }

    /**
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event in order to implement a custom user event system.
     *  The supplied {@link Action} is executed on the application thread when the {@link Observable} event is fired and
     *  irrespective of the thread that {@link Observable} fired the event. &lt;br&gt;
     *  The {@link Action} is expected to perform an effect on the view model or the application state,
     *  &lt;b&gt;but not on the UI directly&lt;/b&gt;. &lt;br&gt;
     *  (see {@link #onView(Observable, Action)} if you want your view model to affect the UI through an observable event)
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(CustomEventSystem.touchGesture(), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a touch gesture event handler
     *  which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      Note that the provided {@link Observable} event should NOT be part of the view model,
     *      but rather part of a custom event system that captures user input or other input
     *      which is not directly related to the business logic of the view model.
     *  &lt;/b&gt;
     *  Use {@link #onView(Observable, Action)} if you want to bind to a view model event,
     *  which ensures that the event is being run in the UI thread, instead of this method,
     *  which runs on the application thread.
     *
     * @param observableEvent The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     * @see #onView(Observable, Action) for a similar method which is intended to be used with view model events.
     */
    public final &lt;E extends Observable&gt; I on( E observableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L4632">        NullUtil.nullArgCheck(observableEvent, &quot;observableEvent&quot;, Observable.class);</span>
<span class="fc" id="L4633">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L4634">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4635">                   ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="fc" id="L4636">                       observableEvent.subscribe(() -&gt; {</span>
<span class="fc" id="L4637">                           _runInApp(() -&gt; {</span>
                               try {
<span class="fc" id="L4639">                                   action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4640">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4641">                                   log.error(&quot;Error in custom event action handler!&quot;, ex);</span>
<span class="fc" id="L4642">                               }</span>
<span class="fc" id="L4643">                           });</span>
<span class="fc" id="L4644">                       })</span>
                   );
<span class="fc" id="L4646">               })</span>
<span class="fc" id="L4647">               ._this();</span>
    }

    /**
     *  This is a logical extension of the {@link #on(Observable, Action)} method.
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event.
     *  The {@link Action} will be called on the application thread when the {@link Observable} event
     *  is fired, irrespective of the thread that fired the {@link Observable} event.
     *  The {@link Action} is expected to perform an effect on the view model or the application state,
     *  &lt;b&gt;but not on the UI directly&lt;/b&gt;. &lt;br&gt;
     *  (see {@link #onView(Observable, Action)} if you want your view model to affect the UI through an observable event)
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(c -&gt; CustomEventSystem.touchGesture(c), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  Which may also be written as:
     *  &lt;pre&gt;{@code
     *    UI.label(&quot;&quot;)
     *    .on(CustomEventSystem::touchGesture, it -&gt; ..some App update.. )
     * }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a component specific
     *  touch gesture event handler which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      Note that the {@link Observable} event supplied by the function
     *      is NOT expected to be part of the view model,
     *      but rather be part of a custom event system that captures user input or other input
     *      which is not directly related to the business logic of the view model.
     *  &lt;/b&gt;
     *
     * @param eventSource The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     * @see #onView(Observable, Action) for a similar method which is intended to be used with view model events.
     */
    public final &lt;E extends Observable&gt; I on( Function&lt;C, E&gt; eventSource, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="nc" id="L4689">        NullUtil.nullArgCheck(eventSource, &quot;eventSource&quot;, Function.class);</span>
<span class="nc" id="L4690">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="nc" id="L4691">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4692">                   E observableEvent = eventSource.apply(thisComponent);</span>
<span class="nc" id="L4693">                   ComponentExtension.from(thisComponent).storeBoundObservable(</span>
<span class="nc" id="L4694">                       observableEvent.subscribe(() -&gt; {</span>
<span class="nc" id="L4695">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L4697">                                   action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4698">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4699">                                   log.error(&quot;Error in custom event action handler!&quot;, ex);</span>
<span class="nc" id="L4700">                               }</span>
<span class="nc" id="L4701">                           });</span>
<span class="nc" id="L4702">                       })</span>
                   );
<span class="nc" id="L4704">               })</span>
<span class="nc" id="L4705">               ._this();</span>
    }

    /**
     *  Use this to register periodic update actions which should be called
     *  based on the provided {@code delay}! &lt;br&gt;
     *  The following example produces a label which will display the current date.
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .doUpdates( 100, it -&gt; it.getComponent().setText(new Date().toString()) )
     *  }&lt;/pre&gt;
     *
     * @param delay The delay in milliseconds between calling the provided {@link Action}.
     * @param onUpdate The {@link Action} which should be called periodically.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I doUpdates( int delay, Action&lt;ComponentDelegate&lt;C, ActionEvent&gt;&gt; onUpdate ) {
<span class="fc" id="L4722">        NullUtil.nullArgCheck(onUpdate, &quot;onUpdate&quot;, Action.class);</span>
<span class="fc" id="L4723">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4724">                   Timer timer = new Timer(delay, e -&gt; {</span>
                       try {
<span class="fc" id="L4726">                           onUpdate.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4727">                       } catch ( Exception ex ) {</span>
<span class="nc" id="L4728">                           log.error(&quot;Error in update action handler!&quot;, ex);</span>
<span class="fc" id="L4729">                       }</span>
<span class="fc" id="L4730">                   });</span>
                   {
<span class="fc" id="L4732">                       java.util.List&lt;Timer&gt; timers = (java.util.List&lt;Timer&gt;) thisComponent.getClientProperty(_TIMERS_KEY);</span>
<span class="pc bpc" id="L4733" title="1 of 2 branches missed.">                       if ( timers == null ) {</span>
<span class="fc" id="L4734">                           timers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L4735">                           thisComponent.putClientProperty(_TIMERS_KEY, timers);</span>
                       }
<span class="fc" id="L4737">                       timers.add(timer);</span>
                   }
<span class="fc" id="L4739">                   timer.start();</span>
<span class="fc" id="L4740">               })</span>
<span class="fc" id="L4741">               ._this();</span>
    }

    @Override
    protected void _addComponentTo(
        C                       thisComponent,
        JComponent              addedComponent,
        @Nullable AddConstraint constraints
    ) {
<span class="fc" id="L4750">        NullUtil.nullArgCheck(addedComponent, &quot;component&quot;, JComponent.class);</span>
<span class="fc bfc" id="L4751" title="All 2 branches covered.">        if ( constraints == null )</span>
<span class="fc" id="L4752">            thisComponent.add( addedComponent );</span>
        else
<span class="fc" id="L4754">            thisComponent.add( addedComponent, constraints.toConstraintForLayoutManager() );</span>
<span class="fc" id="L4755">    }</span>

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument is expected to contain layout information for the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( String attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L4771">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The mig-layout attribute.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add(AddConstraint attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L4788">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s 
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be passed to the {@link LayoutManager} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *  This may look like this:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .add(&quot;wrap&quot;, UI.label(&quot;A&quot;), UI.label(&quot;B&quot;))
     *    .add(&quot;grow&quot;, UI.label(&quot;C&quot;), UI.label(&quot;D&quot;))
     *  }&lt;/pre&gt;
     *  Note that the first argument, &quot;wrap&quot; and &quot;grow&quot; in this case, are
     *  used as layout constraints for all the {@link JComponent}s which are added
     *  in the subsequent arguments of a single call to this method.
     *
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent} 
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( String attr, B... builders ) {
<span class="fc" id="L4817">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4818">                   _addBuildersTo(thisComponent, ()-&gt;attr, builders);</span>
<span class="fc" id="L4819">               })</span>
<span class="fc" id="L4820">               ._this();</span>
    }

    private void _addBuildersTo(C thisComponent, AddConstraint attr, UIForAnySwing&lt;?, ?&gt;... builders ) {
<span class="fc" id="L4824">        LayoutManager layout = thisComponent.getLayout();</span>
<span class="fc" id="L4825">        Object constraints = attr.toConstraintForLayoutManager();</span>
<span class="fc bfc" id="L4826" title="All 4 branches covered.">        if ( _isBorderLayout(constraints) &amp;&amp; !(layout instanceof BorderLayout) ) {</span>
<span class="pc bpc" id="L4827" title="1 of 2 branches missed.">            if ( layout instanceof MigLayout )</span>
<span class="fc" id="L4828">                log.warn(&quot;Layout ambiguity detected! Border layout constraint cannot be added to 'MigLayout'.&quot;);</span>
<span class="fc" id="L4829">            thisComponent.setLayout(new BorderLayout()); // The UI Maker tries to fill in the blanks!</span>
        }
<span class="fc bfc" id="L4831" title="All 2 branches covered.">        for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="fc" id="L4832">            _addBuilderTo(thisComponent, b, attr);</span>
<span class="fc" id="L4833">    }</span>

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add(AddConstraint attr, B... builders ) {
<span class="fc" id="L4851">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L4852">        Objects.requireNonNull(builders, &quot;builders&quot;);</span>
<span class="fc" id="L4853">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4854">                    _addBuildersTo(thisComponent, attr, builders);</span>
<span class="fc" id="L4855">                })</span>
<span class="fc" id="L4856">                ._this();</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the {@link JComponent}s
     *  wrapped by the provided builders
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents placement constraints for the provided components which will
     *  be passed to the {@link MigLayout} of the underlying {@link JComponent}
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( CC attr, B... builders ) {
<span class="nc" id="L4876">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L4877">        Objects.requireNonNull(builders, &quot;builders&quot;);</span>
<span class="nc" id="L4878">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4879">                   LayoutManager layout = thisComponent.getLayout();</span>
<span class="nc bnc" id="L4880" title="All 2 branches missed.">                   if ( !(layout instanceof MigLayout) )</span>
<span class="nc" id="L4881">                       log.warn(&quot;Layout ambiguity detected! Mig layout constraint cannot be added to '{}'.&quot;, layout.getClass().getSimpleName());</span>

<span class="nc bnc" id="L4883" title="All 2 branches missed.">                   for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="nc" id="L4884">                       _addBuilderTo(thisComponent, b, ()-&gt;attr);</span>
<span class="nc" id="L4885">               })</span>
<span class="nc" id="L4886">               ._this();</span>
    }

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be applied to the subsequently provided {@link JComponent} types.
     *  &lt;br&gt;&lt;br&gt;
     *  This may look like this:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .add(&quot;wrap&quot;, new JLabel(&quot;A&quot;), new JLabel(&quot;B&quot;))
     *    .add(&quot;grow&quot;, new JLabel(&quot;C&quot;), new JLabel(&quot;D&quot;))
     *  }&lt;/pre&gt;
     *  Note that the first argument, &quot;wrap&quot; and &quot;grow&quot; in this case, are
     *  used as layout constraints for all the {@link JComponent}s which are added
     *  in the subsequent arguments of a single call to this method.
     *
     * @param attr The additional layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( String attr, E... components ) {
<span class="fc" id="L4912">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L4913">        NullUtil.nullArgCheck(components, &quot;components&quot;, JComponent[].class);</span>
<span class="fc" id="L4914">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4915">                   _addComponentsTo( thisComponent, attr, components );</span>
<span class="fc" id="L4916">               })</span>
<span class="fc" id="L4917">               ._this();</span>
    }

    @SafeVarargs
    private final &lt;E extends JComponent&gt; void _addComponentsTo( C thisComponent, String attr, E... components ) {
<span class="fc bfc" id="L4922" title="All 2 branches covered.">        for ( E component : components ) {</span>
<span class="fc" id="L4923">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L4924">            _addBuildersTo( thisComponent, ()-&gt;attr, new UIForSwing[]{UI.of(component)} );</span>
        }
<span class="fc" id="L4926">    }</span>

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first 2 arguments will be joined by a comma and passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( AddConstraint attr, E... components ) {
<span class="nc" id="L4942">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4943">                    _addComponentsTo( thisComponent, attr, components );</span>
<span class="nc" id="L4944">                })</span>
<span class="nc" id="L4945">                ._this();</span>
    }

    @SafeVarargs
    private final &lt;E extends JComponent&gt; void _addComponentsTo( C thisComponent, AddConstraint attr, E... components ) {
<span class="nc bnc" id="L4950" title="All 2 branches missed.">        for ( E component : components ) {</span>
<span class="nc" id="L4951">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="nc" id="L4952">            _addBuildersTo( thisComponent, attr, new UIForSwing[]{UI.of(component)} );</span>
        }
<span class="nc" id="L4954">    }</span>

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     * @throws NullPointerException If either the {@code model} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I add( Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L4971">        Objects.requireNonNull(model, &quot;model&quot;);</span>
<span class="fc" id="L4972">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L4973">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4974">                   _addViewablePropTo(thisComponent, model, null, viewSupplier);</span>
<span class="fc" id="L4975">               })</span>
<span class="fc" id="L4976">               ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The {@link String} based {@link MigLayout} layout information
     *             which should be used as layout constraints for each generated view.
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     * @throws NullPointerException If either the {@code attr}, the {@code model} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I add( String attr, Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L4996">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L4997">        Objects.requireNonNull(model, &quot;model&quot;);</span>
<span class="nc" id="L4998">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="nc" id="L4999">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L5000">            _addViewablePropTo(thisComponent, model, ()-&gt;attr, viewSupplier);</span>
<span class="nc" id="L5001">        })</span>
<span class="nc" id="L5002">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     * @throws NullPointerException If either the layout {@code attr}, the {@code model} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I add( AddConstraint attr, Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5021">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L5022">        Objects.requireNonNull(model, &quot;model&quot;);</span>
<span class="fc" id="L5023">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5024">        return  _with( thisComponent -&gt; {</span>
<span class="fc" id="L5025">            _addViewablePropTo(thisComponent, model, attr, viewSupplier);</span>
<span class="fc" id="L5026">        })</span>
<span class="fc" id="L5027">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;
     *          See {@link #addAll(Val, ViewSupplier)} and {@link #addAll(Var, BoundViewSupplier)}
     *          as the recommended alternative to this method.
     *      &lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     * @throws NullPointerException If either the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5056">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5057">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5058">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5059" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5060">                        log.error(&quot;Binding 'JComboBox' to a property list not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5062">                    _bindTo( models, null, viewSupplier, thisComponent );</span>
                    }
<span class="fc" id="L5064">                })</span>
<span class="fc" id="L5065">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;
     *          See {@link #addAll(String, Val, ViewSupplier)} and {@link #addAll(AddConstraint, Val, ViewSupplier)}
     *          as the recommended alternative to this method.
     *      &lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param attr The {@link String} based {@link MigLayout} layout information
     *             which should be used as layout constraints for each generated view.
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( String attr, Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5096">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L5097">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5098">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5099" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5100">                        log.error(&quot;Binding 'JComboBox' to a property list not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5102">                        _bindTo(models, () -&gt; attr, viewSupplier, thisComponent);</span>
                    }
<span class="fc" id="L5104">                })</span>
<span class="fc" id="L5105">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;
     *          See {@link #addAll(AddConstraint, Val, ViewSupplier)} and {@link #addAll(Var, BoundViewSupplier)}
     *          as the recommended alternative to this method.
     *      &lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( AddConstraint attr, Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L5135">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L5136">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="nc" id="L5137">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="nc" id="L5138">        return _with( thisComponent -&gt; {</span>
<span class="nc bnc" id="L5139" title="All 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5140">                        log.error(&quot;Binding 'JComboBox' to a property list not supported.&quot;, new Throwable());</span>
                    } else {
<span class="nc" id="L5142">                        _bindTo(models, attr, viewSupplier, thisComponent);</span>
                    }
<span class="nc" id="L5144">                })</span>
<span class="nc" id="L5145">                ._this();</span>
    }

    /**
     *  Dynamically generate views for the items in a {@link Tuple} of items,
     *  and automatically regenerate the view when the tuple in the specified property changes.
     *  The type of individual items in the tuple can be anything, but it is usually value
     *  based view models.&lt;br&gt;
     *  The {@link ViewSupplier} lambda passed to this method will be invoked with
     *  each item in the tuple and is expected to return a {@link JComponent} instance
     *  which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  &lt;p&gt;
     *      If you want to bind individual items of a {@link Tuple} property
     *      &lt;b&gt;bi-directionally&lt;/b&gt; instead of just rendering them,
     *      use the {@link #addAll(Var, BoundViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Val}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( Val&lt;Tuple&lt;M&gt;&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5174">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5175">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5176">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5177" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5178">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5180">                        _bindTo(models, null, viewSupplier, thisComponent);</span>
                    }
<span class="fc" id="L5182">                })</span>
<span class="fc" id="L5183">                ._this();</span>
    }

    /**
     *  Dynamically generate views for the items in a {@link Tuple} of items,
     *  and automatically regenerate the view when the tuple in the specified property changes.
     *  The type of individual items in the tuple can be anything, but it is usually value
     *  based view models.&lt;br&gt;
     *  The {@link ViewSupplier} lambda passed to this method will be invoked with
     *  each item in the tuple and is expected to return a {@link JComponent} instance
     *  which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  &lt;p&gt;
     *      If you want to bind individual items of a {@link Tuple} property
     *      &lt;b&gt;bi-directionally&lt;/b&gt; instead of just rendering them,
     *      use the {@link #addAll(Var, BoundViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Val}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param attr The {@link String} based {@link MigLayout} layout information
     *             which should be used as layout constraints for the generated views.
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( String attr, Val&lt;Tuple&lt;M&gt;&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5214">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L5215">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5216">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5217">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5218" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5219">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5221">                        _bindTo(models, () -&gt; attr, viewSupplier, thisComponent);</span>
                    }
<span class="fc" id="L5223">                })</span>
<span class="fc" id="L5224">                ._this();</span>
    }

    /**
     *  Dynamically generate views for the items in a {@link Tuple} of items,
     *  and automatically regenerate the view when the tuple in the specified property changes.
     *  The type of individual items in the tuple can be anything, but it is usually value
     *  based view models.&lt;br&gt;
     *  The {@link ViewSupplier} lambda passed to this method will be invoked with
     *  each item in the tuple and is expected to return a {@link JComponent} instance
     *  which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  &lt;p&gt;
     *      If you want to bind individual items of a {@link Tuple} property
     *      &lt;b&gt;bi-directionally&lt;/b&gt; instead of just rendering them,
     *      use the {@link #addAll(Var, BoundViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Val}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M&gt; I addAll( AddConstraint attr, Val&lt;Tuple&lt;M&gt;&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L5254">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L5255">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="nc" id="L5256">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="nc" id="L5257">        return _with( thisComponent -&gt; {</span>
<span class="nc bnc" id="L5258" title="All 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5259">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="nc" id="L5261">                        _bindTo(models, attr, viewSupplier, thisComponent);</span>
                    }
<span class="nc" id="L5263">                })</span>
<span class="nc" id="L5264">                ._this();</span>
    }

    /**
     *  Dynamically generate views bi-directionally bound to {@link HasId} based items
     *  in a {@link Tuple} of items, and automatically regenerate a view if the {@link HasId#id()}
     *  of any item in the tuple changes.&lt;br&gt;
     *  If items change in terms of other properties, the view will not be updated,
     *  but individually bound properties in the view may update themselves.&lt;br&gt;
     *  The {@link BoundViewSupplier} lambda passed to this method will be invoked with
     *  a {@link Var} property lens onto each item in the tuple and is expected to return
     *  a {@link JComponent} instance which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  Use the {@link Var#zoomTo(Function, BiFunction)} method on the item lens to zoom further
     *  into the properties of your items (which are typically view models) and bind them to the view components.&lt;br&gt;
     *  &lt;p&gt;
     *      This method is the recommended way to bind views to value objects (like records),
     *      with a custom identity (that is not based on the object reference).
     *      If you want to bind views to mutable objects, use the {@link #addAll(Vals, ViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Var}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link BoundViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M extends HasId&lt;?&gt;&gt; I addAll( Var&lt;Tuple&lt;M&gt;&gt; models, BoundViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5296">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5297">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5298">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5299" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5300">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5302">                        _bindTo(models, null, viewSupplier, thisComponent);</span>
                    }
<span class="fc" id="L5304">                })</span>
<span class="fc" id="L5305">                ._this();</span>
    }

    /**
     *  Dynamically generate views bi-directionally bound to {@link HasId} based items
     *  in a {@link Tuple} of items, and automatically regenerate a view if the {@link HasId#id()}
     *  of any item in the tuple changes.&lt;br&gt;
     *  If items change in terms of other properties, the view will not be updated,
     *  but individually bound properties in the view may update themselves.&lt;br&gt;
     *  The {@link BoundViewSupplier} lambda passed to this method will be invoked with
     *  a {@link Var} property lens onto each item in the tuple and is expected to return
     *  a {@link JComponent} instance which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  Use the {@link Var#zoomTo(Function, BiFunction)} method on the item lens to zoom further
     *  into the properties of your items (which are typically view models) and bind them to the view components.&lt;br&gt;
     *  &lt;p&gt;
     *      This method is the recommended way to bind views to value objects (like records),
     *      with a custom identity (that is not based on the object reference).
     *      If you want to bind views to mutable objects, use the {@link #addAll(String, Vals, ViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Var}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param attr The {@link String} based {@link MigLayout} layout information
     *             which should be used as layout constraints for the generated views.
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link BoundViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M extends HasId&lt;?&gt;&gt; I addAll( String attr, Var&lt;Tuple&lt;M&gt;&gt; models, BoundViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L5339">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L5340">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="nc" id="L5341">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="nc" id="L5342">        return _with( thisComponent -&gt; {</span>
<span class="nc bnc" id="L5343" title="All 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5344">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="nc" id="L5346">                        _bindTo(models, () -&gt; attr, viewSupplier, thisComponent);</span>
                    }
<span class="nc" id="L5348">                })</span>
<span class="nc" id="L5349">                ._this();</span>
    }

    /**
     *  Dynamically generate views bi-directionally bound to {@link HasId} based items
     *  in a {@link Tuple} of items, and automatically regenerate a view if the {@link HasId#id()}
     *  of any item in the tuple changes.&lt;br&gt;
     *  If items change in terms of other properties, the view will not be updated,
     *  but individually bound properties in the view may update themselves.&lt;br&gt;
     *  The {@link BoundViewSupplier} lambda passed to this method will be invoked with
     *  a {@link Var} property lens onto each item in the tuple and is expected to return
     *  a {@link JComponent} instance which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *  Use the {@link Var#zoomTo(Function, BiFunction)} method on the item lens to zoom further
     *  into the properties of your items (which are typically view models) and bind them to the view components.&lt;br&gt;
     *  &lt;p&gt;
     *      This method is the recommended way to bind views to value objects (like records),
     *      with a custom identity (that is not based on the object reference).
     *      If you want to bind views to mutable objects, use the {@link #addAll(AddConstraint, Vals, ViewSupplier)} method.
     *  &lt;/p&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      WARNING: The binding established by this method assumes full ownership over
     *      all subcomponents referenced by this component. You must not add or remove
     *      components other than through the bound {@link Var}. Otherwise, your GUI may break!
     *  &lt;/b&gt;&lt;br&gt;
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link BoundViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     * @throws NullPointerException If either the layout {@code attr}, the {@code models} or the {@code viewSupplier} is null.
     */
    public final &lt;M extends HasId&lt;?&gt;&gt; I addAll( AddConstraint attr, Var&lt;Tuple&lt;M&gt;&gt; models, BoundViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5382">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L5383">        Objects.requireNonNull(models, &quot;models&quot;);</span>
<span class="fc" id="L5384">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5385">        return _with( thisComponent -&gt; {</span>
<span class="pc bpc" id="L5386" title="1 of 2 branches missed.">                    if ( thisComponent instanceof JComboBox ) {</span>
<span class="nc" id="L5387">                        log.error(&quot;Binding 'JComboBox' to a tuple property not supported.&quot;, new Throwable());</span>
                    } else {
<span class="fc" id="L5389">                        _bindTo(models, attr, viewSupplier, thisComponent);</span>
                    }
<span class="fc" id="L5391">                })</span>
<span class="fc" id="L5392">                ._this();</span>
    }

    private &lt;M&gt; void _bindTo( Vals&lt;M&gt; models, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5396">        _checkComponentStateBeforeBinding(thisComponent);</span>
<span class="fc" id="L5397">        _addViewableProps(models, attr, ModelToViewConverter.of(thisComponent, viewSupplier, (model, exception)-&gt;{</span>
<span class="nc" id="L5398">                log.error(&quot;Error while creating view for '&quot;+model+&quot;'.&quot;, exception);</span>
<span class="nc" id="L5399">                return UI.box().get(JBox.class);</span>
            }), thisComponent);
<span class="fc" id="L5401">    }</span>

    // Overridden in UIForScrollPanels
    protected &lt;M&gt; void _addViewableProps( Vals&lt;M&gt; models, @Nullable AddConstraint attr, ModelToViewConverter&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5405">        _onShow( models, thisComponent, (innerComponent, delegate) -&gt; {</span>
<span class="fc" id="L5406">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L5407">            _updateSubViews(innerComponent, attr, delegate, viewSupplier);</span>
<span class="fc" id="L5408">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L5409">        });</span>
<span class="fc" id="L5410">        models.forEach( v -&gt; {</span>
<span class="fc" id="L5411">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5413">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L5414">            } catch ( Exception e ) {</span>
<span class="nc" id="L5415">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L5416">            }</span>
<span class="pc bpc" id="L5417" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5418">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc bfc" id="L5420" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L5421">                _addBuildersTo( thisComponent, view );</span>
            else
<span class="fc" id="L5423">                _addBuildersTo( thisComponent, attr, view );</span>
<span class="fc" id="L5424">        });</span>
<span class="fc" id="L5425">    }</span>

    private &lt;M&gt; void _updateSubViews(C innerComponent, @Nullable AddConstraint attr, ValsDelegate&lt;M&gt; delegate, ModelToViewConverter&lt;M&gt; viewSupplier) {
        // we simply redo all the components.
<span class="fc" id="L5429">        Vals&lt;M&gt; newValues = delegate.newValues();</span>
<span class="fc" id="L5430">        Vals&lt;M&gt; oldValues = delegate.oldValues();</span>
<span class="fc" id="L5431">        int index = delegate.index().orElse(-1);</span>

<span class="pc bpc" id="L5433" title="2 of 7 branches missed.">        switch ( delegate.change() ) {</span>
            case SET:
<span class="pc bpc" id="L5435" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5436">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L5437">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5438" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5439">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="fc" id="L5441">                    Tuple&lt;Component&gt; componentSnapshot = Tuple.of(Component.class, InternalUtil._actualComponentsFrom(innerComponent));</span>
<span class="fc" id="L5442">                    List&lt;Integer&gt; alreadyRemoved = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L5443" title="All 2 branches covered.">                    for ( int i = 0; i &lt; newValues.size(); i++ ) {</span>
<span class="fc" id="L5444">                        int position = i + index;</span>
<span class="fc" id="L5445">                        _updateComponentAt(position, newValues.at(i).get(), viewSupplier, attr, innerComponent, componentSnapshot, alreadyRemoved);</span>
                    }
                }
<span class="fc" id="L5448">                break;</span>
            case ADD:
<span class="pc bpc" id="L5450" title="2 of 4 branches missed.">                if ( index &lt; 0 || newValues.any(Val::isEmpty) ) {</span>
<span class="nc" id="L5451">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5452" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5453">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="fc bfc" id="L5455" title="All 2 branches covered.">                    for ( int i = 0; i &lt; newValues.size(); i++ ) {</span>
<span class="fc" id="L5456">                        int position = i + index;</span>
<span class="fc" id="L5457">                        _addComponentAt(position, newValues.at(i).orElseNull(), viewSupplier, attr, innerComponent);</span>
                    }
                }
<span class="fc" id="L5460">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L5462" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5463">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L5464">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5465" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5466">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="fc bfc" id="L5468" title="All 2 branches covered.">                    for ( int i = oldValues.size() - 1; i &gt;= 0; i-- ) {</span>
<span class="fc" id="L5469">                        int position = i + index;</span>
<span class="fc" id="L5470">                        _removeComponentAt(position, innerComponent);</span>
                    }
                }
<span class="fc" id="L5473">                break;</span>
<span class="fc" id="L5474">            case CLEAR: _clearComponentsOf(innerComponent); break;</span>
<span class="fc" id="L5475">            case REVERSE: _reverseComponentsOf(innerComponent); break;</span>
<span class="nc" id="L5476">            case NONE: break;</span>
            default:
<span class="nc" id="L5478">                log.error(&quot;Unknown change type: {}&quot;, delegate.change(), new Throwable());</span>
                // We do a simple rebuild:
<span class="nc" id="L5480">                Vals&lt;M&gt; currentValues = delegate.currentValues();</span>
<span class="nc" id="L5481">                _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5482" title="All 2 branches missed.">                for ( int i = 0; i &lt; currentValues.size(); i++ )</span>
<span class="nc" id="L5483">                    _addComponentAt( i, currentValues.at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
        }
<span class="fc" id="L5485">        int componentCount = InternalUtil._actualComponentCountFrom(innerComponent);</span>
<span class="pc bpc" id="L5486" title="1 of 2 branches missed.">        if ( componentCount != delegate.currentValues().size() )</span>
<span class="nc" id="L5487">            log.warn(</span>
                    &quot;Broken binding to view model list detected! \n&quot; +
                    &quot;UI sub-component count '&quot;+componentCount+&quot;' &quot; +
<span class="nc" id="L5490">                    &quot;does not match viewable models list of size '&quot;+delegate.currentValues().size()+&quot;'. \n&quot; +</span>
                    &quot;A possible cause for this is that components &quot; +
<span class="nc bnc" id="L5492" title="All 2 branches missed.">                    &quot;were &quot; + ( componentCount &gt; delegate.currentValues().size() ? &quot;added&quot; : &quot;removed&quot; ) + &quot; &quot; +</span>
                    &quot;to this '&quot; + innerComponent + &quot;' \ndirectly, instead of through the property list binding. \n&quot; +
                    &quot;However, this could also be a bug in the UI framework.&quot;,
                    new Throwable()
                );
<span class="fc" id="L5497">    }</span>

    private &lt;M&gt; void _bindTo( Val&lt;Tuple&lt;M&gt;&gt; models, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5500">        _checkComponentStateBeforeBinding(thisComponent);</span>
<span class="fc" id="L5501">        _addViewableProps(models, attr, ModelToViewConverter.of(thisComponent, viewSupplier, (model, exception)-&gt;{</span>
<span class="nc" id="L5502">            log.error(&quot;Error while creating view for '&quot;+model+&quot;'.&quot;, exception);</span>
<span class="nc" id="L5503">            return UI.box().get(JBox.class);</span>
        }), thisComponent);
<span class="fc" id="L5505">    }</span>

    private &lt;M extends HasId&lt;?&gt;&gt; void _bindTo(Var&lt;Tuple&lt;M&gt;&gt; models, @Nullable AddConstraint attr, BoundViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5508">        _checkComponentStateBeforeBinding(thisComponent);</span>
<span class="fc" id="L5509">        _addViewableProps(models, attr, ModelToViewConverter.of(thisComponent, (ViewHandle&lt;M&gt; handle)-&gt;viewSupplier.createViewFor(handle.property()), (model, exception)-&gt;{</span>
<span class="nc" id="L5510">            log.error(&quot;Error while creating view for '&quot;+model+&quot;'.&quot;, exception);</span>
<span class="nc" id="L5511">            return UI.box().get(JBox.class);</span>
        }), thisComponent);
<span class="fc" id="L5513">    }</span>

    // Overridden in UIForScrollPanels
    protected &lt;M&gt; void _addViewableProps(
        Val&lt;Tuple&lt;M&gt;&gt; models,
        @Nullable AddConstraint attr,
        ModelToViewConverter&lt;M&gt; viewSupplier,
        C thisComponent
    ) {
<span class="fc" id="L5522">        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L5523" title="1 of 2 branches missed.">        if (models.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L5524">            lastDiffRef.set(((SequenceDiffOwner)models.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L5525">        _onShowDelegated( models, thisComponent, (component, delegate) -&gt; {</span>
<span class="fc" id="L5526">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L5527">            _updateSubViews(component, delegate, attr, lastDiffRef, viewSupplier);</span>
<span class="fc" id="L5528">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L5529">        });</span>
<span class="fc" id="L5530">        Tuple&lt;M&gt; tupleOfModels = models.get();</span>
<span class="fc" id="L5531">        _addAllFromTuple(tupleOfModels, attr, viewSupplier, thisComponent);</span>
<span class="fc" id="L5532">    }</span>

    static class ViewHandle&lt;M&gt; {
        private @Nullable Var&lt;M&gt; property;
        private final WeakReference&lt;JComponent&gt; parent;
<span class="fc" id="L5537">        private @Nullable WeakReference&lt;JComponent&gt; child = null;</span>

<span class="fc" id="L5539">        ViewHandle( JComponent parent ) {</span>
<span class="fc" id="L5540">            this.parent = new WeakReference&lt;&gt;(parent);</span>
<span class="fc" id="L5541">        }</span>
        static &lt;M&gt; ViewHandle&lt;M&gt; of( Var&lt;Tuple&lt;M&gt;&gt; models, int initialIndex, JComponent parent ) {
<span class="fc" id="L5543">            ViewHandle&lt;M&gt; handle = new ViewHandle&lt;&gt;(Objects.requireNonNull(parent));</span>
<span class="fc" id="L5544">            Supplier&lt;Integer&gt; indexSupplier = ()-&gt;UI.runAndGet(()-&gt;{</span>
<span class="fc" id="L5545">                JComponent currentParent = handle.parent.get();</span>
<span class="fc" id="L5546">                JComponent currentSubView = handle.child();</span>
<span class="fc bfc" id="L5547" title="All 2 branches covered.">                if ( currentParent instanceof JScrollPanels) {</span>
<span class="fc" id="L5548">                    currentParent = ((JScrollPanels) currentParent).getContentPanel();</span>
                }
<span class="pc bpc" id="L5550" title="1 of 4 branches missed.">                if ( currentSubView == null || currentParent == null ) {</span>
<span class="fc" id="L5551">                    return initialIndex;</span>
                }
<span class="fc" id="L5553">                int componentCount = InternalUtil._actualComponentCountFrom(currentParent);</span>
<span class="fc bfc" id="L5554" title="All 2 branches covered.">                for ( int i = 0; i &lt; componentCount; i++ ) {</span>
                    try {
<span class="fc" id="L5556">                        Component child = InternalUtil._actualGetComponentAt(i, currentParent);</span>
<span class="fc bfc" id="L5557" title="All 2 branches covered.">                        if (child instanceof JScrollPanels.EntryPanel) {</span>
<span class="fc" id="L5558">                            child = ((JScrollPanels.EntryPanel) child).getComponent(0);</span>
                        }
<span class="fc bfc" id="L5560" title="All 2 branches covered.">                        if (child == currentSubView)</span>
<span class="fc" id="L5561">                            return i;</span>
<span class="nc" id="L5562">                    } catch (Exception e) {</span>
<span class="nc" id="L5563">                        log.error(&quot;Failed to check if child component is current.&quot;, e);</span>
<span class="fc" id="L5564">                    }</span>
                }
<span class="fc" id="L5566">                return -1;</span>
            });
<span class="fc" id="L5568">            TupleLens&lt;M&gt; lens = new TupleLens&lt;&gt;(models, indexSupplier, initialIndex);</span>
<span class="fc bfc" id="L5569" title="All 2 branches covered.">            if ( lens.allowsNull() )</span>
<span class="fc" id="L5570">                handle.property = models.zoomToNullable(models.orElseThrowUnchecked().type(), lens);</span>
            else
<span class="fc" id="L5572">                handle.property = models.zoomTo(lens);</span>
<span class="fc" id="L5573">            return handle;</span>
        }
<span class="fc" id="L5575">        public Var&lt;M&gt; property() {return Objects.requireNonNull(property);}</span>
<span class="nc" id="L5576">        public @Nullable JComponent parent() {return parent.get();}</span>
<span class="fc bfc" id="L5577" title="All 2 branches covered.">        public @Nullable JComponent child() {return child == null ? null : child.get();}</span>
<span class="fc" id="L5578">        public void setChild( JComponent child ) {this.child = new WeakReference&lt;&gt;(child);}</span>

    }

    private static class TupleLens&lt;M&gt; implements Lens&lt;Tuple&lt;M&gt;, M&gt; {

        private final Supplier&lt;Integer&gt; indexSupplier;
        private final AtomicReference&lt;M&gt; lastFetchedItem;
        private final boolean allowsNull;
        private final Class&lt;M&gt; type;

        public TupleLens(
            Var&lt;Tuple&lt;M&gt;&gt; models,
            Supplier&lt;Integer&gt; indexSupplier,
            int initialIndex
<span class="fc" id="L5593">        ) {</span>
<span class="fc" id="L5594">            Tuple&lt;M&gt; tuple = models.orElseThrowUnchecked();</span>
<span class="fc" id="L5595">            this.indexSupplier = indexSupplier;</span>
<span class="fc" id="L5596">            this.lastFetchedItem = new AtomicReference&lt;&gt;(null);</span>
<span class="fc" id="L5597">            this.allowsNull = tuple.allowsNull();</span>
<span class="fc" id="L5598">            this.type = tuple.type();</span>
<span class="pc bpc" id="L5599" title="2 of 4 branches missed.">            if ( initialIndex &gt;= 0 &amp;&amp; initialIndex &lt; tuple.size() ) {</span>
<span class="fc" id="L5600">                lastFetchedItem.set(tuple.get(initialIndex));</span>
            }
<span class="fc" id="L5602">        }</span>

        public boolean allowsNull() {
<span class="fc" id="L5605">            return allowsNull;</span>
        }

        @Override
        public M getter(Tuple&lt;M&gt; parentValue) throws Exception {
            try {
                // We get the index of the subview in the parent:
<span class="fc" id="L5612">                int index = indexSupplier.get();</span>
<span class="fc bfc" id="L5613" title="All 2 branches covered.">                if ( index &lt; 0 ) {</span>
<span class="fc" id="L5614">                    return tryAvoidNull(lastFetchedItem.get());</span>
                }
<span class="fc" id="L5616">                M currentItemAtIndex = parentValue.get(index);</span>
<span class="fc" id="L5617">                lastFetchedItem.set(currentItemAtIndex);</span>
<span class="fc" id="L5618">                return tryAvoidNull(currentItemAtIndex);</span>
<span class="nc" id="L5619">            } catch (Exception ignored) {</span>
                /*
                    Lenses on a position in a tuple are a tricky thing!
                    They can very easily break. Do we care? No, why should we?
                    This lens may still be bound to an old GUI, which we do not want to disturb.
                */
<span class="nc" id="L5625">                return tryAvoidNull(lastFetchedItem.get());</span>
            }
        }

        @Override
        public Tuple&lt;M&gt; wither(Tuple&lt;M&gt; parentValue, M newValue) throws Exception {
            try {
                // We get the index of the subview in the parent:
<span class="fc" id="L5633">                int index = indexSupplier.get();</span>
<span class="pc bpc" id="L5634" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5635">                    return parentValue;</span>
                }
<span class="fc" id="L5637">                return parentValue.setAt(index, newValue);</span>
<span class="nc" id="L5638">            } catch (Exception ignored) {</span>
                // The lens is no longer relevant! We do not care.
            }
<span class="nc" id="L5641">            return parentValue;</span>
        }

        private M tryAvoidNull(@Nullable M item) {
<span class="pc bpc" id="L5645" title="1 of 4 branches missed.">            if ( item != null || allowsNull ) {</span>
<span class="fc" id="L5646">                return NullUtil.fakeNonNull(item);</span>
<span class="nc bnc" id="L5647" title="All 2 branches missed.">            } else if ( type == String.class ) {</span>
<span class="nc" id="L5648">                return type.cast(&quot;&quot;);</span>
<span class="nc bnc" id="L5649" title="All 2 branches missed.">            } else if ( type == Integer.class ) {</span>
<span class="nc" id="L5650">                return type.cast(0);</span>
<span class="nc bnc" id="L5651" title="All 2 branches missed.">            } else if ( type == Boolean.class ) {</span>
<span class="nc" id="L5652">                return type.cast(false);</span>
<span class="nc bnc" id="L5653" title="All 2 branches missed.">            } else if ( type == Double.class ) {</span>
<span class="nc" id="L5654">                return type.cast(0.0);</span>
<span class="nc bnc" id="L5655" title="All 2 branches missed.">            } else if ( type == Float.class ) {</span>
<span class="nc" id="L5656">                return type.cast(0.0F);</span>
<span class="nc bnc" id="L5657" title="All 2 branches missed.">            } else if ( type == Short.class ) {</span>
<span class="nc" id="L5658">                return type.cast((short)0);</span>
<span class="nc bnc" id="L5659" title="All 2 branches missed.">            } else if ( type == Byte.class ) {</span>
<span class="nc" id="L5660">                return type.cast((byte)0);</span>
<span class="nc bnc" id="L5661" title="All 2 branches missed.">            }  else if ( type == Character.class ) {</span>
<span class="nc" id="L5662">                return type.cast((char)0);</span>
            }
<span class="nc" id="L5664">            return NullUtil.fakeNonNull(item);</span>
        }
    }

    // Overridden in UIForScrollPanels
    protected &lt;M&gt; void _addViewableProps(
        Var&lt;Tuple&lt;M&gt;&gt; models,
        @Nullable AddConstraint attr,
        ModelToViewConverter&lt;ViewHandle&lt;M&gt;&gt; viewSupplier,
        C thisComponent
    ) {
<span class="fc" id="L5675">        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L5676" title="1 of 2 branches missed.">        if (models.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L5677">            lastDiffRef.set(((SequenceDiffOwner)models.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L5678">        _onShowDelegated( models, thisComponent, (component, delegate) -&gt; {</span>
<span class="fc" id="L5679">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L5680">            _updateSubViews(component, delegate, models, attr, lastDiffRef, viewSupplier);</span>
<span class="fc" id="L5681">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L5682">        });</span>
<span class="fc" id="L5683">        _addAllFromTuple(models, attr, viewSupplier, thisComponent);</span>
<span class="fc" id="L5684">    }</span>

    private &lt;M&gt; void _updateSubViews(
        C innerComponent,
        ValDelegate&lt;Tuple&lt;M&gt;&gt; changeDelegate,
        @Nullable AddConstraint attr,
        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef,
        ModelToViewConverter&lt;M&gt; viewSupplier
    ) {
<span class="fc" id="L5693">        boolean isCurrentStateValid = _checkForTupleBindingConsistencyBeforeUpdate(innerComponent, changeDelegate);</span>
<span class="fc" id="L5694">        Tuple&lt;M&gt; tupleOfModels = changeDelegate.currentValue().orElseThrowUnchecked();</span>
<span class="pc bpc" id="L5695" title="1 of 2 branches missed.">        @Nullable SequenceDiff diff = !isCurrentStateValid ? null : _diffFrom(changeDelegate, lastDiffRef);</span>
<span class="fc bfc" id="L5696" title="All 2 branches covered.">        boolean success = diff != null;</span>
<span class="fc bfc" id="L5697" title="All 2 branches covered.">        if ( diff != null ) {</span>
            try {
<span class="fc" id="L5699">                int index = diff.index().orElse(-1);</span>
<span class="fc" id="L5700">                int count = diff.size();</span>
<span class="fc" id="L5701">                SequenceChange change = diff.change();</span>
<span class="fc" id="L5702">                _doInformedSubViewUpdate(index, count, change, innerComponent, tupleOfModels, attr, viewSupplier);</span>
<span class="nc" id="L5703">            } catch (Exception e) {</span>
<span class="nc" id="L5704">                log.error(</span>
                    &quot;Failed to perform an informed tuple bound view update, \n&quot; +
                    &quot;using sequence diff '{}' and models '{}'.&quot;,
                    diff, tupleOfModels, e
                );
<span class="nc" id="L5709">                success = false;</span>
<span class="fc" id="L5710">            }</span>
        }
<span class="fc bfc" id="L5712" title="All 2 branches covered.">        if ( !success ) {</span>
<span class="fc" id="L5713">            _clearComponentsOf(innerComponent);</span>
<span class="fc" id="L5714">            _addAllFromTuple(tupleOfModels, attr, viewSupplier, innerComponent);</span>
        }
<span class="fc" id="L5716">        _checkForTupleBindingConsistencyAfterUpdate(innerComponent, changeDelegate);</span>
<span class="fc" id="L5717">    }</span>

    private &lt;M&gt; void _doInformedSubViewUpdate(
        int index,
        int count,
        SequenceChange change,
        C c,
        Tuple&lt;M&gt; tupleOfModels,
        @Nullable AddConstraint attr,
        ModelToViewConverter&lt;M&gt; viewSupplier
    ) {
<span class="pc bpc" id="L5728" title="2 of 8 branches missed.">        switch (change) {</span>
            case SET:
<span class="pc bpc" id="L5730" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5731">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5732">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc" id="L5734">                    Tuple&lt;Component&gt; componentSnapshot = Tuple.of(Component.class, InternalUtil._actualComponentsFrom(c));</span>
<span class="fc" id="L5735">                    List&lt;Integer&gt; alreadyRemoved = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L5736" title="All 2 branches covered.">                    for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5737">                        _updateComponentAt(i, tupleOfModels.get(i), viewSupplier, attr, c, componentSnapshot, alreadyRemoved);</span>
                }
<span class="fc" id="L5739">                break;</span>
            case ADD:
<span class="pc bpc" id="L5741" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5742">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5743">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc bfc" id="L5745" title="All 2 branches covered.">                    for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5746">                        _addComponentAt(i, tupleOfModels.get(i), viewSupplier, attr, c);</span>
                }
<span class="fc" id="L5748">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L5750" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5751">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5752">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc bfc" id="L5754" title="All 2 branches covered.">                    for ( int i = (index + count - 1); i &gt;= index; i-- )</span>
<span class="fc" id="L5755">                        _removeComponentAt(i, c);</span>
                }
<span class="fc" id="L5757">                break;</span>
            case RETAIN: // Only keep the elements in the range.
<span class="pc bpc" id="L5759" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5760">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5761">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
                    // Remove trailing components:
<span class="fc" id="L5764">                    int componentCount = InternalUtil._actualComponentCountFrom(c);</span>
<span class="fc bfc" id="L5765" title="All 2 branches covered.">                    for ( int i = (componentCount - 1); i &gt;= (index + count); i-- )</span>
<span class="fc" id="L5766">                        _removeComponentAt(i, c);</span>
                    // Remove leading components:
<span class="fc bfc" id="L5768" title="All 2 branches covered.">                    for ( int i = (index - 1); i &gt;= 0; i-- )</span>
<span class="fc" id="L5769">                        _removeComponentAt(i, c);</span>
                }
<span class="fc" id="L5771">                break;</span>
<span class="fc" id="L5772">            case CLEAR: _clearComponentsOf(c); break;</span>
<span class="fc" id="L5773">            case REVERSE: _reverseComponentsOf(c); break;</span>
            case NONE:
<span class="nc" id="L5775">                break;</span>
            default:
<span class="nc" id="L5777">                log.error(&quot;Unknown change type: {}&quot;, change, new Throwable());</span>
                // We do a simple rebuild:
<span class="nc" id="L5779">                _clearComponentsOf(c);</span>
<span class="nc" id="L5780">                _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
        }
<span class="fc" id="L5782">    }</span>

    private &lt;M&gt; void _updateSubViews(
        C innerComponent,
        ValDelegate&lt;Tuple&lt;M&gt;&gt; changeDelegate,
        Var&lt;Tuple&lt;M&gt;&gt; tupleOfModels,
        @Nullable AddConstraint attr,
        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef,
        ModelToViewConverter&lt;ViewHandle&lt;M&gt;&gt; viewSupplier
    ) {
<span class="fc" id="L5792">        boolean isCurrentStateValid = _checkForTupleBindingConsistencyBeforeUpdate(innerComponent, changeDelegate);</span>
<span class="pc bpc" id="L5793" title="1 of 2 branches missed.">        @Nullable SequenceDiff diff = !isCurrentStateValid ? null : _diffFrom(changeDelegate, lastDiffRef);</span>
<span class="fc bfc" id="L5794" title="All 2 branches covered.">        boolean success = diff != null;</span>
<span class="fc bfc" id="L5795" title="All 2 branches covered.">        if ( diff != null ) {</span>
            try {
<span class="fc" id="L5797">                int index = diff.index().orElse(-1);</span>
<span class="fc" id="L5798">                int count = diff.size();</span>
<span class="fc" id="L5799">                SequenceChange change = diff.change();</span>
<span class="fc" id="L5800">                _doInformedSubViewUpdate(index, count, change, innerComponent, tupleOfModels, attr, viewSupplier);</span>
<span class="nc" id="L5801">            } catch (Exception e) {</span>
<span class="nc" id="L5802">                log.error(</span>
                    &quot;Failed to perform an informed tuple bound view update, \n&quot; +
                    &quot;using sequence diff '{}' and models '{}'.&quot;,
                    diff, tupleOfModels, e
                );
<span class="nc" id="L5807">                success = false;</span>
<span class="fc" id="L5808">            }</span>
        }
<span class="fc bfc" id="L5810" title="All 2 branches covered.">        if ( !success ) {</span>
<span class="fc" id="L5811">            _clearComponentsOf(innerComponent);</span>
<span class="fc" id="L5812">            _addAllFromTuple(tupleOfModels, attr, viewSupplier, innerComponent);</span>
        }
<span class="fc" id="L5814">        _checkForTupleBindingConsistencyAfterUpdate(innerComponent, changeDelegate);</span>
<span class="fc" id="L5815">    }</span>

    private static &lt;T&gt; @Nullable SequenceDiff _diffFrom(ValDelegate&lt;Tuple&lt;T&gt;&gt; delegate, AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef) {
<span class="fc" id="L5818">        @Nullable Tuple&lt;T&gt; oldValue = delegate.oldValue().orElseNull();</span>
<span class="fc" id="L5819">        Tuple&lt;T&gt; currentValue = delegate.currentValue().orElseThrowUnchecked();</span>
<span class="fc" id="L5820">        SequenceDiff diff = null;</span>
<span class="fc" id="L5821">        SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L5822" title="1 of 2 branches missed.">        if (currentValue instanceof SequenceDiffOwner)</span>
<span class="fc" id="L5823">            diff = ((SequenceDiffOwner)currentValue).differenceFromPrevious().orElse(null);</span>
<span class="pc bpc" id="L5824" title="2 of 6 branches missed.">        if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) )</span>
<span class="fc" id="L5825">            diff = _tryCalculatingDiffBetween(oldValue, currentValue);</span>
<span class="fc" id="L5826">        lastDiffRef.set(diff);</span>
<span class="fc" id="L5827">        return diff;</span>
    }

    private &lt;M&gt; void _doInformedSubViewUpdate(
        int index,
        int count,
        SequenceChange change,
        C c,
        Var&lt;Tuple&lt;M&gt;&gt; tupleOfModels,
        @Nullable AddConstraint attr,
        ModelToViewConverter&lt;ViewHandle&lt;M&gt;&gt; viewSupplier
    ) {
<span class="pc bpc" id="L5839" title="2 of 8 branches missed.">        switch (change) {</span>
            case SET:
<span class="pc bpc" id="L5841" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5842">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5843">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc" id="L5845">                    Tuple&lt;Component&gt; componentSnapshot = Tuple.of(Component.class, InternalUtil._actualComponentsFrom(c));</span>
<span class="fc" id="L5846">                    List&lt;Integer&gt; alreadyRemoved = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L5847" title="All 2 branches covered.">                    for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5848">                        _updateComponentAt(i, tupleOfModels, viewSupplier, attr, c, componentSnapshot, alreadyRemoved);</span>
                }
<span class="fc" id="L5850">                break;</span>
            case ADD:
<span class="pc bpc" id="L5852" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5853">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5854">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc bfc" id="L5856" title="All 2 branches covered.">                    for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5857">                        _addComponentAt(i, tupleOfModels, viewSupplier, attr, c);</span>
                }
<span class="fc" id="L5859">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L5861" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5862">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5863">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
<span class="fc bfc" id="L5865" title="All 2 branches covered.">                    for ( int i = (index + count - 1); i &gt;= index; i-- )</span>
<span class="fc" id="L5866">                        _removeComponentAt(i, c);</span>
                }
<span class="fc" id="L5868">                break;</span>
            case RETAIN: // Only keep the elements in the range.
<span class="pc bpc" id="L5870" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5871">                    _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5872">                    _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                } else {
                    // Remove trailing components:
<span class="fc" id="L5875">                    int componentCount = InternalUtil._actualComponentCountFrom(c);</span>
<span class="fc bfc" id="L5876" title="All 2 branches covered.">                    for ( int i = (componentCount - 1); i &gt;= (index + count); i-- )</span>
<span class="fc" id="L5877">                        _removeComponentAt(i, c);</span>
                    // Remove leading components:
<span class="fc bfc" id="L5879" title="All 2 branches covered.">                    for ( int i = (index - 1); i &gt;= 0; i-- )</span>
<span class="fc" id="L5880">                        _removeComponentAt(i, c);</span>
                }
<span class="fc" id="L5882">                break;</span>
<span class="fc" id="L5883">            case CLEAR: _clearComponentsOf(c); break;</span>
<span class="fc" id="L5884">            case REVERSE: _reverseComponentsOf(c); break;</span>
            case NONE:
<span class="nc" id="L5886">                break;</span>
            default:
<span class="nc" id="L5888">                log.error(&quot;Unknown change type: {}&quot;, change, new Throwable());</span>
                // We do a simple rebuild:
<span class="nc" id="L5890">                _clearComponentsOf(c);</span>
<span class="nc" id="L5891">                _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
        }
<span class="fc" id="L5893">    }</span>

    private &lt;M&gt; void _addAllFromTuple( Tuple&lt;M&gt; tupleOfModels, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc bfc" id="L5896" title="All 2 branches covered.">        for ( int i = 0; i &lt; tupleOfModels.size(); i++ ) {</span>
<span class="fc" id="L5897">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5899">                view = viewSupplier.createViewFor(tupleOfModels.get(i));</span>
<span class="nc" id="L5900">            } catch ( Exception e ) {</span>
<span class="nc" id="L5901">                log.error(&quot;Error while creating view for '&quot;+tupleOfModels.get(i)+&quot;'.&quot;, e);</span>
<span class="fc" id="L5902">            }</span>
<span class="pc bpc" id="L5903" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5904">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc bfc" id="L5906" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L5907">                _addBuildersTo( thisComponent, view );</span>
            else
<span class="fc" id="L5909">                _addBuildersTo( thisComponent, attr, view );</span>
        }
<span class="fc" id="L5911">    }</span>

    private &lt;M&gt; void _addAllFromTuple( Var&lt;Tuple&lt;M&gt;&gt; tupleOfModels, @Nullable AddConstraint attr, ViewSupplier&lt;ViewHandle&lt;M&gt;&gt; viewSupplier, C thisComponent ) {
<span class="fc bfc" id="L5914" title="All 2 branches covered.">        for ( int i = 0; i &lt; tupleOfModels.get().size(); i++ ) {</span>
<span class="fc" id="L5915">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5917">                view = viewSupplier.createViewFor(ViewHandle.of(tupleOfModels, i, thisComponent));</span>
<span class="nc" id="L5918">            } catch ( Exception e ) {</span>
<span class="nc" id="L5919">                log.error(&quot;Error while creating view for '&quot;+tupleOfModels.get().get(i)+&quot;'.&quot;, e);</span>
<span class="fc" id="L5920">            }</span>
<span class="pc bpc" id="L5921" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5922">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc bfc" id="L5924" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L5925">                _addBuildersTo( thisComponent, view );</span>
            else
<span class="fc" id="L5927">                _addBuildersTo( thisComponent, attr, view );</span>
        }
<span class="fc" id="L5929">    }</span>

    private &lt;M&gt; void _addViewablePropTo(
        C thisComponent, Val&lt;M&gt; viewable, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier
    ) {
        // First we remember the index of the component which will be provided by the viewable dynamically.
<span class="fc" id="L5935">        final int index = InternalUtil._actualComponentCountFrom(thisComponent);</span>
        // Then we add the component provided by the viewable to the list of children.
<span class="fc bfc" id="L5937" title="All 2 branches covered.">        if ( attr == null ) {</span>
<span class="fc bfc" id="L5938" title="All 2 branches covered.">            if ( viewable.isPresent() ) {</span>
<span class="fc" id="L5939">                UIForAnySwing&lt;?, ?&gt; view = null;</span>
                try {
<span class="fc" id="L5941">                    view = viewSupplier.createViewFor(viewable.get());</span>
<span class="nc" id="L5942">                } catch ( Exception e ) {</span>
<span class="nc" id="L5943">                    log.error(&quot;Error while creating view for '{}'.&quot;, viewable.orElseNull(), e);</span>
<span class="fc" id="L5944">                }</span>
<span class="pc bpc" id="L5945" title="1 of 2 branches missed.">                if ( view == null )</span>
<span class="nc" id="L5946">                    view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L5948">                _addBuildersTo(thisComponent, view);</span>
<span class="fc" id="L5949">            } else</span>
<span class="fc" id="L5950">                _addComponentsTo(thisComponent, new JPanel()); // We add a dummy component to the list of children.</span>
        } else {
<span class="pc bpc" id="L5952" title="1 of 2 branches missed.">            if ( viewable.isPresent() ) {</span>
<span class="fc" id="L5953">                UIForAnySwing&lt;?, ?&gt; view = null;</span>
                try {
<span class="fc" id="L5955">                    view = viewSupplier.createViewFor(viewable.get());</span>
<span class="nc" id="L5956">                } catch ( Exception e ) {</span>
<span class="nc" id="L5957">                    log.error(&quot;Error while creating view for '{}'.&quot;, viewable.orElseNull(), e);</span>
<span class="fc" id="L5958">                }</span>
<span class="pc bpc" id="L5959" title="1 of 2 branches missed.">                if ( view == null )</span>
<span class="nc" id="L5960">                    view = UI.box(); // We add a dummy component to the list of children.</span>
<span class="fc" id="L5961">                _addBuildersTo(thisComponent, attr, view);</span>
<span class="fc" id="L5962">            } else</span>
<span class="nc" id="L5963">                _addComponentsTo(thisComponent, attr, new JPanel()); // We add a dummy component to the list of children.</span>
        }
        // Finally we add a listener to the viewable which will update the component when the viewable changes.
<span class="fc" id="L5966">        _onShow( viewable, thisComponent, (c,v) -&gt; {</span>
<span class="fc" id="L5967">            Tuple&lt;Component&gt; componentSnapshot = Tuple.of(Component.class, InternalUtil._actualComponentsFrom(c));</span>
<span class="fc" id="L5968">            List&lt;Integer&gt; alreadyRemoved = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L5969">            _updateComponentAt(index, v, viewSupplier, attr, c, componentSnapshot, alreadyRemoved);</span>
<span class="fc" id="L5970">        });</span>
<span class="fc" id="L5971">    }</span>

    private &lt;M&gt; void _updateComponentAt(
        int index,
        @Nullable M v,
        ViewSupplier&lt;M&gt; viewSupplier,
        @Nullable AddConstraint attr, C c,
        Tuple&lt;Component&gt; componentSnapshot,
        List&lt;Integer&gt; alreadyRemoved
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L5982" title="1 of 2 branches missed.">        if ( v == null ) {</span>
<span class="nc" id="L5983">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L5985">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5987">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L5988">            } catch ( Exception e ) {</span>
<span class="nc" id="L5989">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L5990">            }</span>
<span class="pc bpc" id="L5991" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5992">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L5994">            newComponent = view.get((Class)view.getType());</span>
        }
<span class="fc" id="L5996">        Component currentComponentAtIndex = componentSnapshot.get(index);</span>
<span class="fc bfc" id="L5997" title="All 2 branches covered.">        if ( currentComponentAtIndex != newComponent ) { // Avoid unnecessary changes</span>
<span class="fc" id="L5998">            int indexOfNewComponent = componentSnapshot.firstIndexOf(newComponent);</span>
<span class="fc bfc" id="L5999" title="All 2 branches covered.">            if ( indexOfNewComponent &gt;= 0 ) {</span>
                // The component already exists! We remove it
<span class="fc" id="L6001">                c.remove(newComponent);</span>
<span class="fc" id="L6002">                alreadyRemoved.add(indexOfNewComponent);</span>
            }
<span class="fc bfc" id="L6004" title="All 2 branches covered.">            if ( !alreadyRemoved.contains(index) ) {</span>
                // We remove the old component.
<span class="fc" id="L6006">                c.remove(currentComponentAtIndex);</span>
            }
            // We add the new component:
<span class="pc bpc" id="L6009" title="1 of 2 branches missed.">            if ( attr == null )</span>
<span class="fc" id="L6010">                c.add(newComponent, index);</span>
            else
<span class="nc" id="L6012">                c.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
            // We update the layout.
<span class="fc" id="L6014">            c.revalidate();</span>
<span class="fc" id="L6015">            c.repaint();</span>
        }
<span class="fc" id="L6017">    }</span>

    private &lt;M&gt; void _updateComponentAt(
        int index,
        Var&lt;Tuple&lt;M&gt;&gt; v,
        ViewSupplier&lt;ViewHandle&lt;M&gt;&gt; viewSupplier,
        @Nullable AddConstraint attr,
        C c,
        Tuple&lt;Component&gt; componentSnapshot,
        List&lt;Integer&gt; alreadyRemoved
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L6029" title="1 of 2 branches missed.">        if ( v == null ) {</span>
<span class="nc" id="L6030">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L6032">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L6034">                view = viewSupplier.createViewFor(ViewHandle.of(v, index, c));</span>
<span class="nc" id="L6035">            } catch ( Exception e ) {</span>
<span class="nc" id="L6036">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L6037">            }</span>
<span class="pc bpc" id="L6038" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L6039">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L6041">            newComponent = view.get((Class)view.getType());</span>
        }
<span class="fc" id="L6043">        Component currentComponentAtIndex = componentSnapshot.get(index);</span>
<span class="fc bfc" id="L6044" title="All 2 branches covered.">        if ( currentComponentAtIndex != newComponent ) { // Avoid unnecessary changes</span>
<span class="fc" id="L6045">            int indexOfNewComponent = componentSnapshot.firstIndexOf(newComponent);</span>
<span class="fc bfc" id="L6046" title="All 2 branches covered.">            if ( indexOfNewComponent &gt;= 0 ) {</span>
                // The component already exists! We remove it
<span class="fc" id="L6048">                c.remove(newComponent);</span>
<span class="fc" id="L6049">                alreadyRemoved.add(indexOfNewComponent);</span>
            }
<span class="fc bfc" id="L6051" title="All 2 branches covered.">            if ( !alreadyRemoved.contains(index) ) {</span>
                // We remove the old component.
<span class="fc" id="L6053">                c.remove(currentComponentAtIndex);</span>
            }
            // We add the new component:
<span class="fc bfc" id="L6056" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L6057">                c.add(newComponent, index);</span>
            else
<span class="fc" id="L6059">                c.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
            // We update the layout.
<span class="fc" id="L6061">            c.revalidate();</span>
<span class="fc" id="L6062">            c.repaint();</span>
        }
<span class="fc" id="L6064">    }</span>

    private &lt;M&gt; void _addComponentAt(
        int index, @Nullable M v, ViewSupplier&lt;M&gt; viewSupplier, @Nullable AddConstraint attr, C thisComponent
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L6070" title="1 of 2 branches missed.">        if ( v == null ) {</span>
<span class="nc" id="L6071">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L6073">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L6075">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L6076">            } catch ( Exception e ) {</span>
<span class="nc" id="L6077">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L6078">            }</span>
<span class="pc bpc" id="L6079" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L6080">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L6082">            newComponent = view.get((Class)view.getType());</span>
        }
        // We add the new component.
<span class="fc bfc" id="L6085" title="All 2 branches covered.">        if ( attr == null )</span>
<span class="fc" id="L6086">            thisComponent.add(newComponent, index);</span>
        else
<span class="fc" id="L6088">            thisComponent.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
        // We update the layout.
<span class="fc" id="L6090">        thisComponent.revalidate();</span>
<span class="fc" id="L6091">        thisComponent.repaint();</span>
<span class="fc" id="L6092">    }</span>

    private &lt;M&gt; void _addComponentAt(
        int index, Var&lt;Tuple&lt;M&gt;&gt; v, ViewSupplier&lt;ViewHandle&lt;M&gt;&gt; viewSupplier, @Nullable AddConstraint attr, C thisComponent
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L6098" title="2 of 4 branches missed.">        if ( v.isEmpty() || v.get().isEmpty() ) {</span>
<span class="nc" id="L6099">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L6101">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L6103">                view = viewSupplier.createViewFor(ViewHandle.of(v, index, thisComponent));</span>
<span class="nc" id="L6104">            } catch ( Exception e ) {</span>
<span class="nc" id="L6105">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L6106">            }</span>
<span class="pc bpc" id="L6107" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L6108">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L6110">            newComponent = view.get((Class)view.getType());</span>
        }
        // We add the new component.
<span class="pc bpc" id="L6113" title="1 of 2 branches missed.">        if ( attr == null )</span>
<span class="fc" id="L6114">            thisComponent.add(newComponent, index);</span>
        else
<span class="nc" id="L6116">            thisComponent.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
        // We update the layout.
<span class="fc" id="L6118">        thisComponent.revalidate();</span>
<span class="fc" id="L6119">        thisComponent.repaint();</span>
<span class="fc" id="L6120">    }</span>

    private void _removeComponentAt( int index, C thisComponent )
    {
<span class="pc bpc" id="L6124" title="1 of 2 branches missed.">        if ( index &lt; 0 ) {</span>
<span class="nc" id="L6125">            log.error(</span>
                &quot;Cannot remove sub-component of '&quot;+thisComponent+&quot;' \n&quot; +
                &quot;at index '&quot;+index+&quot;' because the index is negative.&quot;,
                new Throwable()
            );
        } else {
<span class="fc" id="L6131">            int numberOfExistingComponents = InternalUtil._actualComponentCountFrom(thisComponent);</span>
<span class="pc bpc" id="L6132" title="1 of 2 branches missed.">            if (index &gt;= numberOfExistingComponents) {</span>
<span class="nc" id="L6133">                log.error(</span>
                    &quot;Cannot remove sub-component of '&quot; + thisComponent + &quot;' \n&quot; +
                    &quot;at index '&quot; + index + &quot;' because there it currently only has '&quot; + numberOfExistingComponents + &quot;' &quot; +
                    &quot;sub-components instead of at least '&quot; + (index + 1) + &quot;' sub-components.&quot;,
                    new Throwable()
                );
            } else {
                // We get the component at the specified index.
<span class="fc" id="L6141">                Component component = InternalUtil._actualGetComponentAt(index, thisComponent);</span>
<span class="pc bpc" id="L6142" title="1 of 2 branches missed.">                if ( component == null ) {</span>
<span class="nc" id="L6143">                    log.error(</span>
                        &quot;Cannot remove sub-component of '&quot; + thisComponent + &quot;' \n&quot; +
                        &quot;at index '&quot; + index + &quot;' because there is no component at that index.&quot;,
                        new Throwable()
                    );
                } else {
                    // We remove the component.
<span class="fc" id="L6150">                    thisComponent.remove(component);</span>
                    // We update the layout.
<span class="fc" id="L6152">                    thisComponent.revalidate();</span>
<span class="fc" id="L6153">                    thisComponent.repaint();</span>
                }
            }
        }
<span class="fc" id="L6157">    }</span>

    private void _checkComponentStateBeforeBinding(C thisComponent) {
<span class="fc bfc" id="L6160" title="All 2 branches covered.">        JComponent contentComponent = (thisComponent instanceof JScrollPanels</span>
<span class="fc" id="L6161">                                        ? ((JScrollPanels)thisComponent).getContentPanel()</span>
<span class="fc" id="L6162">                                        : thisComponent);</span>
<span class="fc" id="L6163">        int componentCount = InternalUtil._actualComponentCountFrom(contentComponent);</span>
<span class="fc bfc" id="L6164" title="All 2 branches covered.">        if ( componentCount &gt; 0 ) {</span>
<span class="fc" id="L6165">            log.error(</span>
                &quot;Trying to bind multiple sub-views to component '{}' despite it already being \n&quot; +
                &quot;the owner of '{}' sub-components added before the 'addAll' binding call! \n&quot; +
                &quot;If you use any of the bi-directionally binding 'addAll' methods, you may not \n&quot; +
                &quot;add sub-views through a regular 'add' or any other way. Clearing component now...&quot;,
<span class="fc" id="L6170">                    contentComponent, componentCount, new Throwable()</span>
            );
<span class="fc" id="L6172">            _clearComponentsOf(contentComponent);</span>
        }
<span class="fc" id="L6174">    }</span>

    private static &lt;T&gt; boolean _checkForTupleBindingConsistencyBeforeUpdate(
        JComponent innerComponent, ValDelegate&lt;Tuple&lt;T&gt;&gt; changeDelegate
    ) {
<span class="fc" id="L6179">        boolean isCurrentStateValid = true;</span>
<span class="fc" id="L6180">        int currentComponentCount = InternalUtil._actualComponentCountFrom(innerComponent);</span>
<span class="fc" id="L6181">        int expectedComponentCount = changeDelegate.oldValue().mapTo(Integer.class, Tuple::size).orElse(currentComponentCount);</span>
<span class="pc bpc" id="L6182" title="1 of 2 branches missed.">        if ( currentComponentCount != expectedComponentCount ) {</span>
<span class="nc" id="L6183">            log.error(</span>
                &quot;Trying to update 'addAll' tuple property based binding to component '{}' \n&quot; +
                &quot;with an unexpected number of '{}' sub-components despite the previous tuple \n&quot; +
                &quot;implying a number of '{}' components instead!\n&quot; +
                &quot;If you use any of the bi-directionally binding 'addAll' methods, you may not \n&quot; +
                &quot;add sub-views through a regular 'add' or any other way. Clearing component now...&quot;,
<span class="nc" id="L6189">                innerComponent, currentComponentCount, expectedComponentCount, new Throwable()</span>
            );
<span class="nc" id="L6191">            isCurrentStateValid = false;</span>
        }
<span class="fc" id="L6193">        return isCurrentStateValid;</span>
    }

    private static &lt;T&gt; void _checkForTupleBindingConsistencyAfterUpdate(
        JComponent innerComponent, ValDelegate&lt;Tuple&lt;T&gt;&gt; changeDelegate
    ) {
<span class="fc" id="L6199">        Tuple&lt;T&gt; tupleOfModels = changeDelegate.currentValue().orElseThrowUnchecked();</span>
<span class="fc" id="L6200">        int currentComponentCount = InternalUtil._actualComponentCountFrom(innerComponent);</span>
<span class="pc bpc" id="L6201" title="1 of 2 branches missed.">        if ( currentComponentCount != tupleOfModels.size() )</span>
<span class="nc" id="L6202">            log.warn(</span>
                    &quot;Broken binding to view model tuple detected! \n&quot; +
                    &quot;UI sub-component count '{}' does not match the bound tuple of size '{}'. \n&quot; +
                    &quot;A possible cause for this is that components were {} this '{}' \n&quot; +
                    &quot;directly, instead of through the property tuple binding. \n&quot; +
                    &quot;However, this could also be a bug in the UI framework.&quot;,
<span class="nc" id="L6208">                    currentComponentCount, tupleOfModels.size(),</span>
<span class="nc bnc" id="L6209" title="All 2 branches missed.">                    currentComponentCount &gt; tupleOfModels.size() ? &quot;added to&quot; : &quot;removed from&quot;,</span>
                    innerComponent,
                    new Throwable()
                );
<span class="fc" id="L6213">    }</span>

    private void _clearComponentsOf( JComponent thisComponent ) {
        // We remove all components.
<span class="fc" id="L6217">        thisComponent.removeAll();</span>
        // We update the layout.
<span class="fc" id="L6219">        thisComponent.revalidate();</span>
<span class="fc" id="L6220">        thisComponent.repaint();</span>
<span class="fc" id="L6221">    }</span>

    private void _reverseComponentsOf(C thisComponent ) {
        // save to a list
<span class="fc" id="L6225">        List&lt;Component&gt; components = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L6226">        Collections.addAll(components, InternalUtil._actualComponentsFrom(thisComponent));</span>
        // We remove all components.
<span class="fc" id="L6228">        thisComponent.removeAll();</span>
        // Reverse the list
<span class="fc" id="L6230">        Collections.reverse(components);</span>
        // Add the components back in reverse order
<span class="fc" id="L6232">        components.forEach(thisComponent::add);</span>
<span class="fc" id="L6233">    }</span>

    private static boolean _isBorderLayout( Object o ) {
<span class="fc bfc" id="L6236" title="All 2 branches covered.">        return BorderLayout.CENTER.equals(o)     ||</span>
<span class="fc bfc" id="L6237" title="All 2 branches covered.">               BorderLayout.PAGE_START.equals(o) ||</span>
<span class="fc bfc" id="L6238" title="All 2 branches covered.">               BorderLayout.PAGE_END.equals(o)   ||</span>
<span class="fc bfc" id="L6239" title="All 2 branches covered.">               BorderLayout.LINE_END.equals(o)   ||</span>
<span class="fc bfc" id="L6240" title="All 2 branches covered.">               BorderLayout.LINE_START.equals(o) ||</span>
<span class="pc bpc" id="L6241" title="1 of 2 branches missed.">               BorderLayout.EAST.equals(o)       ||</span>
<span class="pc bpc" id="L6242" title="1 of 2 branches missed.">               BorderLayout.WEST.equals(o)       ||</span>
<span class="pc bpc" id="L6243" title="1 of 2 branches missed.">               BorderLayout.NORTH.equals(o)      ||</span>
<span class="pc bpc" id="L6244" title="1 of 2 branches missed.">               BorderLayout.SOUTH.equals(o);</span>
    }


    protected static @Nullable SequenceDiff _tryCalculatingDiffBetween(@Nullable Tuple&lt;?&gt; previous, @Nullable Tuple&lt;?&gt; current) {
<span class="pc bpc" id="L6249" title="2 of 4 branches missed.">        if ( previous == null || current == null )</span>
<span class="nc" id="L6250">            return null;</span>

<span class="fc" id="L6252">        final int MAX_SIZE = 256;</span>
<span class="pc bpc" id="L6253" title="2 of 4 branches missed.">        if (previous.size() &gt; MAX_SIZE || current.size() &gt; MAX_SIZE) {</span>
<span class="nc bnc" id="L6254" title="All 2 branches missed.">            if (previous.size() == current.size()) {</span>
                // We do a basic set across the entire range:
<span class="nc" id="L6256">                return SequenceDiff.of(previous, SequenceChange.SET, 0, current.size());</span>
            }
<span class="nc" id="L6258">            return null;</span>
        }

<span class="pc bpc" id="L6261" title="1 of 2 branches missed.">        if (previous.equals(current)) {</span>
<span class="nc" id="L6262">            return SequenceDiff.of(previous, SequenceChange.NONE, 0, 0);</span>
        }

<span class="pc bpc" id="L6265" title="1 of 2 branches missed.">        if (current.isEmpty()) {</span>
<span class="nc" id="L6266">            return SequenceDiff.of(previous, SequenceChange.CLEAR, 0, previous.size());</span>
        }

<span class="pc bpc" id="L6269" title="1 of 2 branches missed.">        if (previous.isEmpty()) {</span>
<span class="nc" id="L6270">            return SequenceDiff.of(previous, SequenceChange.ADD, 0, current.size());</span>
        }

        // Check for set sequence:
<span class="fc" id="L6274">        boolean foundAllLeading = false;</span>
<span class="fc" id="L6275">        int numberOfLeadingEqual = 0;</span>
<span class="fc" id="L6276">        boolean foundAllTrailing = false;</span>
<span class="fc" id="L6277">        int numberOfTrailingEqual = 0;</span>
<span class="fc" id="L6278">        int commonSize = Math.min(previous.size(), current.size());</span>
<span class="fc bfc" id="L6279" title="All 2 branches covered.">        for ( int i = 0; i &lt; commonSize; i++ ) {</span>
<span class="fc bfc" id="L6280" title="All 2 branches covered.">            if ( !foundAllLeading ) {</span>
<span class="fc" id="L6281">                Object leadingPrevious = previous.get(i);</span>
<span class="fc" id="L6282">                Object leadingCurrent = current.get(i);</span>
<span class="pc bpc" id="L6283" title="1 of 2 branches missed.">                if ( Objects.equals(leadingPrevious, leadingCurrent) )</span>
<span class="nc" id="L6284">                    numberOfLeadingEqual++;</span>
                else
<span class="fc" id="L6286">                    foundAllLeading = true;</span>
            }
<span class="fc bfc" id="L6288" title="All 2 branches covered.">            if ( !foundAllTrailing ) {</span>
<span class="fc" id="L6289">                Object trailingPrevious = previous.get(previous.size() - 1 - i);</span>
<span class="fc" id="L6290">                Object trailingCurrent = current.get(current.size() - 1 - i);</span>
<span class="pc bpc" id="L6291" title="1 of 2 branches missed.">                if ( Objects.equals(trailingPrevious, trailingCurrent) )</span>
<span class="nc" id="L6292">                    numberOfTrailingEqual++;</span>
                else
<span class="fc" id="L6294">                    foundAllTrailing = true;</span>
            }
        }

<span class="fc bfc" id="L6298" title="All 2 branches covered.">        if (previous.size() == current.size()) {</span>
            // We swap out changes in the middle!
<span class="fc" id="L6300">            int changesInTheMiddle = (commonSize - numberOfLeadingEqual - numberOfTrailingEqual);</span>
<span class="fc" id="L6301">            return SequenceDiff.of(previous, SequenceChange.SET, numberOfLeadingEqual, changesInTheMiddle);</span>
        }

<span class="fc" id="L6304">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>