<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAnySwing.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAnySwing.java</span></div><h1>UIForAnySwing.java</h1><pre class="source lang-java linenums">package swingtree;


import net.miginfocom.layout.AC;
import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.Action;
import sprouts.Event;
import sprouts.Observable;
import sprouts.Observer;
import sprouts.*;
import sprouts.impl.SequenceDiff;
import sprouts.impl.SequenceDiffOwner;
import swingtree.animation.AnimationDispatcher;
import swingtree.animation.AnimationStatus;
import swingtree.animation.LifeTime;
import swingtree.api.*;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.components.JBox;
import swingtree.input.Keyboard;
import swingtree.layout.AddConstraint;
import swingtree.layout.LayoutConstraint;
import swingtree.layout.ResponsiveGridFlowLayout;
import swingtree.layout.Size;
import swingtree.style.ComponentExtension;

import javax.swing.Timer;
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import java.awt.*;
import java.awt.dnd.DragSource;
import java.awt.dnd.DropTarget;
import java.awt.event.*;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Function;


/**
 *  A generic SwingTree builder node designed as a basis for configuring any kind of {@link JComponent} instance.
 *  This is the most generic builder type and therefore abstract super-type for almost all other builders.
 *  This builder defines nested building for anything extending the {@link JComponent} class.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *  &lt;br&gt;&lt;br&gt;
 *
 * @param &lt;I&gt; The concrete extension of the {@link UIForAnything}.
 * @param &lt;C&gt; The type parameter for the component type wrapped by an instance of this class.
 */
<span class="fc" id="L61">public abstract class UIForAnySwing&lt;I, C extends JComponent&gt; extends UIForAnything&lt;I, C, JComponent&gt;</span>
{
<span class="fc" id="L63">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(UIForAnySwing.class);</span>

    private final static String _TIMERS_KEY = &quot;_swing-tree.timers&quot;;


    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedFont( Font font ) {
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        return font == UI.Font.UNDEFINED;</span>
    }

    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedColor( Color color ) {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        return color == UI.Color.UNDEFINED;</span>
    }

    private void _bindRepaintOn( JComponent thisComponent, Observable event ) {
<span class="nc" id="L79">        event.subscribe( () -&gt; _runInUI( thisComponent::repaint ) );</span>
<span class="nc" id="L80">    }</span>

    private void _bindRepaintOn( JComponent thisComponent, Event event ) {
<span class="fc" id="L83">        Observable.cast(event).subscribe(</span>
<span class="pc" id="L84">            Observer.ofWeak(thisComponent, innerComponent -&gt; _runInUI(innerComponent::repaint) )</span>
        );
<span class="fc" id="L86">    }</span>

    private void _bindRepaintOn( JComponent thisComponent, Val&lt;?&gt; event ) {
<span class="fc" id="L89">        Viewable.cast(event).subscribe(</span>
<span class="pc" id="L90">            Observer.ofWeak(thisComponent, innerComponent -&gt; _runInUI(innerComponent::repaint) )</span>
        );
<span class="fc" id="L92">    }</span>

    /**
     *  Use this to bind an {@link Observable} (usually from a sprouts.Event)
     *  to the {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever
     *  the source of the observable is fired or changed.
     *
     * @param observable The observable to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Observable observable ) {
<span class="nc" id="L104">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, observable) )._this();</span>
    }

    /**
     *  This method exposes a concise way to bind multiple {@link Observable}s (usually sprouts.Event instances)
     *  to the {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever the source of any one of the
     *  observables is fired or changed.
     *
     * @param first The first observable to which the repaint method of the component will be bound.
     * @param second The second observable to which the repaint method of the component will be bound.
     * @param rest The rest of the observables to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Observable first, Observable second, Observable... rest ) {
<span class="nc" id="L119">        return _with( c -&gt; {</span>
<span class="nc" id="L120">                    _bindRepaintOn(c, first);</span>
<span class="nc" id="L121">                    _bindRepaintOn(c, second);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                    for ( Observable o : rest ) {</span>
<span class="nc" id="L123">                        _bindRepaintOn(c, o);</span>
                    }
<span class="nc" id="L125">                })._this();</span>
    }

    /**
     *  Allows you to bind an {@link Event} to the {@link JComponent#repaint()} method of
     *  the component represented by this builder. &lt;br&gt;
     *  This means that the component will be repainted whenever the event is fired
     *  through the {@link Event#fire()} method.
     *
     * @param event The event to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Event event ) {
<span class="fc" id="L138">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, event) )._this();</span>
    }

    /**
     *  This method exposes a concise way to bind multiple {@link Event}s to the
     *  {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever any one of the events is fired
     *  through the {@link Event#fire()} method.
     *
     * @param first The first event to which the repaint method of the component will be bound.
     * @param second The second event to which the repaint method of the component will be bound.
     * @param rest The rest of the events to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Event first, Event second, Event... rest ) {
<span class="nc" id="L153">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L154">                    _bindRepaintOn(thisComponent, first);</span>
<span class="nc" id="L155">                    _bindRepaintOn(thisComponent, second);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                    for ( Event e : rest ) {</span>
<span class="nc" id="L157">                        _bindRepaintOn(thisComponent, e);</span>
                    }
<span class="nc" id="L159">                })</span>
<span class="nc" id="L160">                ._this();</span>
    }

    /**
     *  Allows you to bind a {@link Val} to the {@link JComponent#repaint()} method
     *  of the component represented by this builder. &lt;br&gt;
     *  This means that the component will be repainted whenever the value of the {@link Val}
     *  changes. If the {@link Val} is a mutable {@link Var} property,
     *  then this event is usually triggered through the {@link Var#set(Object)} method.&lt;br&gt;
     *  &lt;p&gt;
     *      A typical use case is to use {@link Var} properties in the
     *      {@link Styler} of the style API exposed by {@link UIForAnySwing#withStyle(Styler)},
     *      and then also pass these properties to the this {@code withRepaintOn}
     *      method to ensure that the style gets re-evaluated and then repainted.
     *  &lt;/p&gt;
     *
     * @param event The {@link Val} to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Val&lt;?&gt; event ) {
<span class="fc" id="L180">        return _with( thisComponent -&gt; _bindRepaintOn(thisComponent, event) )._this();</span>
    }

    /**
     *  Use this method to bind multiple {@link Val}s to the
     *  {@link JComponent#repaint()} method of the component represented by this builder.
     *  This means that the component will be repainted whenever the value of any one of the
     *  {@link Val}s changes. If the {@link Val} is a mutable {@link Var} property,
     *  then this event is usually triggered through the {@link Var#set(Object)} method.&lt;br&gt;
     *  &lt;p&gt;
     *      A typical use case is to use {@link Var} properties in the
     *      {@link Styler} of the style API exposed by {@link UIForAnySwing#withStyle(Styler)},
     *      and then also pass these properties to the this {@code withRepaintOn}
     *      method to ensure that the style gets re-evaluated and then repainted.
     *  &lt;/p&gt;
     *
     * @param first The first {@link Val} to which the repaint method of the component will be bound.
     * @param second The second {@link Val} to which the repaint method of the component will be bound.
     * @param rest The rest of the {@link Val}s to which the repaint method of the component will be bound.
     * @return This declarative builder instance, which enables builder-style method chaining.
     */
    public final I withRepaintOn( Val&lt;?&gt; first, Val&lt;?&gt; second, Val&lt;?&gt;... rest ) {
<span class="nc" id="L202">        return _with( c -&gt; {</span>
<span class="nc" id="L203">                    _bindRepaintOn(c, first);</span>
<span class="nc" id="L204">                    _bindRepaintOn(c, second);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    for ( Val&lt;?&gt; o : rest ) {</span>
<span class="nc" id="L206">                        _bindRepaintOn(c, o);</span>
                    }
<span class="nc" id="L208">                })._this();</span>
    }

    /**
     *  This method exposes a concise way to set an identifier for the component
     *  represented by this builder chain.
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *
     * @param id The identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be managed by this builder.
     */
    public final I id( String id ) {
<span class="fc" id="L224">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method exposes a concise way to set an enum based identifier for the component
     *  represented by this builder chain.
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *  &lt;p&gt;
     *  The enum identifier will be translated to a string using {@link Enum#name()}.
     *
     * @param id The enum identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be managed by this builder.
     * @param &lt;E&gt; The enum type.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I id( E id ) {
<span class="nc" id="L243">        Objects.requireNonNull(id);</span>
<span class="nc" id="L244">        return _with( c -&gt; ComponentExtension.from(c).setId(id) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to a style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *      {@literal @}Override
     *      protected void build() {
     *          add(group(&quot;A&quot;).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *              .backgroundColor(Color.RED)
     *          );
     *          add(group(&quot;B&quot;), it -&amp;gt; it
     *              .borderWidth(12)
     *          );
     *          add(group(&quot;C&quot;), it -&amp;gt; it
     *              .borderWidth(16)
     *              .borderColor(Color.YELLOW)
     *          );
     *      }
     *    }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(&quot;A&quot;)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;&lt;br&gt;
     *  &lt;b&gt;It is advised to use the {@link #group(Enum[])} method
     *  instead of this method, as the usage of enums for modelling
     *  group tags offers much better compile time type safety!&lt;/b&gt;
     *
     * @param groupTags The names of the style groups to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I group( String... groupTags ) {
<span class="fc" id="L286">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to an enum based style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *          {@literal @}Override
     *          protected void build() {
     *              add(group(MyGroups.A).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *                  .backgroundColor(Color.RED)
     *              );
     *              add(group(MyGroups.B), it -&amp;gt; it
     *                  .borderWidth(12)
     *              );
     *              add(group(MyGroups.C), it -&amp;gt; it
     *                  .borderWidth(16)
     *                  .borderColor(Color.YELLOW)
     *              );
     *          }
     *      }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(MyGroup.A)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;
     *
     * @param groupTags The enum based style group to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The enum type.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; I group( E... groupTags ) {
<span class="fc" id="L327">        return _with( c -&gt; ComponentExtension.from(c).setStyleGroups(groupTags) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type visible or invisible
     *  depending on the supplied boolean value.
     *
     * @param isVisible The truth value determining if the component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( boolean isVisible ) {
<span class="fc" id="L338">        return _with( c -&gt; c.setVisible(isVisible) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(boolean)}, and it is
     *  used to make the underlying {@link JComponent} type visible or invisible.
     *  &lt;p&gt;
     *  If the supplied boolean value is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied boolean value is {@code false}, the component will be visible.
     *
     * @param isVisible The truth value determining if the UI component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( boolean isVisible ) {
<span class="fc bfc" id="L352" title="All 2 branches covered.">        return _with( c -&gt; c.setVisible(!isVisible) )._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  through the supplied {@link Val} property, which is automatically bound
     *  to the {@link JComponent#setVisible(boolean)} method of the underlying {@link JComponent} type.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *           send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L372">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L373">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L374">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="fc" id="L375">                    c.setVisible(v);</span>
<span class="fc" id="L376">                })</span>
<span class="fc" id="L377">                ._with( c -&gt; {</span>
<span class="fc" id="L378">                    c.setVisible( isVisible.orElseThrowUnchecked() );</span>
<span class="fc" id="L379">                })</span>
<span class="fc" id="L380">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  then visibility of the underlying {@link JComponent} type will be updated accordingly.
     *  &lt;p&gt;
     *  If the supplied {@link Val} property is {@code true}, the component will be invisible. &lt;br&gt;
     *  If the supplied {@link Val} property is {@code false}, the component will be visible.
     *  &lt;p&gt;
     *  &lt;i&gt;
     *      Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to
     *            send the property value to this view component.
     *  &lt;/i&gt;
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L401">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L402">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component! A boolean should only be true or false!&quot;);</span>
<span class="fc" id="L403">        return _withOnShow( isVisible, (c, v) -&gt; {</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                    c.setVisible(!v);</span>
<span class="fc" id="L405">                })</span>
<span class="fc" id="L406">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">                    c.setVisible( !isVisible.orElseThrowUnchecked() );</span>
<span class="fc" id="L408">                })</span>
<span class="fc" id="L409">                ._this();</span>
    }

    /**
     *  Make the underlying {@link JComponent} type dynamically visible or invisible
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be visible,
     *  otherwise it will be invisible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component visible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component visible.
     * @param &lt;E&gt; The enum type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L431">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L432">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L433">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L434">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                    c.setVisible( v == enumValue );</span>
<span class="fc" id="L436">                })</span>
<span class="fc" id="L437">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                    c.setVisible( enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L439">                })</span>
<span class="fc" id="L440">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Enum, Val)}, and it is
     *  used to make the underlying {@link JComponent} type dynamically visible or invisible.
     *  &lt;p&gt;
     *  This means that when the supplied {@link Val} property changes its value,
     *  and the new value is equal to the supplied enum value,
     *  then the underlying {@link JComponent} type will be invisible,
     *  otherwise it will be visible.
     * &lt;i&gt;
     *     Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your
     *           view model to send the property value to this view component.
     * &lt;/i&gt;
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component invisible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component invisible.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L461">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L462">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L463">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L464">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                    c.setVisible( v != enumValue );</span>
<span class="fc" id="L466">                })</span>
<span class="fc" id="L467">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                    c.setVisible( enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L469">                })</span>
<span class="fc" id="L470">                ._this();</span>
    }

    /**
     *  Use this to enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( boolean isEnabled ) {
<span class="fc" id="L480">        return _with( c -&gt; _setEnabled(c, isEnabled) )._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(boolean)}.
     *  Use this to disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( boolean isEnabled ) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">        return _with( c -&gt; _setEnabled(c, !isEnabled) )._this();</span>
    }

    /**
     *  Use this to dynamically enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L501">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L502">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L503">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="fc" id="L504">                    c.setEnabled(v);</span>
<span class="fc" id="L505">                })</span>
<span class="fc" id="L506">                ._with( c -&gt; {</span>
<span class="fc" id="L507">                    _setEnabled(c,  isEnabled.orElseThrowUnchecked() );</span>
<span class="fc" id="L508">                })</span>
<span class="fc" id="L509">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Val)}.
     *  Use this to dynamically disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L520">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L521">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L522">        return _withOnShow( isEnabled, (c,v) -&gt; {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                    _setEnabled(c, !v);</span>
<span class="nc" id="L524">                })</span>
<span class="fc" id="L525">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                    _setEnabled(c,  !isEnabled.orElseThrowUnchecked() );</span>
<span class="fc" id="L527">                })</span>
<span class="fc" id="L528">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically enabled or disabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component enabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component enabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L542">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L543">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L544">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L545">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                    _setEnabled( c,  v == enumValue );</span>
<span class="fc" id="L547">                })</span>
<span class="fc" id="L548">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L550">                })</span>
<span class="fc" id="L551">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically disabled or enabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component disabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component disabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L566">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L567">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L568">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L569">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">                    _setEnabled( c,  v != enumValue );</span>
<span class="fc" id="L571">                })</span>
<span class="fc" id="L572">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                    _setEnabled(c,  enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L574">                })</span>
<span class="fc" id="L575">                ._this();</span>
    }

    protected void _setEnabled( C c, boolean isEnabled ) { 
<span class="fc" id="L579">        c.setEnabled( isEnabled ); </span>
<span class="fc" id="L580">    }</span>

    /**
     *  Use this to make the wrapped UI component grab the input focus.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeFocused() {
<span class="fc" id="L587">        return _with( c -&gt; {</span>
<span class="fc" id="L588">                    UI.runLater(() -&gt; {</span>
<span class="fc" id="L589">                        c.grabFocus();</span>
                        // We do this later because in this point in time the UI is probably not
                        // yet fully built (swing-tree is using the builder-pattern).
<span class="fc" id="L592">                    });</span>
<span class="fc" id="L593">                })</span>
<span class="fc" id="L594">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable.
     *  @param isFocusable The truth value determining if the UI component should be focusable or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( boolean isFocusable ) {
<span class="nc" id="L603">        return _with( c -&gt; c.setFocusable(isFocusable) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L616">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L617">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L618">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="fc" id="L619">                    c.setFocusable(v);</span>
<span class="fc" id="L620">                })</span>
<span class="fc" id="L621">                ._with( c -&gt; {</span>
<span class="fc" id="L622">                    c.setFocusable( isFocusable.orElseThrowUnchecked() );</span>
<span class="fc" id="L623">                })</span>
<span class="fc" id="L624">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable if a certain condition is not met.
     *  @param notFocusable The truth value determining if the UI component should be focusable or not.
     *                     If {@code false}, the component will be focusable.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIfNot( boolean notFocusable ) {
<span class="nc bnc" id="L634" title="All 2 branches missed.">        return _with( c -&gt; c.setFocusable( !notFocusable ) )._this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not, wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code isFocusable} is {@code null}.
     */
    public final I isFocusableIfNot( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L648">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L649">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L650">        return _withOnShow( isFocusable, (c,v) -&gt; {</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                    c.setFocusable( !v );</span>
<span class="fc" id="L652">                })</span>
<span class="fc" id="L653">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                    c.setFocusable( !isFocusable.orElseThrowUnchecked() );</span>
<span class="fc" id="L655">                })</span>
<span class="fc" id="L656">                ._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L671">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L672">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L673">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L674">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">                    c.setFocusable( v == enumValue );</span>
<span class="fc" id="L676">                })</span>
<span class="fc" id="L677">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                    c.setFocusable( enumValue == enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L679">                })</span>
<span class="fc" id="L680">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isFocusableIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component non-focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component non-focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L696">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L697">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L698">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="fc" id="L699">        return _withOnShow( enumProperty, (c,v) -&gt; {</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">                    c.setFocusable( v != enumValue );</span>
<span class="fc" id="L701">                })</span>
<span class="fc" id="L702">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                    c.setFocusable( enumValue != enumProperty.orElseThrowUnchecked() );</span>
<span class="fc" id="L704">                })</span>
<span class="fc" id="L705">                ._this();</span>
    }


    /**
     *  Use this to make the wrapped UI component opaque.
     *  This is the inverse of {@link #makeNonOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     *  @deprecated SwingTree considers the opaqueness a property which emerges from the
     *              style configuration of the component. Therefore, it is not recommended
     *              to set the opaqueness directly. Instead, use the {@link #withBackground(Color)}
     *              method to set the style of the component so that it becomes opaque.
     */
    @Deprecated
    public final I makeOpaque() {
<span class="nc" id="L721">        return _with( c -&gt; c.setOpaque( true ) )._this();</span>
    }

    /**
     *  Use this to make the wrapped UI component transparent.
     *  This is the inverse of {@link #makeOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     *  @deprecated Use {@link #withBackground(Color)} instead, by passing
     *             it the {@link UI.Color#TRANSPARENT} constant.&lt;br&gt;
     *             Alternatively, you may use the {@link #peek(Peeker)}
     *             method to peek into the builder's component
     *             and set the flag directly.
     */
    @Deprecated
    public final I makeNonOpaque() {
<span class="fc" id="L737">        return _with( c -&gt; c.setOpaque( false ) )._this();</span>
    }

    /**
     *  This allows you to register validation logic for the wrapped UI component.
     *  Although the delegate exposed to the {@link UIVerifier} lambda
     *  indirectly exposes you to the UIs state, you should not access the UI directly
     *  from within the lambda, but modify the properties inside your view model instead.
     *
     * @param verifier The validation logic provided by your view model.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isValidIf( UIVerifier&lt;C&gt; verifier ) {
<span class="fc" id="L750">        return _with( c -&gt; {</span>
<span class="fc" id="L751">                    c.setInputVerifier(new InputVerifier() {</span>
                        @Override
                        public boolean verify( JComponent input ) {
<span class="nc" id="L754">                            return verifier.isValid(</span>
                                    new ComponentDelegate&lt;&gt;(
                                            c,
                                            new ComponentEvent(c, 0)
                                    )
                            );
                        /*
                            We expect the user to model the state of the UI components
                            using properties in the view model.
                         */
                        }
                    });
<span class="fc" id="L766">                })</span>
<span class="fc" id="L767">                ._this();</span>
    }

    /**
     * Adds {@link String} key/value &quot;client property&quot; pairs to the wrapped component.
     * &lt;p&gt;
     * The arguments will be passed to {@link JComponent#putClientProperty(Object, Object)}
     * which accesses
     * a small per-instance hashtable. Callers can use get/putClientProperty
     * to annotate components that were created by another module.
     * For example, a
     * layout manager might store per child constraints this way. &lt;br&gt;
     * This is in essence a more convenient way than the alternative usage pattern involving
     * the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     * &lt;pre&gt;{@code
     *     UI.button()
     *     .peek( button -&gt; button.putClientProperty(&quot;key&quot;, &quot;value&quot;) );
     * }&lt;/pre&gt;
     *
     * @param key the new client property key which may be used for styles or layout managers.
     * @param value the new client property value.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withProperty( String key, String value ) {
<span class="fc" id="L791">        return _with( c -&gt; c.putClientProperty(key, value) )._this();</span>
    }

    /**
     *  Use this to attach a border to the wrapped component.
     *
     * @param border The {@link Border} which should be set for the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Border border ) {
<span class="fc" id="L801">        Objects.requireNonNull(border, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L802">        return _with( c -&gt; c.setBorder(border) )._this();</span>
    }

    /**
     *  Use this to dynamically attach a border to the wrapped component. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param border The {@link Border} which should be set for the wrapped component wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     * @deprecated Because changing the {@link Border} of a component dynamically after
     *             the component was initialized through the declarative SwingTree API,
     *             causes issues with the style engine of a component.
     *             (Which itself is based on using a custom border for style rendering)
     */
    @Deprecated
    public final I withBorder( Val&lt;Border&gt; border ) {
<span class="fc" id="L818">        NullUtil.nullArgCheck(border, &quot;border&quot;, Val.class);</span>
<span class="fc" id="L819">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L820">        return _withOnShow( border, (c,v) -&gt; {</span>
<span class="nc" id="L821">                    c.setBorder(v);</span>
<span class="nc" id="L822">                })</span>
<span class="fc" id="L823">                ._with( c -&gt; {</span>
<span class="fc" id="L824">                    c.setBorder( border.orElseThrowUnchecked() );</span>
<span class="fc" id="L825">                })</span>
<span class="fc" id="L826">                ._this();</span>
    }


    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int top, int left, int bottom, int right ) {
<span class="fc" id="L840">        return _with( c -&gt; c.setBorder(BorderFactory.createEmptyBorder(top, left, bottom, right)) )._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int top, int left, int bottom, int right ) {
<span class="fc" id="L854">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L855">        return _with( c -&gt; c.setBorder(</span>
<span class="fc" id="L856">                        BorderFactory.createTitledBorder(</span>
<span class="fc" id="L857">                            BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                            title
                        )
                    )
                )
<span class="fc" id="L862">                ._this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val},
     *              which will update the border title dynamically when changed.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int top, int left, int bottom, int right ) {
<span class="nc" id="L878">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L879">        NullUtil.nullPropertyCheck( title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot; );</span>
<span class="nc" id="L880">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L881">                    c.setBorder(</span>
<span class="nc" id="L882">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L883">                                BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
                                v
                            )
                        );
<span class="nc" id="L887">                })</span>
<span class="nc" id="L888">                ._with( c -&gt; {</span>
<span class="nc" id="L889">                    c.setBorder(</span>
<span class="nc" id="L890">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L891">                                    BorderFactory.createEmptyBorder(top, left, bottom, right),</span>
<span class="nc" id="L892">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L895">                })</span>
<span class="nc" id="L896">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int topBottom, int leftRight ) {
<span class="nc" id="L907">        return withEmptyBorder( topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int topBottom, int leftRight ) {
<span class="nc" id="L919">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L920">        return withEmptyBorderTitled( title, topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val}. When the value changes, the border title will be updated.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int topBottom, int leftRight ) {
<span class="nc" id="L933">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L934">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L935">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L936">                    c.setBorder(</span>
<span class="nc" id="L937">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L938">                                BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
                                v
                            )
                        );
<span class="nc" id="L942">                })</span>
<span class="nc" id="L943">                ._with( c -&gt; {</span>
<span class="nc" id="L944">                    c.setBorder(</span>
<span class="nc" id="L945">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L946">                                    BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight),</span>
<span class="nc" id="L947">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L950">                })</span>
<span class="nc" id="L951">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L960">    public final I withEmptyBorder( int all ) { return withEmptyBorder(all, all, all, all); }</span>

    /**
     *  Creates an empty and un-titled {@link Border} with the provided insets
     *  property bound to all insets of said border.
     *  &lt;p&gt;
     *  An empty and un-titled {@link Border} is basically just a way to add some
     *  space around the component. It is not visible by default.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( Val&lt;Integer&gt; all ) {
<span class="nc" id="L973">        NullUtil.nullArgCheck( all, &quot;all&quot;, Val.class );</span>
<span class="nc" id="L974">        NullUtil.nullPropertyCheck(all, &quot;all&quot;, &quot;Null value for all is not allowed! Use an empty border instead!&quot;);</span>
<span class="nc" id="L975">        return _withOnShow( all, (c,v) -&gt; {</span>
<span class="nc" id="L976">                    c.setBorder(BorderFactory.createEmptyBorder(v, v, v, v));</span>
<span class="nc" id="L977">                })</span>
<span class="nc" id="L978">                ._with( c -&gt; {</span>
<span class="nc" id="L979">                    c.setBorder(BorderFactory.createEmptyBorder(all.orElseThrowUnchecked(), all.orElseThrowUnchecked(), all.orElseThrowUnchecked(), all.orElseThrowUnchecked()));</span>
<span class="nc" id="L980">                })</span>
<span class="nc" id="L981">                ._this();</span>
    }

            /**
             *  Use this to define a titled empty {@link Border} with the provided insets.
             *
             * @param title The title of the border.
             * @param all The insets for all sides.
             * @return This very instance, which enables builder-style method chaining.
             */
    public final I withEmptyBorderTitled( String title, int all ) {
<span class="fc" id="L992">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L993">        return withEmptyBorderTitled(title, all, all, all, all);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property and the provided insets.
     * @param title The title of the border in the form of a {@link Val} property.
     * @param all The insets size for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int all ) {
<span class="nc" id="L1003">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1004">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1005">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1006">                    c.setBorder(</span>
<span class="nc" id="L1007">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1008">                                BorderFactory.createEmptyBorder(all, all, all, all),</span>
                                v
                            )
                        );
<span class="nc" id="L1012">                })</span>
<span class="nc" id="L1013">                ._with( c -&gt; {</span>
<span class="nc" id="L1014">                    c.setBorder(</span>
<span class="nc" id="L1015">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1016">                                    BorderFactory.createEmptyBorder(all, all, all, all),</span>
<span class="nc" id="L1017">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L1020">                })</span>
<span class="nc" id="L1021">                ._this();</span>
    }

    /**
     *  Use this to define an empty {@link Border} with a title
     *  and a default insets size of 5.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title ) {
<span class="nc" id="L1032">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1033">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property
     *  and a default insets size of 5.
     *
     * @param title The title of the border in the form of a {@link Val} property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1044">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and insets.
     *
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color, int thickness ) {
<span class="fc" id="L1055">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="fc" id="L1056">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness)) )._this();</span>
    }

    /**
     *  Creates a line border bound to a {@link Color} property.
     *  When the color changes, the border will be updated with the new color.
     * @param color The color of the border in the form of a {@link Val} property.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1067">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1068">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1069">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1070">                    c.setBorder(BorderFactory.createLineBorder(v, thickness));</span>
<span class="nc" id="L1071">                })</span>
<span class="nc" id="L1072">                ._with( c -&gt; {</span>
<span class="nc" id="L1073">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness));</span>
<span class="nc" id="L1074">                })</span>
<span class="nc" id="L1075">                ._this();</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and insets.
     *
     * @param title The title of the border.
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L1087">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1088">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1089">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1090">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1091">                            BorderFactory.createLineBorder(color, thickness),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1096">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property.
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1107">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1108">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1109">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1110">                    c.setBorder(</span>
<span class="nc" id="L1111">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1112">                                BorderFactory.createLineBorder(color, thickness),</span>
                                v
                            )
                        );
<span class="nc" id="L1116">                })</span>
<span class="nc" id="L1117">                ._with( c -&gt; {</span>
<span class="nc" id="L1118">                    c.setBorder(</span>
<span class="nc" id="L1119">                            BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1120">                                    BorderFactory.createLineBorder(color, thickness),</span>
<span class="nc" id="L1121">                                    title.orElseThrowUnchecked()</span>
                            )
                    );
<span class="nc" id="L1124">                })</span>
<span class="nc" id="L1125">                ._this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property
     * and a {@link Color} property.
     * When any of the properties change, the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1139">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1140">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1141">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1142">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1143">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1144">                    c.setBorder(</span>
<span class="nc" id="L1145">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1146">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness),</span>
                            v
                        )
                    );
<span class="nc" id="L1150">                })</span>
<span class="nc" id="L1151">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1152">                    c.setBorder(</span>
<span class="nc" id="L1153">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1154">                            BorderFactory.createLineBorder(v, thickness),</span>
<span class="nc" id="L1155">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1158">                })</span>
<span class="nc" id="L1159">                ._with( c -&gt; {</span>
<span class="nc" id="L1160">                    c.setBorder(</span>
<span class="nc" id="L1161">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1162">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness),</span>
<span class="nc" id="L1163">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1166">                })</span>
<span class="nc" id="L1167">                ._this();</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color ) {
<span class="nc" id="L1177">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1178">        return withLineBorder(color, 1);</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1189">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1190">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1191">        return withLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color, int thickness ) {
<span class="nc" id="L1203">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1204">        return _with( c -&gt; c.setBorder(BorderFactory.createLineBorder(color, thickness, true)) )._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L1217">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1218">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1219">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1220">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1221">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1226">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title property.
     *  When the title property changes, the border will be updated with the new value.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L1241">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1242">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1243">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1244">                    c.setBorder(</span>
<span class="nc" id="L1245">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1246">                            BorderFactory.createLineBorder(color, thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1250">                })</span>
<span class="nc" id="L1251">                ._with( c -&gt; {</span>
<span class="nc" id="L1252">                    c.setBorder(</span>
<span class="nc" id="L1253">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1254">                            BorderFactory.createLineBorder(color, thickness, true),</span>
<span class="nc" id="L1255">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1258">                })</span>
<span class="nc" id="L1259">                ._this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title and color properties.
     *  When the title or color properties change,
     *  then the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1275">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L1276">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L1277">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1278">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1279">        return _withOnShow( title, (c,v) -&gt; {</span>
<span class="nc" id="L1280">                    c.setBorder(</span>
<span class="nc" id="L1281">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1282">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true),</span>
                            v
                        )
                    );
<span class="nc" id="L1286">                })</span>
<span class="nc" id="L1287">                ._withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1288">                    c.setBorder(</span>
<span class="nc" id="L1289">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1290">                            BorderFactory.createLineBorder(v, thickness, true),</span>
<span class="nc" id="L1291">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1294">                })</span>
<span class="nc" id="L1295">                ._with( c -&gt; {</span>
<span class="nc" id="L1296">                    c.setBorder(</span>
<span class="nc" id="L1297">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1298">                            BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true),</span>
<span class="nc" id="L1299">                            title.orElseThrowUnchecked()</span>
                        )
                    );
<span class="nc" id="L1302">                })</span>
<span class="nc" id="L1303">                ._this();</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color ) {
<span class="nc" id="L1314">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1315">        return withRoundedLineBorder(color, 1);</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color property and a custom thickness to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1327">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1328">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1329">        return _withOnShow( color, (c,v) -&gt; {</span>
<span class="nc" id="L1330">                    c.setBorder(BorderFactory.createLineBorder(v, thickness, true));</span>
<span class="nc" id="L1331">                })</span>
<span class="nc" id="L1332">                ._with( c -&gt; {</span>
<span class="nc" id="L1333">                    c.setBorder(BorderFactory.createLineBorder(color.orElseThrowUnchecked(), thickness, true));</span>
<span class="nc" id="L1334">                })</span>
<span class="nc" id="L1335">                ._this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title, color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1347">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1348">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1349">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title and color to the {@link JComponent}, as well as a default thickness of {@code 1}.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @param color The color property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color ) {
<span class="nc" id="L1361">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1362">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1363">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1364">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1373">    public final I withRoundedLineBorder() { return withRoundedLineBorder(Color.BLACK, 1); }</span>

    /**
     *  Use this to attach a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title ) {
<span class="nc" id="L1383">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1384">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Creates a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent} and binds it to the provided
     *  title property.
     *  When the property changes, the border will be updated.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1397">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1398">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1399">        return withRoundedLineBorderTitled( title, java.awt.Color.BLACK, 1 );</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1414">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1415">        return _with( c -&gt; c.setBorder(BorderFactory.createMatteBorder(top, left, bottom, right, color)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1431">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1432">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1433">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1434">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1435">                            BorderFactory.createMatteBorder(top, left, bottom, right, color),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1440">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1453">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1454">        return withMatteBorder(color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1468">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1469">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1470">        return withMatteBorderTitled(title, color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int all ) {
<span class="nc" id="L1482">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1483">        return withMatteBorder(color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int all ) {
<span class="nc" id="L1496">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1497">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1498">        return withMatteBorderTitled(title, color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.CompoundBorder} with the provided
     *  borders to the {@link JComponent}.
     *
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorder( Border first, Border second ) {
<span class="nc" id="L1510">        NullUtil.nullArgCheck( first, &quot;first&quot;, Border.class );</span>
<span class="nc" id="L1511">        NullUtil.nullArgCheck( second, &quot;second&quot;, Border.class );</span>
<span class="nc" id="L1512">        return _with( c -&gt; c.setBorder(BorderFactory.createCompoundBorder(first, second)) )._this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.CompoundBorder} with the
     *  provided borders to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorderTitled( String title, Border first, Border second ) {
<span class="nc" id="L1525">        return _with( c -&gt; c.setBorder(</span>
<span class="nc" id="L1526">                        BorderFactory.createTitledBorder(</span>
<span class="nc" id="L1527">                            BorderFactory.createCompoundBorder(first, second),</span>
                            title
                        )
                    )
                )
<span class="nc" id="L1532">                ._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the provided title.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( String title ) {
<span class="fc" id="L1542">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1543">        return _with( c -&gt; c.setBorder(BorderFactory.createTitledBorder(title)) )._this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the
     *  provided title property dynamically setting the title String.
     *
     * @param title The title property for the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( Val&lt;String&gt; title ) {
<span class="fc" id="L1554">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1555">        return _withOnShow( title, (c,t) -&gt; {</span>
<span class="fc" id="L1556">                    Border foundBorder = c.getBorder();</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">                    if ( foundBorder instanceof TitledBorder )</span>
<span class="fc" id="L1558">                        ((TitledBorder)foundBorder).setTitle(t);</span>
                    else
<span class="nc" id="L1560">                        c.setBorder(BorderFactory.createTitledBorder(t));</span>
<span class="fc" id="L1561">                })</span>
<span class="fc" id="L1562">                ._with( c -&gt; {</span>
<span class="fc" id="L1563">                    c.setBorder(BorderFactory.createTitledBorder(title.orElseThrowUnchecked()));</span>
<span class="fc" id="L1564">                })</span>
<span class="fc" id="L1565">                ._this();</span>
    }

    /**
     *  Use this set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder.
     *  &lt;br&gt;
     *  Here an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me!&quot;).withCursor(UI.Cursor.HAND);
     *  }&lt;/pre&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( UI.Cursor type ) {
<span class="fc" id="L1581">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="fc" id="L1582">        return _with( c -&gt; c.setCursor( new java.awt.Cursor( type.type ) ) )._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( Val&lt;UI.Cursor&gt; type ) {
<span class="fc" id="L1594">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="fc" id="L1595">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="fc" id="L1596">        return _withOnShow( type, (c,t) -&gt; {</span>
<span class="fc" id="L1597">                    c.setCursor( new java.awt.Cursor( t.type ) );</span>
<span class="fc" id="L1598">                })</span>
<span class="fc" id="L1599">                ._with( c -&gt; {</span>
<span class="fc" id="L1600">                    c.setCursor( new java.awt.Cursor( type.orElseThrowUnchecked().type ) );</span>
<span class="fc" id="L1601">                })</span>
<span class="fc" id="L1602">                ._this();</span>
    }

    /**
     *  Use this to set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, UI.Cursor type ) {
<span class="nc" id="L1616">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1617">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="nc" id="L1618">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1619">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( v ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1621">                })</span>
<span class="nc" id="L1622">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? type.type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1624">                })</span>
<span class="nc" id="L1625">                ._this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type property defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, Val&lt;UI.Cursor&gt; type ) {
<span class="nc" id="L1639">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1640">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="nc" id="L1641">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1642">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="nc" id="L1643">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L1644">                    Cursor[] baseCursor = new Cursor[1];</span>
<span class="nc" id="L1645">                    _onShow( condition, thisComponent, (c,v) -&gt; type.fireChange(From.VIEW_MODEL) );</span>
<span class="nc" id="L1646">                    _onShow( type, thisComponent, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                        if ( baseCursor[0] == null ) baseCursor[0] = c.getCursor();</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                        c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? v.type : baseCursor[0].getType() ) );</span>
<span class="nc" id="L1649">                    });</span>
<span class="nc" id="L1650">                })</span>
<span class="nc" id="L1651">                ._with( c -&gt; {</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                    c.setCursor( new java.awt.Cursor( condition.orElseThrowUnchecked() ? type.orElseThrowUnchecked().type : UI.Cursor.DEFAULT.type ) );</span>
<span class="nc" id="L1653">                })</span>
<span class="nc" id="L1654">                ._this();</span>
    }

    /**
     *  Use this to set the {@link LayoutManager} of the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FavouriteLayoutManager()) );
     *  }&lt;/pre&gt;
     *
     * @param layout The {@link LayoutManager} which should be supplied to the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutManager layout ) {
<span class="fc" id="L1670">        return _with( c -&gt; c.setLayout(layout) )._this();</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1684">    public final I withFlowLayout() { return this.withLayout(new ResponsiveGridFlowLayout()); }</span>

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment ) {
<span class="nc" id="L1699">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="nc" id="L1700">        return this.withLayout(new ResponsiveGridFlowLayout(alignment));</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout(alignment.forFlowLayout(), hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param alignment The alignment of the layout.
     * @param hgap The horizontal gap between components.
     * @param vgap The vertical gap between components.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withFlowLayout( UI.HorizontalAlignment alignment, int hgap, int vgap ) {
<span class="fc" id="L1718">        NullUtil.nullArgCheck( alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class );</span>
<span class="fc" id="L1719">        return this.withLayout(new ResponsiveGridFlowLayout(alignment, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1733">    public final I withGridLayout() { return this.withLayout(new GridLayout()); }</span>

    /**
     *  Use this to set a new {@link GridBagLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridBagLayout()) );
     *  }&lt;/pre&gt;
     *  ...or specifying the layout manager like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.panel().withLayout( new GridBagLayout() );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1750">    public final I withGridBagLayout() { return this.withLayout(new GridBagLayout()); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1765">    public final I withGridLayout( int rows, int cols ) { return this.withLayout(new GridLayout(rows, cols)); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols, hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @param hgap The horizontal gap between cells.
     * @param vgap The vertical gap between cells.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withGridLayout( int rows, int cols, int hgap, int vgap ) {
<span class="nc" id="L1783">        return this.withLayout(new GridLayout(rows, cols, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link BoxLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new BoxLayout(panel, axis.forBoxLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param axis The axis for the box layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If the provided axis is {@code null}.
     * @see UI.Axis
     * @see BoxLayout
     */
    public final I withBoxLayout( UI.Axis axis ) {
<span class="nc" id="L1802">        NullUtil.nullArgCheck( axis, &quot;axis&quot;, UI.Axis.class );</span>
<span class="nc" id="L1803">        return _with( c -&gt; c.setLayout(new BoxLayout(c, axis.forBoxLayout())) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-constraints in the form of a simple string
     *  which is parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;fill wrap 2&quot;);
     *    .add( UI.button(&quot;Name:&quot;) )
     *    .add( UI.textArea() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns
     *  and fill the entire available space of the parent container.
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param attr The constraints concerning the entire layout.
     *             Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr ) {
<span class="fc" id="L1852">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, String.class );</span>
<span class="fc" id="L1853">        return withLayout(attr, &quot;&quot;);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LC} instance,
     *  which is a builder for the layout constraints.
     *
     * @param attr A string defining the constraints concerning the entire layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr ) {
<span class="nc" id="L1867">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LC.class );</span>
<span class="nc" id="L1868">        return withLayout(attr, (AC) null, (AC) null);</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LayoutConstraint} instance,
     *  which is an immutable string wrapper for the layout constraints.
     *  Instances of this are usually obtained from the {@link UI} namespace like
     *  {@link UI#FILL} or {@link UI#FILL_X}...
     *
     * @param attr Essentially an immutable string wrapper defining the mig layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     */
    public final I withLayout( LayoutConstraint attr ) {
<span class="fc" id="L1883">        NullUtil.nullArgCheck( attr, &quot;attr&quot;, LayoutConstraint.class );</span>
<span class="fc" id="L1884">        return withLayout(attr.toString(), &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder
     *  based on the provided layout constraints in the form of a string.
     *
     * @param attr A string defining constraints for the entire layout.
     * @param colConstrains The layout constraints for the columns int the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String attr, String colConstrains ) {
<span class="fc" id="L1898">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1899">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1900">        return withLayout(attr, colConstrains, &quot;&quot;);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a {@link AC} instance.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a {@link AC} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, AC colConstrains ) {
<span class="nc" id="L1915">        return withLayout(attr, colConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains ) {
<span class="nc bnc" id="L1930" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains == null ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc" id="L1931">        return withLayout(attr, parsedColConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column and row constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @param rowConstraints The row layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LC attr, String colConstrains, String rowConstraints ) {
<span class="nc" id="L1947">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1948">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc" id="L1949">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains.isEmpty() ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">        AC parsedRowConstrains = rowConstraints.isEmpty() ? null : ConstraintParser.parseRowConstraints(rowConstraints);</span>
<span class="nc" id="L1952">        return withLayout(attr, parsedColConstrains, parsedRowConstrains);</span>
    }

    /**
     *  Takes the supplied layout constraints and column constraints
     *  uses them to construct a new {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains ) {
<span class="fc" id="L1966">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1967">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1968">        return withLayout(attr.toString(), colConstrains, &quot;&quot;);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout in the form of a {@link LayoutConstraint} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutConstraint attr, String colConstrains, String rowConstraints ) {
<span class="fc" id="L1980">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1981">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L1982">        return withLayout(attr.toString(), colConstrains, rowConstraints);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout-, column- and row-constraints in the form of simple strings,
     *  which are parsed by the {@link ConstraintParser} class into {@link LC} and {@link AC} instances.
     *  (also see {@link #withLayout(LC, AC, AC)}) &lt;br&gt; &lt;br&gt;
     *  A typical usage pattern would be like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(new MyCustomPanel())
     *    .withLayout(&quot;wrap 2&quot;, &quot;[]6[]&quot;, &quot;[]8[]&quot;);
     *    .add( UI.label(&quot;Name:&quot;) )
     *    .add( UI.textField() )
     *    .add(...)
     *    ...
     *  }&lt;/pre&gt;
     *  In this example a new {@link MigLayout} is created which
     *  will wrap the components in the layout grid after 2 columns,
     *  where the 2 columns are separated by a 6 pixel gap and the rows
     *  are separated by an 8 pixel gap. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if not explicitly specified, the default {@code hidemode} will be set to 2, which means that
     *  when a component is hidden, it will not take up any space and the gaps around it will
     *  be collapsed. &lt;br&gt;
     *  Here an overview of the available hidemode values:
     *  &lt;ul&gt;
     *      &lt;li&gt;&lt;b&gt;0:&lt;/b&gt;&lt;br&gt;
     *         Invisible components will be handled exactly as if they were visible.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;1:&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;2 (SwingTree default):&lt;/b&gt;&lt;br&gt;
     *          The size of the component (if invisible) will be set to 0, 0 and the gaps
     *          will also be set to 0 around it.
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;b&gt;3:&lt;/b&gt;&lt;br&gt;
     *          Invisible components will not participate in the layout at all and it will
     *          for instance not take up a grid cell.
     *      &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param constraints The constraints concerning the entire layout.
     *                    Passing {@code null} will result in an exception, use an empty string instead.
     * @param colConstrains The column layout for the {@link MigLayout} instance,
     *                      which concern the columns in the layout grid.
     *                      Passing {@code null} will result in an exception, use an empty string instead.
     * @param rowConstraints The row layout for the {@link MigLayout} instance,
     *                       which concern the rows in the layout grid.
     *                       Passing {@code null} will result in an exception, use an empty string instead.
     * @return This very instance, which enables builder-style method chaining.
     *
     * @throws IllegalArgumentException If any of the arguments are {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public final I withLayout( String constraints, String colConstrains, String rowConstraints ) {
<span class="fc" id="L2039">        NullUtil.nullArgCheck(constraints, &quot;constraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L2040">        NullUtil.nullArgCheck(colConstrains, &quot;colConstrains&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>
<span class="fc" id="L2041">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class, &quot;Please use an empty String instead of null!&quot;);</span>

        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">        if ( constraints.isEmpty() )</span>
<span class="nc" id="L2045">            constraints = &quot;hidemode 2&quot;;</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        else if ( !constraints.contains(&quot;hidemode&quot;) )</span>
<span class="fc" id="L2047">            constraints += &quot;, hidemode 2&quot;;</span>

<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">        constraints    = ( constraints.isEmpty() ? null : constraints );</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">        colConstrains  = ( colConstrains.isEmpty() ? null : colConstrains );</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        rowConstraints = ( rowConstraints.isEmpty() ? null : rowConstraints );</span>

<span class="fc" id="L2053">        MigLayout migLayout = new MigLayout(constraints, colConstrains, rowConstraints);</span>
<span class="fc" id="L2054">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( @Nullable LC attr, @Nullable AC colConstrains, @Nullable AC rowConstraints ) {
        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="nc bnc" id="L2067" title="All 2 branches missed.">        if ( attr == null )</span>
<span class="nc" id="L2068">            attr = new LC().hideMode(2);</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        else if ( attr.getHideMode() == 0 )</span>
<span class="nc" id="L2070">            attr = attr.hideMode(2);</span>

<span class="nc" id="L2072">        MigLayout migLayout = new MigLayout(attr, colConstrains, rowConstraints);</span>
<span class="nc" id="L2073">        return _with( c -&gt; c.setLayout(migLayout) )._this();</span>
    }

    /**
     *  Use this to set a helpful tool tip text for this UI component.
     *  The tool tip text will be displayed when the mouse hovers on the
     *  UI component for some time. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; button.setToolTipText(&quot;Can be clicked!&quot;) );
     *  }&lt;/pre&gt;
     *
     * @param tooltip The tool tip text which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withTooltip( String tooltip ) {
<span class="fc" id="L2091">        NullUtil.nullArgCheck(tooltip, &quot;tooltip&quot;, String.class, &quot;Use the empty string to clear the tooltip text!&quot;);</span>
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">        return _with( c -&gt; c.setToolTipText(tooltip.isEmpty() ? null : tooltip) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a tooltip string.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          tip.onSetItem(JButton::setToolTipText);
     *          button.setToolTipText(tip.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param tip The tooltip which should be displayed when hovering over the tab header.
     * @return A new {@link Tab} instance with the provided argument, which enables builder-style method chaining.
     */
    public final I withTooltip( Val&lt;String&gt; tip ) {
<span class="fc" id="L2113">        NullUtil.nullArgCheck(tip, &quot;tip&quot;, Val.class);</span>
<span class="fc" id="L2114">        NullUtil.nullPropertyCheck(tip, &quot;tip&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2115">        return _withOnShow( tip, (c,v) -&gt; {</span>
<span class="fc bfc" id="L2116" title="All 2 branches covered.">                    c.setToolTipText( v.isEmpty() ? null : v );</span>
<span class="fc" id="L2117">                })</span>
<span class="fc" id="L2118">                ._with( c -&gt; {</span>
<span class="fc" id="L2119">                    String tipString = tip.orElse(&quot;&quot;);</span>
<span class="pc bpc" id="L2120" title="1 of 2 branches missed.">                    c.setToolTipText( tipString.isEmpty() ? null : tipString );</span>
<span class="fc" id="L2121">                })</span>
<span class="fc" id="L2122">                ._this();</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  wrapped by this builder.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(Color.CYAN) );
     *  }&lt;/pre&gt;
     *
     * @param color The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Color color ) {
<span class="fc" id="L2139">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="fc" id="L2140">        return _with( c -&gt; _setBackground(c, color) )</span>
<span class="fc" id="L2141">                ._this();</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  of this declarative builder using a color String.
     *  The supplied {@link String} is parsed to a {@link UI.Color}
     *  through the {@link UI#color(String)} method.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(UI.color(&quot;cyan&quot;)) );
     *  }&lt;/pre&gt;
     *
     * @param color A color string which should be parsed to a {@link UI.Color} instance
     *              and then set as the background color of the UI component.
     * @return A new reference to this type of builder, to allow for fluent method chaining.
     */
    public final I withBackgroundColor( String color ) {
<span class="fc" id="L2161">        NullUtil.nullArgCheck(color, &quot;color&quot;, String.class);</span>
<span class="fc" id="L2162">        return this.withBackground(UI.color(color));</span>
    }

    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected void _setBackground( JComponent thisComponent, Color color ) {
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">        color = _isUndefinedColor(color) ? null : color;</span>
<span class="fc" id="L2168">        thisComponent.setBackground( color );</span>
<span class="fc" id="L2169">        color = thisComponent.getBackground();</span>
        // ^ If the provided color is null the component may inherit the color from its parent!
<span class="fc bfc" id="L2171" title="All 2 branches covered.">        if ( color == UI.Color.TRANSPARENT ) {</span>
<span class="fc" id="L2172">            thisComponent.setOpaque(false);</span>
        }
<span class="fc" id="L2174">    }</span>

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a background color.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          bg.onSetItem(JButton::setBackground);
     *          button.setBackground(bg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param bg The background color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Val&lt;Color&gt; bg ) {
<span class="fc" id="L2194">        NullUtil.nullArgCheck(bg, &quot;bg&quot;, Val.class);</span>
<span class="fc" id="L2195">        NullUtil.nullPropertyCheck(bg, &quot;bg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2196">        return _withOnShow( bg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2197" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(v) ? null : v );</span>
<span class="fc" id="L2198">                })</span>
<span class="fc" id="L2199">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2200" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(bg.get()) ? null : bg.get() );</span>
<span class="fc" id="L2201">                })</span>
<span class="fc" id="L2202">                ._this();</span>
    }

    /**
     *  Use this to bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue ) {
<span class="fc" id="L2215">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2216">        NullUtil.nullArgCheck(colorIfTrue, &quot;bg&quot;, Color.class);</span>
<span class="fc" id="L2217">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2218">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2219">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2220">                    Var&lt;Color&gt; color = Var.of( colorIfTrue );</span>
<span class="fc" id="L2221">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2222">                })</span>
<span class="fc" id="L2223">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">                    Color newColor =  condition.get() ? colorIfTrue : c.getBackground();</span>
<span class="pc bpc" id="L2225" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2226">                })</span>
<span class="fc" id="L2227">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The background color property which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2240">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2241">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2242">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2243">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided background color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2244">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2245">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getBackground() );</span>
<span class="fc" id="L2246">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2247">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateBackground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2248">                })</span>
<span class="fc" id="L2249">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getBackground();</span>
<span class="pc bpc" id="L2251" title="1 of 2 branches missed.">                    c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2252">                })</span>
<span class="fc" id="L2253">                ._this();</span>
    }

    /**
     *  Use this to bind to 2 colors to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2267">        return this.withBackgroundIf( condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
    }

    /**
     *  Use this to bind to 2 color properties to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2281">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2282">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2283">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2284">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L2285">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2286">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2287">               })</span>
<span class="fc" id="L2288">               ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="nc" id="L2289">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2290">               })</span>
<span class="fc" id="L2291">               ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="nc" id="L2292">                   _updateBackground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="nc" id="L2293">               })</span>
<span class="fc" id="L2294">               ._with( c -&gt; {</span>
<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">                   Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2296" title="1 of 2 branches missed.">                   c.setBackground( _isUndefinedColor(newColor) ? null : newColor );</span>
<span class="fc" id="L2297">               })</span>
<span class="fc" id="L2298">               ._this();</span>
    }

    /**
     *    Allows you to configure how the component wrapped by this builder
     *    looks and behaves, by passing a {@link Styler} lambda to this method
     *    which receiving a {@link swingtree.style.ComponentStyleDelegate} and returns
     *    an updated version with the desired style rules applied.
     *    &lt;p&gt;
     *    Here a typical example of how to style a button
     *    using the style API:
     *    &lt;pre&gt;{@code
     *        UI.button(&quot;Click Me!&quot;)
     *        .withStyle( it -&gt; it
     *            .borderColor(Color.CYAN)
     *            .borderWidthAt(Edge.BOTTOM, 3)
     *            .borderRadius(10)
     *        )
     *    }&lt;/pre&gt;
     *    &lt;p&gt;
     *    Here the {@code it} variable is the {@link swingtree.style.ComponentStyleDelegate} which
     *    exposes an extensive API for configuring how a particular component
     *    looks and behaves.
     *    &lt;p&gt;
     *    If you want to define style rules for an entire GUI or a part of it,
     *    take a look at the {@link swingtree.style.StyleSheet} class,
     *    which exposes an API for defining style rules similar to CSS
     *    but based on declarative source code instead of a text file.
     *
     * @param styler A {@link Styler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withStyle( Styler&lt;C&gt; styler ) {
<span class="fc" id="L2334">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, Styler.class);</span>
<span class="fc" id="L2335">        return _with( c -&gt; {</span>
<span class="fc" id="L2336">                    ComponentExtension.from(c).addStyler( styler );</span>
<span class="fc" id="L2337">                })</span>
<span class="fc" id="L2338">                ._this();</span>
    }

    /**
     *    Here an example demonstrating how a transitional style can be applied
     *    to make a border which can transition between 2 colors based on a boolean property:
     *    &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me!&quot;)
     *      .withTransitionalStyle(vm.isError(), LifeTime.of(1, TimeUnit.SECONDS), (state, it) -&gt; it
     *          .backgroundColor(Color.CYAN)
     *          .border(3, new Color((int)(state.progress() * 255), 0, 0))
     *      )
     *    }&lt;/pre&gt;
     *
     *
     * @param transitionToggle The boolean {@link Val} property which determines the state to which the style should transition.
     *                         When the value of this property is {@code true}, the style will transition to a {@link AnimationStatus#progress()}
     *                         of {@code 1.0} over the provided {@link LifeTime}.
     *                         And when the value of this property is {@code false}, the style will transition to a {@link AnimationStatus#progress()}
     *                         of {@code 0.0} over the provided {@link LifeTime}.
     *
     * @param transitionLifeTime The {@link LifeTime} of the transition animation.
     *                           It defines for ow long the {@link AnimationStatus#progress()} will transition from {@code 0} to {@code 1} or vice versa.
     *
     * @param styler An {@link AnimatedStyler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving an {@link AnimationStatus} and a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *               The {@link AnimatedStyler} may apply the style properties according to the {@link AnimationStatus}
     *               and its {@link AnimationStatus#progress()} method (or other methods) to create a smooth
     *               transition between the 2 states.
     *
     * @return This builder instance, which enables fluent method chaining.
     * @see #withTransitoryStyle(Event, LifeTime, AnimatedStyler)
     */
    public final I withTransitionalStyle(
        Val&lt;Boolean&gt;      transitionToggle,
        LifeTime          transitionLifeTime,
        AnimatedStyler&lt;C&gt; styler
    ) {
<span class="fc" id="L2377">        NullUtil.nullArgCheck(transitionToggle, &quot;transitionToggle&quot;, Val.class);</span>
<span class="fc" id="L2378">        NullUtil.nullArgCheck(transitionLifeTime, &quot;transitionLifeTime&quot;, LifeTime.class);</span>
<span class="fc" id="L2379">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, AnimatedStyler.class);</span>
<span class="fc" id="L2380">        return _with( c -&gt; {</span>
<span class="fc" id="L2381">                    FlipFlopStyler&lt;C&gt; flipFlopStyler = new FlipFlopStyler&lt;&gt;(transitionToggle.get(), c, transitionLifeTime, styler);</span>
<span class="fc" id="L2382">                    ComponentExtension.from(c).addStyler(flipFlopStyler::style);</span>
<span class="fc" id="L2383">                    _onShow( transitionToggle, c, (comp, v) -&gt; flipFlopStyler.set(v) );</span>
<span class="fc" id="L2384">                })</span>
<span class="fc" id="L2385">                ._this();</span>
    }

    /**
     *    Allows you to configure a style which will be applied to the component temporarily
     *    when the provided {@link Event} is fired. The style will be applied for the provided
     *    {@link LifeTime} and then removed again.
     *    Here an example demonstrating how an event based style animation which temporarily
     *    defines a custom background and border color on a label:
     *    &lt;pre&gt;{@code
     *      UI.label(&quot;I have a highlight animation!&quot;)
     *      .withTransitoryStyle(vm.highlightEvent(), LifeTime.of(0.5, TimeUnit.SECONDS), (state, it) -&gt; it
     *          .backgroundColor(new Color(0, 0, 0, (int)(state.progress() * 255)))
     *          .borderColor(new Color(255, 255, 255, (int)(state.progress() * 255)))
     *      )
     *    }&lt;/pre&gt;
     *
     * @param styleEvent The {@link Event} which should trigger the style animation.
     * @param styleLifeTime The {@link LifeTime} of the style animation.
     * @param styler An {@link AnimatedStyler} lambda can define a set of style rules for the component wrapped by this builder
     *               by receiving an {@link AnimationStatus} and a {@link swingtree.style.ComponentStyleDelegate} and returning
     *               an updated version with the desired style rules applied.
     *               The {@link AnimatedStyler} may apply the style properties according to the {@link AnimationStatus}
     *               and its {@link AnimationStatus#progress()} method (or other methods) to create a smooth
     *               transition between the 2 states.
     *
     * @return This builder instance, which enables fluent method chaining.
     * @see #withTransitionalStyle(Val, LifeTime, AnimatedStyler)
     */
    public final I withTransitoryStyle(
        Event             styleEvent,
        LifeTime          styleLifeTime,
        AnimatedStyler&lt;C&gt; styler
    ){
<span class="fc" id="L2419">        NullUtil.nullArgCheck(styleEvent, &quot;styleEvent&quot;, Event.class);</span>
<span class="fc" id="L2420">        NullUtil.nullArgCheck(styleLifeTime, &quot;styleLifeTime&quot;, LifeTime.class);</span>
<span class="fc" id="L2421">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, AnimatedStyler.class);</span>
<span class="fc" id="L2422">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2423">                    Observable.cast(styleEvent).subscribe(Observer.ofWeak(thisComponent, (innerComponent)-&gt;{</span>
<span class="fc" id="L2424">                        AnimationDispatcher.animateFor(styleLifeTime, thisComponent).go(status -&gt;</span>
<span class="fc" id="L2425">                            ComponentExtension.from(thisComponent)</span>
<span class="fc" id="L2426">                                .addAnimatedStyler(status, conf -&gt; styler.style(status, conf))</span>
                        );
<span class="fc" id="L2428">                    }));</span>
<span class="fc" id="L2429">                })</span>
<span class="fc" id="L2430">                ._this();</span>
    }

    /**
     *  Set the color of this {@link JComponent}. (This is usually the font color for components displaying text) &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(Color.GRAY) );
     *  }&lt;/pre&gt;
     *
     * @param color The color of the foreground (usually text).
     * @return This very builder to allow for method chaining.
     */
    public final I withForeground( Color color ) {
<span class="fc" id="L2446">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="pc bpc" id="L2447" title="1 of 2 branches missed.">        return _with( c -&gt; c.setForeground( _isUndefinedColor(color) ? null : color ) )._this();</span>
    }

    /**
     *  Allows you to define the {@link JComponent#getForeground()} color of
     *  the underlying {@link JComponent} using a color string.
     *  The supplied {@link String} is parsed to a {@link UI.Color}
     *  through the {@link UI#color(String)} method for you. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(UI.color(&quot;oak&quot;)) );
     *  }&lt;/pre&gt;
     *
     * @param color A color string which should be parsed to a {@link UI.Color} instance
     *              and then set as the foreground color of the UI component.
     * @return A new reference to this type of builder, to allow for fluent method chaining.
     */
    public final I withForegroundColor( String color ) {
<span class="fc" id="L2467">        NullUtil.nullArgCheck(color, &quot;color&quot;, String.class);</span>
<span class="fc" id="L2468">        return this.withForeground(UI.color(color));</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a foreground color.
     *  This is a convenience method, which works
     *  similar to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          fg.onChange(From.VIEW_MODEL,  v -&gt; button.setForeground(v.get()) );
     *          button.setForeground(fg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForeground( Val&lt;Color&gt; fg ) {
<span class="fc" id="L2489">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Val.class);</span>
<span class="fc" id="L2490">        NullUtil.nullPropertyCheck(fg, &quot;fg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L2491">        return _withOnShow( fg, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">                    c.setForeground( _isUndefinedColor(v) ? null : v );</span>
<span class="fc" id="L2493">                })</span>
<span class="fc" id="L2494">                ._with( c -&gt; {</span>
<span class="fc" id="L2495">                    Color newColor = fg.get();</span>
<span class="pc bpc" id="L2496" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2497">                        newColor = null;</span>
<span class="fc" id="L2498">                    c.setForeground( newColor );</span>
<span class="fc" id="L2499">                })</span>
<span class="fc" id="L2500">                ._this();</span>
    }

    /**
     *  Use this to bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color fg ) {
<span class="fc" id="L2513">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2514">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Color.class);</span>
<span class="fc" id="L2515">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2516">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2517">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2518">                    Var&lt;Color&gt; newColor = Var.of( fg );</span>
<span class="fc" id="L2519">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, newColor, baseColor ) );</span>
<span class="fc" id="L2520">                })</span>
<span class="fc" id="L2521">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2522" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? fg : c.getForeground();</span>
<span class="pc bpc" id="L2523" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2524">                        newColor = null;</span>
<span class="fc" id="L2525">                    c.setForeground( newColor );</span>
<span class="fc" id="L2526">                })</span>
<span class="fc" id="L2527">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The foreground color property which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L2540">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2541">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L2542">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2543">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2544">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L2545">                    Var&lt;Color&gt; baseColor = Var.of( thisComponent.getForeground() );</span>
<span class="fc" id="L2546">                    _onShow( condition, thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2547">                    _onShow( color,     thisComponent, (c,v) -&gt; _updateForeground( c, condition, color, baseColor ) );</span>
<span class="fc" id="L2548">                })</span>
<span class="fc" id="L2549">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2550" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? color.get() : c.getForeground();</span>
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2552">                        newColor = null;</span>
<span class="fc" id="L2553">                    c.setForeground( newColor );</span>
<span class="fc" id="L2554">                })</span>
<span class="fc" id="L2555">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color which should be set for the UI component.
     * @param colorIfFalse The foreground color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L2569">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2570">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Color.class);</span>
<span class="fc" id="L2571">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Color.class);</span>
<span class="fc" id="L2572">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2573">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2574">                    _updateForeground( c, condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
<span class="fc" id="L2575">                })</span>
<span class="fc" id="L2576">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2577" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue : colorIfFalse;</span>
<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor) )</span>
<span class="nc" id="L2579">                        newColor = null;</span>
<span class="fc" id="L2580">                    c.setForeground( newColor );</span>
<span class="fc" id="L2581">                })</span>
<span class="fc" id="L2582">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color property which should be set for the UI component.
     * @param colorIfFalse The foreground color property which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L2596">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L2597">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L2598">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L2599">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L2600">        NullUtil.nullPropertyCheck(colorIfTrue, &quot;colorIfTrue&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2601">        NullUtil.nullPropertyCheck(colorIfFalse, &quot;colorIfFalse&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L2602">        return _withOnShow( condition, (c,v) -&gt; {</span>
<span class="fc" id="L2603">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2604">                })</span>
<span class="fc" id="L2605">                ._withOnShow( colorIfTrue, (c,v) -&gt; {</span>
<span class="fc" id="L2606">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2607">                })</span>
<span class="fc" id="L2608">                ._withOnShow( colorIfFalse, (c,v) -&gt; {</span>
<span class="fc" id="L2609">                    _updateForeground( c, condition, colorIfTrue, Var.of(colorIfFalse.get()) );</span>
<span class="fc" id="L2610">                })</span>
<span class="fc" id="L2611">                ._with( c -&gt; {</span>
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">                    Color newColor = condition.get() ? colorIfTrue.get() : colorIfFalse.get();</span>
<span class="pc bpc" id="L2613" title="1 of 2 branches missed.">                    if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2614">                        newColor = null;</span>
<span class="fc" id="L2615">                    c.setForeground( newColor );</span>
<span class="fc" id="L2616">                })</span>
<span class="fc" id="L2617">                ._this();</span>
    }

    private void _updateForeground(
        C component,
        Val&lt;Boolean&gt; condition,
        Val&lt;Color&gt;   color,
        Val&lt;Color&gt;   baseColor
    ) {
<span class="fc bfc" id="L2626" title="All 2 branches covered.">        Color newColor = condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2627" title="1 of 2 branches missed.">        if ( _isUndefinedColor(newColor))</span>
<span class="nc" id="L2628">            newColor = null;</span>

<span class="fc" id="L2630">        component.setForeground(newColor);</span>
<span class="fc" id="L2631">    }</span>

    private void _updateBackground(
            C component,
            Val&lt;Boolean&gt; condition,
            Val&lt;Color&gt; color,
            Val&lt;Color&gt; baseColor
    ) {
<span class="fc bfc" id="L2639" title="All 2 branches covered.">        Color newColor =  condition.is(true) ? color.get() : baseColor.get();</span>
<span class="pc bpc" id="L2640" title="1 of 2 branches missed.">        if ( _isUndefinedColor(newColor) )</span>
<span class="nc" id="L2641">            newColor = null;</span>

<span class="fc" id="L2643">        component.setBackground(newColor);</span>
<span class="fc" id="L2644">    }</span>

    /**
     *  Set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Use {@link #withMinSize(Size)} instead.
     */
    @Deprecated
    public final I withMinSize( Dimension size ) {
<span class="fc" id="L2656">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2657">        return _with( c -&gt; c.setMinimumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the minimum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Size size ) {
<span class="fc" id="L2667">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2668">        return _with( c -&gt; c.setMinimumSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} (Dimension)} on the underlying component. &lt;br&gt;
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click Me&quot;)
     *    .peek( button -&gt; {
     *      size.onSetItem(JButton::setMinimumSize);
     *      button.setMinimumSize(size.get());
     *    });
     *  }&lt;/pre&gt;
     *
     * @param size The minimum {@link Size} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L2688">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2689">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the minimum size of this component!&quot;);</span>
<span class="fc" id="L2690">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2691">                    c.setMinimumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L2692">                    _revalidate(c);</span>
<span class="fc" id="L2693">                })</span>
<span class="fc" id="L2694">                ._with( c -&gt; {</span>
<span class="fc" id="L2695">                    c.setMinimumSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L2696">                })</span>
<span class="fc" id="L2697">                ._this();</span>
    }

    /**
     *  Set the minimum width and heigh ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( int width, int height ) {
<span class="fc" id="L2708">        return _with( c -&gt; c.setMinimumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2720">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2721">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2722">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2723">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2724">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2725">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2726">                    _revalidate(c);</span>
<span class="fc" id="L2727">                })</span>
<span class="fc" id="L2728">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2729">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2730">                    _revalidate(c);</span>
<span class="fc" id="L2731">                })</span>
<span class="fc" id="L2732">                ._with( c -&gt; {</span>
<span class="fc" id="L2733">                    c.setMinimumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2734">                })</span>
<span class="fc" id="L2735">                ._this();</span>
    }

    /**
     *  Use this to only set the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( int width ) {
<span class="fc" id="L2745">        return _with( c -&gt; {</span>
<span class="fc" id="L2746">                    _setMinWidth(c, width);</span>
<span class="fc" id="L2747">               })</span>
<span class="fc" id="L2748">               ._this();</span>
    }

    protected final void _setMinWidth( C component, int width ) {
<span class="fc" id="L2752">        int currentHeight = component.getMinimumSize().height;</span>
<span class="pc bpc" id="L2753" title="1 of 4 branches missed.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2754">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2755">        component.setMinimumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2756">    }</span>

    /**
     *  Use this to dynamically set only the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2765">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2766">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2767">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2768">                    c.setMinimumSize(new Dimension(UI.scale(w), c.getMinimumSize().height));</span>
<span class="fc" id="L2769">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2770">                })</span>
<span class="fc" id="L2771">                ._with( c -&gt; {</span>
<span class="fc" id="L2772">                    _setMinWidth(c, width.get());</span>
<span class="fc" id="L2773">                })</span>
<span class="fc" id="L2774">                ._this();</span>
    }


    /**
     *  Use this to only set the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( int height ) {
<span class="fc" id="L2785">        return _with( c -&gt; {</span>
<span class="fc" id="L2786">                    _setMinHeight(c, height);</span>
<span class="fc" id="L2787">                })</span>
<span class="fc" id="L2788">                ._this();</span>
    }

    protected final void _setMinHeight( C component, int height ) {
<span class="fc" id="L2792">        int currentWidth = component.getMinimumSize().width;</span>
<span class="fc bfc" id="L2793" title="All 4 branches covered.">        if ( !component.isMinimumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2794">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2795">        component.setMinimumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2796">    }</span>

    /**
     *  Use this to dynamically set only the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2805">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2806">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2807">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2808">                    c.setMinimumSize(new Dimension(c.getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2809">                    _revalidate(c); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2810">                })</span>
<span class="fc" id="L2811">                ._with( c -&gt; {</span>
<span class="fc" id="L2812">                    _setMinHeight(c, height.get());</span>
<span class="fc" id="L2813">                })</span>
<span class="fc" id="L2814">                ._this();</span>
    }

    /**
     *  Set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Use {@link #withMaxSize(Size)} instead.
     */
    @Deprecated
    public final I withMaxSize( Dimension size ) {
<span class="fc" id="L2827">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2828">        return _with( c -&gt; c.setMaximumSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Size size ) {
<span class="fc" id="L2838">        NullUtil.nullArgCheck(size, &quot;size&quot;, Size.class);</span>
<span class="fc" id="L2839">        return _with( c -&gt; c.setMaximumSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Size} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Size} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L2850">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2851">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the maximum size of this component!&quot;);</span>
<span class="fc" id="L2852">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L2853">                    c.setMaximumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L2854">                    _revalidate(c); // For some reason this is needed to make the change visible.</span>
<span class="fc" id="L2855">                })</span>
<span class="fc" id="L2856">                ._with( c -&gt; {</span>
<span class="fc" id="L2857">                    c.setMaximumSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L2858">                })</span>
<span class="fc" id="L2859">                ._this();</span>
    }

    /**
     *  Set the maximum width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( int width, int height ) {
<span class="fc" id="L2870">        return _with( c -&gt; c.setMaximumSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the maximum size of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2881">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2882">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2883">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2884">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2885">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2886">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2887">                    _revalidate(c); // Raw Swing is not smart enough to do this automatically :(</span>
<span class="fc" id="L2888">                })</span>
<span class="fc" id="L2889">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2890">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2891">                    _revalidate(c); // Still not smart enough to do this automatically :(</span>
<span class="fc" id="L2892">                })</span>
<span class="fc" id="L2893">                ._with( c -&gt; {</span>
<span class="fc" id="L2894">                    c.setMaximumSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L2895">                })</span>
<span class="fc" id="L2896">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( int width ) {
<span class="fc" id="L2906">        return _with( c -&gt; {</span>
<span class="fc" id="L2907">                    _setMaxWidth(c, width);</span>
<span class="fc" id="L2908">                })</span>
<span class="fc" id="L2909">                ._this();</span>
    }

    private void _setMaxWidth( C component, int width ) {
<span class="fc" id="L2913">        int currentHeight = component.getMaximumSize().height;</span>
<span class="pc bpc" id="L2914" title="1 of 4 branches missed.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2915">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L2916">        component.setMaximumSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L2917">    }</span>

    /**
     *  Use this to dynamically set only the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2926">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2927">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2928">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L2929">                    c.setMaximumSize(new Dimension(UI.scale(w), c.getMaximumSize().height));</span>
<span class="fc" id="L2930">                    _revalidate(c); // When the size changes, the layout manager needs to be informed.</span>
<span class="fc" id="L2931">                })</span>
<span class="fc" id="L2932">                ._with( c -&gt; {</span>
<span class="fc" id="L2933">                    _setMaxWidth(c, width.get());</span>
<span class="fc" id="L2934">                })</span>
<span class="fc" id="L2935">                ._this();</span>
    }

    /**
     *  Use this to only set the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( int height ) {
<span class="fc" id="L2945">        return _with( c -&gt; {</span>
<span class="fc" id="L2946">                    _setMaxHeight(c, height);</span>
<span class="fc" id="L2947">                })</span>
<span class="fc" id="L2948">                ._this();</span>
    }

    private void _setMaxHeight( C component, int height ) {
<span class="fc" id="L2952">        int currentWidth = component.getMaximumSize().width;</span>
<span class="fc bfc" id="L2953" title="All 4 branches covered.">        if ( !component.isMaximumSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L2954">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L2955">        component.setMaximumSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L2956">    }</span>

    /**
     *  Use this to dynamically set only the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2965">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2966">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2967">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L2968">                    c.setMaximumSize(new Dimension(c.getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2969">                    _revalidate(c); // The revalidate is necessary to make the change visible, this makes sure the layout is recalculated.</span>
<span class="fc" id="L2970">                })</span>
<span class="fc" id="L2971">                ._with( c -&gt; {</span>
<span class="fc" id="L2972">                    _setMaxHeight(c, height.get());</span>
<span class="fc" id="L2973">                })</span>
<span class="fc" id="L2974">                ._this();</span>
    }

    /**
     *  Set the preferred {@link Dimension} of this {@link JComponent}, which consists
     *  of a width and a height used as a suggestion to the {@link LayoutManager} of the
     *  parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The preferred {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Please use {@link #withPrefSize(Size)} instead.
     */
    @Deprecated
    public final I withPrefSize( Dimension size ) {
<span class="fc" id="L2990">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2991">        return _with( c -&gt; c.setPreferredSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Set the preferred {@link Size} of this {@link JComponent}, which consists
     *  of a width and a height used as a suggestion to the {@link LayoutManager} of the
     *  parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Size size ) {
<span class="fc" id="L3003">        NullUtil.nullArgCheck(size, &quot;size&quot;, Size.class);</span>
<span class="fc" id="L3004">        return _with( c -&gt; c.setPreferredSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the preferred {@link Size} of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size A property holding the preferred {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L3017">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3018">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the preferred size of this component!&quot;);</span>
<span class="fc" id="L3019">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3020">                    c.setPreferredSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3021">                    _revalidate(c);</span>
<span class="fc" id="L3022">                })</span>
<span class="fc" id="L3023">                ._with( c -&gt; {</span>
<span class="fc" id="L3024">                    c.setPreferredSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L3025">                })</span>
<span class="fc" id="L3026">                ._this();</span>
    }

    /**
     *  Set the preferred width and height ({@link Dimension}) of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( int width, int height ) {
<span class="fc" id="L3039">        return _with( c -&gt; c.setPreferredSize(new Dimension(UI.scale(width), UI.scale(height))) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the preferred {@link Dimension} of this {@link JComponent},
     *  which consists of a width and a height used as a suggestion
     *  to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L3052">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3053">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3054">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L3055">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L3056">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3057">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L3058">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L3059">                })</span>
<span class="fc" id="L3060">                ._withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3061">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L3062">                    _revalidate(c); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L3063">                })</span>
<span class="fc" id="L3064">                ._with( c -&gt; {</span>
<span class="fc" id="L3065">                    c.setPreferredSize( new Dimension(UI.scale(width.get()), UI.scale(height.get())) );</span>
<span class="fc" id="L3066">                })</span>
<span class="fc" id="L3067">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred width of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( int width ) {
<span class="fc" id="L3078">        return _with( c -&gt; {</span>
<span class="fc" id="L3079">                    _setPrefWidth(c, width);</span>
<span class="fc" id="L3080">                })</span>
<span class="fc" id="L3081">                ._this();</span>
    }

    protected final void _setPrefWidth( C component, int width ) {
<span class="fc" id="L3085">        int currentHeight = component.getPreferredSize().height;</span>
<span class="fc bfc" id="L3086" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L3087">            currentHeight = UI.scale(currentHeight);</span>
<span class="fc" id="L3088">        component.setPreferredSize(new Dimension(UI.scale(width), currentHeight));</span>
<span class="fc" id="L3089">    }</span>

    /**
     *  Use this to dynamically set only the preferred width of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3099">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3100">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L3101">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3102">                    c.setPreferredSize(new Dimension(UI.scale(w), c.getPreferredSize().height));</span>
<span class="fc" id="L3103">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L3104">                })</span>
<span class="fc" id="L3105">                ._with( c -&gt; {</span>
<span class="fc" id="L3106">                    _setPrefWidth(c, width.get());</span>
<span class="fc" id="L3107">                })</span>
<span class="fc" id="L3108">                ._this();</span>
    }

    /**
     *  Use this to only set the preferred height of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( int height ) {
<span class="fc" id="L3119">        return _with( c -&gt; {</span>
<span class="fc" id="L3120">                    _setPrefHeight(c, height);</span>
<span class="fc" id="L3121">                })</span>
<span class="fc" id="L3122">                ._this();</span>
    }

    private void _setPrefHeight( C component, int height ) {
<span class="fc" id="L3126">        int currentWidth = component.getPreferredSize().width;</span>
<span class="fc bfc" id="L3127" title="All 4 branches covered.">        if ( !component.isPreferredSizeSet() &amp;&amp; UI.currentLookAndFeel().isOneOf(UI.LookAndFeel.METAL, UI.LookAndFeel.NIMBUS) )</span>
<span class="fc" id="L3128">            currentWidth = UI.scale(currentWidth);</span>
<span class="fc" id="L3129">        component.setPreferredSize(new Dimension(currentWidth, UI.scale(height)));</span>
<span class="fc" id="L3130">    }</span>

    /**
     *  Use this to dynamically set only the preferred height of this {@link JComponent},
     *  which serves as a suggestion to the {@link LayoutManager} of the parent container. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3140">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3141">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L3142">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3143">                    c.setPreferredSize(new Dimension(c.getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L3144">                    _revalidate(c); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L3145">                })</span>
<span class="fc" id="L3146">                ._with( c -&gt; {</span>
<span class="fc" id="L3147">                    _setPrefHeight(c, height.get());</span>
<span class="fc" id="L3148">                })</span>
<span class="fc" id="L3149">                ._this();</span>
    }

    /**
     *  Set the current {@link Dimension})/size (width and height) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     * @deprecated Due to the inherent pitfalls that come along with the {@link Dimension} being mutable!&lt;br&gt;
     *             Please use {@link #withSize(Size)} instead.
     */
    @Deprecated
    public final I withSize( Dimension size ) {
<span class="fc" id="L3162">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L3163">        return _with( c -&gt; c.setSize(UI.scale(size)) )._this();</span>
    }

    /**
     *  Sets the current {@link Size}) (width and height) of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(Size)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The current {@link Size} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Size size ) {
<span class="fc" id="L3178">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L3179">        return _with( c -&gt; c.setSize(UI.scale(size.toDimension())) )._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current {@link Dimension} of this {@link JComponent}
     *  using a {@link Size} object. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(Val)} method instead. &lt;br&gt;
     *  The {@link Size} is automatically translated to a call to
     *  {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param size The current {@link Size} of the component wrapped by a {@link Val} property.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Val&lt;Size&gt; size ) {
<span class="fc" id="L3196">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3197">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L3198">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3199">                    c.setSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3200">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3201">                })</span>
<span class="fc" id="L3202">                ._with( c -&gt; {</span>
<span class="fc" id="L3203">                    c.setSize( UI.scale(size.get().toDimension()) );</span>
<span class="fc" id="L3204">                })</span>
<span class="fc" id="L3205">                ._this();</span>
    }

    /**
     *  Allows you to directly set the width and height of the current component
     *  directly instead of through the layout manager. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the size of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefSize(int, int)} method instead. &lt;br&gt;
     *  Also note that this method translates to invoking
     *  {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     *
     * @param width The width of the component.
     * @param height The height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( int width, int height ) {
<span class="fc" id="L3223">        return this.withSize( new Dimension(width, height) );</span>
    }

    /**
     *  Set the current width of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the set width of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefWidth(int)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( int width ) {
<span class="fc" id="L3237">        return _with( c -&gt; {</span>
<span class="fc" id="L3238">                    c.setSize(new Dimension(UI.scale(width), c.getSize().height));</span>
<span class="fc" id="L3239">                })</span>
<span class="fc" id="L3240">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current width of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the width of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefWidth(Val)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3254">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L3255">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3256">        return _withOnShow( width, (c,w) -&gt; {</span>
<span class="fc" id="L3257">                    c.setSize(new Dimension(UI.scale(w), c.getSize().height));</span>
<span class="fc" id="L3258">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3259">                })</span>
<span class="fc" id="L3260">                ._with( c -&gt; {</span>
<span class="fc" id="L3261">                    c.setSize(new Dimension(UI.scale(width.get()), c.getSize().height));</span>
<span class="fc" id="L3262">                })</span>
<span class="fc" id="L3263">                ._this();</span>
    }

    /**
     *  Set the current height of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the height of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefHeight(int)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( int height ) {
<span class="fc" id="L3277">        return _with( c -&gt; {</span>
<span class="fc" id="L3278">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height)));</span>
<span class="fc" id="L3279">                })</span>
<span class="fc" id="L3280">                ._this();</span>
    }

    /**
     *  Bind to a {@link Val} object to dynamically set the current height of this {@link JComponent}. &lt;br&gt;
     *  Note however that calling this method, may not necessarily have a visual effect
     *  on the component, as the layout manager may override the height of the component. &lt;br&gt;
     *  So in case of the component being part of a layout (which is the case most of the time),
     *  you may want to use the {@link #withPrefHeight(Val)} method instead. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3294">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L3295">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3296">        return _withOnShow( height, (c,h) -&gt; {</span>
<span class="fc" id="L3297">                    c.setSize(new Dimension(c.getSize().width, UI.scale(h)));</span>
<span class="fc" id="L3298">                    _revalidate(c); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L3299">                })</span>
<span class="fc" id="L3300">                ._with( c -&gt; {</span>
<span class="fc" id="L3301">                    c.setSize(new Dimension(c.getSize().width, UI.scale(height.get())));</span>
<span class="fc" id="L3302">                })</span>
<span class="fc" id="L3303">                ._this();</span>
    }

    private static void _revalidate( Component comp ) {
<span class="fc" id="L3307">        comp.revalidate();</span>
<span class="pc bpc" id="L3308" title="1 of 2 branches missed.">        if ( comp instanceof JScrollPane )</span>
<span class="nc" id="L3309">            Optional.ofNullable(comp.getParent())</span>
<span class="nc" id="L3310">                    .ifPresent(Component::revalidate); // For some reason, JScrollPane does not revalidate its parent when its preferred size changes.</span>
<span class="fc" id="L3311">    }</span>

    /**
     *   Allows you to define a common width and height for the minimum, maximum, and preferred size of this component.
     *   This is a convenience method, which is equivalent to:
     *   &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *   }&lt;/pre&gt;
     *   This method call translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *   {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *   on the underlying component.
     *
     * @param width The min-, max- and preferred with of the component.
     * @param height The min-, max- and preferred height of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( int width, int height ) {
<span class="fc" id="L3330">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3331">        self = UIForAnySwing.class.cast(self.withMinSize(width, height));</span>
<span class="fc" id="L3332">        self = UIForAnySwing.class.cast(self.withMaxSize(width, height));</span>
<span class="fc" id="L3333">        self = UIForAnySwing.class.cast(self.withPrefSize(width, height));</span>
<span class="fc" id="L3334">        return self._this();</span>
    }

    /**
     *  Allows you to define a common width and height for the minimum, maximum, and preferred size of this component
     *  in the form of the supplied {@link Size} object.
     *  This is in essence a convenience method equivalent to:
     *  &lt;pre&gt;{@code
     *      .withMinSize(size)
     *      .withMaxSize(size)
     *      .withPrefSize(size)
     *  }&lt;/pre&gt;
     *  Underneath, this method call translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param size The min-, max- and preferred {@link Size} of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( Size size ) {
<span class="fc" id="L3354">        Objects.requireNonNull(size, &quot;size&quot;);</span>
<span class="pc bpc" id="L3355" title="1 of 2 branches missed.">        if ( size.equals(Size.unknown()) )</span>
<span class="nc" id="L3356">            return _this();</span>

<span class="pc bpc" id="L3358" title="1 of 2 branches missed.">        if ( !size.hasPositiveHeight() ) // Width only!</span>
<span class="nc" id="L3359">            return withWidthExactly(size.width().map(Number::intValue).orElse(0));</span>
<span class="pc bpc" id="L3360" title="1 of 2 branches missed.">         else if ( !size.hasPositiveWidth() ) // Height only!</span>
<span class="nc" id="L3361">            return withHeightExactly(size.height().map(Number::intValue).orElse(0));</span>
        else
<span class="fc" id="L3363">            return withSizeExactly(</span>
<span class="fc" id="L3364">                    size.width().map(Number::intValue).orElse(0),</span>
<span class="fc" id="L3365">                    size.height().map(Number::intValue).orElse(0)</span>
                );
    }

    /**
     *  Bind to a {@link Size} object to dynamically update the common
     *  width and height for the minimum, maximum, and preferred size of this component.
     *  This is in essence a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *  }&lt;/pre&gt;
     *  This method translates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param size A property wrapping the min-, max- and preferred {@link Size} of the component.
     *             When the property item changes, the size of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withSizeExactly( Val&lt;Size&gt; size ) {
<span class="fc" id="L3387">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L3388">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L3389">        return _withOnShow( size, (c,v) -&gt; {</span>
<span class="fc" id="L3390">                    c.setMinimumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3391">                    c.setMaximumSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3392">                    c.setPreferredSize(UI.scale(v.toDimension()));</span>
<span class="fc" id="L3393">                    _revalidate(c);</span>
<span class="fc" id="L3394">                })</span>
<span class="fc" id="L3395">                ._with( c -&gt; {</span>
<span class="fc" id="L3396">                    c.setMinimumSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3397">                    c.setMaximumSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3398">                    c.setPreferredSize(UI.scale(size.get().toDimension()));</span>
<span class="fc" id="L3399">                })</span>
<span class="fc" id="L3400">                ._this();</span>
    }

    /**
     *  Allows you to bind to two {@link Val} properties to dynamically update the common width and height
     *  for the minimum, maximum, and preferred size of this component.
     *  This is in essence a convenience method, which is equivalent to:
     *  &lt;pre&gt;{@code
     *      .withMinSize(width, height)
     *      .withMaxSize(width, height)
     *      .withPrefSize(width, height)
     *  }&lt;/pre&gt;
     *  This method will translate the property updates to calling {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component in the form of an integer property.
     *              When the property item changes, the width of the component will be updated accordingly.
     * @param height The min-, max- and preferred height of the component in the form of an integer property.
     *               When the property item changes, the height of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     * @throws NullPointerException If any of the provided properties is {@code null}.
     */
    public final I withSizeExactly( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L3424">        Objects.requireNonNull(width, &quot;width&quot;);</span>
<span class="fc" id="L3425">        Objects.requireNonNull(height, &quot;height&quot;);</span>
<span class="fc" id="L3426">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3427">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3428">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3429">        self = UIForAnySwing.class.cast(self.withMinSize(width, height));</span>
<span class="fc" id="L3430">        self = UIForAnySwing.class.cast(self.withMaxSize(width, height));</span>
<span class="fc" id="L3431">        self = UIForAnySwing.class.cast(self.withPrefSize(width, height));</span>
<span class="fc" id="L3432">        return self._this();</span>
    }

    /**
     *  Use this to set the min-, max- and preferred width of this {@link JComponent} to the same value. &lt;br&gt;
     *  This is a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinWidth(width)
     *      .withMaxWidth(width)
     *      .withPrefWidth(width)
     *  }&lt;/pre&gt;
     *  An invocation to this method translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withWidthExactly( int width ) {
<span class="nc" id="L3451">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="nc" id="L3452">        self = UIForAnySwing.class.cast(self.withMinWidth(width));</span>
<span class="nc" id="L3453">        self = UIForAnySwing.class.cast(self.withMaxWidth(width));</span>
<span class="nc" id="L3454">        self = UIForAnySwing.class.cast(self.withPrefWidth(width));</span>
<span class="nc" id="L3455">        return self._this();</span>
    }

    /**
     *  Use this to bind to a {@link Val} property to dynamically update the min-, max- and preferred width
     *  of this {@link JComponent} to the same value. &lt;br&gt;
     *  So whenever the item of the property changes, all these widths will
     *  be updated automatically for you.
     *  This is a convenience method, which is equivalent to calling {@link #withMinWidth(Val)},
     *  {@link #withMaxWidth(Val)} and {@link #withPrefWidth(Val)} on the underlying component.
     *  &lt;pre&gt;{@code
     *      .withMinWidth(width)
     *      .withMaxWidth(width)
     *      .withPrefWidth(width)
     *  }&lt;/pre&gt;
     *  Eventually, all of this ultimately translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param width The min-, max- and preferred width of the component wrapped by a {@link Val}.
     *              When the property item changes, the width of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withWidthExactly( Val&lt;Integer&gt; width ) {
<span class="fc" id="L3479">        Objects.requireNonNull(width, &quot;width&quot;);</span>
<span class="fc" id="L3480">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L3481">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3482">        self = UIForAnySwing.class.cast(self.withMinWidth(width));</span>
<span class="fc" id="L3483">        self = UIForAnySwing.class.cast(self.withMaxWidth(width));</span>
<span class="fc" id="L3484">        self = UIForAnySwing.class.cast(self.withPrefWidth(width));</span>
<span class="fc" id="L3485">        return self._this();</span>
    }

    /**
     *  Use this to set the min-, max- and preferred height of this {@link JComponent} to the same value. &lt;br&gt;
     *  This is a convenience method, which is equivalent to calling:
     *  &lt;pre&gt;{@code
     *      .withMinHeight(height)
     *      .withMaxHeight(height)
     *      .withPrefHeight(height)
     *  }&lt;/pre&gt;
     *  An invocation to this method translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param height The min-, max- and preferred height of the component.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withHeightExactly( int height ) {
<span class="nc" id="L3504">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="nc" id="L3505">        self = UIForAnySwing.class.cast(self.withMinHeight(height));</span>
<span class="nc" id="L3506">        self = UIForAnySwing.class.cast(self.withMaxHeight(height));</span>
<span class="nc" id="L3507">        self = UIForAnySwing.class.cast(self.withPrefHeight(height));</span>
<span class="nc" id="L3508">        return self._this();</span>
    }

    /**
     *  Use this to bind to a {@link Val} property to dynamically update the min-, max- and preferred height
     *  of this {@link JComponent} to the same value. &lt;br&gt;
     *  So whenever the item of the property changes, all these heights will
     *  be updated automatically for you.
     *  This is a convenience method, which is equivalent to calling {@link #withMinHeight(Val)},
     *  {@link #withMaxHeight(Val)} and {@link #withPrefHeight(Val)} on the underlying component.
     *  &lt;pre&gt;{@code
     *      .withMinHeight(height)
     *      .withMaxHeight(height)
     *      .withPrefHeight(height)
     *  }&lt;/pre&gt;
     *  Eventually, all of this ultimately translates to {@link JComponent#setMinimumSize(Dimension)},
     *  {@link JComponent#setMaximumSize(Dimension)}, and {@link JComponent#setPreferredSize(Dimension)}
     *  on the underlying component.
     *
     * @param height The min-, max- and preferred height of the component wrapped by a {@link Val}.
     *               When the property item changes, the height of the component will be updated accordingly.
     * @return A declarative builder instance to allow for further method chaining.
     */
    public final I withHeightExactly( Val&lt;Integer&gt; height ) {
<span class="fc" id="L3532">        Objects.requireNonNull(height, &quot;height&quot;);</span>
<span class="fc" id="L3533">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L3534">        UIForAnySwing&lt;I, C&gt; self = this;</span>
<span class="fc" id="L3535">        self = UIForAnySwing.class.cast(self.withMinHeight(height));</span>
<span class="fc" id="L3536">        self = UIForAnySwing.class.cast(self.withMaxHeight(height));</span>
<span class="fc" id="L3537">        self = UIForAnySwing.class.cast(self.withPrefHeight(height));</span>
<span class="fc" id="L3538">        return self._this();</span>
    }

    /**
     *  Calls the provided action event handler when the mouse gets pressed and then released.
     *  This delegates to a {@link MouseListener} based mouse click event listener registered in the UI component.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that a click is defined as the combination of the &lt;b&gt;mouse being pressed
     *  and then released on the same position as it was pressed.&lt;/b&gt;
     *  If the mouse moves between the press and the release events, then the
     *  event is considered a drag event instead of a mouse click! (see {@link #onMouseDrag(Action)})
     *
     * @param onClick The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseClick( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onClick ) {
<span class="fc" id="L3554">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L3555">        return _with( c -&gt; {</span>
<span class="fc" id="L3556">                    c.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseClicked(MouseEvent e) {
<span class="fc" id="L3558">                            _runInApp(() -&gt; {</span>
                                try {
<span class="fc" id="L3560">                                    onClick.accept(new ComponentMouseEventDelegate&lt;&gt;(c, e));</span>
<span class="nc" id="L3561">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3562">                                    log.error(&quot;Error in mouse click event action handler!&quot;, ex);</span>
<span class="fc" id="L3563">                                }</span>
<span class="fc" id="L3564">                            });</span>
<span class="fc" id="L3565">                        }</span>
                    });
<span class="fc" id="L3567">                })</span>
<span class="fc" id="L3568">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse release events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onRelease The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseRelease( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onRelease ) {
<span class="fc" id="L3581">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="fc" id="L3582">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3583">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3585">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3587">                                    onRelease.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e ));</span>
<span class="nc" id="L3588">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3589">                                    log.error(&quot;Error in mouse release event action handler!&quot;, ex);</span>
<span class="nc" id="L3590">                                }</span>
<span class="nc" id="L3591">                            });</span>
<span class="nc" id="L3592">                        }</span>
                    });
<span class="fc" id="L3594">                })</span>
<span class="fc" id="L3595">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse press events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onPress The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMousePress( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onPress ) {
<span class="fc" id="L3608">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="fc" id="L3609">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3610">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3612">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3614">                                    onPress.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3615">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3616">                                    log.error(&quot;Error in mouse press event action handler!&quot;, ex);</span>
<span class="nc" id="L3617">                                }</span>
<span class="nc" id="L3618">                            });</span>
<span class="nc" id="L3619">                        }</span>
                    });
<span class="fc" id="L3621">                })</span>
<span class="fc" id="L3622">                ._this();</span>
    }

    /**
     *  Use this to register and catch mouse enter events on
     *  the {@link UI.ComponentArea#BODY} of this UI component, &lt;br&gt;
     *  which consists of the full component boundaries except for the surrounding
     *  margins and corner rounding areas. &lt;br&gt;
     *  &lt;p&gt;
     *  If you want to catch mouse enter events on a different area of the component, use
     *  {@link #onMouseEnter(UI.ComponentArea, Action)} instead.
     *  Internally, this method adds the supplied {@link Action} lambda to a custom event dispatcher
     *  which ensures that the mouse enter event is only triggered when the mouse enters the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3642">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3643">        return onMouseEnter(UI.ComponentArea.BODY, onEnter);</span>
    }

    /**
     *  Use this to register and catch mouse enter events on a specific area of this UI component,
     *  defined by the first argument, a {@link UI.ComponentArea} enum value, and the second argument,
     *  a lambda instance which will be invoked when the mouse enters the specified area.
     *  Internally, the provided {@link Action} lambda is handled by a custom event dispatcher
     *  which ensures that the mouse enter event is only triggered when the mouse enters the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse enter event is different from the native Swing mouse enter event,
     *  which also considers child components with mouse listeners as enter/exit boundaries.&lt;br&gt;
     *  If you want to rely on this the Swing behavior, use {@link #onMouseEnterGreedy(Action)} instead.&lt;br&gt;
     *  &lt;b&gt;
     *      We do however recommended to rely on this method, to avoid bugs due to the unexpected side effect
     *      of enter events being fired at the boundary to child components.
     *  &lt;/b&gt;
     *
     * @param area The specific area of the component where the mouse enter event should be caught.
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( UI.ComponentArea area, Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3667">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3668">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3669">                    WeakReference&lt;@Nullable C&gt; source = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L3670">                    MouseListener listener = new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="fc" id="L3672">                            @Nullable C localComponent = source.get();</span>
<span class="pc bpc" id="L3673" title="1 of 2 branches missed.">                            if ( localComponent != null )</span>
<span class="fc" id="L3674">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L3676">                                        onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(localComponent, e));</span>
<span class="nc" id="L3677">                                    } catch ( Exception ex ) {</span>
<span class="nc" id="L3678">                                        log.error(&quot;Error in mouse enter event action handler!&quot;, ex);</span>
<span class="fc" id="L3679">                                    }</span>
<span class="fc" id="L3680">                                });</span>
<span class="fc" id="L3681">                        }</span>
                    };
<span class="fc" id="L3683">                    EnterExitComponentBoundsEventDispatcher.addMouseEnterListener(area, thisComponent, listener);</span>
<span class="fc" id="L3684">                })</span>
<span class="fc" id="L3685">                ._this();</span>
    }

    /**
     *  Use this to register and catch simple {@link MouseListener} based mouse enter events on this UI component.
     *  This method adds the supplied {@link Action} lambda in a {@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  This method is greedy in the sense that in case of the parent of this component
     *  also having a mouse listener, then a mouse cursor transition on top of this component
     *  will be considered an exit from the parent component and an enter into this component. &lt;br&gt;
     *  If you want to catch mouse enter events strictly in terms of the cursor being inside
     *  the component boundaries, or one of its areas, use {@link #onMouseEnter(Action)}, or
     *  {@link #onMouseEnter(UI.ComponentArea, Action)} instead.&lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *      To avoid bugs due to the unexpected side effect of enter events being fired at the surface
     *      boundaries to child components, we recommend to use {@link #onMouseEnter(Action)} instead of this method!&lt;br&gt;
     *      Also note that this method is different from {@link #onMouseEnter(Action)}, in that it reports enter events at
     *      the boundaries of {@link swingtree.UI.ComponentArea#ALL} instead of {@link swingtree.UI.ComponentArea#BODY}.
     *  &lt;/b&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnterGreedy( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L3709">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L3710">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3711">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="nc" id="L3713">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3715">                                    onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3716">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3717">                                    log.error(&quot;Error in greedy mouse enter event action handler!&quot;, ex);</span>
<span class="nc" id="L3718">                                }</span>
<span class="nc" id="L3719">                            });</span>
<span class="nc" id="L3720">                        }</span>
                    });
<span class="fc" id="L3722">                })</span>
<span class="fc" id="L3723">                ._this();</span>
    }

    /**
     *  Use this to register and catch mouse exit events on
     *  the {@link UI.ComponentArea#BODY} of this UI component, &lt;br&gt;
     *  which consists of the full component boundaries except for the surrounding
     *  margins and corner rounding areas. &lt;br&gt;
     *  &lt;p&gt;
     *  If you want to catch mouse exit events on a different area than the body of the component, use
     *  {@link #onMouseExit(UI.ComponentArea, Action)} instead.
     *  Internally, this method adds the supplied {@link Action} lambda to a custom event dispatcher
     *  which ensures that the mouse exit event is only triggered when the mouse exits the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse enter event is different from the native Swing mouse enter event,
     *  which also considers child components with mouse listeners as enter/exit event boundaries.&lt;br&gt;
     *  If you want to rely on this the Swing behavior, use {@link #onMouseExitGreedy(Action)} instead.&lt;br&gt;
     *  &lt;b&gt;
     *      We do however recommended to rely on this method, to avoid bugs due to the unexpected side effect
     *      of exit events being fired at the boundary to child components.
     *  &lt;/b&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3750">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3751">        return onMouseExit(UI.ComponentArea.BODY, onExit);</span>
    }

    /**
     *  Use this to register and catch mouse exit events on a specific area of this UI component,
     *  by supplying a {@link UI.ComponentArea} enum value to define the area, and a {@link Action}
     *  lambda which will be invoked when the mouse exits the specified area, so that you can
     *  react to the event accordingly.&lt;br&gt;
     *  &lt;p&gt;
     *  Internally, the provided {@link Action} lambda is handled by a custom event dispatcher
     *  which ensures that the mouse exit event is only triggered when the mouse exits the
     *  boundaries of the specified area, irrespective of the existence of child components.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that this mouse exit event is different from the native Swing mouse exit event,
     *  which also considers child components with mouse listeners as enter/exit boundaries.
     *  If you want to rely on the native Swing behavior, use {@link #onMouseExitGreedy(Action)}
     *  instead of this method.
     *
     * @param area The specific area of the component where the mouse exit event should be caught.
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( UI.ComponentArea area, Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3774">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3775">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3776">                    WeakReference&lt;@Nullable C&gt; source = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L3777">                    MouseListener listener = new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L3779">                            @Nullable C localComponent = source.get();</span>
<span class="nc bnc" id="L3780" title="All 2 branches missed.">                            if ( localComponent != null )</span>
<span class="nc" id="L3781">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="nc" id="L3783">                                        onExit.accept(new ComponentMouseEventDelegate&lt;&gt;(localComponent, e));</span>
<span class="nc" id="L3784">                                    } catch ( Exception ex ) {</span>
<span class="nc" id="L3785">                                        log.error(&quot;Error in mouse exit event action handler!&quot;, ex);</span>
<span class="nc" id="L3786">                                    }</span>
<span class="nc" id="L3787">                                });</span>
<span class="nc" id="L3788">                        }</span>
                    };
<span class="fc" id="L3790">                    EnterExitComponentBoundsEventDispatcher.addMouseExitListener(area, thisComponent, listener);</span>
<span class="fc" id="L3791">                })</span>
<span class="fc" id="L3792">                ._this();</span>
    }

    /**
     *  Use this to register and catch simple {@link MouseListener} based mouse exit events on this UI component.
     *  This method adds the supplied {@link Action} lambda in a {@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The method is considered greedy in the sense that in case of the parent of this component
     *  also having a mouse listener, then a mouse cursor transition over to be on top of this component
     *  will be considered an exit from the parent components and an enter into this component. &lt;br&gt;
     *  If you want to catch mouse exit events strictly in terms of the cursor being inside
     *  the component boundaries, or one of its areas, use {@link #onMouseExit(Action)}, or
     *  {@link #onMouseExit(UI.ComponentArea, Action)} instead.&lt;br&gt;
     *  &lt;p&gt;&lt;b&gt;
     *      To avoid bugs due to the unexpected side effect of exit events being fired at the surface
     *      boundaries to child components, we recommend to use {@link #onMouseExit(Action)} instead of this method!&lt;br&gt;
     *      Also note that this method is different from {@link #onMouseExit(Action)}, in that it reports exit events at
     *      the boundaries of {@link swingtree.UI.ComponentArea#ALL} instead of {@link swingtree.UI.ComponentArea#BODY}.
     *  &lt;/b&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExitGreedy( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L3816">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L3817">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3818">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L3820">                            _runInApp(() -&gt; {</span>
                                try {
<span class="nc" id="L3822">                                onExit.accept(new ComponentMouseEventDelegate&lt;&gt;( thisComponent, e ));</span>
<span class="nc" id="L3823">                                } catch ( Exception ex ) {</span>
<span class="nc" id="L3824">                                    log.error(&quot;Error in greedy mouse exit event action handler!&quot;, ex);</span>
<span class="nc" id="L3825">                                }</span>
<span class="nc" id="L3826">                            });</span>
<span class="nc" id="L3827">                        }</span>
                    });
<span class="fc" id="L3829">                })</span>
<span class="fc" id="L3830">                ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse drag events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The {@link ComponentDragEventDelegate} received by the {@link Action} lambda
     *  exposes both component and drag event
     *  context information, including a list of all the {@link MouseEvent}s involved
     *  in one continuous dragging motion (see {@link ComponentDragEventDelegate#dragEvents()} for more information).
     *
     * @param onDrag The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseDrag( Action&lt;ComponentDragEventDelegate&lt;C&gt;&gt; onDrag ) {
<span class="nc" id="L3847">        NullUtil.nullArgCheck(onDrag, &quot;onDrag&quot;, Action.class);</span>
<span class="nc" id="L3848">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3849">                   java.util.List&lt;MouseEvent&gt; dragEventHistory = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3850">                   MouseAdapter listener = new MouseAdapter() {</span>
                       @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L3852">                           dragEventHistory.clear();</span>
<span class="nc" id="L3853">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3854">                       }</span>
                       @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L3856">                           dragEventHistory.clear();</span>
<span class="nc" id="L3857">                       }</span>
                       @Override public void mouseDragged(MouseEvent e) {
<span class="nc" id="L3859">                           dragEventHistory.add(e);</span>
<span class="nc" id="L3860">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3862">                                   onDrag.accept(new ComponentDragEventDelegate&lt;&gt;(thisComponent, e, dragEventHistory));</span>
<span class="nc" id="L3863">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3864">                                   log.error(&quot;Error in mouse drag event action handler!&quot;, ex);</span>
<span class="nc" id="L3865">                               }</span>
<span class="nc" id="L3866">                           });</span>
<span class="nc" id="L3867">                       }</span>
                   };
<span class="nc" id="L3869">                   thisComponent.addMouseListener(listener);</span>
<span class="nc" id="L3870">                   thisComponent.addMouseMotionListener(listener);</span>
<span class="nc" id="L3871">               })</span>
<span class="nc" id="L3872">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse move events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onMove The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseMove( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onMove ) {
<span class="fc" id="L3885">        NullUtil.nullArgCheck(onMove, &quot;onMove&quot;, Action.class);</span>
<span class="fc" id="L3886">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3887">                   thisComponent.addMouseListener(new MouseAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3889">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3891">                                   onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3892">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3893">                                   log.error(&quot;Error in mouse move event action handler!&quot;, ex);</span>
<span class="nc" id="L3894">                               }</span>
<span class="nc" id="L3895">                           });</span>
<span class="nc" id="L3896">                       }</span>
                   });
<span class="fc" id="L3898">                   thisComponent.addMouseMotionListener(new MouseMotionAdapter() {</span>
                       @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L3900">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3902">                                   onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3903">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3904">                                   log.error(&quot;Error in mouse move event action handler!&quot;, ex);</span>
<span class="nc" id="L3905">                               }</span>
<span class="nc" id="L3906">                           });</span>
<span class="nc" id="L3907">                       }</span>
                   });
<span class="fc" id="L3909">               })</span>
<span class="fc" id="L3910">               ._this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse wheel events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onWheel The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelMove( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheel ) {
<span class="nc" id="L3923">        NullUtil.nullArgCheck(onWheel, &quot;onWheel&quot;, Action.class);</span>
<span class="nc" id="L3924">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3925">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc" id="L3926">                       _runInApp(() -&gt; {</span>
                           try {
<span class="nc" id="L3928">                               onWheel.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3929">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L3930">                               log.error(&quot;Error in mouse wheel event action handler!&quot;, ex);</span>
<span class="nc" id="L3931">                           }</span>
<span class="nc" id="L3932">                       });</span>
<span class="nc" id="L3933">                   });</span>
<span class="nc" id="L3934">               })</span>
<span class="nc" id="L3935">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel up movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelUp The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelUp( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelUp ) {
<span class="nc" id="L3947">        NullUtil.nullArgCheck(onWheelUp, &quot;onWheelUp&quot;, Action.class);</span>
<span class="nc" id="L3948">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3949">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3950" title="All 2 branches missed.">                       if ( e.getWheelRotation() &lt; 0 )</span>
<span class="nc" id="L3951">                           _runInApp(() -&gt; {</span>
                               try {
<span class="nc" id="L3953">                                   onWheelUp.accept(new ComponentDelegate&lt;&gt;(thisComponent, e ));</span>
<span class="nc" id="L3954">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L3955">                                   log.error(&quot;Error in mouse wheel up event action handler!&quot;, ex);</span>
<span class="nc" id="L3956">                               }</span>
<span class="nc" id="L3957">                           });</span>
<span class="nc" id="L3958">                   });</span>
<span class="nc" id="L3959">               })</span>
<span class="nc" id="L3960">               ._this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel down movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelDown The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelDown( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelDown ) {
<span class="nc" id="L3972">        NullUtil.nullArgCheck(onWheelDown, &quot;onWheelDown&quot;, Action.class);</span>
<span class="nc" id="L3973">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L3974">                   thisComponent.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L3975" title="All 2 branches missed.">                       if ( e.getWheelRotation() &gt; 0 )</span>
<span class="nc" id="L3976">                               _runInApp(() -&gt; {</span>
                                   try {
<span class="nc" id="L3978">                                       onWheelDown.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L3979">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L3980">                                       log.error(&quot;Error in mouse wheel down event action handler!&quot;, ex);</span>
<span class="nc" id="L3981">                                   }</span>
<span class="nc" id="L3982">                               });</span>
<span class="nc" id="L3983">                   });</span>
<span class="nc" id="L3984">               })</span>
<span class="nc" id="L3985">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component's size changes.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *  Passing null to this method will cause an exception to be thrown.
     *
     * @param onResize The resize action which will be called when the underlying component changes size.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onResize( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onResize ) {
<span class="fc" id="L3997">        NullUtil.nullArgCheck(onResize, &quot;onResize&quot;, Action.class);</span>
<span class="fc" id="L3998">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L3999">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentResized(ComponentEvent e) {
<span class="fc" id="L4001">                           _runInApp(()-&gt;{</span>
                               try {
<span class="fc" id="L4003">                                   onResize.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4004">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4005">                                   log.error(&quot;Error in resize event action handler!&quot;, ex);</span>
<span class="fc" id="L4006">                               }</span>
<span class="fc" id="L4007">                           });</span>
<span class="fc" id="L4008">                       }</span>
                   });
<span class="fc" id="L4010">               })</span>
<span class="fc" id="L4011">               ._this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component was moved.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *
     * @param onMoved The action lambda which will be executed once the component was moved / its position canged.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMoved( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onMoved ) {
<span class="fc" id="L4022">        NullUtil.nullArgCheck(onMoved, &quot;onMoved&quot;, Action.class);</span>
<span class="fc" id="L4023">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4024">                   thisComponent.addComponentListener(new ComponentAdapter() {</span>
                       @Override public void componentMoved(ComponentEvent e) {
<span class="nc" id="L4026">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4028">                                   onMoved.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4029">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4030">                                   log.error(&quot;Error in move event action handler!&quot;, ex);</span>
<span class="nc" id="L4031">                               }</span>
<span class="nc" id="L4032">                           });</span>
<span class="nc" id="L4033">                       }</span>
                   });
<span class="fc" id="L4035">               })</span>
<span class="fc" id="L4036">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link AncestorListener}
     *  to the component, to receive calls when the wrapped component becomes visible
     *  on the screen. &lt;br&gt;
     *  &lt;p&gt;
     *  Note that this does not correlate 1:1 with the {@link Component#isVisible()} flag,
     *  because a component may also be invisible when it is not part of the component hierarchy
     *  with a visible root component (window) or one of its ancestors (parent components)
     *  is not visible.
     *
     * @param onShown The {@link Action} which gets invoked when the component has been made visible
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onShown( Action&lt;ComponentDelegate&lt;C, AncestorEvent&gt;&gt; onShown ) {
<span class="fc" id="L4053">        NullUtil.nullArgCheck(onShown, &quot;onShown&quot;, Action.class);</span>
<span class="fc" id="L4054">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4055">                   _prependAncestorListenerTo(thisComponent, new AncestorListener() {</span>
                       @Override public void ancestorAdded(AncestorEvent event) {
<span class="fc" id="L4057">                           _runInApp(()-&gt;{</span>
                               try {
<span class="fc" id="L4059">                                   onShown.accept(new ComponentDelegate&lt;&gt;(thisComponent, event));</span>
<span class="nc" id="L4060">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4061">                                   log.error(&quot;Error in show event action handler!&quot;, ex);</span>
<span class="fc" id="L4062">                               }</span>
<span class="fc" id="L4063">                           });</span>
<span class="fc" id="L4064">                       }</span>
<span class="nc" id="L4065">                       @Override public void ancestorRemoved(AncestorEvent event) {}</span>
<span class="fc" id="L4066">                       @Override public void ancestorMoved(AncestorEvent event) {}</span>
                   });
<span class="fc" id="L4068">               })</span>
<span class="fc" id="L4069">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link AncestorListener}
     *  to the component, to receive calls when the wrapped component becomes invisible
     *  on the users screen. &lt;br&gt;
     *  &lt;p&gt;
     *  Note that this does not correlate 1:1 with the {@link Component#isVisible()} flag,
     *  because a component may also be invisible when it is not part of the component hierarchy
     *  with a visible root component (window) or one of its ancestors (parent components)
     *  is not visible.
     *
     * @param onHidden The {@link Action} which gets invoked when the component has been made invisible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onHidden( Action&lt;ComponentDelegate&lt;C, AncestorEvent&gt;&gt; onHidden ) {
<span class="fc" id="L4086">        NullUtil.nullArgCheck(onHidden, &quot;onHidden&quot;, Action.class);</span>
<span class="fc" id="L4087">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4088">                    _prependAncestorListenerTo(thisComponent, new AncestorListener() {</span>
<span class="fc" id="L4089">                          @Override public void ancestorAdded(AncestorEvent event) {}</span>
                          @Override public void ancestorRemoved(AncestorEvent event) {
<span class="fc" id="L4091">                            _runInApp(()-&gt;{</span>
                                 try {
<span class="fc" id="L4093">                                      onHidden.accept(new ComponentDelegate&lt;&gt;(thisComponent, event));</span>
<span class="nc" id="L4094">                                 } catch ( Exception ex ) {</span>
<span class="nc" id="L4095">                                      log.error(&quot;Error in hide event action handler!&quot;, ex);</span>
<span class="fc" id="L4096">                                 }</span>
<span class="fc" id="L4097">                            });</span>
<span class="fc" id="L4098">                          }</span>
<span class="fc" id="L4099">                          @Override public void ancestorMoved(AncestorEvent event) {}</span>
                     });
<span class="fc" id="L4101">               })</span>
<span class="fc" id="L4102">               ._this();</span>
    }

    /**
     *  Adds {@link AncestorListener} to the component so that it will
     *  be called after the previously added ancestor listener was called.&lt;br&gt;
     *  The default behavior of Swing is to call the listeners from the most recently added to the oldest.
     *  This method will prepend the listener to the list of listeners, so that it will be called first.
     * @param component The component to which the listener should be added.
     * @param listener The listener to be added.
     */
    private static void _prependAncestorListenerTo( JComponent component, AncestorListener listener ) {
<span class="fc" id="L4114">        java.util.List&lt;AncestorListener&gt; listeners = new ArrayList&lt;&gt;(Arrays.asList(component.getAncestorListeners()));</span>
<span class="fc bfc" id="L4115" title="All 2 branches covered.">        for ( AncestorListener l : listeners )</span>
<span class="fc" id="L4116">            component.removeAncestorListener(l);</span>

<span class="fc" id="L4118">        listeners.add(listener);</span>
<span class="fc" id="L4119">        Collections.reverse(listeners);// revert the order of the listeners</span>

<span class="fc bfc" id="L4121" title="All 2 branches covered.">        for ( AncestorListener l : listeners )</span>
<span class="fc" id="L4122">            component.addAncestorListener(l);</span>
<span class="fc" id="L4123">    }</span>

    /**
     * Adds the supplied {@link Action} wrapped in a {@link FocusListener}
     * to the component, to receive those focus events where the wrapped component gains input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was gained on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusGain( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L4133">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L4134">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4135">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusGained(FocusEvent e) {
<span class="nc" id="L4137">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4139">                                   onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4140">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4141">                                   log.error(&quot;Error in focus gain event action handler!&quot;, ex);</span>
<span class="nc" id="L4142">                               }</span>
<span class="nc" id="L4143">                           });</span>
<span class="nc" id="L4144">                       }</span>
                   });
<span class="fc" id="L4146">               })</span>
<span class="fc" id="L4147">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a focus listener
     * to receive those focus events where the wrapped component loses input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was lost on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusLoss( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L4158">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L4159">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4160">                   thisComponent.addFocusListener(new FocusAdapter() {</span>
                       @Override public void focusLost(FocusEvent e) {
<span class="nc" id="L4162">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4164">                                   onFocus.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4165">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4166">                                   log.error(&quot;Error in focus loss event action handler!&quot;, ex);</span>
<span class="nc" id="L4167">                               }</span>
<span class="nc" id="L4168">                           });</span>
<span class="nc" id="L4169">                       }</span>
                   });
<span class="fc" id="L4171">               })</span>
<span class="fc" id="L4172">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received a key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onKeyPress( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L4183">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L4184">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4185">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed(KeyEvent e) {
<span class="nc" id="L4187">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4189">                                   onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4190">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4191">                                   log.error(&quot;Error in key press event action handler!&quot;, ex);</span>
<span class="nc" id="L4192">                               }</span>
<span class="nc" id="L4193">                           });</span>
<span class="nc" id="L4194">                       }</span>
                   });
<span class="fc" id="L4196">               })</span>
<span class="fc" id="L4197">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received the targeted key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onPressed( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L4210">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4211">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L4212">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4213">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyPressed( KeyEvent e ) {
<span class="nc bnc" id="L4215" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4216">                               _runInApp(()-&gt;{</span>
                                   try {
<span class="nc" id="L4218">                                       onKeyPressed.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4219">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L4220">                                       log.error(&quot;Error in key press event action handler!&quot;, ex);</span>
<span class="nc" id="L4221">                                   }</span>
<span class="nc" id="L4222">                               });</span>
<span class="nc" id="L4223">                       }</span>
                   });
<span class="fc" id="L4225">               })</span>
<span class="fc" id="L4226">               ._this();</span>
    }

                             /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received a key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     */
    public final I onKeyRelease( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L4238">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L4239">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4240">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased(KeyEvent e) {
<span class="nc" id="L4242">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4244">                                   onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4245">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4246">                                   log.error(&quot;Error in key release event action handler!&quot;, ex);</span>
<span class="nc" id="L4247">                               }</span>
<span class="nc" id="L4248">                           });</span>
<span class="nc" id="L4249">                       }</span>
                   });
<span class="fc" id="L4251">               })</span>
<span class="fc" id="L4252">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the built component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received the targeted key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onRelease( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L4267">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4268">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L4269">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4270">                   thisComponent.addKeyListener(new KeyAdapter() {</span>
                       @Override public void keyReleased( KeyEvent e ) {
<span class="nc bnc" id="L4272" title="All 2 branches missed.">                           if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4273">                               _runInApp(()-&gt;{</span>
                                   try {
<span class="nc" id="L4275">                                       onKeyReleased.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4276">                                   } catch ( Exception ex ) {</span>
<span class="nc" id="L4277">                                       log.error(&quot;Error in key release event action handler!&quot;, ex);</span>
<span class="nc" id="L4278">                                   }</span>
<span class="nc" id="L4279">                               });</span>
<span class="nc" id="L4280">                       }</span>
                   });
<span class="fc" id="L4282">               })</span>
<span class="fc" id="L4283">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received a key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     */
    public final I onKeyTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L4296">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L4297">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4298">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc" id="L4299">                       _runInApp(() -&gt; {</span>
                           try {
<span class="nc" id="L4301">                               onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4302">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4303">                               log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4304">                           }</span>
<span class="nc" id="L4305">                       });</span>
<span class="nc" id="L4306">                   });</span>
<span class="fc" id="L4307">               })</span>
<span class="fc" id="L4308">               ._this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received the targeted key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPress(Action)
     * @see #onKeyRelease(Action)
     * @see #onKeyTyped(Action)
     */
    public final I onTyped( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L4324">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L4325">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L4326">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4327">                   _onKeyTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc bnc" id="L4328" title="All 2 branches missed.">                       if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L4329">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4331">                                   onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4332">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4333">                                   log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4334">                               }</span>
<span class="nc" id="L4335">                           });</span>
<span class="nc" id="L4336">                   });</span>
<span class="fc" id="L4337">               })</span>
<span class="fc" id="L4338">               ._this();</span>
    }

    private void _onKeyTyped(C component, BiConsumer&lt;KeyEvent, KeyAdapter&gt; action ) {
<span class="fc" id="L4342">        component.addKeyListener(new KeyAdapter() {</span>
            private @Nullable KeyEvent lastEvent;

            @Override
            public void keyPressed(KeyEvent e) {
<span class="nc" id="L4347">                lastEvent = e;</span>
<span class="nc" id="L4348">            }</span>
            @Override
            public void keyReleased(KeyEvent e) {
<span class="nc bnc" id="L4351" title="All 4 branches missed.">                if ( lastEvent != null &amp;&amp; lastEvent.getKeyCode() == e.getKeyCode() ) {</span>
<span class="nc" id="L4352">                    action.accept(lastEvent, this);</span>
<span class="nc" id="L4353">                    lastEvent = null;</span>
                }
<span class="nc" id="L4355">            }</span>
        });
<span class="fc" id="L4357">    }</span>

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     *  to receive key events triggered when the wrapped component receives a particular
     *  keyboard input matching the provided character. &lt;br&gt;
     *  This method is a logical extension of the {@link #onTyped(Keyboard.Key, Action)} method,
     *  with the difference that it listens for any character instead of a specific key code.
     *  This also works with special characters which are typed using the combination
     *  of multiple keys (e.g. shift + number keys).
     *  &lt;br&gt;&lt;br&gt;
     * @param character The character to listen for.
     * @param onKeyTyped The action to execute when the character is typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyTyped(Action)
     * @see #onTyped(Keyboard.Key, Action)
     */
    public final I onTyped( char character, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="nc" id="L4375">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="nc" id="L4376">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4377">                   _onCharTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc bnc" id="L4378" title="All 2 branches missed.">                       if ( e.getKeyChar() == character )</span>
<span class="nc" id="L4379">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L4381">                                   onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4382">                               } catch ( Exception ex ) {</span>
<span class="nc" id="L4383">                                   log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4384">                               }</span>
<span class="nc" id="L4385">                           });</span>
<span class="nc" id="L4386">                   });</span>
<span class="nc" id="L4387">               })</span>
<span class="nc" id="L4388">               ._this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     *  to receive key events triggered when the wrapped component receives a particular
     *  keyboard input matching the provided character. &lt;br&gt;
     *  This method is a logical extension of the {@link #onTyped(Keyboard.Key, Action)} method,
     *  with the difference that it listens for any character instead of a specific key code.
     *  This also works with special characters which are typed using the combination
     *  of multiple keys (e.g. shift + number keys).
     *  &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The action to execute when the character is typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyTyped(Action)
     * @see #onKeyTyped(Action)
     * @see #onTyped(Keyboard.Key, Action)
     */
    public final I onCharTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="nc" id="L4407">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="nc" id="L4408">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4409">                   _onCharTyped(thisComponent, (e, kl) -&gt; {</span>
<span class="nc" id="L4410">                       _runInApp(()-&gt;{</span>
                           try {
<span class="nc" id="L4412">                               onKeyTyped.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4413">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4414">                               log.error(&quot;Error in key typed event action handler!&quot;, ex);</span>
<span class="nc" id="L4415">                           }</span>
<span class="nc" id="L4416">                       });</span>
<span class="nc" id="L4417">                   });</span>
<span class="nc" id="L4418">               })</span>
<span class="nc" id="L4419">               ._this();</span>
    }

    private void _onCharTyped( C component, BiConsumer&lt;KeyEvent, KeyAdapter&gt; action ) {
<span class="nc" id="L4423">        component.addKeyListener(new KeyAdapter() {</span>
            @Override
            public void keyTyped(KeyEvent e) {
<span class="nc" id="L4426">                action.accept(e, this);</span>
<span class="nc" id="L4427">            }</span>
        });
<span class="nc" id="L4429">    }</span>

    /**
     *  Exposes a functional {@link Configurator} API for turning the component into a drag source site
     *  with the given configuration. This method is a convenience method which internally
     *  creates and configures an AWT native {@link DragSource} instance for the component.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Drag me!&quot;)
     *      .withDragAway( conf -&gt; conf
     *          .enabled(true)
     *          .opacity(0.25)
     *          .payload(&quot;IT WORKS&quot;)
     *          .onDragMove( it -&gt; {...})
     *      )
     *  }&lt;/pre&gt;
     *  The example above creates a draggable label which will be dragged with an opacity of 0.25
     *  and carries the payload &quot;IT WORKS&quot; when dragged. The drag move event handler
     *  is attached to the drag source site and will be called when the label is dragged.&lt;br&gt;
     *  &lt;p&gt;
     *  If you want to create a drop site instead of a drag source site, use {@link #withDropSite(Configurator)}.
     *
     * @param configurator The {@link Configurator} which allows you to configure the drag source site
     *                     by receiving a {@link DragAwayComponentConf} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withDragAway( Configurator&lt;DragAwayComponentConf&lt;C&gt;&gt; configurator ) {
<span class="nc" id="L4457">        NullUtil.nullArgCheck(configurator, &quot;configurator&quot;, Configurator.class);</span>
<span class="nc" id="L4458">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4459">                    ComponentExtension.from(thisComponent).addDragAwayConf(mousePosition -&gt; {</span>
<span class="nc" id="L4460">                        DragAwayComponentConf&lt;C&gt; conf = DragAwayComponentConf.of(thisComponent, mousePosition);</span>
                        try {
<span class="nc" id="L4462">                            return configurator.configure(conf);</span>
<span class="nc" id="L4463">                        } catch (Exception e) {</span>
<span class="nc" id="L4464">                            log.error(&quot;Failed to configure drag away!&quot;, e);</span>
                        }
<span class="nc" id="L4466">                        return conf;</span>
                    });
<span class="nc" id="L4468">               })</span>
<span class="nc" id="L4469">               ._this();</span>
    }

    /**
     *  Exposes a functional {@link Configurator} API for turning the component into a drag drop
     *  receiver site with the given configuration.
     *  This method is a convenience method which internally
     *  creates and configures an AWT native {@link DropTarget} instance for the component.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Drop here!&quot;)
     *      .withDropSite( conf -&gt; conf
     *          .onDragOver( it -&gt; {
     *              it.animateFor(1, TimeUnit.SECONDS, status -&gt; {
     *                  double r = 30 * status.fadeIn() * it.getScale();
     *                  double x = it.getEvent().getLocation().x - r / 2.0;
     *                  double y = it.getEvent().getLocation().y - r / 2.0;
     *                  it.paint(status, g -&gt; {
     *                      g.setColor(new Color(0f, 1f, 1f, (float) status.fadeOut()));
     *                      g.fillOval((int) x, (int) y, (int) r, (int) r);
     *                  });
     *              });
     *          })
     *          .onDrop(it -&gt; {
     *              it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *                  double r = 480 * status.fadeIn() * it.getScale();
     *                  double x = it.getEvent().getLocation().x - r / 2.0;
     *                  double y = it.getEvent().getLocation().y - r / 2.0;
     *                  it.paint(status, g -&gt; {
     *                      g.setColor(UI.color(0.5+status.fadeOut()/2, status.fadeOut(), status.fadeIn(), status.fadeOut()));
     *                      g.fillOval((int) x, (int) y, (int) r, (int) r);
     *                  });
     *              });
     *          })
     *      )
     *  }&lt;/pre&gt;
     *  The example above creates a drop site label which will animate an expanding circle when a drag is over it
     *  and another circle when a drop is performed on it. The drag over event handler
     *  is attached to the drop site and will be called when the label is dragged over it.
     *  &lt;p&gt;
     *  If you want to create a drag source site instead of a drop site, use {@link #withDragAway(Configurator)}.
     *
     * @param configurator The {@link Configurator} which allows you to configure the drop site
     *                     by receiving a {@link DragDropComponentConf} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withDropSite( Configurator&lt;DragDropComponentConf&lt;C&gt;&gt; configurator ) {
<span class="nc" id="L4517">        NullUtil.nullArgCheck(configurator, &quot;configurator&quot;, Configurator.class);</span>
<span class="nc" id="L4518">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4519">                    _runInApp(() -&gt; {</span>
                        try {
<span class="nc" id="L4521">                            DragDropComponentConf&lt;C&gt; conf = configurator.configure(DragDropComponentConf.of(thisComponent));</span>
<span class="nc" id="L4522">                            DropTarget target = conf.toNewDropTarget();</span>
<span class="nc" id="L4523">                            thisComponent.setDropTarget(target);</span>
<span class="nc" id="L4524">                        } catch (Exception e) {</span>
<span class="nc" id="L4525">                            throw new RuntimeException(&quot;Failed to configure drop site!&quot;, e);</span>
<span class="nc" id="L4526">                        }</span>
<span class="nc" id="L4527">                    });</span>
<span class="nc" id="L4528">               })</span>
<span class="nc" id="L4529">               ._this();</span>
    }

    /**
     *  Allows you to cause an effect inside your UI when an observable event is fired.
     *  The provided {@link Action} event handler will be called
     *  on the UI thread when the {@link Observable} event is fired, irrespective of
     *  what thread the {@link Observable} event is fired on.
     *  However, it is expected that the {@link Observable} event is fired on the application thread
     *  and &lt;b&gt;the concrete implementation of the {@link Observable} is intended to
     *  be part of your view model&lt;/b&gt;.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example:
     *  &lt;pre&gt;{@code
     *  UI.label(&quot;I have a color animation!&quot;)
     *  .on(viewModel.someEvent(), it -&gt;
     *    it.animateFor(3, TimeUnit.SECONDS, status -&gt; {
     *      double r = status.progress();
     *      double g = 1 - status.progress();
     *      double b = status.pulse();
     *      it.setBackgroundColor(r, g, b);
     *    })
     *  )
     *  }&lt;/pre&gt;
     *
     * @param observableEvent The {@link Observable} event to which the {@link Action} should be attached
     *                        and called on the UI thread when the event is fired in the view model.
     * @param action The {@link Action} which is invoked by the UI thread after the {@link Observable} event was fired
     *               by the business logic of the view model.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     */
    public final &lt;E extends Observable&gt; I onView( E observableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L4562">        NullUtil.nullArgCheck(observableEvent, &quot;observableEvent&quot;, Observable.class);</span>
<span class="fc" id="L4563">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L4564">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4565">                   observableEvent.subscribe(() -&gt; {</span>
<span class="fc" id="L4566">                       _runInUI(() -&gt; {</span>
                           try {
<span class="fc" id="L4568">                               action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4569">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4570">                               log.error(&quot;Error in view event action handler!&quot;, ex);</span>
<span class="fc" id="L4571">                           }</span>
<span class="fc" id="L4572">                       });</span>
<span class="fc" id="L4573">                   });</span>
<span class="fc" id="L4574">               })</span>
<span class="fc" id="L4575">               ._this();</span>
    }

    /**
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event in order to implement a custom user event system.
     *  The supplied {@link Action} is executed on the application thread when the {@link Observable} event is fired and
     *  irrespective of the thread that {@link Observable} fired the event. &lt;br&gt;
     *  The {@link Action} is expected to perform an effect on the view model or the application state,
     *  &lt;b&gt;but not on the UI directly&lt;/b&gt;. &lt;br&gt;
     *  (see {@link #onView(Observable, Action)} if you want your view model to affect the UI through an observable event)
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(CustomEventSystem.touchGesture(), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a touch gesture event handler
     *  which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      Note that the provided {@link Observable} event is NOT expected to be part of the view model,
     *      but rather part of a custom event system that captures user input or other input
     *      which is not directly related to the business logic of the view model.
     *  &lt;/b&gt;
     *
     * @param observableEvent The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     * @see #onView(Observable, Action) for a similar method which is intended to be used with view model events.
     */
    public final &lt;E extends Observable&gt; I on( E observableEvent, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="fc" id="L4610">        NullUtil.nullArgCheck(observableEvent, &quot;observableEvent&quot;, Observable.class);</span>
<span class="fc" id="L4611">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L4612">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4613">                   observableEvent.subscribe(() -&gt; {</span>
<span class="fc" id="L4614">                       _runInApp(() -&gt; {</span>
                           try {
<span class="fc" id="L4616">                               action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4617">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4618">                               log.error(&quot;Error in custom event action handler!&quot;, ex);</span>
<span class="fc" id="L4619">                           }</span>
<span class="fc" id="L4620">                       });</span>
<span class="fc" id="L4621">                   });</span>
<span class="fc" id="L4622">               })</span>
<span class="fc" id="L4623">               ._this();</span>
    }

    /**
     *  This is a logical extension of the {@link #on(Observable, Action)} method.
     *  Use this to attach a component {@link Action} event handler to a functionally supplied
     *  {@link Observable} event.
     *  The {@link Action} will be called on the application thread when the {@link Observable} event
     *  is fired, irrespective of the thread that fired the {@link Observable} event.
     *  The {@link Action} is expected to perform an effect on the view model or the application state,
     *  &lt;b&gt;but not on the UI directly&lt;/b&gt;. &lt;br&gt;
     *  (see {@link #onView(Observable, Action)} if you want your view model to affect the UI through an observable event)
     *  &lt;br&gt;&lt;br&gt;
     *  Consider the following example:
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .on(c -&gt; CustomEventSystem.touchGesture(c), it -&gt; ..some App update.. )
     *  }&lt;/pre&gt;
     *  Which may also be written as:
     *  &lt;pre&gt;{@code
     *    UI.label(&quot;&quot;)
     *    .on(CustomEventSystem::touchGesture, it -&gt; ..some App update.. )
     * }&lt;/pre&gt;
     *  In this example we use an imaginary {@code CustomEventSystem} to register a component specific
     *  touch gesture event handler which will be called on the application thread when the touch gesture event is fired.
     *  Although neither Swing nor SwingTree have a touch gesture event system, this example illustrates
     *  how one could easily integrate a custom event system into SwingTree UIs.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *      Note that the {@link Observable} event supplied by the function
     *      is NOT expected to be part of the view model,
     *      but rather be part of a custom event system that captures user input or other input
     *      which is not directly related to the business logic of the view model.
     *  &lt;/b&gt;
     *
     * @param eventSource The {@link Observable} event to which the {@link Action} should be attached.
     * @param action The {@link Action} which is invoked by the application thread after the {@link Observable} event was fired.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link Observable} event.
     * @see #onView(Observable, Action) for a similar method which is intended to be used with view model events.
     */
    public final &lt;E extends Observable&gt; I on( Function&lt;C, E&gt; eventSource, Action&lt;ComponentDelegate&lt;C, E&gt;&gt; action ) {
<span class="nc" id="L4665">        NullUtil.nullArgCheck(eventSource, &quot;eventSource&quot;, Function.class);</span>
<span class="nc" id="L4666">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="nc" id="L4667">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4668">                   E observableEvent = eventSource.apply(thisComponent);</span>
<span class="nc" id="L4669">                   observableEvent.subscribe(() -&gt; {</span>
<span class="nc" id="L4670">                       _runInApp(() -&gt; {</span>
                           try {
<span class="nc" id="L4672">                               action.accept(new ComponentDelegate&lt;&gt;(thisComponent, observableEvent));</span>
<span class="nc" id="L4673">                           } catch ( Exception ex ) {</span>
<span class="nc" id="L4674">                               log.error(&quot;Error in custom event action handler!&quot;, ex);</span>
<span class="nc" id="L4675">                           }</span>
<span class="nc" id="L4676">                       });</span>
<span class="nc" id="L4677">                   });</span>
<span class="nc" id="L4678">               })</span>
<span class="nc" id="L4679">               ._this();</span>
    }

    /**
     *  Use this to register periodic update actions which should be called
     *  based on the provided {@code delay}! &lt;br&gt;
     *  The following example produces a label which will display the current date.
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *      .doUpdates( 100, it -&gt; it.getComponent().setText(new Date().toString()) )
     *  }&lt;/pre&gt;
     *
     * @param delay The delay in milliseconds between calling the provided {@link Action}.
     * @param onUpdate The {@link Action} which should be called periodically.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I doUpdates( int delay, Action&lt;ComponentDelegate&lt;C, ActionEvent&gt;&gt; onUpdate ) {
<span class="fc" id="L4696">        NullUtil.nullArgCheck(onUpdate, &quot;onUpdate&quot;, Action.class);</span>
<span class="fc" id="L4697">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4698">                   Timer timer = new Timer(delay, e -&gt; {</span>
                       try {
<span class="fc" id="L4700">                           onUpdate.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L4701">                       } catch ( Exception ex ) {</span>
<span class="nc" id="L4702">                           log.error(&quot;Error in update action handler!&quot;, ex);</span>
<span class="fc" id="L4703">                       }</span>
<span class="fc" id="L4704">                   });</span>
                   {
<span class="fc" id="L4706">                       java.util.List&lt;Timer&gt; timers = (java.util.List&lt;Timer&gt;) thisComponent.getClientProperty(_TIMERS_KEY);</span>
<span class="pc bpc" id="L4707" title="1 of 2 branches missed.">                       if ( timers == null ) {</span>
<span class="fc" id="L4708">                           timers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L4709">                           thisComponent.putClientProperty(_TIMERS_KEY, timers);</span>
                       }
<span class="fc" id="L4711">                       timers.add(timer);</span>
                   }
<span class="fc" id="L4713">                   timer.start();</span>
<span class="fc" id="L4714">               })</span>
<span class="fc" id="L4715">               ._this();</span>
    }

    @Override
    protected void _addComponentTo(
        C                       thisComponent,
        JComponent              addedComponent,
        @Nullable AddConstraint constraints
    ) {
<span class="fc" id="L4724">        NullUtil.nullArgCheck(addedComponent, &quot;component&quot;, JComponent.class);</span>
<span class="fc bfc" id="L4725" title="All 2 branches covered.">        if ( constraints == null )</span>
<span class="fc" id="L4726">            thisComponent.add( addedComponent );</span>
        else
<span class="fc" id="L4728">            thisComponent.add( addedComponent, constraints.toConstraintForLayoutManager() );</span>
<span class="fc" id="L4729">    }</span>

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument is expected to contain layout information for the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( String attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L4745">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The mig-layout attribute.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add(AddConstraint attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L4762">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s 
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be passed to the {@link LayoutManager} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *  This may look like this:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .add(&quot;wrap&quot;, UI.label(&quot;A&quot;), UI.label(&quot;B&quot;))
     *    .add(&quot;grow&quot;, UI.label(&quot;C&quot;), UI.label(&quot;D&quot;))
     *  }&lt;/pre&gt;
     *  Note that the first argument, &quot;wrap&quot; and &quot;grow&quot; in this case, are
     *  used as layout constraints for all the {@link JComponent}s which are added
     *  in the subsequent arguments of a single call to this method.
     *
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent} 
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( String attr, B... builders ) {
<span class="fc" id="L4791">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4792">                   _addBuildersTo(thisComponent, ()-&gt;attr, builders);</span>
<span class="fc" id="L4793">               })</span>
<span class="fc" id="L4794">               ._this();</span>
    }

    private void _addBuildersTo(C thisComponent, AddConstraint attr, UIForAnySwing&lt;?, ?&gt;... builders ) {
<span class="fc" id="L4798">        LayoutManager layout = thisComponent.getLayout();</span>
<span class="fc" id="L4799">        Object constraints = attr.toConstraintForLayoutManager();</span>
<span class="fc bfc" id="L4800" title="All 4 branches covered.">        if ( _isBorderLayout(constraints) &amp;&amp; !(layout instanceof BorderLayout) ) {</span>
<span class="pc bpc" id="L4801" title="1 of 2 branches missed.">            if ( layout instanceof MigLayout )</span>
<span class="fc" id="L4802">                log.warn(&quot;Layout ambiguity detected! Border layout constraint cannot be added to 'MigLayout'.&quot;);</span>
<span class="fc" id="L4803">            thisComponent.setLayout(new BorderLayout()); // The UI Maker tries to fill in the blanks!</span>
        }
<span class="fc bfc" id="L4805" title="All 2 branches covered.">        for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="fc" id="L4806">            _addBuilderTo(thisComponent, b, attr);</span>
<span class="fc" id="L4807">    }</span>

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add(AddConstraint attr, B... builders ) {
<span class="fc" id="L4825">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="fc" id="L4826">        Objects.requireNonNull(builders, &quot;builders&quot;);</span>
<span class="fc" id="L4827">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4828">                    _addBuildersTo(thisComponent, attr, builders);</span>
<span class="fc" id="L4829">                })</span>
<span class="fc" id="L4830">                ._this();</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the {@link JComponent}s
     *  wrapped by the provided builders
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents placement constraints for the provided components which will
     *  be passed to the {@link MigLayout} of the underlying {@link JComponent}
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( CC attr, B... builders ) {
<span class="nc" id="L4850">        Objects.requireNonNull(attr, &quot;attr&quot;);</span>
<span class="nc" id="L4851">        Objects.requireNonNull(builders, &quot;builders&quot;);</span>
<span class="nc" id="L4852">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4853">                   LayoutManager layout = thisComponent.getLayout();</span>
<span class="nc bnc" id="L4854" title="All 2 branches missed.">                   if ( !(layout instanceof MigLayout) )</span>
<span class="nc" id="L4855">                       log.warn(&quot;Layout ambiguity detected! Mig layout constraint cannot be added to '{}'.&quot;, layout.getClass().getSimpleName());</span>

<span class="nc bnc" id="L4857" title="All 2 branches missed.">                   for ( UIForAnySwing&lt;?, ?&gt; b : builders )</span>
<span class="nc" id="L4858">                       _addBuilderTo(thisComponent, b, ()-&gt;attr);</span>
<span class="nc" id="L4859">               })</span>
<span class="nc" id="L4860">               ._this();</span>
    }

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be applied to the subsequently provided {@link JComponent} types.
     *  &lt;br&gt;&lt;br&gt;
     *  This may look like this:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .add(&quot;wrap&quot;, new JLabel(&quot;A&quot;), new JLabel(&quot;B&quot;))
     *    .add(&quot;grow&quot;, new JLabel(&quot;C&quot;), new JLabel(&quot;D&quot;))
     *  }&lt;/pre&gt;
     *  Note that the first argument, &quot;wrap&quot; and &quot;grow&quot; in this case, are
     *  used as layout constraints for all the {@link JComponent}s which are added
     *  in the subsequent arguments of a single call to this method.
     *
     * @param attr The additional layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( String attr, E... components ) {
<span class="fc" id="L4886">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L4887">        NullUtil.nullArgCheck(components, &quot;components&quot;, JComponent[].class);</span>
<span class="fc" id="L4888">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4889">                   _addComponentsTo( thisComponent, attr, components );</span>
<span class="fc" id="L4890">               })</span>
<span class="fc" id="L4891">               ._this();</span>
    }

    @SafeVarargs
    private final &lt;E extends JComponent&gt; void _addComponentsTo( C thisComponent, String attr, E... components ) {
<span class="fc bfc" id="L4896" title="All 2 branches covered.">        for ( E component : components ) {</span>
<span class="fc" id="L4897">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L4898">            _addBuildersTo( thisComponent, ()-&gt;attr, new UIForSwing[]{UI.of(component)} );</span>
        }
<span class="fc" id="L4900">    }</span>

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first 2 arguments will be joined by a comma and passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( AddConstraint attr, E... components ) {
<span class="nc" id="L4916">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4917">                    _addComponentsTo( thisComponent, attr, components );</span>
<span class="nc" id="L4918">                })</span>
<span class="nc" id="L4919">                ._this();</span>
    }

    @SafeVarargs
    private final &lt;E extends JComponent&gt; void _addComponentsTo( C thisComponent, AddConstraint attr, E... components ) {
<span class="nc bnc" id="L4924" title="All 2 branches missed.">        for ( E component : components ) {</span>
<span class="nc" id="L4925">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="nc" id="L4926">            _addBuildersTo( thisComponent, attr, new UIForSwing[]{UI.of(component)} );</span>
        }
<span class="nc" id="L4928">    }</span>

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L4944">        NullUtil.nullArgCheck(model, &quot;viewable&quot;, Val.class);</span>
<span class="fc" id="L4945">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L4946">                   _addViewablePropTo(thisComponent, model, null, viewSupplier);</span>
<span class="fc" id="L4947">               })</span>
<span class="fc" id="L4948">               ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( String attr, Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L4966">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="nc" id="L4967">        NullUtil.nullArgCheck(model, &quot;viewable&quot;, Val.class);</span>
<span class="nc" id="L4968">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L4969">            _addViewablePropTo(thisComponent, model, ()-&gt;attr, viewSupplier);</span>
<span class="nc" id="L4970">        })</span>
<span class="nc" id="L4971">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param model A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( AddConstraint attr, Val&lt;M&gt; model, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L4989">        return  _with( thisComponent -&gt; {</span>
<span class="fc" id="L4990">            _addViewablePropTo(thisComponent, model, attr, viewSupplier);</span>
<span class="fc" id="L4991">        })</span>
<span class="fc" id="L4992">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;See {@link #addAll(Val, ViewSupplier)} as the recommended alternative to this method.&lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I addAll( Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5017">        NullUtil.nullArgCheck(models, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L5018">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5019">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L5020">                    _bindTo( models, null, viewSupplier, thisComponent );</span>
<span class="fc" id="L5021">                })</span>
<span class="fc" id="L5022">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;See {@link #addAll(String, Val, ViewSupplier)} as the recommended alternative to this method.&lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I addAll( String attr, Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5048">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="fc" id="L5049">        NullUtil.nullArgCheck(models, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L5050">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L5051">                    _bindTo( models, ()-&gt;attr, viewSupplier, thisComponent );</span>
<span class="fc" id="L5052">                })</span>
<span class="fc" id="L5053">                ._this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.&lt;br&gt;
     *  &lt;b&gt;
     *      Due to the usage of the mutable the {@link Vals} property list, this method assumes your view models
     *      to be based on place oriented programming practices. Although SwingTree offers API for this style of
     *      programming, we strongly recommend using value objects for your view models and {@link Tuple}s
     *      instead of {@link Vals} lists. &lt;br&gt;
     *      &lt;u&gt;See {@link #addAll(AddConstraint, Val, ViewSupplier)} as the recommended alternative to this method.&lt;/u&gt;
     *  &lt;/b&gt;
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param models A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I addAll( AddConstraint attr, Vals&lt;M&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L5079">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L5080">                    _bindTo( models, attr, viewSupplier, thisComponent );</span>
<span class="nc" id="L5081">                })</span>
<span class="nc" id="L5082">                ._this();</span>
    }

    /**
     *  Dynamically generate views for the items in a {@link Tuple} of items,
     *  and automatically regenerate the view when any of the items in the tuple change.
     *  The type of item can be anything, but it is usually value based view models.
     *  The {@link ViewSupplier} lambda passed to this method will be invoked with
     *  each item in the tuple and is expected to return a {@link JComponent} instance
     *  which will either be added to this UI component or replace an existing view.&lt;br&gt;
     *
     *
     * @param models A property of a {@link Tuple} of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the tuple.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Tuple}, which is the type of the view model.
     */
    public final &lt;M&gt; I addAll( Val&lt;Tuple&lt;M&gt;&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5100">        NullUtil.nullArgCheck(models, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L5101">        Objects.requireNonNull(viewSupplier, &quot;viewSupplier&quot;);</span>
<span class="fc" id="L5102">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L5103">                    _bindTo( models, null, viewSupplier, thisComponent );</span>
<span class="fc" id="L5104">                })</span>
<span class="fc" id="L5105">                ._this();</span>
    }

    public final &lt;M&gt; I addAll( String attr, Val&lt;Tuple&lt;M&gt;&gt; models, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L5109">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="fc" id="L5110">        NullUtil.nullArgCheck(models, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L5111">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L5112">                    _bindTo( models, ()-&gt;attr, viewSupplier, thisComponent );</span>
<span class="fc" id="L5113">                })</span>
<span class="fc" id="L5114">                ._this();</span>
    }

    public final &lt;M&gt; I addAll( AddConstraint attr, Val&lt;Tuple&lt;M&gt;&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L5118">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L5119">                    _bindTo( viewables, attr, viewSupplier, thisComponent );</span>
<span class="nc" id="L5120">                })</span>
<span class="nc" id="L5121">                ._this();</span>
    }

    private &lt;M&gt; void _bindTo( Vals&lt;M&gt; models, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5125">        _addViewableProps(models, attr, ModelToViewConverter.of(thisComponent, viewSupplier, (model, exception)-&gt;{</span>
<span class="nc" id="L5126">                log.error(&quot;Error while creating view for '&quot;+model+&quot;'.&quot;, exception);</span>
<span class="nc" id="L5127">                return UI.box().get(JBox.class);</span>
            }), thisComponent);
<span class="fc" id="L5129">    }</span>

    protected &lt;M&gt; void _addViewableProps( Vals&lt;M&gt; models, @Nullable AddConstraint attr, ModelToViewConverter&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5132">        _onShow( models, thisComponent, (innerComponent, delegate) -&gt; {</span>
<span class="fc" id="L5133">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L5134">            _updateSubViews(innerComponent, attr, delegate, viewSupplier);</span>
<span class="fc" id="L5135">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L5136">        });</span>
<span class="fc" id="L5137">        models.forEach( v -&gt; {</span>
<span class="fc" id="L5138">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5140">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L5141">            } catch ( Exception e ) {</span>
<span class="nc" id="L5142">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L5143">            }</span>
<span class="pc bpc" id="L5144" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5145">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc bfc" id="L5147" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L5148">                _addBuildersTo( thisComponent, view );</span>
            else
<span class="fc" id="L5150">                _addBuildersTo( thisComponent, attr, view );</span>
<span class="fc" id="L5151">        });</span>
<span class="fc" id="L5152">    }</span>

    private &lt;M&gt; void _updateSubViews(C innerComponent, @Nullable AddConstraint attr, ValsDelegate&lt;M&gt; delegate, ModelToViewConverter&lt;M&gt; viewSupplier) {
        // we simply redo all the components.
<span class="fc" id="L5156">        Vals&lt;M&gt; newValues = delegate.newValues();</span>
<span class="fc" id="L5157">        Vals&lt;M&gt; oldValues = delegate.oldValues();</span>
<span class="fc" id="L5158">        int index = delegate.index().orElse(-1);</span>

<span class="pc bpc" id="L5160" title="3 of 7 branches missed.">        switch ( delegate.change() ) {</span>
            case SET:
<span class="nc bnc" id="L5162" title="All 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5163">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L5164">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5165" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5166">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="nc bnc" id="L5168" title="All 2 branches missed.">                    for ( int i = 0; i &lt; newValues.size(); i++ ) {</span>
<span class="nc" id="L5169">                        int position = i + index;</span>
<span class="nc" id="L5170">                        _updateComponentAt(position, newValues.at(i).get(), viewSupplier, attr, innerComponent);</span>
                    }
                }
<span class="nc" id="L5173">                break;</span>
            case ADD:
<span class="pc bpc" id="L5175" title="2 of 4 branches missed.">                if ( index &lt; 0 || newValues.any(Val::isEmpty) ) {</span>
<span class="nc" id="L5176">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5177" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5178">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="fc bfc" id="L5180" title="All 2 branches covered.">                    for ( int i = 0; i &lt; newValues.size(); i++ ) {</span>
<span class="fc" id="L5181">                        int position = i + index;</span>
<span class="fc" id="L5182">                        _addComponentAt(position, newValues.at(i).orElseNull(), viewSupplier, attr, innerComponent);</span>
                    }
                }
<span class="fc" id="L5185">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L5187" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L5188">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L5189">                    _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5190" title="All 2 branches missed.">                    for ( int i = 0; i &lt; delegate.currentValues().size(); i++ )</span>
<span class="nc" id="L5191">                        _addComponentAt( i, delegate.currentValues().at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
                } else {
<span class="fc bfc" id="L5193" title="All 2 branches covered.">                    for ( int i = oldValues.size() - 1; i &gt;= 0; i-- ) {</span>
<span class="fc" id="L5194">                        int position = i + index;</span>
<span class="fc" id="L5195">                        _removeComponentAt(position, innerComponent);</span>
                    }
                }
<span class="fc" id="L5198">                break;</span>
<span class="fc" id="L5199">            case CLEAR: _clearComponentsOf(innerComponent); break;</span>
<span class="fc" id="L5200">            case REVERSE: _reverseComponentsOf(innerComponent); break;</span>
<span class="nc" id="L5201">            case NONE: break;</span>
            default:
<span class="nc" id="L5203">                log.error(&quot;Unknown change type: {}&quot;, delegate.change(), new Throwable());</span>
                // We do a simple rebuild:
<span class="nc" id="L5205">                Vals&lt;M&gt; currentValues = delegate.currentValues();</span>
<span class="nc" id="L5206">                _clearComponentsOf(innerComponent);</span>
<span class="nc bnc" id="L5207" title="All 2 branches missed.">                for ( int i = 0; i &lt; currentValues.size(); i++ )</span>
<span class="nc" id="L5208">                    _addComponentAt( i, currentValues.at(i).orElseNull(), viewSupplier, attr, innerComponent );</span>
        }
<span class="pc bpc" id="L5210" title="1 of 2 branches missed.">        if ( innerComponent.getComponentCount() != delegate.currentValues().size() )</span>
<span class="nc" id="L5211">            log.warn(</span>
                    &quot;Broken binding to view model list detected! \n&quot; +
<span class="nc" id="L5213">                    &quot;UI sub-component count '&quot;+innerComponent.getComponentCount()+&quot;' &quot; +</span>
<span class="nc" id="L5214">                    &quot;does not match viewable models list of size '&quot;+delegate.currentValues().size()+&quot;'. \n&quot; +</span>
                    &quot;A possible cause for this is that components &quot; +
<span class="nc bnc" id="L5216" title="All 2 branches missed.">                    &quot;were &quot; + ( innerComponent.getComponentCount() &gt; delegate.currentValues().size() ? &quot;added&quot; : &quot;removed&quot; ) + &quot; &quot; +</span>
                    &quot;to this '&quot; + innerComponent + &quot;' \ndirectly, instead of through the property list binding. \n&quot; +
                    &quot;However, this could also be a bug in the UI framework.&quot;,
                    new Throwable()
                );
<span class="fc" id="L5221">    }</span>

    private &lt;M&gt; void _bindTo( Val&lt;Tuple&lt;M&gt;&gt; models, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5224">        _addViewableProps(models, attr, ModelToViewConverter.of(thisComponent, viewSupplier, (model, exception)-&gt;{</span>
<span class="nc" id="L5225">            log.error(&quot;Error while creating view for '&quot;+model+&quot;'.&quot;, exception);</span>
<span class="nc" id="L5226">            return UI.box().get(JBox.class);</span>
        }), thisComponent);
<span class="fc" id="L5228">    }</span>

    protected &lt;M&gt; void _addViewableProps( Val&lt;Tuple&lt;M&gt;&gt; models, @Nullable AddConstraint attr, ModelToViewConverter&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc" id="L5231">        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L5232" title="1 of 2 branches missed.">        if (models.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L5233">            lastDiffRef.set(((SequenceDiffOwner)models.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L5234">        _onShow( models, thisComponent, (c, tupleOfModels) -&gt; {</span>
<span class="fc" id="L5235">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L5236">            _updateSubViews(c, tupleOfModels, attr, lastDiffRef, viewSupplier);</span>
<span class="fc" id="L5237">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L5238">        });</span>
<span class="fc" id="L5239">        Tuple&lt;M&gt; tupleOfModels = models.get();</span>
<span class="fc" id="L5240">        _addAllFromTuple(tupleOfModels, attr, viewSupplier, thisComponent);</span>
<span class="fc" id="L5241">    }</span>

    private &lt;M&gt; void _updateSubViews(C c, Tuple&lt;M&gt; tupleOfModels, @Nullable AddConstraint attr, AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef, ModelToViewConverter&lt;M&gt; viewSupplier) {
<span class="fc" id="L5244">            SequenceDiff diff = null;</span>
<span class="fc" id="L5245">            SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L5246" title="1 of 2 branches missed.">            if (tupleOfModels instanceof SequenceDiffOwner)</span>
<span class="fc" id="L5247">                diff = ((SequenceDiffOwner)tupleOfModels).differenceFromPrevious().orElse(null);</span>
<span class="fc" id="L5248">            lastDiffRef.set(diff);</span>

<span class="pc bpc" id="L5250" title="2 of 6 branches missed.">            if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) ) {</span>
<span class="fc" id="L5251">                _clearComponentsOf(c);</span>
<span class="fc" id="L5252">                _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
            } else {
<span class="fc" id="L5254">                int index = diff.index().orElse(-1);</span>
<span class="fc" id="L5255">                int count = diff.size();</span>
<span class="pc bpc" id="L5256" title="2 of 8 branches missed.">                switch (diff.change()) {</span>
                    case SET:
<span class="pc bpc" id="L5258" title="1 of 2 branches missed.">                        if ( index &lt; 0 ) {</span>
<span class="nc" id="L5259">                            _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5260">                            _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                        } else {
<span class="fc bfc" id="L5262" title="All 2 branches covered.">                            for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5263">                                _updateComponentAt(i, tupleOfModels.get(i), viewSupplier, attr, c);</span>
                        }
<span class="fc" id="L5265">                        break;</span>
                    case ADD:
<span class="pc bpc" id="L5267" title="1 of 2 branches missed.">                        if ( index &lt; 0 ) {</span>
<span class="nc" id="L5268">                            _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5269">                            _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                        } else {
<span class="fc bfc" id="L5271" title="All 2 branches covered.">                            for ( int i = index; i &lt; (index + count); i++ )</span>
<span class="fc" id="L5272">                                _addComponentAt(i, tupleOfModels.get(i), viewSupplier, attr, c);</span>
                        }
<span class="fc" id="L5274">                        break;</span>
                    case REMOVE:
<span class="pc bpc" id="L5276" title="1 of 2 branches missed.">                        if ( index &lt; 0 ) {</span>
<span class="nc" id="L5277">                            _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5278">                            _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                        } else {
<span class="fc bfc" id="L5280" title="All 2 branches covered.">                            for ( int i = (index + count - 1); i &gt;= index; i-- )</span>
<span class="fc" id="L5281">                                _removeComponentAt(i, c);</span>
                        }
<span class="fc" id="L5283">                        break;</span>
                    case RETAIN: // Only keep the elements in the range.
<span class="pc bpc" id="L5285" title="1 of 2 branches missed.">                        if ( index &lt; 0 ) {</span>
<span class="nc" id="L5286">                            _clearComponentsOf(c); // We do a simple re-build</span>
<span class="nc" id="L5287">                            _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                        } else {
                            // Remove trailing components:
<span class="fc bfc" id="L5290" title="All 2 branches covered.">                            for ( int i = (c.getComponentCount() - 1); i &gt;= (index + count); i-- )</span>
<span class="fc" id="L5291">                                _removeComponentAt(i, c);</span>
                            // Remove leading components:
<span class="fc bfc" id="L5293" title="All 2 branches covered.">                            for ( int i = (index - 1); i &gt;= 0; i-- )</span>
<span class="fc" id="L5294">                                _removeComponentAt(i, c);</span>
                        }
<span class="fc" id="L5296">                        break;</span>
<span class="fc" id="L5297">                    case CLEAR: _clearComponentsOf(c); break;</span>
<span class="fc" id="L5298">                    case REVERSE: _reverseComponentsOf(c); break;</span>
                    case NONE:
<span class="nc" id="L5300">                        break;</span>
                    default:
<span class="nc" id="L5302">                        log.error(&quot;Unknown change type: {}&quot;, diff.change(), new Throwable());</span>
                        // We do a simple rebuild:
<span class="nc" id="L5304">                        _clearComponentsOf(c);</span>
<span class="nc" id="L5305">                        _addAllFromTuple(tupleOfModels, attr, viewSupplier, c);</span>
                }
            }
<span class="fc" id="L5308">    }</span>

    private &lt;M&gt; void _addAllFromTuple( Tuple&lt;M&gt; tupleOfModels, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier, C thisComponent ) {
<span class="fc bfc" id="L5311" title="All 2 branches covered.">        for ( int i = 0; i &lt; tupleOfModels.size(); i++ ) {</span>
<span class="fc" id="L5312">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5314">                view = viewSupplier.createViewFor(tupleOfModels.get(i));</span>
<span class="nc" id="L5315">            } catch ( Exception e ) {</span>
<span class="nc" id="L5316">                log.error(&quot;Error while creating view for '&quot;+tupleOfModels.get(i)+&quot;'.&quot;, e);</span>
<span class="fc" id="L5317">            }</span>
<span class="pc bpc" id="L5318" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5319">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc bfc" id="L5321" title="All 2 branches covered.">            if ( attr == null )</span>
<span class="fc" id="L5322">                _addBuildersTo( thisComponent, view );</span>
            else
<span class="fc" id="L5324">                _addBuildersTo( thisComponent, attr, view );</span>
        }
<span class="fc" id="L5326">    }</span>

    private &lt;M&gt; void _addViewablePropTo(
        C thisComponent, Val&lt;M&gt; viewable, @Nullable AddConstraint attr, ViewSupplier&lt;M&gt; viewSupplier
    ) {
        // First we remember the index of the component which will be provided by the viewable dynamically.
<span class="fc" id="L5332">        final int index = thisComponent.getComponentCount();</span>
        // Then we add the component provided by the viewable to the list of children.
<span class="fc bfc" id="L5334" title="All 2 branches covered.">        if ( attr == null ) {</span>
<span class="fc bfc" id="L5335" title="All 2 branches covered.">            if ( viewable.isPresent() ) {</span>
<span class="fc" id="L5336">                UIForAnySwing&lt;?, ?&gt; view = null;</span>
                try {
<span class="fc" id="L5338">                    view = viewSupplier.createViewFor(viewable.get());</span>
<span class="nc" id="L5339">                } catch ( Exception e ) {</span>
<span class="nc" id="L5340">                    log.error(&quot;Error while creating view for '{}'.&quot;, viewable.orElseNull(), e);</span>
<span class="fc" id="L5341">                }</span>
<span class="pc bpc" id="L5342" title="1 of 2 branches missed.">                if ( view == null )</span>
<span class="nc" id="L5343">                    view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L5345">                _addBuildersTo(thisComponent, view);</span>
<span class="fc" id="L5346">            } else</span>
<span class="fc" id="L5347">                _addComponentsTo(thisComponent, new JPanel()); // We add a dummy component to the list of children.</span>
        } else {
<span class="pc bpc" id="L5349" title="1 of 2 branches missed.">            if ( viewable.isPresent() ) {</span>
<span class="fc" id="L5350">                UIForAnySwing&lt;?, ?&gt; view = null;</span>
                try {
<span class="fc" id="L5352">                    view = viewSupplier.createViewFor(viewable.get());</span>
<span class="nc" id="L5353">                } catch ( Exception e ) {</span>
<span class="nc" id="L5354">                    log.error(&quot;Error while creating view for '{}'.&quot;, viewable.orElseNull(), e);</span>
<span class="fc" id="L5355">                }</span>
<span class="pc bpc" id="L5356" title="1 of 2 branches missed.">                if ( view == null )</span>
<span class="nc" id="L5357">                    view = UI.box(); // We add a dummy component to the list of children.</span>
<span class="fc" id="L5358">                _addBuildersTo(thisComponent, attr, view);</span>
<span class="fc" id="L5359">            } else</span>
<span class="nc" id="L5360">                _addComponentsTo(thisComponent, attr, new JPanel()); // We add a dummy component to the list of children.</span>
        }
        // Finally we add a listener to the viewable which will update the component when the viewable changes.
<span class="fc" id="L5363">        _onShow( viewable, thisComponent, (c,v) -&gt; _updateComponentAt(index, v, viewSupplier, attr, c) );</span>
<span class="fc" id="L5364">    }</span>

    private &lt;M&gt; void _updateComponentAt(
        int index, @Nullable M v, ViewSupplier&lt;M&gt; viewSupplier, @Nullable AddConstraint attr, C c
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L5370" title="1 of 2 branches missed.">        if ( v == null ) {</span>
<span class="nc" id="L5371">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L5373">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5375">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L5376">            } catch ( Exception e ) {</span>
<span class="nc" id="L5377">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L5378">            }</span>
<span class="pc bpc" id="L5379" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5380">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L5382">            newComponent = view.get((Class)view.getType());</span>
        }
        // We remove the old component.
<span class="fc" id="L5385">        c.remove(c.getComponent(index));</span>
        // We add the new component.
<span class="pc bpc" id="L5387" title="1 of 2 branches missed.">        if ( attr == null )</span>
<span class="fc" id="L5388">            c.add(newComponent, index);</span>
        else
<span class="nc" id="L5390">            c.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
        // We update the layout.
<span class="fc" id="L5392">        c.revalidate();</span>
<span class="fc" id="L5393">        c.repaint();</span>
<span class="fc" id="L5394">    }</span>

    private &lt;M&gt; void _addComponentAt(
        int index, @Nullable M v, ViewSupplier&lt;M&gt; viewSupplier, @Nullable AddConstraint attr, C thisComponent
    ) {
        JComponent newComponent;
<span class="pc bpc" id="L5400" title="1 of 2 branches missed.">        if ( v == null ) {</span>
<span class="nc" id="L5401">            newComponent = new JBox();</span>
        } else {
<span class="fc" id="L5403">            UIForAnySwing&lt;?, ?&gt; view = null;</span>
            try {
<span class="fc" id="L5405">                view = viewSupplier.createViewFor(v);</span>
<span class="nc" id="L5406">            } catch ( Exception e ) {</span>
<span class="nc" id="L5407">                log.error(&quot;Error while creating view for '&quot;+v+&quot;'.&quot;, e);</span>
<span class="fc" id="L5408">            }</span>
<span class="pc bpc" id="L5409" title="1 of 2 branches missed.">            if ( view == null )</span>
<span class="nc" id="L5410">                view = UI.box(); // We add a dummy component to the list of children.</span>

<span class="fc" id="L5412">            newComponent = view.get((Class)view.getType());</span>
        }
        // We add the new component.
<span class="fc bfc" id="L5415" title="All 2 branches covered.">        if ( attr == null )</span>
<span class="fc" id="L5416">            thisComponent.add(newComponent, index);</span>
        else
<span class="fc" id="L5418">            thisComponent.add(newComponent, attr.toConstraintForLayoutManager(), index);</span>
        // We update the layout.
<span class="fc" id="L5420">        thisComponent.revalidate();</span>
<span class="fc" id="L5421">        thisComponent.repaint();</span>
<span class="fc" id="L5422">    }</span>

    private void _removeComponentAt( int index, C thisComponent )
    {
<span class="pc bpc" id="L5426" title="1 of 2 branches missed.">        if ( index &lt; 0 ) {</span>
<span class="nc" id="L5427">            log.error(</span>
                &quot;Cannot remove sub-component of '&quot;+thisComponent+&quot;' \n&quot; +
                &quot;at index '&quot;+index+&quot;' because the index is negative.&quot;,
                new Throwable()
            );
        } else {
<span class="fc" id="L5433">            int numberOfExistingComponents = thisComponent.getComponentCount();</span>
<span class="pc bpc" id="L5434" title="1 of 2 branches missed.">            if (index &gt;= numberOfExistingComponents) {</span>
<span class="nc" id="L5435">                log.error(</span>
                    &quot;Cannot remove sub-component of '&quot; + thisComponent + &quot;' \n&quot; +
                    &quot;at index '&quot; + index + &quot;' because there it currently only has '&quot; + numberOfExistingComponents + &quot;' &quot; +
                    &quot;sub-components instead of at least '&quot; + (index + 1) + &quot;' sub-components.&quot;,
                    new Throwable()
                );
            } else {
                // We get the component at the specified index.
<span class="fc" id="L5443">                Component component = thisComponent.getComponent(index);</span>
<span class="pc bpc" id="L5444" title="1 of 2 branches missed.">                if ( component == null ) {</span>
<span class="nc" id="L5445">                    log.error(</span>
                        &quot;Cannot remove sub-component of '&quot; + thisComponent + &quot;' \n&quot; +
                        &quot;at index '&quot; + index + &quot;' because there is no component at that index.&quot;,
                        new Throwable()
                    );
                } else {
                    // We remove the component.
<span class="fc" id="L5452">                    thisComponent.remove(component);</span>
                    // We update the layout.
<span class="fc" id="L5454">                    thisComponent.revalidate();</span>
<span class="fc" id="L5455">                    thisComponent.repaint();</span>
                }
            }
        }
<span class="fc" id="L5459">    }</span>

    private void _clearComponentsOf( C thisComponent ) {
        // We remove all components.
<span class="fc" id="L5463">        thisComponent.removeAll();</span>
        // We update the layout.
<span class="fc" id="L5465">        thisComponent.revalidate();</span>
<span class="fc" id="L5466">        thisComponent.repaint();</span>
<span class="fc" id="L5467">    }</span>

    private void _reverseComponentsOf(C thisComponent ) {
        // save to a list
<span class="fc" id="L5471">        List&lt;Component&gt; components = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L5472">        Collections.addAll(components, thisComponent.getComponents());</span>
        // We remove all components.
<span class="fc" id="L5474">        thisComponent.removeAll();</span>
        // Reverse the list
<span class="fc" id="L5476">        Collections.reverse(components);</span>
        // Add the components back in reverse order
<span class="fc" id="L5478">        components.forEach(thisComponent::add);</span>
<span class="fc" id="L5479">    }</span>

    private static boolean _isBorderLayout( Object o ) {
<span class="fc bfc" id="L5482" title="All 2 branches covered.">        return BorderLayout.CENTER.equals(o)     ||</span>
<span class="fc bfc" id="L5483" title="All 2 branches covered.">               BorderLayout.PAGE_START.equals(o) ||</span>
<span class="fc bfc" id="L5484" title="All 2 branches covered.">               BorderLayout.PAGE_END.equals(o)   ||</span>
<span class="fc bfc" id="L5485" title="All 2 branches covered.">               BorderLayout.LINE_END.equals(o)   ||</span>
<span class="fc bfc" id="L5486" title="All 2 branches covered.">               BorderLayout.LINE_START.equals(o) ||</span>
<span class="pc bpc" id="L5487" title="1 of 2 branches missed.">               BorderLayout.EAST.equals(o)       ||</span>
<span class="pc bpc" id="L5488" title="1 of 2 branches missed.">               BorderLayout.WEST.equals(o)       ||</span>
<span class="pc bpc" id="L5489" title="1 of 2 branches missed.">               BorderLayout.NORTH.equals(o)      ||</span>
<span class="pc bpc" id="L5490" title="1 of 2 branches missed.">               BorderLayout.SOUTH.equals(o);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>