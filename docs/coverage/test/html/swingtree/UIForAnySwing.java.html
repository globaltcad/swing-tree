<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAnySwing.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAnySwing.java</span></div><h1>UIForAnySwing.java</h1><pre class="source lang-java linenums">package swingtree;


import net.miginfocom.layout.AC;
import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.slf4j.Logger;
import sprouts.Action;
import sprouts.*;
import swingtree.api.Peeker;
import swingtree.api.Styler;
import swingtree.api.UIVerifier;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.input.Keyboard;
import swingtree.layout.CompAttr;
import swingtree.layout.LayoutAttr;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;


/**
 *  A swing tree builder node for any kind {@link JComponent} instance.
 *  This is the most generic builder type and therefore abstract super-type for almost all other builders.
 *  This builder defines nested building for anything extending the {@link JComponent} class.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *  &lt;br&gt;&lt;br&gt;
 *
 * @param &lt;I&gt; The concrete extension of the {@link AbstractNestedBuilder}.
 * @param &lt;C&gt; The type parameter for the component type wrapped by an instance of this class.
 */
public abstract class UIForAnySwing&lt;I, C extends JComponent&gt; extends AbstractNestedBuilder&lt;I, C, JComponent&gt;
{
<span class="fc" id="L47">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(UI.class);</span>

    private final static String _TIMERS_KEY = &quot;_swing-tree.timers&quot;;

<span class="fc" id="L51">    private boolean _idAlreadySet = false; // The id translates to the 'name' property of swing components.</span>
<span class="fc" id="L52">    private boolean _migAlreadySet = false;</span>

    /**
     *  Extensions of the {@link  UIForAnySwing} always wrap
     *  a single component for which they are responsible.
     *
     * @param component The JComponent type which will be wrapped by this builder node.
     */
<span class="fc" id="L60">    public UIForAnySwing( C component ) { super(component); }</span>

    /**
     *  This method exposes a concise way to bind a {@link Noticeable} (usually a sprouts.Event to the
     *  {@link JComponent#repaint()} method of the component wrapped by this {@link UI}!
     *  This means that the component will be repainted whenever the event is fired.
     *  &lt;p&gt;
     * @param noticeable The event to which the repaint method of the component will be bound.
     * @return The JComponent type which will be wrapped by this builder node.
     */
    public final I withRepaintIf( Noticeable noticeable ) {
<span class="pc" id="L71">        noticeable.subscribe( () -&gt; _doUI( () -&gt; getComponent().repaint() ) );</span>
<span class="fc" id="L72">        return _this();</span>
    }

    /**
     *  This method exposes a concise way to set an identifier for the component
     *  wrapped by this {@link UI}!
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *
     * @param id The identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be wrapped by this builder node.
     */
    public final I id( String id ) {
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        if ( _idAlreadySet )</span>
<span class="nc" id="L89">            throw new IllegalArgumentException(&quot;The id has already been specified for this component!&quot;);</span>
<span class="fc" id="L90">        getComponent().setName(id);</span>
<span class="fc" id="L91">        _idAlreadySet = true;</span>
<span class="fc" id="L92">        return _this();</span>
    }

    /**
     *  This method exposes a concise way to set an enum based identifier for the component
     *  wrapped by this {@link UI}!
     *  In essence this is simply a delegate for the {@link JComponent#setName(String)} method
     *  to make it more expressive and widely recognized what is meant
     *  (&quot;id&quot; is shorter and makes more sense than &quot;name&quot; which could be confused with &quot;title&quot;).
     *  &lt;p&gt;
     *  The enum identifier will be translated to a string using {@link Enum#name()}.
     *
     * @param id The enum identifier for this {@link JComponent} which will
     *           simply translate to {@link JComponent#setName(String)}
     *
     * @return The JComponent type which will be wrapped by this builder node.
     * @param &lt;E&gt; The enum type.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I id( E id ) {
<span class="nc" id="L111">        Objects.requireNonNull(id);</span>
<span class="nc" id="L112">        return id( id.getClass().getSimpleName() + &quot;.&quot; + id.name() );</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to a style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *      {@literal @}Override
     *      protected void build() {
     *          add(group(&quot;A&quot;).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *              .backgroundColor(Color.RED)
     *          );
     *          add(group(&quot;B&quot;), it -&amp;gt; it
     *              .borderWidth(12)
     *          );
     *          add(group(&quot;C&quot;), it -&amp;gt; it
     *              .borderWidth(16)
     *              .borderColor(Color.YELLOW)
     *          );
     *      }
     *    }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(&quot;A&quot;)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;
     *
     * @param groupNames The names of the style groups to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I group( String... groupNames ) {
<span class="fc" id="L151">        ComponentExtension.from(getComponent()).setStyleGroups(groupNames);</span>
<span class="fc" id="L152">        return _this();</span>
    }

    /**
     *  This method is part of the SwingTree style API, and it allows you to
     *  add this component to an enum based style group.
     *  This is conceptually similar to CSS classes, with the difference that
     *  style groups can inherit from each other inside {@link swingtree.style.StyleSheet}s. &lt;br&gt;
     *  Here an example of how to define styles for a style group:
     *  &lt;pre&gt;&lt;code&gt;
     *  new StyleSheet() {
     *          {@literal @}Override
     *          protected void build() {
     *              add(group(MyGroups.A).inherits(&quot;B&quot;, &quot;C&quot;), it -&amp;gt; it
     *                  .backgroundColor(Color.RED)
     *              );
     *              add(group(MyGroups.B), it -&amp;gt; it
     *                  .borderWidth(12)
     *              );
     *              add(group(MyGroups.C), it -&amp;gt; it
     *                  .borderWidth(16)
     *                  .borderColor(Color.YELLOW)
     *              );
     *          }
     *      }
     *  &lt;/code&gt;&lt;/pre&gt;
     *  &lt;br&gt;
     *  The style sheet in the above example code can be applied to a component like so:
     *  &lt;pre&gt;{@code
     *      UI.use(new MyStyleSheet(), ()-&gt;
     *          UI.button(&quot;Click me&quot;).group(MyGroup.A)
     *          .onClick(it -&gt; {...})
     *      );
     *  }&lt;/pre&gt;
     *
     * @param groupName The enum based style group to which this component should be added.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The enum type.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; I group( E... groupName ) {
<span class="fc" id="L193">        String[] names = new String[groupName.length];</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for ( int i = 0; i &lt; groupName.length; i++ ) {</span>
<span class="fc" id="L195">            E group = groupName[i];</span>
<span class="fc" id="L196">            Objects.requireNonNull(group);</span>
<span class="fc" id="L197">            names[i] = group.getClass().getSimpleName() + &quot;.&quot; + group.name();</span>
        }
<span class="fc" id="L199">        return group(names);</span>
    }

    /**
     *  Use this to make the wrapped UI component visible or invisible.
     *
     * @param isVisible The truth value determining if the UI component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( boolean isVisible ) {
<span class="fc" id="L209">        getComponent().setVisible( isVisible );</span>
<span class="fc" id="L210">        return _this();</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(boolean)}.
     *  Use this to make the wrapped UI component invisible or visible.
     * @param isVisible The truth value determining if the UI component should be visible or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( boolean isVisible ) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        getComponent().setVisible(!isVisible);</span>
<span class="fc" id="L221">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically visible or invisible. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIf( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L232">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L233">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="fc" id="L234">        _onShow( isVisible, v -&gt; getComponent().setVisible(v) );</span>
<span class="fc" id="L235">        return isVisibleIf( isVisible.orElseThrow() );</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Val)}.
     *  Use this to make the wrapped UI component dynamically invisible or visible. &lt;br&gt;
     * @param isVisible The truth value determining if the UI component should be visible or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isVisibleIfNot( Val&lt;Boolean&gt; isVisible ) {
<span class="fc" id="L245">        NullUtil.nullArgCheck(isVisible, &quot;isVisible&quot;, Val.class);</span>
<span class="fc" id="L246">        NullUtil.nullPropertyCheck(isVisible, &quot;isVisible&quot;, &quot;Null is not allowed to model the visibility of a UI component! A boolean should only be true or false!&quot;);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        _onShow( isVisible, v -&gt; getComponent().setVisible(!v) );</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        return isVisibleIf( !isVisible.orElseThrow() );</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically visible or invisible,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component visible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component visible.
     * @param &lt;E&gt; The enum type.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L262">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L263">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L264">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; getComponent().setVisible( v == enumValue ) );</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        return isVisibleIf( enumValue == enumProperty.orElseThrow() );</span>
    }

    /**
     *  This is the inverse of {@link #isVisibleIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically invisible or visible,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component invisible.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component invisible.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isVisibleIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L279">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L280">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L281">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;Null is not allowed to model the visibility of a UI component!&quot;);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; getComponent().setVisible( v != enumValue ) );</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        return isVisibleIf( enumValue != enumProperty.orElseThrow() );</span>
    }

    /**
     *  Use this to enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( boolean isEnabled ) {
<span class="fc" id="L293">        _setEnabled( isEnabled );</span>
<span class="fc" id="L294">        return _this();</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(boolean)}.
     *  Use this to disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( boolean isEnabled ) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        _setEnabled( !isEnabled );</span>
<span class="nc" id="L306">        return _this();</span>
    }

    /**
     *  Use this to dynamically enable or disable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIf( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L316">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L317">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="fc" id="L318">        _onShow( isEnabled, v -&gt; _setEnabled(v) );</span>
<span class="fc" id="L319">        return isEnabledIf( isEnabled.orElseThrow() );</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Val)}.
     *  Use this to dynamically disable or enable the wrapped UI component.
     *
     * @param isEnabled The truth value determining if the UI component should be enabled or not wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isEnabledIfNot( Val&lt;Boolean&gt; isEnabled ) {
<span class="fc" id="L330">        NullUtil.nullArgCheck(isEnabled, &quot;isEnabled&quot;, Val.class);</span>
<span class="fc" id="L331">        NullUtil.nullPropertyCheck(isEnabled, &quot;isEnabled&quot;, &quot;Null value for isEnabled is not allowed!&quot;);</span>
<span class="pc bnc" id="L332" title="All 2 branches missed.">        _onShow( isEnabled, v -&gt; _setEnabled(!v) );</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        return isEnabledIf( !isEnabled.orElseThrow() );</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically enabled or disabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component enabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component enabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L347">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L348">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L349">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; _setEnabled( v == enumValue ) );</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        return isEnabledIf( enumValue == enumProperty.orElseThrow() );</span>
    }

    /**
     *  This is the inverse of {@link #isEnabledIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically disabled or enabled,
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component disabled.
     * @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component disabled.
     * @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isEnabledIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L366">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L367">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L368">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; _setEnabled( v != enumValue ) );</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        return isEnabledIf( enumValue != enumProperty.orElseThrow() );</span>
    }

<span class="fc" id="L373">    protected void _setEnabled( boolean isEnabled ) { getComponent().setEnabled( isEnabled ); }</span>

    /**
     *  Use this to make the wrapped UI component grab the input focus.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeFocused() {
<span class="fc" id="L380">        UI.runLater(() -&gt; {</span>
<span class="fc" id="L381">            getComponent().grabFocus();</span>
            // We do this later because in this point in time the UI is probably not
            // yet fully built (swing-tree is using the builder-pattern).
<span class="fc" id="L384">        });</span>
<span class="fc" id="L385">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable.
     *  @param isFocusable The truth value determining if the UI component should be focusable or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( boolean isFocusable ) {
<span class="fc" id="L394">        getComponent().setFocusable( isFocusable );</span>
<span class="fc" id="L395">        return _this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIf( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L408">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L409">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="fc" id="L410">        _onShow( isFocusable, v -&gt; isFocusableIf(v) );</span>
<span class="fc" id="L411">        this.isFocusableIf( isFocusable.orElseThrow() );</span>
<span class="fc" id="L412">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component focusable if a certain condition is not met.
     *  @param notFocusable The truth value determining if the UI component should be focusable or not.
     *                     If {@code false}, the component will be focusable.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isFocusableIfNot( boolean notFocusable ) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        getComponent().setFocusable( !notFocusable );</span>
<span class="nc" id="L423">        return _this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component focusable.
     *  This is useful if you want to make a component focusable only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isFocusable The truth value determining if the UI component should be focusable or not, wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code isFocusable} is {@code null}.
     */
    public final I isFocusableIfNot( Val&lt;Boolean&gt; isFocusable ) {
<span class="fc" id="L437">        NullUtil.nullArgCheck(isFocusable, &quot;isFocusable&quot;, Val.class);</span>
<span class="fc" id="L438">        NullUtil.nullPropertyCheck(isFocusable, &quot;isFocusable&quot;, &quot;Null value for isFocusable is not allowed!&quot;);</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        _onShow( isFocusable, v -&gt; isFocusableIf(!v) );</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        this.isFocusableIf( !isFocusable.orElseThrow() );</span>
<span class="fc" id="L441">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIf( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L456">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L457">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L458">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; isFocusableIf( v == enumValue ) );</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        return isFocusableIf( enumValue == enumProperty.orElseThrow() );</span>
    }

    /**
     *  This is the inverse of {@link #isFocusableIf(Enum, Val)}.
     *  Use this to make the wrapped UI component dynamically focusable or non-focusable
     *  based on the equality between the supplied enum value and enum property. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param enumValue The enum value which, if equal to the supplied enum property, makes the UI component non-focusable.
     *  @param enumProperty The enum property which, if equal to the supplied enum value, makes the UI component non-focusable.
     *  @param &lt;E&gt; The enum type for both the supplied enum value and enum property.
     *  @return This very instance, which enables builder-style method chaining.
     *  @throws IllegalArgumentException if the supplied {@code enumValue} or {@code enumProperty} is {@code null}.
     */
    public final &lt;E extends Enum&lt;E&gt;&gt; I isFocusableIfNot( E enumValue, Val&lt;E&gt; enumProperty ) {
<span class="fc" id="L476">        NullUtil.nullArgCheck(enumValue, &quot;enumValue&quot;, Enum.class);</span>
<span class="fc" id="L477">        NullUtil.nullArgCheck(enumProperty, &quot;enumProperty&quot;, Val.class);</span>
<span class="fc" id="L478">        NullUtil.nullPropertyCheck(enumProperty, &quot;enumProperty&quot;, &quot;The enumProperty may not have null values!&quot;);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        _onShow( enumProperty, v -&gt; isFocusableIf( v != enumValue ) );</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        return isFocusableIf( enumValue != enumProperty.orElseThrow() );</span>
    }


    /**
     *  Use this to make the wrapped UI component opaque.
     *  This is the inverse of {@link #makeNonOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeOpaque() {
<span class="nc" id="L491">        getComponent().setOpaque( true );</span>
<span class="nc" id="L492">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component transparent.
     *  This is the inverse of {@link #makeOpaque()}.
     *
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I makeNonOpaque() {
<span class="fc" id="L502">        getComponent().setOpaque( false );</span>
<span class="fc" id="L503">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component opaque.
     *  @param isOpaque The truth value determining if the UI component should be opaque or not.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIf( boolean isOpaque ) {
<span class="nc" id="L512">        getComponent().setOpaque( isOpaque );</span>
<span class="nc" id="L513">        return _this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component opaque.
     *  This is useful if you want to make a component opaque only if a certain condition is met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param isOpaque The truth value determining if the UI component should be opaque or not wrapped in a {@link Val}.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIf( Val&lt;Boolean&gt; isOpaque ) {
<span class="nc" id="L526">        NullUtil.nullArgCheck( isOpaque, &quot;isOpaque&quot;, Val.class );</span>
<span class="nc" id="L527">        NullUtil.nullPropertyCheck(isOpaque, &quot;isOpaque&quot;, &quot;Null value for isOpaque is not allowed! A boolean should only have the values true or false!&quot;);</span>
<span class="nc" id="L528">        _onShow( isOpaque, v -&gt; isOpaqueIf(v) );</span>
<span class="nc" id="L529">        this.isOpaqueIf( isOpaque.orElseThrow() );</span>
<span class="nc" id="L530">        return _this();</span>
    }

    /**
     *  Use this to make the wrapped UI component opaque if the given condition is not met.
     *  @param notOpaque The truth value determining if the UI component should be opaque or not, where false means opaque.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIfNot( boolean notOpaque ) {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        getComponent().setOpaque( !notOpaque );</span>
<span class="nc" id="L540">        return _this();</span>
    }

    /**
     *  Use this to dynamically make the wrapped UI component opaque if the boolean item of the given {@link Val} is false.
     *  This is useful if you want to make a component opaque only if a certain condition is not met.
     *  &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     *  @param notOpaque The truth value determining if the UI component should be opaque or not, wrapped in a {@link Val}, where false means opaque.
     *  @return This very instance, which enables builder-style method chaining.
     */
    public final I isOpaqueIfNot( Val&lt;Boolean&gt; notOpaque ) {
<span class="nc" id="L553">        NullUtil.nullArgCheck( notOpaque, &quot;notOpaque&quot;, Val.class );</span>
<span class="nc" id="L554">        NullUtil.nullPropertyCheck(notOpaque, &quot;notOpaque&quot;, &quot;Null value for isOpaque is not allowed! A boolean should only have the values true or false!&quot;);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        _onShow( notOpaque, v -&gt; isOpaqueIf(!v) );</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        this.isOpaqueIf( !notOpaque.orElseThrow() );</span>
<span class="nc" id="L557">        return _this();</span>
    }

    /**
     *  This allows you to register validation logic for the wrapped UI component.
     *  Although the delegate exposed to the {@link UIVerifier} lambda
     *  indirectly exposes you to the UIs state, you should not access the UI directly
     *  from within the lambda, but modify the properties inside your view model instead.
     *
     * @param verifier The validation logic provided by your view model.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I isValidIf( UIVerifier&lt;C&gt; verifier ) {
<span class="fc" id="L570">        getComponent().setInputVerifier(new InputVerifier() {</span>
            @Override
            public boolean verify( JComponent input ) {
<span class="nc" id="L573">                return verifier.isValid(</span>
                        new ComponentDelegate&lt;&gt;(
<span class="nc" id="L575">                                getComponent(),</span>
<span class="nc" id="L576">                                new ComponentEvent(getComponent(), 0),</span>
<span class="nc" id="L577">                                () -&gt; getSiblinghood()</span>
                            )
                        );
                /*
                    We expect the user to model the state of the UI components
                    using properties in the view model.
                 */
            }
        });
<span class="fc" id="L586">        return _this();</span>
    }

    /**
     * Adds {@link String} key/value &quot;client property&quot; pairs to the wrapped component.
     * &lt;p&gt;
     * The arguments will be passed to {@link JComponent#putClientProperty(Object, Object)}
     * which accesses
     * a small per-instance hashtable. Callers can use get/putClientProperty
     * to annotate components that were created by another module.
     * For example, a
     * layout manager might store per child constraints this way. &lt;br&gt;
     * This is in essence a more convenient way than the alternative usage pattern involving
     * the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     * &lt;pre&gt;{@code
     *     UI.button()
     *     .peek( button -&gt; button.putClientProperty(&quot;key&quot;, &quot;value&quot;) );
     * }&lt;/pre&gt;
     *
     * @param key the new client property key which may be used for styles or layout managers.
     * @param value the new client property value.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withProperty( String key, String value ) {
<span class="fc" id="L610">        getComponent().putClientProperty(key, value);</span>
<span class="fc" id="L611">        return _this();</span>
    }

    /**
     *  Use this to attach a border to the wrapped component.
     *
     * @param border The {@link Border} which should be set for the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Border border ) {
<span class="fc" id="L621">        Objects.requireNonNull(border, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="fc" id="L622">        getComponent().setBorder( border );</span>
<span class="fc" id="L623">        return _this();</span>
    }

    /**
     *  Use this to dynamically attach a border to the wrapped component. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param border The {@link Border} which should be set for the wrapped component wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorder( Val&lt;Border&gt; border ) {
<span class="fc" id="L634">        NullUtil.nullArgCheck(border, &quot;border&quot;, Val.class);</span>
<span class="fc" id="L635">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null value for border is not allowed! Use an empty border instead!&quot;);</span>
<span class="pc" id="L636">        _onShow( border, v -&gt; getComponent().setBorder(v) );</span>
<span class="fc" id="L637">        return this.withBorder( border.orElseNull() );</span>
    }


    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int top, int left, int bottom, int right ) {
<span class="nc" id="L651">        getComponent().setBorder(BorderFactory.createEmptyBorder(top, left, bottom, right));</span>
<span class="nc" id="L652">        return _this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int top, int left, int bottom, int right ) {
<span class="fc" id="L666">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L667">        getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(top, left, bottom, right), title));</span>
<span class="fc" id="L668">        return _this();</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val},
     *              which will update the border title dynamically when changed.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int top, int left, int bottom, int right ) {
<span class="nc" id="L684">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L685">        NullUtil.nullPropertyCheck( title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot; );</span>
<span class="nc" id="L686">        _onShow( title, v -&gt;</span>
<span class="nc" id="L687">                getComponent().setBorder(</span>
<span class="nc" id="L688">                        BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(top, left, bottom, right), v)</span>
                    )
            );
<span class="nc" id="L691">        return this.withEmptyBorderTitled( title.orElseNull(), top, left, bottom, right );</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( int topBottom, int leftRight ) {
<span class="nc" id="L702">        return withEmptyBorder(topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets.
     *
     * @param title The title of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title, int topBottom, int leftRight ) {
<span class="nc" id="L714">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L715">        return withEmptyBorderTitled( title, topBottom, leftRight, topBottom, leftRight );</span>
    }

    /**
     *  Use this to define a titled empty {@link Border} with the provided insets
     *  and where the title is bound to a {@link Val}.
     *
     * @param title The title of the border wrapped in a {@link Val}. When the value changes, the border title will be updated.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int topBottom, int leftRight ) {
<span class="nc" id="L728">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L729">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L730">        _onShow( title, v -&gt; getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(topBottom, leftRight, topBottom, leftRight), v)) );</span>
<span class="nc" id="L731">        return this.withEmptyBorderTitled( title.orElseNull(), topBottom, leftRight );</span>
    }

    /**
     *  Use this to define an empty {@link Border} with the provided insets.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L740">    public final I withEmptyBorder( int all ) { return withEmptyBorder(all, all, all, all); }</span>

    /**
     *  Creates an empty and un-titled {@link Border} with the provided insets
     *  property bound to all insets of said border.
     *  &lt;p&gt;
     *  An empty and un-titled {@link Border} is basically just a way to add some
     *  space around the component. It is not visible by default.
     *
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorder( Val&lt;Integer&gt; all ) {
<span class="nc" id="L753">        NullUtil.nullArgCheck( all, &quot;all&quot;, Val.class );</span>
<span class="nc" id="L754">        NullUtil.nullPropertyCheck(all, &quot;all&quot;, &quot;Null value for all is not allowed! Use an empty border instead!&quot;);</span>
<span class="nc" id="L755">        _onShow( all, v -&gt; getComponent().setBorder(BorderFactory.createEmptyBorder(v, v, v, v)) );</span>
<span class="nc" id="L756">        return this.withEmptyBorder( all.get() );</span>
    }

            /**
             *  Use this to define a titled empty {@link Border} with the provided insets.
             *
             * @param title The title of the border.
             * @param all The insets for all sides.
             * @return This very instance, which enables builder-style method chaining.
             */
    public final I withEmptyBorderTitled( String title, int all ) {
<span class="fc" id="L767">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="fc" id="L768">        return withEmptyBorderTitled(title, all, all, all, all);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property and the provided insets.
     * @param title The title of the border in the form of a {@link Val} property.
     * @param all The insets size for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title, int all ) {
<span class="nc" id="L778">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L779">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L780">        _onShow( title, v -&gt;</span>
<span class="nc" id="L781">            getComponent().setBorder(</span>
<span class="nc" id="L782">                BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(all, all, all, all), v)</span>
            )
        );
<span class="nc" id="L785">        return this.withEmptyBorderTitled( title.orElseNull(), all );</span>
    }

    /**
     *  Use this to define an empty {@link Border} with a title
     *  and a default insets size of 5.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( String title ) {
<span class="nc" id="L796">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L797">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Creates a titled empty border bound to a {@link String} property
     *  and a default insets size of 5.
     *
     * @param title The title of the border in the form of a {@link Val} property.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withEmptyBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L808">        return withEmptyBorderTitled(title, 5);</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and insets.
     *
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color, int thickness ) {
<span class="fc" id="L819">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="fc" id="L820">        getComponent().setBorder(BorderFactory.createLineBorder(color, thickness));</span>
<span class="fc" id="L821">        return _this();</span>
    }

    /**
     *  Creates a line border bound to a {@link Color} property.
     *  When the color changes, the border will be updated with the new color.
     * @param color The color of the border in the form of a {@link Val} property.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L832">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L833">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L834">        _onShow( color, v -&gt; getComponent().setBorder(BorderFactory.createLineBorder(v, thickness)) );</span>
<span class="nc" id="L835">        return this.withLineBorder( color.get(), thickness );</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and insets.
     *
     * @param title The title of the border.
     * @param color The color of the line border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L847">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L848">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L849">        getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color, thickness), title));</span>
<span class="nc" id="L850">        return _this();</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property.
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L861">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L862">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L863">        _onShow( title, v -&gt;</span>
<span class="nc" id="L864">            getComponent().setBorder(</span>
<span class="nc" id="L865">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color, thickness), v)</span>
            )
        );
<span class="nc" id="L868">        return this.withLineBorderTitled( title.orElseNull(), color, thickness );</span>
    }

    /**
     * Creates a titled line border bound to a {@link String} property
     * and a {@link Color} property.
     * When any of the properties change, the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the line border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L882">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L883">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L884">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L885">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L886">        _onShow( title, v -&gt;</span>
<span class="nc" id="L887">            getComponent().setBorder(</span>
<span class="nc" id="L888">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color.get(), thickness), v)</span>
            )
        );
<span class="nc" id="L891">        _onShow( color, v -&gt;</span>
<span class="nc" id="L892">            getComponent().setBorder(</span>
<span class="nc" id="L893">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(v, thickness), title.get())</span>
            )
        );
<span class="nc" id="L896">        return this.withLineBorderTitled( title.orElseNull(), color.get(), thickness );</span>
    }

    /**
     *  Use this to define a line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorder( Color color ) {
<span class="nc" id="L906">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L907">        return withLineBorder(color, 1);</span>
    }

    /**
     *  Use this to define a titled line {@link Border} with the provided color and a default thickness of {@code 1}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLineBorderTitled( String title, Color color ) {
<span class="nc" id="L918">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L919">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L920">        return withLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color, int thickness ) {
<span class="nc" id="L932">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L933">        getComponent().setBorder(BorderFactory.createLineBorder(color, thickness, true));</span>
<span class="nc" id="L934">        return _this();</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color, int thickness ) {
<span class="nc" id="L947">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L948">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L949">        getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color, thickness, true), title));</span>
<span class="nc" id="L950">        return _this();</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title property.
     *  When the title property changes, the border will be updated with the new value.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Color color, int thickness ) {
<span class="nc" id="L965">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L966">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L967">        _onShow( title, v -&gt;</span>
<span class="nc" id="L968">            getComponent().setBorder(</span>
<span class="nc" id="L969">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color, thickness, true), v)</span>
            )
        );
<span class="nc" id="L972">        return this.withRoundedLineBorderTitled( title.orElseNull(), color, thickness );</span>
    }

    /**
     *  Creates a titled rounded line {@link Border} with the provided
     *  color and insets for this {@link JComponent} and binds the border to the provided
     *  title and color properties.
     *  When the title or color properties change, 
     *  then the border will be updated with the new values.
     *
     * @param title The title property of the border which will update the border when the value changes.
     * @param color The color property of the border which will update the border when the value changes.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L988">        NullUtil.nullArgCheck( title, &quot;title&quot;, Val.class );</span>
<span class="nc" id="L989">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty string instead!&quot;);</span>
<span class="nc" id="L990">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L991">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L992">        _onShow( title, v -&gt;</span>
<span class="nc" id="L993">            getComponent().setBorder(</span>
<span class="nc" id="L994">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(color.get(), thickness, true), v)</span>
            )
        );
<span class="nc" id="L997">        _onShow( color, v -&gt;</span>
<span class="nc" id="L998">            getComponent().setBorder(</span>
<span class="nc" id="L999">                BorderFactory.createTitledBorder(BorderFactory.createLineBorder(v, thickness, true), title.get())</span>
            )
        );
<span class="nc" id="L1002">        return this.withRoundedLineBorderTitled( title.get(), color.get(), thickness );</span>
    }

    /**
     *  Use this to attach a rounded line {@link Border} with the provided
     *  color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Color color ) {
<span class="nc" id="L1013">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1014">        return withRoundedLineBorder(color, 1);</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  color property and a custom thickness to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param thickness The thickness of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorder( Val&lt;Color&gt; color, int thickness ) {
<span class="nc" id="L1026">        NullUtil.nullArgCheck( color, &quot;color&quot;, Val.class );</span>
<span class="nc" id="L1027">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null value for color is not allowed! Use a transparent color or other default color instead!&quot;);</span>
<span class="nc" id="L1028">        _onShow( color, v -&gt;</span>
<span class="nc" id="L1029">            getComponent().setBorder(BorderFactory.createLineBorder(v, thickness, true))</span>
        );
<span class="nc" id="L1031">        return this.withRoundedLineBorder( color.get(), thickness );</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title, color and a default thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title, Color color ) {
<span class="nc" id="L1043">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1044">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1045">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a titled rounded line {@link Border} with the provided
     *  title and color to the {@link JComponent}, as well as a default thickness of {@code 1}.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @param color The color property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title, Val&lt;Color&gt; color ) {
<span class="nc" id="L1057">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1058">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1059">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1060">        return withRoundedLineBorderTitled( title, color, 1 );</span>
    }

    /**
     *  Use this to attach a rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1069">    public final I withRoundedLineBorder() { return withRoundedLineBorder(Color.BLACK, 1); }</span>

    /**
     *  Use this to attach a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( String title ) {
<span class="nc" id="L1079">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1080">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Creates a titled rounded black line {@link Border} with
     *  a thickness of {@code 1} to the {@link JComponent} and binds it to the provided 
     *  title property.
     *  When the property changes, the border will be updated.
     *
     * @param title The title property of the border, which will update the border when the property changes.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withRoundedLineBorderTitled( Val&lt;String&gt; title ) {
<span class="nc" id="L1093">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1094">        NullUtil.nullPropertyCheck(title, &quot;title&quot;, &quot;Null value for title is not allowed! Use an empty String instead!&quot;);</span>
<span class="nc" id="L1095">        return withRoundedLineBorderTitled( title, Color.BLACK, 1 );</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1110">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1111">        getComponent().setBorder(BorderFactory.createMatteBorder(top, left, bottom, right, color));</span>
<span class="nc" id="L1112">        return _this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param top The top inset.
     * @param left The left inset.
     * @param bottom The bottom inset.
     * @param right The right inset.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int top, int left, int bottom, int right ) {
<span class="nc" id="L1128">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1129">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1130">        getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createMatteBorder(top, left, bottom, right, color), title));</span>
<span class="nc" id="L1131">        return _this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1144">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1145">        return withMatteBorder(color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param topBottom The top and bottom insets.
     * @param leftRight The left and right insets.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int topBottom, int leftRight ) {
<span class="nc" id="L1159">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1160">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1161">        return withMatteBorderTitled(title, color, topBottom, leftRight, topBottom, leftRight);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorder( Color color, int all ) {
<span class="nc" id="L1173">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1174">        return withMatteBorder(color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.MatteBorder} with the provided
     *  color and insets to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param color The color of the border.
     * @param all The insets for all sides.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withMatteBorderTitled( String title, Color color, int all ) {
<span class="nc" id="L1187">        NullUtil.nullArgCheck( title, &quot;title&quot;, String.class );</span>
<span class="nc" id="L1188">        NullUtil.nullArgCheck( color, &quot;color&quot;, Color.class );</span>
<span class="nc" id="L1189">        return withMatteBorderTitled(title, color, all, all, all, all);</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.CompoundBorder} with the provided
     *  borders to the {@link JComponent}.
     *
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorder( Border first, Border second ) {
<span class="nc" id="L1201">        NullUtil.nullArgCheck( first, &quot;first&quot;, Border.class );</span>
<span class="nc" id="L1202">        NullUtil.nullArgCheck( second, &quot;second&quot;, Border.class );</span>
<span class="nc" id="L1203">        getComponent().setBorder(BorderFactory.createCompoundBorder(first, second));</span>
<span class="nc" id="L1204">        return _this();</span>
    }

    /**
     *  Use this to attach a titled {@link javax.swing.border.CompoundBorder} with the
     *  provided borders to the {@link JComponent}.
     *
     * @param title The title of the border.
     * @param first The first border.
     * @param second The second border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCompoundBorderTitled( String title, Border first, Border second ) {
<span class="nc" id="L1217">        getComponent().setBorder(BorderFactory.createTitledBorder(BorderFactory.createCompoundBorder(first, second), title));</span>
<span class="nc" id="L1218">        return _this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the provided title.
     *
     * @param title The title of the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( String title ) {
<span class="fc" id="L1228">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class);</span>
<span class="fc" id="L1229">        getComponent().setBorder(BorderFactory.createTitledBorder(title));</span>
<span class="fc" id="L1230">        return _this();</span>
    }

    /**
     *  Use this to attach a {@link javax.swing.border.TitledBorder} with the
     *  provided title property dynamically setting the title String.
     *
     * @param title The title property for the border.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBorderTitled( Val&lt;String&gt; title ) {
<span class="fc" id="L1241">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1242">        getComponent().setBorder(BorderFactory.createTitledBorder(title.get()));</span>
<span class="fc" id="L1243">        _onShow( title, t -&gt; {</span>
<span class="fc" id="L1244">            Border foundBorder = getComponent().getBorder();</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">            if ( foundBorder instanceof TitledBorder)</span>
<span class="fc" id="L1246">                ((TitledBorder)foundBorder).setTitle(t);</span>
            else
<span class="nc" id="L1248">                getComponent().setBorder(BorderFactory.createTitledBorder(t));</span>
<span class="fc" id="L1249">        });</span>
<span class="fc" id="L1250">        return _this();</span>
    }

    /**
     *  Use this set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder.
     *  &lt;br&gt;
     *  Here an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me!&quot;).withCursor(UI.Cursor.HAND);
     *  }&lt;/pre&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( UI.Cursor type ) {
<span class="fc" id="L1266">        getComponent().setCursor( new java.awt.Cursor( type.type ) );</span>
<span class="fc" id="L1267">        return _this();</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursor( Val&lt;UI.Cursor&gt; type ) {
<span class="fc" id="L1279">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="fc" id="L1280">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="fc" id="L1281">        _onShow( type, t -&gt; getComponent().setCursor( new java.awt.Cursor( t.type ) ) );</span>
<span class="fc" id="L1282">        return withCursor( type.orElseThrow() );</span>
    }

    /**
     *  Use this to set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type defined by a simple enum exposed by this API wrapped in a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, UI.Cursor type ) {
<span class="nc" id="L1296">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1297">        NullUtil.nullArgCheck( type, &quot;type&quot;, UI.Cursor.class );</span>
<span class="nc" id="L1298">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        _onShow( condition, c -&gt; getComponent().setCursor( new java.awt.Cursor( c ? type.type : UI.Cursor.DEFAULT.type ) ) );</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        return withCursor( condition.orElseThrow() ? type : UI.Cursor.DEFAULT );</span>
    }

    /**
     *  Use this to dynamically set the cursor type which should be displayed
     *  when hovering over the UI component wrapped by this builder
     *  based on boolean property determining if the provided cursor should be set ot not. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The boolean property determining if the provided cursor should be set ot not.
     * @param type The {@link UI.Cursor} type property defined by a simple enum exposed by this API.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withCursorIf( Val&lt;Boolean&gt; condition, Val&lt;UI.Cursor&gt; type ) {
<span class="nc" id="L1314">        NullUtil.nullArgCheck( condition, &quot;condition&quot;, Val.class );</span>
<span class="nc" id="L1315">        NullUtil.nullArgCheck( type, &quot;type&quot;, Val.class );</span>
<span class="nc" id="L1316">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the cursor selection state.&quot;);</span>
<span class="nc" id="L1317">        NullUtil.nullPropertyCheck(type, &quot;type&quot;, &quot;Null is not allowed to model a cursor type.&quot;);</span>
<span class="nc" id="L1318">        Cursor[] baseCursor = new Cursor[1];</span>
<span class="nc" id="L1319">        _onShow( condition, c -&gt; type.fireSet() );</span>
<span class="nc" id="L1320">        _onShow( type, c -&gt;{</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if (baseCursor[0] == null) baseCursor[0] = getComponent().getCursor();</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            getComponent().setCursor( new java.awt.Cursor( condition.get() ? c.type : baseCursor[0].getType() ) );</span>
<span class="nc" id="L1323">        });</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">        return withCursor( condition.orElseThrow() ? type.orElseThrow() : UI.Cursor.DEFAULT );</span>
    }

    /**
     *  Use this to set the {@link LayoutManager} of the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FavouriteLayoutManager()) );
     *  }&lt;/pre&gt;
     *
     * @param layout The {@link LayoutManager} which should be supplied to the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutManager layout ) {
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">        if ( _migAlreadySet )</span>
<span class="nc" id="L1341">            throw new IllegalArgumentException(&quot;The mig layout has already been specified for this component!&quot;);</span>
<span class="fc" id="L1342">        getComponent().setLayout(layout);</span>
<span class="fc" id="L1343">        return _this();</span>
    }

    /**
     *  Use this to set a {@link FlowLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new FlowLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1357">    public final I withFlowLayout() { return this.withLayout(new FlowLayout()); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout()) );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1370">    public final I withGridLayout() { return this.withLayout(new GridLayout()); }</span>

    /**
     *  Use this to set a new {@link GridBagLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridBagLayout()) );
     *  }&lt;/pre&gt;
     *  ...or specifying the layout manager like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.panel().withLayout( new GridBagLayout() );
     *  }&lt;/pre&gt;
     *
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1387">    public final I withGridBagLayout() { return this.withLayout(new GridBagLayout()); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1402">    public final I withGridLayout( int rows, int cols ) { return this.withLayout(new GridLayout(rows, cols)); }</span>

    /**
     *  Use this to set a {@link GridLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new GridLayout(rows, cols, hgap, vgap)) );
     *  }&lt;/pre&gt;
     *
     * @param rows The number of rows in the grid.
     * @param cols The number of columns in the grid.
     * @param hgap The horizontal gap between cells.
     * @param vgap The vertical gap between cells.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withGridLayout( int rows, int cols, int hgap, int vgap ) {
<span class="nc" id="L1420">        return this.withLayout(new GridLayout(rows, cols, hgap, vgap));</span>
    }

    /**
     *  Use this to set a {@link BoxLayout} for the component wrapped by this builder. &lt;br&gt;
     *  This is in essence a more convenient way than the alternative usage pattern involving
     *  the {@link #peek(Peeker)} method to peek into the builder's component like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .peek( panel -&gt; panel.setLayout(new BoxLayout(panel, axis.forBoxLayout())) );
     *  }&lt;/pre&gt;
     *
     * @param axis The axis for the box layout.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException If the provided axis is {@code null}.
     * @see UI.Axis
     * @see BoxLayout
     */
    public final I withBoxLayout( UI.Axis axis ) {
<span class="nc" id="L1439">        NullUtil.nullArgCheck( axis, &quot;axis&quot;, UI.Axis.class );</span>
<span class="nc" id="L1440">        return this.withLayout(new BoxLayout(getComponent(), axis.forBoxLayout()));</span>
    }

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a string.
     *
     * @param attr A string defining the layout (usually mig layout).
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1450">    public final I withLayout( String attr ) { return withLayout(attr, null); }</span>

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LC} instance,
     *  which is a builder for the layout constraints.
     *
     * @param attr A string defining the layout (usually mig layout).
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="nc" id="L1460">    public final I withLayout( LC attr ) { return withLayout(attr, (AC) null, (AC) null); }</span>

    /**
     *  Creates a new {@link MigLayout} for the component wrapped by this UI builder,
     *  based on the provided layout constraints in the form of a {@link LayoutAttr} instance,
     *  which is an immutable string wrapper for the layout constraints.
     *  Instances of this are usually obtained from the {@link UI} namespace like
     *  {@link UI#FILL} or {@link UI#FILL_X}...
     *
     * @param attr Essentially an immutable string wrapper defining the mig layout.
     * @return This very instance, which enables builder-style method chaining.
     */
<span class="fc" id="L1472">    public final I withLayout( LayoutAttr attr ) { return withLayout(attr.toString(), null); }</span>

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder
     *  based on the provided layout constraints in the form of a string.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( String attr, String colConstrains ) {
<span class="fc" id="L1483">        return withLayout(attr, colConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a {@link AC} instance.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a {@link AC} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LC attr, AC colConstrains ) {
<span class="nc" id="L1496">        return withLayout(attr, colConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LC attr, String colConstrains ) {
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains == null ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc" id="L1510">        return withLayout(attr, parsedColConstrains, null);</span>
    }

    /**
     * This creates a {@link MigLayout} for the component wrapped by this UI builder
     * based on the provided layout constraints in the form of a {@link LC} instance
     * and column and row constraints in the form of a simple string.
     *
     * @param attr The constraints for the layout, a {@link LC} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance as a simple string.
     * @param rowConstraints The row layout for the {@link MigLayout} instance as a simple string.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LC attr, String colConstrains, String rowConstraints ) {
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        AC parsedColConstrains = colConstrains == null ? null : ConstraintParser.parseColumnConstraints(colConstrains);</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">        AC parsedRowConstrains = rowConstraints == null ? null : ConstraintParser.parseRowConstraints(rowConstraints);</span>
<span class="nc" id="L1526">        return withLayout(attr, parsedColConstrains, parsedRowConstrains);</span>
    }

    /**
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutAttr attr, String colConstrains ) {
<span class="fc" id="L1535">        return withLayout(attr.toString(), colConstrains, null);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout in the form of a {@link LayoutAttr} instance.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LayoutAttr attr, String colConstrains, String rowConstraints ) {
<span class="fc" id="L1547">        return withLayout(attr.toString(), colConstrains, rowConstraints);</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param constraints The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( String constraints, String colConstrains, String rowConstraints ) {
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">        if (_migAlreadySet)</span>
<span class="nc" id="L1560">            throw new IllegalArgumentException(&quot;The mig layout has already been specified for this component!&quot;);</span>

        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="pc bpc" id="L1563" title="2 of 4 branches missed.">        if ( constraints == null || constraints.isEmpty() )</span>
<span class="nc" id="L1564">            constraints = &quot;hidemode 2&quot;;</span>
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">        else if ( !constraints.contains(&quot;hidemode&quot;) )</span>
<span class="fc" id="L1566">            constraints += &quot;, hidemode 2&quot;;</span>

<span class="fc" id="L1568">        MigLayout migLayout = new MigLayout(constraints, colConstrains, rowConstraints);</span>
<span class="fc" id="L1569">        getComponent().setLayout(migLayout);</span>
<span class="fc" id="L1570">        _migAlreadySet = true;</span>
<span class="fc" id="L1571">        return _this();</span>
    }

    /**
     *  This creates a {@link MigLayout} for the component wrapped by this UI builder.
     *
     * @param attr The constraints for the layout.
     * @param colConstrains The column layout for the {@link MigLayout} instance.
     * @param rowConstraints The row layout for the {@link MigLayout} instance.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withLayout( LC attr, AC colConstrains, AC rowConstraints ) {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">        if ( _migAlreadySet )</span>
<span class="nc" id="L1584">            throw new IllegalArgumentException(&quot;The mig layout has already been specified for this component!&quot;);</span>

        // We make sure the default hidemode is 2 instead of 3 (which sucks because it takes up too much space)
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if ( attr == null )</span>
<span class="nc" id="L1588">            attr = new LC().hideMode(2);</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        else if ( attr.getHideMode() == 0 )</span>
<span class="nc" id="L1590">            attr = attr.hideMode(2);</span>

<span class="nc" id="L1592">        MigLayout migLayout = new MigLayout(attr, colConstrains, rowConstraints);</span>
<span class="nc" id="L1593">        getComponent().setLayout(migLayout);</span>
<span class="nc" id="L1594">        _migAlreadySet = true;</span>
<span class="nc" id="L1595">        return _this();</span>
    }

    /**
     *  Use this to set a helpful tool tip text for this UI component.
     *  The tool tip text will be displayed when the mouse hovers on the
     *  UI component for some time. &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; button.setToolTipText(&quot;Can be clicked!&quot;) );
     *  }&lt;/pre&gt;
     *
     * @param tooltip The tool tip text which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withTooltip( String tooltip ) {
<span class="fc" id="L1613">        NullUtil.nullArgCheck(tooltip, &quot;tooltip&quot;, String.class, &quot;Use the empty string to clear the tooltip text!&quot;);</span>
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">        getComponent().setToolTipText(tooltip.isEmpty() ? null : tooltip);</span>
<span class="fc" id="L1615">        return _this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a tooltip string.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          tip.onSetItem(JButton::setToolTipText);
     *          button.setToolTipText(tip.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param tip The tooltip which should be displayed when hovering over the tab header.
     * @return A new {@link Tab} instance with the provided argument, which enables builder-style method chaining.
     */
    public final I withTooltip( Val&lt;String&gt; tip ) {
<span class="fc" id="L1636">        NullUtil.nullArgCheck(tip, &quot;tip&quot;, Val.class);</span>
<span class="fc" id="L1637">        NullUtil.nullPropertyCheck(tip, &quot;tip&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">        _onShow( tip, v -&gt; getComponent().setToolTipText(v.isEmpty() ? null : v) );</span>
<span class="fc" id="L1639">        return this.withTooltip( tip.orElseThrow() );</span>
    }

    /**
     *  Use this to set the background color of the UI component
     *  wrapped by this builder.&lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setBackground(Color.CYAN) );
     *  }&lt;/pre&gt;
     *
     * @param color The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Color color ) {
<span class="fc" id="L1656">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="fc" id="L1657">        getComponent().setBackground(color);</span>
<span class="fc" id="L1658">        return _this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a background color.
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          bg.onSetItem(JButton::setBackground);
     *          button.setBackground(bg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param bg The background color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackground( Val&lt;Color&gt; bg ) {
<span class="fc" id="L1679">        NullUtil.nullArgCheck(bg, &quot;bg&quot;, Val.class);</span>
<span class="fc" id="L1680">        NullUtil.nullPropertyCheck(bg, &quot;bg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L1681">        _onShow( bg, v -&gt; getComponent().setBackground(v) );</span>
<span class="fc" id="L1682">        return this.withBackground( bg.orElseNull() );</span>
    }

    /**
     *  Use this to bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue ) {
<span class="fc" id="L1695">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1696">        NullUtil.nullArgCheck(colorIfTrue, &quot;bg&quot;, Color.class);</span>
<span class="fc" id="L1697">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L1698">        Var&lt;Color&gt; baseColor = Var.of( getComponent().getBackground() );</span>
<span class="fc" id="L1699">        Var&lt;Color&gt; color = Var.of( colorIfTrue );</span>
<span class="fc" id="L1700">        _onShow( condition, v -&gt; _updateBackground( condition, color, baseColor ) );</span>
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">        return this.withBackground( condition.orElse(false) ? colorIfTrue : getComponent().getBackground() );</span>
    }

    /**
     *  Use this to dynamically bind to a background color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The background color property which should be set for the UI component.
     * @param condition The condition property which determines whether the background color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L1714">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1715">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L1716">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L1717">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided background color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L1718">        Var&lt;Color&gt; baseColor = Var.of(getComponent().getBackground());</span>
<span class="fc" id="L1719">        _onShow( condition, setColor -&gt; _updateBackground(condition, color, baseColor) );</span>
<span class="fc" id="L1720">        _onShow( color, v -&gt; _updateBackground(condition, color, baseColor) );</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">        return this.withBackground(condition.orElse(false) ? color.orElseThrow() : getComponent().getBackground());</span>
    }

    /**
     *  Use this to bind to 2 colors to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L1735">        return this.withBackgroundIf( condition, Var.of(colorIfTrue), Var.of(colorIfFalse) );</span>
    }

    /**
     *  Use this to bind to 2 color properties to the background of the component
     *  which sre set based on the value of a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the background color should be set or not.
     * @param colorIfTrue The background color which should be set for the UI component.
     * @param colorIfFalse The background color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withBackgroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L1749">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1750">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L1751">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L1752">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided background color!&quot;);</span>
<span class="fc" id="L1753">        _onShow( condition,    v -&gt; _updateBackground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="pc" id="L1754">        _onShow( colorIfTrue,  v -&gt; _updateBackground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="pc" id="L1755">        _onShow( colorIfFalse, v -&gt; _updateBackground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="pc bpc" id="L1756" title="1 of 2 branches missed.">        return this.withBackground( condition.get() ? colorIfTrue.orElseNull() : colorIfFalse.orElseNull() );</span>
    }

    public final I withStyle( Styler&lt;C&gt; styler ) {
<span class="fc" id="L1760">        NullUtil.nullArgCheck(styler, &quot;styler&quot;, Function.class);</span>
<span class="fc" id="L1761">        ComponentExtension.from(getComponent()).addStyling(styler);</span>
<span class="fc" id="L1762">        return _this();</span>
    }

    /**
     *  Set the color of this {@link JComponent}. (This is usually the font color for components displaying text) &lt;br&gt;
     *  This is in essence a convenience method, which avoid having to expose the underlying component
     *  through the {@link #peek(Peeker)} method like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;Something&quot;)
     *      .peek( label -&gt; label.setForeground(Color.GRAY) );
     *  }&lt;/pre&gt;
     *
     * @param color The color of the foreground (usually text).
     * @return This very builder to allow for method chaining.
     */
    public final I withForeground( Color color ) {
<span class="fc" id="L1778">        NullUtil.nullArgCheck(color, &quot;color&quot;, Color.class);</span>
<span class="fc" id="L1779">        getComponent().setForeground(color);</span>
<span class="fc" id="L1780">        return _this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Val}
     *  containing a foreground color.
     *  This is a convenience method, which works
     *  similar to:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click Me&quot;)
     *      .peek( button -&gt; {
     *          fg.onSet( v -&gt; button.setForeground(v.get()) );
     *          button.setForeground(fg.get());
     *      });
     *  }&lt;/pre&gt;&lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component wrapped by a {@link Val}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForeground( Val&lt;Color&gt; fg ) {
<span class="fc" id="L1801">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Val.class);</span>
<span class="fc" id="L1802">        NullUtil.nullPropertyCheck(fg, &quot;fg&quot;, &quot;Please use the default color of this component instead of null!&quot;);</span>
<span class="fc" id="L1803">        _onShow( fg, v -&gt; getComponent().setForeground(v) );</span>
<span class="fc" id="L1804">        return this.withForeground( fg.orElseNull() );</span>
    }
    
    /**
     *  Use this to bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param fg The foreground color which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color fg ) {
<span class="fc" id="L1817">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1818">        NullUtil.nullArgCheck(fg, &quot;fg&quot;, Color.class);</span>
<span class="fc" id="L1819">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L1820">        Var&lt;Color&gt; baseColor = Var.of(getComponent().getForeground());</span>
<span class="fc" id="L1821">        Var&lt;Color&gt; newColor = Var.of(fg);</span>
<span class="fc" id="L1822">        _onShow( condition, v -&gt; _updateForeground( condition, newColor, baseColor ) );</span>
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">        return this.withForeground( condition.orElse(false) ? fg : getComponent().getForeground() );</span>
    }
    
    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param color The foreground color property which should be set for the UI component.
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; color ) {
<span class="fc" id="L1836">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1837">        NullUtil.nullArgCheck(color, &quot;color&quot;, Val.class);</span>
<span class="fc" id="L1838">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L1839">        NullUtil.nullPropertyCheck(color, &quot;color&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L1840">        Var&lt;Color&gt; baseColor = Var.of(getComponent().getForeground());</span>
<span class="fc" id="L1841">        _onShow( condition, setColor -&gt; _updateForeground(condition, color, baseColor) );</span>
<span class="fc" id="L1842">        _onShow( color, v -&gt; _updateForeground(condition, color, baseColor) );</span>
<span class="pc bpc" id="L1843" title="1 of 2 branches missed.">        return this.withForeground(condition.orElse(false) ? color.orElseThrow() : getComponent().getForeground());</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color which should be set for the UI component.
     * @param colorIfFalse The foreground color which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Color colorIfTrue, Color colorIfFalse ) {
<span class="fc" id="L1857">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1858">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Color.class);</span>
<span class="fc" id="L1859">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Color.class);</span>
<span class="fc" id="L1860">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L1861">        _onShow( condition, v -&gt; _updateForeground( condition, Var.of(colorIfTrue), Var.of(colorIfFalse) ) );</span>
<span class="pc bpc" id="L1862" title="1 of 2 branches missed.">        return this.withForeground( condition.get() ? colorIfTrue : colorIfFalse );</span>
    }

    /**
     *  Use this to dynamically bind to a foreground color
     *  which will be set dynamically based on a boolean property.
     * &lt;i&gt;Hint: Use {@code myProperty.fireSet()} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param condition The condition property which determines whether the foreground color should be set or not.
     * @param colorIfTrue The foreground color property which should be set for the UI component.
     * @param colorIfFalse The foreground color property which should be set for the UI component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I withForegroundIf( Val&lt;Boolean&gt; condition, Val&lt;Color&gt; colorIfTrue, Val&lt;Color&gt; colorIfFalse ) {
<span class="fc" id="L1876">        NullUtil.nullArgCheck(condition, &quot;condition&quot;, Val.class);</span>
<span class="fc" id="L1877">        NullUtil.nullArgCheck(colorIfTrue, &quot;colorIfTrue&quot;, Val.class);</span>
<span class="fc" id="L1878">        NullUtil.nullArgCheck(colorIfFalse, &quot;colorIfFalse&quot;, Val.class);</span>
<span class="fc" id="L1879">        NullUtil.nullPropertyCheck(condition, &quot;condition&quot;, &quot;Null is not allowed to model the usage of the provided foreground color!&quot;);</span>
<span class="fc" id="L1880">        NullUtil.nullPropertyCheck(colorIfTrue, &quot;colorIfTrue&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L1881">        NullUtil.nullPropertyCheck(colorIfFalse, &quot;colorIfFalse&quot;, &quot;Null is not allowed to model the the provided foreground color! Please use the default color of this component instead.&quot;);</span>
<span class="fc" id="L1882">        _onShow( condition, v -&gt; _updateForeground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="fc" id="L1883">        _onShow( colorIfTrue, v -&gt; _updateForeground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="fc" id="L1884">        _onShow( colorIfFalse, v -&gt; _updateForeground( condition, colorIfTrue, Var.of(colorIfFalse.get()) ) );</span>
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">        return this.withForeground( condition.get() ? colorIfTrue.get() : colorIfFalse.get() );</span>
    }

    private void _updateForeground(
        Val&lt;Boolean&gt; condition,
        Val&lt;Color&gt; color,
        Val&lt;Color&gt; baseColor
    ) {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        if ( condition.get() )</span>
<span class="fc" id="L1894">            getComponent().setForeground(color.get());</span>
        else
<span class="fc" id="L1896">            getComponent().setForeground(baseColor.get());</span>
<span class="fc" id="L1897">    }</span>

    private void _updateBackground(
            Val&lt;Boolean&gt; condition,
            Val&lt;Color&gt; color,
            Val&lt;Color&gt; baseColor
    ) {
<span class="fc bfc" id="L1904" title="All 2 branches covered.">        if ( condition.get() )</span>
<span class="fc" id="L1905">            getComponent().setBackground(color.get());</span>
        else
<span class="fc" id="L1907">            getComponent().setBackground(baseColor.get());</span>
<span class="fc" id="L1908">    }</span>

    /**
     *  Set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The minimum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Dimension size ) {
<span class="fc" id="L1917">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L1918">        getComponent().setMinimumSize(UI.scale(size));</span>
<span class="fc" id="L1919">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} (Dimension)} on the underlying component. &lt;br&gt;
     *  This is a convenience method, which would
     *  be equivalent to:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click Me&quot;)
     *    .peek( button -&gt; {
     *      size.onSetItem(JButton::setMinimumSize);
     *      button.setMinimumSize(size.get());
     *    });
     *  }&lt;/pre&gt;
     *
     * @param size The minimum {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L1940">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L1941">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the minimum size of this component!&quot;);</span>
<span class="fc" id="L1942">        _onShow( size, v -&gt; {</span>
<span class="fc" id="L1943">            C comp = getComponent();</span>
<span class="fc" id="L1944">            comp.setMinimumSize(UI.scale(v));</span>
<span class="fc" id="L1945">            _revalidate(comp);</span>
<span class="fc" id="L1946">        });</span>
<span class="fc" id="L1947">        return this.withMinSize( size.orElseThrow() );</span>
    }

    /**
     *  Set the minimum width and heigh ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( int width, int height ) {
<span class="fc" id="L1958">        getComponent().setMinimumSize(new Dimension(UI.scale(width), UI.scale(height)));</span>
<span class="fc" id="L1959">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the minimum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The minimum width of the component.
     * @param height The minimum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L1971">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L1972">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L1973">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L1974">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L1975">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L1976">            C comp = getComponent();</span>
<span class="fc" id="L1977">            comp.setMinimumSize(new Dimension(UI.scale(w), getComponent().getMinimumSize().height));</span>
<span class="fc" id="L1978">            _revalidate(comp);</span>
<span class="fc" id="L1979">        });</span>
<span class="fc" id="L1980">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L1981">            C comp = getComponent();</span>
<span class="fc" id="L1982">            comp.setMinimumSize(new Dimension(getComponent().getMinimumSize().width, UI.scale(h)));</span>
<span class="fc" id="L1983">            _revalidate(comp);</span>
<span class="fc" id="L1984">        });</span>
<span class="fc" id="L1985">        return this.withMinSize( width.orElseThrow(), height.orElseThrow() );</span>
    }

    /**
     *  Use this to only set the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( int width ) {
<span class="fc" id="L1995">        getComponent().setMinimumSize(new Dimension(UI.scale(width), getComponent().getMinimumSize().height));</span>
<span class="fc" id="L1996">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the minimum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The minimum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2006">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2007">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the minimum width of this component!&quot;);</span>
<span class="fc" id="L2008">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2009">            C comp = getComponent();</span>
<span class="fc" id="L2010">            comp.setMinimumSize(new Dimension(UI.scale(w), getComponent().getMinimumSize().height));</span>
<span class="fc" id="L2011">            _revalidate(comp); // Swing is not smart enough to do this automatically</span>
<span class="fc" id="L2012">        });</span>
<span class="fc" id="L2013">        return this.withMinWidth( width.orElseThrow() );</span>
    }


    /**
     *  Use this to only set the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( int height ) {
<span class="fc" id="L2024">        getComponent().setMinimumSize(new Dimension(getComponent().getMinimumSize().width, UI.scale(height)));</span>
<span class="fc" id="L2025">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the minimum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMinimumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The minimum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMinHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2035">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2036">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the minimum height of this component!&quot;);</span>
<span class="fc" id="L2037">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2038">            C comp = getComponent();</span>
<span class="fc" id="L2039">            comp.setMinimumSize( new Dimension(getComponent().getMinimumSize().width, UI.scale(h)) );</span>
<span class="fc" id="L2040">            _revalidate(comp); // The revalidate is necessary to make the change visible.</span>
<span class="fc" id="L2041">        });</span>
<span class="fc" id="L2042">        return this.withMinHeight( height.orElseThrow() );</span>
    }

    /**
     *  Set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Dimension size ) {
<span class="fc" id="L2052">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2053">        getComponent().setMaximumSize(UI.scale(size));</span>
<span class="fc" id="L2054">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The maximum {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2065">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2066">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the maximum size of this component!&quot;);</span>
<span class="fc" id="L2067">        _onShow( size, v -&gt; {</span>
<span class="fc" id="L2068">            C comp = getComponent();</span>
<span class="fc" id="L2069">            comp.setMaximumSize( UI.scale(v) );</span>
<span class="fc" id="L2070">            _revalidate(comp); // For some reason this is needed to make the change visible.</span>
<span class="fc" id="L2071">        });</span>
<span class="fc" id="L2072">        return this.withMaxSize( size.orElseThrow() );</span>
    }

    /**
     *  Set the maximum width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( int width, int height ) {
<span class="fc" id="L2083">        getComponent().setMaximumSize(new Dimension(UI.scale(width), UI.scale(height)));</span>
<span class="fc" id="L2084">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the maximum {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The maximum width of the component.
     * @param height The maximum height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2096">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2097">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2098">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2099">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2100">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2101">            C comp = getComponent();</span>
<span class="fc" id="L2102">            comp.setMaximumSize(new Dimension(UI.scale(w), getComponent().getMaximumSize().height));</span>
<span class="fc" id="L2103">            _revalidate(comp); // Swing is not smart enough to do this automatically :(</span>
<span class="fc" id="L2104">        });</span>
<span class="fc" id="L2105">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2106">            C comp = getComponent();</span>
<span class="fc" id="L2107">            comp.setMaximumSize(new Dimension(getComponent().getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2108">            _revalidate(comp); // Still not smart enough to do this automatically :(</span>
<span class="fc" id="L2109">        });</span>
<span class="fc" id="L2110">        return this.withMaxSize( width.orElseThrow(), height.orElseThrow() );</span>
    }

    /**
     *  Use this to only set the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( int width ) {
<span class="fc" id="L2120">        getComponent().setMaximumSize(new Dimension(UI.scale(width), getComponent().getMaximumSize().height));</span>
<span class="fc" id="L2121">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the maximum width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The maximum width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2131">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2132">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the maximum width of this component!&quot;);</span>
<span class="fc" id="L2133">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2134">            C comp = getComponent();</span>
<span class="fc" id="L2135">            comp.setMaximumSize(new Dimension(UI.scale(w), getComponent().getMaximumSize().height));</span>
<span class="fc" id="L2136">            _revalidate(comp); // When the size changes, the layout manager needs to be informed.</span>
<span class="fc" id="L2137">        });</span>
<span class="fc" id="L2138">        return this.withMaxWidth( width.orElseThrow() );</span>
    }

    /**
     *  Use this to only set the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( int height ) {
<span class="fc" id="L2148">        getComponent().setMaximumSize(new Dimension(getComponent().getMaximumSize().width, UI.scale(height)));</span>
<span class="fc" id="L2149">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the maximum height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setMaximumSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The maximum height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withMaxHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2159">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2160">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the maximum height of this component!&quot;);</span>
<span class="fc" id="L2161">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2162">            C comp = getComponent();</span>
<span class="fc" id="L2163">            comp.setMaximumSize(new Dimension(getComponent().getMaximumSize().width, UI.scale(h)));</span>
<span class="fc" id="L2164">            _revalidate(comp); // The revalidate is necessary to make the change visible, this makes sure the layout is recalculated.</span>
<span class="fc" id="L2165">        });</span>
<span class="fc" id="L2166">        return this.withMaxHeight( height.orElseThrow() );</span>
    }

    /**
     *  Set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Dimension size ) {
<span class="fc" id="L2176">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2177">        getComponent().setPreferredSize(UI.scale(size));</span>
<span class="fc" id="L2178">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The preferred {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2189">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2190">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the preferred size of this component!&quot;);</span>
<span class="fc" id="L2191">        _onShow( size, v -&gt; {</span>
<span class="fc" id="L2192">            C comp = getComponent();</span>
<span class="fc" id="L2193">            comp.setPreferredSize(UI.scale(v));</span>
<span class="fc" id="L2194">            _revalidate(comp);</span>
<span class="fc" id="L2195">        });</span>
<span class="fc" id="L2196">        return this.withPrefSize( size.orElseNull() );</span>
    }

    /**
     *  Set the preferred width and height ({@link Dimension}) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( int width, int height ) {
<span class="fc" id="L2207">        getComponent().setPreferredSize(new Dimension(UI.scale(width), UI.scale(height)));</span>
<span class="fc" id="L2208">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the preferred {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The preferred width of the component.
     * @param height The preferred height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefSize( Val&lt;Integer&gt; width, Val&lt;Integer&gt; height ) {
<span class="fc" id="L2220">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2221">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2222">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L2223">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L2224">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2225">            C comp = getComponent();</span>
<span class="fc" id="L2226">            comp.setPreferredSize(new Dimension(UI.scale(w), getComponent().getPreferredSize().height));</span>
<span class="fc" id="L2227">            _revalidate(comp); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L2228">        });</span>
<span class="fc" id="L2229">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2230">            C comp = getComponent();</span>
<span class="fc" id="L2231">            comp.setPreferredSize(new Dimension(getComponent().getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L2232">            _revalidate(comp); // We need to revalidate the component to make sure the layout manager is aware of the new size.</span>
<span class="fc" id="L2233">        });</span>
<span class="fc" id="L2234">        return this.withPrefSize( width.orElseThrow(), height.orElseThrow() );</span>
    }

    /**
     *  Use this to only set the preferred width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( int width ) {
<span class="fc" id="L2244">        getComponent().setPreferredSize(new Dimension(UI.scale(width), getComponent().getPreferredSize().height));</span>
<span class="fc" id="L2245">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the preferred width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param width The preferred width which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2255">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2256">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the preferred width of this component!&quot;);</span>
<span class="fc" id="L2257">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2258">            C comp = getComponent();</span>
<span class="fc" id="L2259">            comp.setPreferredSize(new Dimension(UI.scale(w), getComponent().getPreferredSize().height));</span>
<span class="fc" id="L2260">            _revalidate(comp); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L2261">        });</span>
<span class="fc" id="L2262">        return this.withPrefWidth( width.orElseThrow() );</span>
    }

    /**
     *  Use this to only set the preferred height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight( int height ) {
<span class="fc" id="L2272">        getComponent().setPreferredSize(new Dimension(getComponent().getPreferredSize().width, UI.scale(height)));</span>
<span class="fc" id="L2273">        return _this();</span>
    }

    /**
     *  Use this to dynamically set only the preferred height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setPreferredSize(Dimension)} on the underlying component for you. &lt;br&gt;
     * @param height The preferred height which should be set for the underlying component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withPrefHeight(Val&lt;Integer&gt; height ) {
<span class="fc" id="L2283">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2284">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the preferred height of this component!&quot;);</span>
<span class="fc" id="L2285">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2286">            C comp = getComponent();</span>
<span class="fc" id="L2287">            comp.setPreferredSize(new Dimension(getComponent().getPreferredSize().width, UI.scale(h)));</span>
<span class="fc" id="L2288">            _revalidate(comp); // We need to revalidate the component to make sure the new preferred size is applied.</span>
<span class="fc" id="L2289">        });</span>
<span class="fc" id="L2290">        return this.withPrefHeight( height.orElseThrow() );</span>
    }

    /**
     *  Set the current {@link Dimension})/size (width and height) of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Dimension size ) {
<span class="fc" id="L2300">        NullUtil.nullArgCheck(size, &quot;size&quot;, Dimension.class);</span>
<span class="fc" id="L2301">        getComponent().setSize( UI.scale(size) );</span>
<span class="fc" id="L2302">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current {@link Dimension} of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The current {@link Dimension} of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( Val&lt;Dimension&gt; size ) {
<span class="fc" id="L2313">        NullUtil.nullArgCheck(size, &quot;size&quot;, Val.class);</span>
<span class="fc" id="L2314">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not allowed to model the size of this component!&quot;);</span>
<span class="fc" id="L2315">        _onShow( size, v -&gt; {</span>
<span class="fc" id="L2316">            C comp = getComponent();</span>
<span class="fc" id="L2317">            comp.setSize( UI.scale(v) );</span>
<span class="fc" id="L2318">            _revalidate(comp); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2319">        });</span>
<span class="fc" id="L2320">        return this.withSize( size.orElseNull() );</span>
    }

    /**
     *  Set the current width and height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withSize( int width, int height ) {
<span class="fc" id="L2331">        return this.withSize( new Dimension(width, height) );</span>
    }

    /**
     *  Set the current width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( int width ) {
<span class="fc" id="L2341">        getComponent().setSize(new Dimension(UI.scale(width), getComponent().getSize().height));</span>
<span class="fc" id="L2342">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current width of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The current width of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withWidth( Val&lt;Integer&gt; width ) {
<span class="fc" id="L2353">        NullUtil.nullArgCheck(width, &quot;width&quot;, Val.class);</span>
<span class="fc" id="L2354">        NullUtil.nullPropertyCheck(width, &quot;width&quot;, &quot;Null is not allowed to model the width of this component!&quot;);</span>
<span class="fc" id="L2355">        _onShow( width, w -&gt; {</span>
<span class="fc" id="L2356">            C comp = getComponent();</span>
<span class="fc" id="L2357">            comp.setSize(new Dimension(UI.scale(w), getComponent().getSize().height));</span>
<span class="fc" id="L2358">            _revalidate(comp); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2359">        });</span>
<span class="fc" id="L2360">        return this.withWidth( width.orElseThrow() );</span>
    }

    /**
     *  Set the current height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( int height ) {
<span class="fc" id="L2370">        getComponent().setSize(new Dimension(getComponent().getSize().width, UI.scale(height)));</span>
<span class="fc" id="L2371">        return _this();</span>
    }

    /**
     *  Bind to a {@link Val} object to
     *  dynamically set the current height of this {@link JComponent}. &lt;br&gt;
     *  This calls {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The current height of the component wrapped by a {@link Val}.
     * @return This very builder to allow for method chaining.
     */
    public final I withHeight( Val&lt;Integer&gt; height ) {
<span class="fc" id="L2382">        NullUtil.nullArgCheck(height, &quot;height&quot;, Val.class);</span>
<span class="fc" id="L2383">        NullUtil.nullPropertyCheck(height, &quot;height&quot;, &quot;Null is not allowed to model the height of this component!&quot;);</span>
<span class="fc" id="L2384">        _onShow( height, h -&gt; {</span>
<span class="fc" id="L2385">            C comp = getComponent();</span>
<span class="fc" id="L2386">            comp.setSize(new Dimension(getComponent().getSize().width, UI.scale(h)));</span>
<span class="fc" id="L2387">            _revalidate(comp); // We need to revalidate the component to make sure the new size is applied.</span>
<span class="fc" id="L2388">        });</span>
<span class="fc" id="L2389">        return this.withHeight( height.orElseThrow() );</span>
    }

    private static void _revalidate( Component comp ) {
<span class="fc" id="L2393">        comp.revalidate();</span>
<span class="pc bpc" id="L2394" title="1 of 2 branches missed.">        if ( comp instanceof JScrollPane )</span>
<span class="nc" id="L2395">            Optional.ofNullable(comp.getParent())</span>
<span class="nc" id="L2396">                    .ifPresent(Component::revalidate); // For some reason, JScrollPane does not revalidate its parent when its preferred size changes.</span>
<span class="fc" id="L2397">    }</span>

    /**
     *  Calls the provided action event handler when the mouse gets pressed and then released.
     *  This delegates to a {@link MouseListener} based mouse click event listener registered in the UI component.
     *  &lt;br&gt;&lt;br&gt;
     *  Note that a click is defined as the combination of the &lt;b&gt;mouse being pressed
     *  and then released on the same position as it was pressed.&lt;/b&gt;
     *  If the mouse moves between the press and the release events, then the
     *  event is considered a drag event instead of a mouse click! (see {@link #onMouseDrag(Action)})
     *
     * @param onClick The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseClick( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onClick ) {
<span class="fc" id="L2412">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L2413">        C component = getComponent();</span>
<span class="fc" id="L2414">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mouseClicked(MouseEvent e) { 
<span class="pc" id="L2416">                _doApp(() -&gt; onClick.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="fc" id="L2417">            }</span>
        });
<span class="fc" id="L2419">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse release events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onRelease The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseRelease( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onRelease ) {
<span class="nc" id="L2432">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="nc" id="L2433">        C component = getComponent();</span>
<span class="nc" id="L2434">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L2436">                _doApp(() -&gt; onRelease.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2437">            }</span>
        });
<span class="nc" id="L2439">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse press events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onPress The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMousePress( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onPress ) {
<span class="nc" id="L2452">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="nc" id="L2453">        C component = getComponent();</span>
<span class="nc" id="L2454">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L2456">                _doApp(() -&gt; onPress.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2457">            }</span>
        });
<span class="nc" id="L2459">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse enter events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onEnter The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseEnter( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onEnter ) {
<span class="fc" id="L2472">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L2473">        C component = getComponent();</span>
<span class="fc" id="L2474">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mouseEntered(MouseEvent e) {
<span class="nc" id="L2476">                _doApp(() -&gt; onEnter.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2477">            }</span>
        });
<span class="fc" id="L2479">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse exit events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onExit The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseExit( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onExit ) {
<span class="fc" id="L2492">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L2493">        C component = getComponent();</span>
<span class="fc" id="L2494">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mouseExited(MouseEvent e) {
<span class="nc" id="L2496">                _doApp(() -&gt; onExit.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2497">            }</span>
        });
<span class="fc" id="L2499">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse drag events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *  The {@link ComponentDragEventDelegate} received by the {@link Action} lambda
     *  exposes both component and drag event
     *  context information, including a list of all the {@link MouseEvent}s involved
     *  in one continuous dragging motion (see {@link ComponentDragEventDelegate#dragEvents()} for more information).
     *
     * @param onDrag The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseDrag( Action&lt;ComponentDragEventDelegate&lt;C&gt;&gt; onDrag ) {
<span class="nc" id="L2516">        NullUtil.nullArgCheck(onDrag, &quot;onDrag&quot;, Action.class);</span>
<span class="nc" id="L2517">        java.util.List&lt;MouseEvent&gt; dragEventHistory = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2518">        C component = getComponent();</span>
<span class="nc" id="L2519">        MouseAdapter listener = new MouseAdapter() {</span>
            @Override public void mousePressed(MouseEvent e) {
<span class="nc" id="L2521">                dragEventHistory.clear();</span>
<span class="nc" id="L2522">                dragEventHistory.add(e);</span>
<span class="nc" id="L2523">            }</span>
            @Override public void mouseReleased(MouseEvent e) {
<span class="nc" id="L2525">                dragEventHistory.clear();</span>
<span class="nc" id="L2526">            }</span>
            @Override public void mouseDragged(MouseEvent e) {
<span class="nc" id="L2528">                dragEventHistory.add(e);</span>
<span class="nc" id="L2529">                _doApp(() -&gt; onDrag.accept(new ComponentDragEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood(), dragEventHistory)));</span>
<span class="nc" id="L2530">            }</span>
        };
<span class="nc" id="L2532">        component.addMouseListener(listener);</span>
<span class="nc" id="L2533">        component.addMouseMotionListener(listener);</span>
<span class="nc" id="L2534">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse move events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onMove The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseMove( Action&lt;ComponentMouseEventDelegate&lt;C&gt;&gt; onMove ) {
<span class="fc" id="L2547">        NullUtil.nullArgCheck(onMove, &quot;onMove&quot;, Action.class);</span>
<span class="fc" id="L2548">        C component = getComponent();</span>
<span class="fc" id="L2549">        component.addMouseListener(new MouseAdapter() {</span>
            @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L2551">                _doApp(() -&gt; onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2552">            }</span>
        });
<span class="fc" id="L2554">        component.addMouseMotionListener(new MouseMotionAdapter() {</span>
            @Override public void mouseMoved(MouseEvent e) {
<span class="nc" id="L2556">                _doApp(() -&gt; onMove.accept(new ComponentMouseEventDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2557">            }</span>
        });
<span class="fc" id="L2559">        return _this();</span>
    }

    /**
     *  Use this to register and catch generic {@link MouseListener} based mouse wheel events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param onWheel The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelMove( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheel ) {
<span class="nc" id="L2572">        NullUtil.nullArgCheck(onWheel, &quot;onWheel&quot;, Action.class);</span>
<span class="nc" id="L2573">        C component = getComponent();</span>
<span class="nc" id="L2574">        component.addMouseWheelListener(new MouseWheelListener() {</span>
            @Override public void mouseWheelMoved(MouseWheelEvent e) {
<span class="nc" id="L2576">                _doApp(() -&gt; onWheel.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2577">            }</span>
        });
<span class="nc" id="L2579">        return _this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel up movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelUp The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelUp( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelUp ) {
<span class="nc" id="L2591">        NullUtil.nullArgCheck(onWheelUp, &quot;onWheelUp&quot;, Action.class);</span>
<span class="nc" id="L2592">        C component = getComponent();</span>
<span class="nc" id="L2593">        component.addMouseWheelListener(new MouseWheelListener() {</span>
            @Override public void mouseWheelMoved(MouseWheelEvent e) {
<span class="nc bnc" id="L2595" title="All 2 branches missed.">                if( e.getWheelRotation() &lt; 0 ) {</span>
<span class="nc" id="L2596">                    _doApp(() -&gt; onWheelUp.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
                }
<span class="nc" id="L2598">            }</span>
        });
<span class="nc" id="L2600">        return _this();</span>
    }

    /**
     *  Use this to register and catch mouse wheel down movement events on this UI component.
     *  This method adds the provided consumer lambda to
     *  an an{@link MouseListener} instance to the component.
     *  &lt;br&gt;&lt;br&gt;
     * @param onWheelDown The lambda instance which will be passed to the button component as {@link MouseListener}.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMouseWheelDown( Action&lt;ComponentDelegate&lt;C, MouseWheelEvent&gt;&gt; onWheelDown ) {
<span class="nc" id="L2612">        NullUtil.nullArgCheck(onWheelDown, &quot;onWheelDown&quot;, Action.class);</span>
<span class="nc" id="L2613">        C component = getComponent();</span>
<span class="nc" id="L2614">        component.addMouseWheelListener( e -&gt; {</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">                if ( e.getWheelRotation() &gt; 0 )</span>
<span class="nc" id="L2616">                    _doApp(() -&gt; onWheelDown.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2617">            });</span>
<span class="nc" id="L2618">        return _this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component's size changes.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *
     * @param onResize The resize action which will be called when the underlying component changes size.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onResize( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onResize ) {
<span class="fc" id="L2629">        NullUtil.nullArgCheck(onResize, &quot;onResize&quot;, Action.class);</span>
<span class="fc" id="L2630">        C component = getComponent();</span>
<span class="fc" id="L2631">        component.addComponentListener(new ComponentAdapter() {</span>
            @Override public void componentResized(ComponentEvent e) {
<span class="pc" id="L2633">                _doApp(()-&gt;onResize.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="fc" id="L2634">            }</span>
        });
<span class="fc" id="L2636">        return _this();</span>
    }

    /**
     *  The provided lambda will be invoked when the component was moved.
     *  This will internally translate to a {@link ComponentListener} implementation.
     *
     * @param onMoved The action lambda which will be executed once the component was moved / its position canged.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onMoved( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onMoved ) {
<span class="fc" id="L2647">        NullUtil.nullArgCheck(onMoved, &quot;onMoved&quot;, Action.class);</span>
<span class="fc" id="L2648">        C component = getComponent();</span>
<span class="fc" id="L2649">        component.addComponentListener(new ComponentAdapter() {</span>
            @Override public void componentMoved(ComponentEvent e) {
<span class="nc" id="L2651">                _doApp(()-&gt;onMoved.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2652">            }</span>
        });
<span class="fc" id="L2654">        return _this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link ComponentListener}
     *  to the component, to receive those component events where the wrapped component becomes visible.
     *
     * @param onShown The {@link Action} which gets invoked when the component has been made visible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onShown( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onShown ) {
<span class="fc" id="L2665">        NullUtil.nullArgCheck(onShown, &quot;onShown&quot;, Action.class);</span>
<span class="fc" id="L2666">        C component = getComponent();</span>
<span class="fc" id="L2667">        component.addComponentListener(new ComponentAdapter() {</span>
            @Override public void componentShown(ComponentEvent e) {
<span class="pc" id="L2669">                _doApp(()-&gt;onShown.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="fc" id="L2670">            }</span>
        });
<span class="fc" id="L2672">        return _this();</span>
    }

    /**
     *  Adds the supplied {@link Action} wrapped in a {@link ComponentListener}
     *  to the component, to receive those component events where the wrapped component becomes invisible.
     *
     * @param onHidden The {@link Action} which gets invoked when the component has been made invisible.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onHidden( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onHidden ) {
<span class="fc" id="L2683">        NullUtil.nullArgCheck(onHidden, &quot;onHidden&quot;, Action.class);</span>
<span class="fc" id="L2684">        C component = getComponent();</span>
<span class="fc" id="L2685">        component.addComponentListener(new ComponentAdapter() {</span>
            @Override public void componentHidden(ComponentEvent e) {
<span class="nc" id="L2687">                _doApp(()-&gt;onHidden.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2688">            }</span>
        });
<span class="fc" id="L2690">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link FocusListener}
     * to the component, to receive those focus events where the wrapped component gains input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was gained on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusGained( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L2701">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L2702">        C component = getComponent();</span>
<span class="fc" id="L2703">        component.addFocusListener(new FocusAdapter() {</span>
            @Override public void focusGained(FocusEvent e) {
<span class="nc" id="L2705">                _doApp(()-&gt;onFocus.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2706">            }</span>
        });
<span class="fc" id="L2708">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a focus listener
     * to receive those focus events where the wrapped component loses input focus.
     *
     * @param onFocus The {@link Action} which should be executed once the input focus was lost on the wrapped component.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onFocusLost( Action&lt;ComponentDelegate&lt;C, ComponentEvent&gt;&gt; onFocus ) {
<span class="fc" id="L2719">        NullUtil.nullArgCheck(onFocus, &quot;onFocus&quot;, Action.class);</span>
<span class="fc" id="L2720">        C component = getComponent();</span>
<span class="fc" id="L2721">        component.addFocusListener(new FocusAdapter() {</span>
            @Override public void focusLost(FocusEvent e) {
<span class="nc" id="L2723">                _doApp(()-&gt;onFocus.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2724">            }</span>
        });
<span class="fc" id="L2726">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received a key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onKeyPressed( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L2737">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L2738">        C component = getComponent();</span>
<span class="fc" id="L2739">        component.addKeyListener(new KeyAdapter() {</span>
            @Override public void keyPressed(KeyEvent e) {
<span class="nc" id="L2741">                _doApp(()-&gt;onKeyPressed.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2742">            }</span>
        });
<span class="fc" id="L2744">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyPressed The {@link Action} which will be executed once the wrapped component received the targeted key press.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I onPressed( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyPressed ) {
<span class="fc" id="L2757">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L2758">        NullUtil.nullArgCheck(onKeyPressed, &quot;onKeyPressed&quot;, Action.class);</span>
<span class="fc" id="L2759">        C component = getComponent();</span>
<span class="fc" id="L2760">        component.addKeyListener(new KeyAdapter() {</span>
            @Override public void keyPressed( KeyEvent e ) {
<span class="nc bnc" id="L2762" title="All 2 branches missed.">                if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L2763">                    _doApp(()-&gt;onKeyPressed.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2764">            }</span>
        });
<span class="fc" id="L2766">        return _this();</span>
    }

                             /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received a key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPressed(Action)
     */
    public final I onKeyReleased( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L2778">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L2779">        C component = getComponent();</span>
<span class="fc" id="L2780">        component.addKeyListener(new KeyAdapter() {</span>
            @Override public void keyReleased(KeyEvent e) {
<span class="nc" id="L2782">                _doApp(()-&gt;onKeyReleased.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood()))); }</span>
        });
<span class="fc" id="L2784">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyReleased The {@link Action} which will be executed once the wrapped component received the targeted key release.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPressed(Action)
     * @see #onKeyReleased(Action)
     */
    public final I onReleased( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyReleased ) {
<span class="fc" id="L2799">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L2800">        NullUtil.nullArgCheck(onKeyReleased, &quot;onKeyReleased&quot;, Action.class);</span>
<span class="fc" id="L2801">        C component = getComponent();</span>
<span class="fc" id="L2802">        component.addKeyListener(new KeyAdapter() {</span>
            @Override public void keyReleased( KeyEvent e ) {
<span class="nc bnc" id="L2804" title="All 2 branches missed.">                if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L2805">                    _doApp(()-&gt;onKeyReleased.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2806">            }</span>
        });
<span class="fc" id="L2808">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener}
     * to the component, to receive key events triggered when the wrapped component receives keyboard input.
     * &lt;br&gt;&lt;br&gt;
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received a key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPressed(Action)
     * @see #onKeyReleased(Action)
     */
    public final I onKeyTyped( Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L2821">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L2822">        C component = getComponent();</span>
<span class="fc" id="L2823">        _onKeyTyped( e -&gt;</span>
<span class="nc" id="L2824">            _doApp(()-&gt;onKeyTyped.accept(new ComponentDelegate&lt;&gt;(component, e, this::getSiblinghood)))</span>
        );
<span class="fc" id="L2826">        return _this();</span>
    }

    /**
     * Adds the supplied {@link Action} wrapped in a {@link KeyListener} to the component,
     * to receive key events triggered when the wrapped component receives a particular
     * keyboard input matching the provided {@link swingtree.input.Keyboard.Key}.
     * &lt;br&gt;&lt;br&gt;
     * @param key The {@link swingtree.input.Keyboard.Key} which should be matched to the key event.
     * @param onKeyTyped The {@link Action} which will be executed once the wrapped component received the targeted key typed.
     * @return This very instance, which enables builder-style method chaining.
     * @see #onKeyPressed(Action)
     * @see #onKeyReleased(Action)
     * @see #onKeyTyped(Action)
     */
    public final I onTyped( Keyboard.Key key, Action&lt;ComponentDelegate&lt;C, KeyEvent&gt;&gt; onKeyTyped ) {
<span class="fc" id="L2842">        NullUtil.nullArgCheck(key, &quot;key&quot;, Keyboard.Key.class);</span>
<span class="fc" id="L2843">        NullUtil.nullArgCheck(onKeyTyped, &quot;onKeyTyped&quot;, Action.class);</span>
<span class="fc" id="L2844">        C component = getComponent();</span>
<span class="fc" id="L2845">        _onKeyTyped( e -&gt; {</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">            if ( e.getKeyCode() == key.code )</span>
<span class="nc" id="L2847">                _doApp(()-&gt;onKeyTyped.accept(new ComponentDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));</span>
<span class="nc" id="L2848">        });</span>
<span class="fc" id="L2849">        return _this();</span>
    }

    protected void _onKeyTyped( Consumer&lt;KeyEvent&gt; action ) {
<span class="fc" id="L2853">        getComponent().addKeyListener(new KeyAdapter() {</span>
            @Override public void keyTyped(KeyEvent e) {
<span class="nc" id="L2855">                action.accept(e);</span>
<span class="nc" id="L2856">            }</span>
        });
<span class="fc" id="L2858">    }</span>

    /**
     *  Use this to register periodic update actions which should be called
     *  based on the provided {@code delay}! &lt;br&gt;
     *  The following example produces a label which will display the current date.
     *  &lt;pre&gt;{@code
     *      UI.label(&quot;&quot;)
     *          .doUpdates( 100, it -&gt; it.getComponent().setText(new Date().toString()) )
     *  }&lt;/pre&gt;
     *
     * @param delay The delay in milliseconds between calling the provided {@link Action}.
     * @param onUpdate The {@link Action} which should be called periodically.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I doUpdates( int delay, Action&lt;ComponentDelegate&lt;C, ActionEvent&gt;&gt; onUpdate ) {
<span class="fc" id="L2874">        NullUtil.nullArgCheck(onUpdate, &quot;onUpdate&quot;, Action.class);</span>
<span class="fc" id="L2875">        Timer timer = new Timer(delay, e -&gt; onUpdate.accept(new ComponentDelegate&lt;&gt;(getComponent(), e, this::getSiblinghood)));</span>
        {
<span class="fc" id="L2877">            java.util.List&lt;Timer&gt; timers = (java.util.List&lt;Timer&gt;) getComponent().getClientProperty(_TIMERS_KEY);</span>
<span class="pc bpc" id="L2878" title="1 of 2 branches missed.">            if ( timers == null ) {</span>
<span class="fc" id="L2879">                timers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2880">                getComponent().putClientProperty(_TIMERS_KEY, timers);</span>
            }
<span class="fc" id="L2882">            timers.add(timer);</span>
        }
<span class="fc" id="L2884">        timer.start();</span>
<span class="fc" id="L2885">        return _this();</span>
    }

    @Override
    protected void _add( JComponent component, Object conf ) {
<span class="fc" id="L2890">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc bfc" id="L2891" title="All 2 branches covered.">        if ( conf == null )</span>
<span class="fc" id="L2892">            getComponent().add(component);</span>
        else
<span class="fc" id="L2894">            getComponent().add(component, conf);</span>
<span class="fc" id="L2895">    }</span>

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument is expected to contain layout information for the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( String attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L2911">        return this.add(attr, new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder nodes into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the layout manager of the wrapped {@link JComponent},
     *  through the {@link JComponent#add(Component, Object)} method.
     *  By default, the {@link MigLayout} is used.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The mig-layout attribute.
     * @param builder A builder for another {@link JComponent} instance which ought to be added to the wrapped component type.
     * @param &lt;T&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T extends JComponent&gt; I add( CompAttr attr, UIForAnySwing&lt;?, T&gt; builder ) {
<span class="fc" id="L2928">        return this.add(attr.toString(), new UIForAnySwing[]{builder});</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s 
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be passed to the {@link LayoutManager} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent} 
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add(String attr, B... builders ) {
<span class="fc" id="L2947">        LayoutManager layout = getComponent().getLayout();</span>
<span class="fc bfc" id="L2948" title="All 4 branches covered.">        if ( _isBorderLayout(attr) &amp;&amp; !(layout instanceof BorderLayout) ) {</span>
<span class="pc bpc" id="L2949" title="1 of 2 branches missed.">            if ( layout instanceof MigLayout )</span>
<span class="fc" id="L2950">                log.warn(&quot;Layout ambiguity detected! Border layout constraint cannot be added to 'MigLayout'.&quot;);</span>
<span class="fc" id="L2951">            getComponent().setLayout(new BorderLayout()); // The UI Maker tries to fill in the blanks!</span>
        }
<span class="fc bfc" id="L2953" title="All 2 branches covered.">        for ( UIForAnySwing&lt;?, ?&gt; b : builders ) _doAdd(b, attr);</span>
<span class="fc" id="L2954">        return _this();</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the wrapped {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument will be passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( CompAttr attr, B... builders ) {
<span class="fc" id="L2973">        return this.add(attr.toString(), builders);</span>
    }

    /**
     *  Use this to nest builder types into this builder to effectively plug the {@link JComponent}s
     *  wrapped by the provided builders
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents placement constraints for the provided components which will
     *  be passed to the {@link MigLayout} of the underlying {@link JComponent}.
     *  through the {@link JComponent#add(Component, Object)} method.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional mig-layout information which should be passed to the UI tree.
     * @param builders An array of builders for a corresponding number of {@link JComponent}
     *                  type which ought to be added to the wrapped component type of this builder.
     * @param &lt;B&gt; The builder type parameter, a subtype of {@link UIForAnySwing}.
     * @return This very instance, which enables builder-style method chaining.
     */
    @SafeVarargs
    public final &lt;B extends UIForAnySwing&lt;?, ?&gt;&gt; I add( CC attr, B... builders ) {
<span class="nc" id="L2993">        LayoutManager layout = getComponent().getLayout();</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">        if ( !(layout instanceof MigLayout) )</span>
<span class="nc" id="L2995">            log.warn(&quot;Layout ambiguity detected! Mig layout constraint cannot be added to '{}'.&quot;, layout.getClass().getSimpleName());</span>

<span class="nc bnc" id="L2997" title="All 2 branches missed.">        for ( UIForAnySwing&lt;?, ?&gt; b : builders ) _doAdd( b, attr );</span>
<span class="nc" id="L2998">        return _this();</span>
    }

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first argument represents layout attributes/constraints which will
     *  be applied to the subsequently provided {@link JComponent} types.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The additional layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( String attr, E... components ) {
<span class="fc" id="L3015">        NullUtil.nullArgCheck(attr, &quot;conf&quot;, Object.class);</span>
<span class="fc" id="L3016">        NullUtil.nullArgCheck(components, &quot;components&quot;, Object[].class);</span>
<span class="fc bfc" id="L3017" title="All 2 branches covered.">        for( E component : components ) {</span>
<span class="fc" id="L3018">            NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L3019">            this.add(attr, UI.of(component));</span>
        }
<span class="fc" id="L3021">        return _this();</span>
    }

    /**
     *  Use this to nest {@link JComponent} types into this builder to effectively plug the provided {@link JComponent}s
     *  into the {@link JComponent} type wrapped by this builder instance.
     *  The first 2 arguments will be joined by a comma and passed to the {@link LayoutManager}
     *  of the underlying {@link JComponent} to serve as layout constraints.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param attr The first layout information which should be passed to the UI tree.
     * @param components A {@link JComponent}s array which ought to be added to the wrapped component type.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;E&gt; The type of the {@link JComponent} which is wrapped by the provided builder.
     */
    @SafeVarargs
    public final &lt;E extends JComponent&gt; I add( CompAttr attr, E... components ) {
<span class="nc" id="L3038">        return this.add(attr.toString(), components);</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L3055">        NullUtil.nullArgCheck(viewable, &quot;viewable&quot;, Val.class);</span>
<span class="fc" id="L3056">        _addViewableProp(viewable, null, viewSupplier);</span>
<span class="fc" id="L3057">        return _this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L3075">        NullUtil.nullArgCheck(viewables, &quot;viewables&quot;, Vals.class);</span>
<span class="fc" id="L3076">        _addViewableProps( viewables, null, viewSupplier);</span>
<span class="fc" id="L3077">        return _this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( String attr, Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L3095">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="fc" id="L3096">        NullUtil.nullArgCheck(viewable, &quot;viewable&quot;, Val.class);</span>
<span class="fc" id="L3097">        _addViewableProp(viewable, attr, viewSupplier);</span>
<span class="fc" id="L3098">        return _this();</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( String attr, Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="nc" id="L3117">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Object.class);</span>
<span class="nc" id="L3118">        NullUtil.nullArgCheck(viewables, &quot;viewables&quot;, Vals.class);</span>
<span class="nc" id="L3119">        _addViewableProps( viewables, attr, viewSupplier);</span>
<span class="nc" id="L3120">        return _this();</span>
    }

    /**
     *  This allows you to dynamically generate a view for the item of a property (usually a property
     *  holding a sub-view model) and automatically regenerate the view when the property changes.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated view.
     * @param viewable A {@link sprouts.Val} property holding null or any other type of value,
     *                 preferably a view model instance.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for the value held by the property.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the value held by the {@link Val} property.
     */
    public final &lt;M&gt; I add( CompAttr attr, Val&lt;M&gt; viewable, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L3138">        return this.add(attr.toString(), viewable, viewSupplier);</span>
    }

    /**
     *  This allows you to dynamically generate views for the items in a {@link Vals} property list
     *  and automatically regenerate the view when any of the items change.
     *  The type of item can be anything, but it is usually a view model instance.
     *  The {@link ViewSupplier} lambda passed to this method will receive the value of the property
     *  and is then expected to return a {@link JComponent} instance which will be added to the
     *  wrapped {@link JComponent} type of this builder.
     *
     * @param attr The layout information which should be used as layout constraints for the generated views.
     * @param viewables A {@link sprouts.Vals} list of items of any type but preferably view model instances.
     * @param viewSupplier A {@link ViewSupplier} instance which will be used to generate the view for each item in the list.
     *               The views will be added to the component wrapped by this builder instance.
     * @return This very instance, which enables builder-style method chaining.
     * @param &lt;M&gt; The type of the items in the {@link Vals} list.
     */
    public final &lt;M&gt; I add( CompAttr attr, Vals&lt;M&gt; viewables, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="nc" id="L3157">        return this.add(attr.toString(), viewables, viewSupplier);</span>
    }

    protected &lt;M&gt; void _addViewableProps( Vals&lt;M&gt; viewables, String attr, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L3161">        _onShow( viewables, delegate -&gt; {</span>
            // we simply redo all the components.
<span class="pc bpc" id="L3163" title="3 of 6 branches missed.">            switch ( delegate.changeType() ) {</span>
<span class="nc" id="L3164">                case SET: _updateComponentAt(delegate.index(), delegate.newValue().get(), viewSupplier, attr); break;</span>
                case ADD:
<span class="pc bpc" id="L3166" title="3 of 4 branches missed.">                    if ( delegate.index() &lt; 0 &amp;&amp; delegate.newValue().isEmpty() ) {</span>
                        // This is basically a add all operation, so we clear the components first.
<span class="nc" id="L3168">                        _clearComponents();</span>
                        // and then we add all the components.
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                        for ( int i = 0; i &lt; delegate.vals().size(); i++ )</span>
<span class="nc" id="L3171">                            _addComponentAt( i, delegate.vals().at(i).get(), viewSupplier, attr );</span>
                    }
                    else
<span class="fc" id="L3174">                        _addComponentAt(delegate.index(), delegate.newValue().get(), viewSupplier, attr);</span>
<span class="fc" id="L3175">                    break;</span>
<span class="fc" id="L3176">                case REMOVE: _removeComponentAt(delegate.index()); break;</span>
<span class="fc" id="L3177">                case CLEAR: _clearComponents(); break;</span>
<span class="nc" id="L3178">                case NONE: break;</span>
<span class="nc" id="L3179">                default: throw new IllegalStateException(&quot;Unknown type: &quot;+delegate.changeType());</span>
            }
<span class="fc" id="L3181">        });</span>
<span class="fc" id="L3182">        viewables.forEach( v -&gt; add(viewSupplier.createViewFor(v)) );</span>
<span class="fc" id="L3183">    }</span>

    private &lt;M&gt; void _addViewableProp( Val&lt;M&gt; viewable, String attr, ViewSupplier&lt;M&gt; viewSupplier) {
        // First we remember the index of the component which will be provided by the viewable dynamically.
<span class="fc" id="L3187">        final int index = _childCount();</span>
        // Then we add the component provided by the viewable to the list of children.
<span class="fc bfc" id="L3189" title="All 2 branches covered.">        if ( attr == null ) {</span>
<span class="fc bfc" id="L3190" title="All 2 branches covered.">            if ( viewable.isPresent() )</span>
<span class="fc" id="L3191">                this.add(viewSupplier.createViewFor(viewable.get()));</span>
            else
<span class="fc" id="L3193">                this.add(new JPanel()); // We add a dummy component to the list of children.</span>
        } else {
<span class="pc bpc" id="L3195" title="1 of 2 branches missed.">            if ( viewable.isPresent() )</span>
<span class="fc" id="L3196">                this.add(attr, viewSupplier.createViewFor(viewable.get()));</span>
            else
<span class="nc" id="L3198">                this.add(attr, new JPanel()); // We add a dummy component to the list of children.</span>
        }
        // Finally we add a listener to the viewable which will update the component when the viewable changes.
<span class="fc" id="L3201">        _onShow( viewable, v -&gt; _updateComponentAt(index, v, viewSupplier, attr) );</span>
<span class="fc" id="L3202">    }</span>

    private &lt;M&gt; void _updateComponentAt(int index, M v, ViewSupplier&lt;M&gt; viewSupplier, String attr ) {
<span class="fc" id="L3205">        component().ifPresent( c -&gt; {</span>
<span class="pc bpc" id="L3206" title="1 of 2 branches missed.">            JComponent newComponent = v == null ? new JPanel() : UI.use(_eventProcessor, () -&gt; viewSupplier.createViewFor(v).getComponent() );</span>
            // We remove the old component.
<span class="fc" id="L3208">            c.remove(c.getComponent(index));</span>
            // We add the new component.
<span class="pc bpc" id="L3210" title="1 of 2 branches missed.">            if ( attr == null )</span>
<span class="fc" id="L3211">                c.add(newComponent, index);</span>
            else
<span class="nc" id="L3213">                c.add(newComponent, attr, index);</span>
            // We update the layout.
<span class="fc" id="L3215">            c.revalidate();</span>
<span class="fc" id="L3216">            c.repaint();</span>
<span class="fc" id="L3217">        });</span>
<span class="fc" id="L3218">    }</span>

    private &lt;M&gt; void _addComponentAt(int index, M v, ViewSupplier&lt;M&gt; viewSupplier, String attr ) {
<span class="fc" id="L3221">        component().ifPresent( c -&gt; {</span>
            // We add the new component.
<span class="pc bpc" id="L3223" title="1 of 2 branches missed.">            if ( attr == null )</span>
<span class="fc" id="L3224">                c.add(UI.use(_eventProcessor, () -&gt; viewSupplier.createViewFor(v).getComponent()), index);</span>
            else
<span class="nc" id="L3226">                c.add(UI.use(_eventProcessor, () -&gt; viewSupplier.createViewFor(v).getComponent()), attr, index);</span>
            // We update the layout.
<span class="fc" id="L3228">            c.revalidate();</span>
<span class="fc" id="L3229">            c.repaint();</span>
<span class="fc" id="L3230">        });</span>
<span class="fc" id="L3231">    }</span>

    private void _removeComponentAt( int index ) {
<span class="fc" id="L3234">        component().ifPresent( c -&gt; {</span>
            // We remove the old component.
<span class="fc" id="L3236">            c.remove(c.getComponent(index));</span>
            // We update the layout.
<span class="fc" id="L3238">            c.revalidate();</span>
<span class="fc" id="L3239">            c.repaint();</span>
<span class="fc" id="L3240">        });</span>
<span class="fc" id="L3241">    }</span>

    private void _clearComponents() {
<span class="fc" id="L3244">        component().ifPresent( c -&gt; {</span>
            // We remove all components.
<span class="fc" id="L3246">            c.removeAll();</span>
            // We update the layout.
<span class="fc" id="L3248">            c.revalidate();</span>
<span class="fc" id="L3249">            c.repaint();</span>
<span class="fc" id="L3250">        });</span>
<span class="fc" id="L3251">    }</span>

    private static boolean _isBorderLayout( Object o ) {
<span class="fc bfc" id="L3254" title="All 2 branches covered.">        return BorderLayout.CENTER.equals(o) ||</span>
<span class="fc bfc" id="L3255" title="All 2 branches covered.">                BorderLayout.PAGE_START.equals(o) ||</span>
<span class="fc bfc" id="L3256" title="All 2 branches covered.">                BorderLayout.PAGE_END.equals(o) ||</span>
<span class="fc bfc" id="L3257" title="All 2 branches covered.">                BorderLayout.LINE_END.equals(o) ||</span>
<span class="fc bfc" id="L3258" title="All 2 branches covered.">                BorderLayout.LINE_START.equals(o) ||</span>
<span class="pc bpc" id="L3259" title="1 of 2 branches missed.">                BorderLayout.EAST.equals(o)  ||</span>
<span class="pc bpc" id="L3260" title="1 of 2 branches missed.">                BorderLayout.WEST.equals(o)  ||</span>
<span class="pc bpc" id="L3261" title="1 of 2 branches missed.">                BorderLayout.NORTH.equals(o) ||</span>
<span class="pc bpc" id="L3262" title="1 of 2 branches missed.">                BorderLayout.SOUTH.equals(o);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>