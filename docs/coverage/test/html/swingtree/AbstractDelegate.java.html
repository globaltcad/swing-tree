<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDelegate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractDelegate.java</span></div><h1>AbstractDelegate.java</h1><pre class="source lang-java linenums">package swingtree;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.Val;
import swingtree.animation.Animation;
import swingtree.animation.AnimationDispatcher;
import swingtree.animation.AnimationStatus;
import swingtree.animation.LifeTime;
import swingtree.api.AnimatedStyler;
import swingtree.api.Painter;
import swingtree.api.Styler;
import swingtree.layout.Bounds;
import swingtree.layout.Position;
import swingtree.layout.Size;
import swingtree.style.ComponentExtension;

import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.border.Border;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *  Extensions of this class delegate a component
 *  as well as provide useful methods for trying the tree of the components
 *  in which the delegated component is contained. &lt;br&gt;
 *  Instances of this class are passed to various user event {@link Action} handlers.
 *  You can use this to change the state of the component, schedule animations
 *  for the component or query the tree of the components.
 *
 * @param &lt;C&gt; The type of the component that is delegated.
 */
public class AbstractDelegate&lt;C extends JComponent&gt;
{
<span class="fc" id="L43">    private static final Logger log = LoggerFactory.getLogger(AbstractDelegate.class);</span>
    private final GuiTraverser _guiTraverser; // the traverser object that allows us to query the component tree
    private final C _component;

    /**
     * @param component The component that is delegated.
     * @param handle A component that is used as a starting point for traversing the component tree,
     *               usually the same component as the one that is delegated.
     */
<span class="fc" id="L52">    AbstractDelegate( boolean nullable, C component, JComponent handle ) {</span>
<span class="fc" id="L53">        _guiTraverser = new GuiTraverser(Objects.requireNonNull(handle));</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        _component    = nullable ? component : Objects.requireNonNull(component);</span>
<span class="fc" id="L55">    }</span>

    /**
     *  Checks if the given font is the undefined font constant
     *  with respect to regular object identity instead of value equality.
     *  This is a deliberate design choice to allow the user to use the
     *  {@link UI.Font#UNDEFINED} constant instead of {@code null}
     *  as a placeholder for the absence of a font.
     * @param font The font to check.
     * @return {@code true} if the font is the undefined font constant, {@code false} otherwise.
     */
    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedFont( Font font ) {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        return font == UI.Font.UNDEFINED;</span>
    }

    /**
     *  Checks if the given color is the undefined color constant
     *  with respect to regular object identity instead of value equality.
     *  This is a deliberate design choice to allow the user to use the
     *  {@link UI.Color#UNDEFINED} constant instead of {@code null}
     *  as a placeholder for the absence of a color.
     * @param color The color to check.
     * @return {@code true} if the color is the undefined color constant, {@code false} otherwise.
     */
    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    protected final boolean _isUndefinedColor( Color color ) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        return color == UI.Color.UNDEFINED;</span>
    }


    protected final C _component() {
<span class="fc" id="L87">        return _component;</span>
    }

    /**
     *  A library internal utility method that exposes the sibling components
     *  of the delegated component.
     * @return A list of sibling components.
     */
    protected final List&lt;JComponent&gt; _siblingsSource() {
<span class="fc" id="L96">        return Optional.ofNullable(_component.getParent())</span>
<span class="fc" id="L97">                .map(Container::getComponents)</span>
<span class="fc" id="L98">                .map(Arrays::stream)</span>
<span class="fc" id="L99">                .orElseGet(Stream::empty)</span>
<span class="fc" id="L100">                .filter(c -&gt; c instanceof JComponent)</span>
<span class="fc" id="L101">                .map(c -&gt; (JComponent) c)</span>
<span class="fc" id="L102">                .collect(Collectors.toList());</span>
    }

    /**
     *  This is a delegate to the underlying component, but not every method of the component
     *  is delegated. This method allows you to access the underlying component directly.
     *  &lt;p&gt;
     *  Note that this method expects that the accessing thread is the event dispatch thread,
     *  not the application thread.
     *  If you want to access the component from the application thread, you should use &lt;br&gt;
     *  {@code UI.run(() -&gt; delegate.component())}.
     *
     * @return The underlying component.
     * @throws IllegalStateException If the accessing thread is not the event dispatch thread.
     */
    public final C get() {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L119">            throw new IllegalStateException(</span>
                    &quot;You can only access the component from the GUI thread. &quot; +
                    &quot;Use 'UI.run(() -&gt; delegate.component())' to access the component from the application thread.&quot;
                );
<span class="fc" id="L123">        return _component();</span>
    }

    /**
     *  Allows you to access the x-coordinate of the delegated component relative to its parent,
     *  and &lt;b&gt;scaled to &quot;developer pixel space&quot; instead of &quot;component pixel space&quot;.&lt;/b&gt;
     *  This means that even if your component and its placement was upscaled
     *  for a particular high DPI environment for example, then you will still
     *  receive a consistent coordinate.
     *
     * @return The x-coordinate of the component relative to its parent
     *         and in &quot;developer pixel space&quot; (without DPI aware scaling applied).
     */
<span class="nc" id="L136">    public final int getX() { return UI.unscale(_component().getX()); }</span>

    /**
     *  Allows you to access the y-coordinate of the delegated component relative to its parent,
     *  and &lt;b&gt;scaled to &quot;developer pixel space&quot; instead of &quot;component pixel space&quot;.&lt;/b&gt;
     *  This means that even if your component and its placement was upscaled
     *  for a particular high DPI environment for example, then you will still
     *  receive a consistent coordinate.
     *
     * @return The y-coordinate of the component relative to its parent
     *         and in &quot;developer pixel space&quot; (without DPI aware scaling applied).
     */
<span class="nc" id="L148">    public final int getY() { return UI.unscale(_component().getY()); }</span>

    /**
     *  This method allows you to access the location of the delegated component r
     *  elative to its parent in &quot;developer pixel space&quot; instead of &quot;component pixel space&quot;.
     *  It returns an immutable {@link Position} object holding both x and y components
     *  which are equal to the values available through {@link #getX()} and {@link #getY()}.
     *
     * @return The location of the component relative to its parent
     *         in &quot;developer pixel space&quot; (without DPI scaling applied).
     */
    public final Position getLocation() {
<span class="nc" id="L160">        return Position.of(getX(), getY());</span>
    }

    /**
     *  This is a component delegate API, which means that it represents
     *  the API of a wrapped component. So this method allows you to access
     *  the parent of the underlying component.
     *  In essence, this is a delegate to {@link Component#getParent()}. &lt;br&gt;
     *
     * @return The parent {@link Container} of the underlying component.
     * @throws IllegalStateException If the accessing thread is not the event dispatch thread.
     */
    public final Container getParent() {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if ( UI.thisIsUIThread() )</span>
<span class="nc" id="L174">            return _component().getParent();</span>
        else
<span class="nc" id="L176">            throw new IllegalStateException(</span>
                    &quot;You can only access the parent component from the GUI thread. &quot; +
                    &quot;Use 'UI.run(() -&gt; delegate.getParent())' to access the parent component from the application thread.&quot;
                );
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param color The color that should be used to paint the background of the component.
     *              If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *              the background color of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackground( Color color ) {
<span class="nc" id="L196">        Objects.requireNonNull(color, &quot;Use UI.Color.UNDEFINED instead of null to represent the absence of a color.&quot;);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if ( _isUndefinedColor(color) )</span>
<span class="nc" id="L198">            _component().setBackground(null);</span>
        else
<span class="nc" id="L200">            _component().setBackground(color);</span>

<span class="nc" id="L202">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( double r, double g, double b ) {
<span class="nc" id="L219">        return setBackgroundColor(r, g, b, 1.0);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @param a The alpha component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( double r, double g, double b, double a ) {
<span class="nc" id="L237">        return setBackground(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( int r, int g, int b ) {
<span class="nc" id="L254">        return setBackgroundColor(r, g, b, 255);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @param a The alpha component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( int r, int g, int b, int a ) {
<span class="nc" id="L272">        return setBackground(new Color(r, g, b, a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the background color of the component.
     *  &lt;p&gt;
     *  See {@link Component#getBackground()} for more information.
     *  &lt;/p&gt;
     *
     * @return The background color of the component, or {@link UI.Color#UNDEFINED} if the component
     *         does not have a background color (i.e. {@link Component#getBackground()} returns &lt;code&gt;null&lt;/code&gt;).
     *         The return value will never be &lt;code&gt;null&lt;/code&gt;.
     */
    public final Color getBackground() {
<span class="nc" id="L287">        Color backgroundColor = _component().getBackground();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if ( backgroundColor == null )</span>
<span class="nc" id="L289">            return UI.Color.UNDEFINED;</span>
        else
<span class="nc" id="L291">            return backgroundColor;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param color The color that should be used to paint the foreground of the component.
     *              If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *              the foreground color of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForeground( Color color ) {
<span class="nc" id="L308">        Objects.requireNonNull(color, &quot;Use UI.Color.UNDEFINED instead of null to represent the absence of a color.&quot;);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if ( _isUndefinedColor(color) )</span>
<span class="nc" id="L310">            _component().setForeground( null );</span>
        else
<span class="nc" id="L312">            _component().setForeground( color );</span>
<span class="nc" id="L313">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the foreground color of the component.
     *  &lt;p&gt;
     *  See {@link Component#getForeground()} for more information.
     *  &lt;/p&gt;
     *
     * @return The foreground color of the component, or {@link UI.Color#UNDEFINED} if the component
     *        does not have a foreground color (i.e. {@link Component#getForeground()} returns &lt;code&gt;null&lt;/code&gt;).
     *        The return value will never be &lt;code&gt;null&lt;/code&gt;.
     */
    public final Color getForeground() {
<span class="nc" id="L328">        Color foregroundColor = _component().getForeground();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if ( foregroundColor == null )</span>
<span class="nc" id="L330">            return UI.Color.UNDEFINED;</span>
        else
<span class="nc" id="L332">            return foregroundColor;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( double r, double g, double b ) {
<span class="nc" id="L349">        return setForegroundColor(r, g, b, 1.0);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @param a The alpha component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( double r, double g, double b, double a ) {
<span class="nc" id="L367">        return setForeground(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( int r, int g, int b ) {
<span class="nc" id="L384">        return setForegroundColor(r, g, b, 255);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @param a The alpha component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( int r, int g, int b, int a ) {
<span class="nc" id="L402">        return setForeground(new Color(r, g, b, a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the font of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setFont(Font)} for more information.
     *  &lt;/p&gt;
     *
     * @param font The font that should be used to paint the text of the component.
     *             If this parameter is {@link UI.Font#UNDEFINED} then this component will inherit
     *             the font of its parent. Null is not allowed.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setFont( Font font ) {
<span class="nc" id="L419">        Objects.requireNonNull(font, &quot;Use UI.Font.UNDEFINED instead of null to represent the absence of a font.&quot;);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if ( _isUndefinedFont(font) )</span>
<span class="nc" id="L421">            _component().setFont(null);</span>
        else
<span class="nc" id="L423">            _component().setFont(font);</span>
<span class="nc" id="L424">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the font of the component.
     *  &lt;p&gt;
     *  See {@link Component#getFont()} for more information.
     *  &lt;/p&gt;
     *
     * @return The font of the component.
     */
    public final Font getFont() {
<span class="nc" id="L437">        Font font = _component().getFont();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if ( font == null )</span>
<span class="nc" id="L439">            return UI.Font.UNDEFINED;</span>
        else
<span class="nc" id="L441">            return font;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the border of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  Note that this method is a delegate to {@link JComponent#setBorder(Border)}.
     *  &lt;/p&gt;
     *
     * @param border The border that should be used to paint the border of the component.
     *               If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *               the border of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBorder( Border border ) {
<span class="nc" id="L458">        _component().setBorder(border);</span>
<span class="nc" id="L459">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the border of the component.
     *  &lt;p&gt;
     *  Note that this method is a delegate to {@link JComponent#getBorder()}.
     *  &lt;/p&gt;
     *
     * @return The border of the component.
     */
    public final Border getBorder() {
<span class="nc" id="L472">        return _component().getBorder();</span>
    }

    /**
     *  Allows you to specify new bounds for the delegated component in &quot;developer pixel space&quot;
     *  and then have them scaled and set as &quot;component pixel size&quot;, which may be scaled for hgigh
     *  DPI environments by the {@link UI#scale()} factor.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBounds(int, int, int, int)} for more information.
     *  &lt;/p&gt;
     *
     *  @param x The x coordinate of the new location of the component.
     *           This is relative to the component's parent.
     *  @param y The y coordinate of the new location of the component.
     *           This is relative to the component's parent.
     *  @param width The new width of the component.
     *  @param height The new height of the component.
     *  @return The delegate itself, so you can chain calls to this method.
     */
    public final AbstractDelegate&lt;C&gt; setBounds( int x, int y, int width, int height ) {
<span class="nc" id="L493">        _component().setBounds(UI.scale(x), UI.scale(y), UI.scale(width), UI.scale(height));</span>
<span class="nc" id="L494">        return this;</span>
    }

    /**
     *  Delegates to the {@link JComponent#setBounds(int, int, int, int)} method
     *  of the underlying component. The bounds consist of a location and a size
     *  which are relative to the component's parent.
     *  &lt;b&gt;Important:&lt;/b&gt; The supplied bounds are interpreted as &quot;being in developer pixel space&quot;
     *  without any scaling factor applied to it. And so this method will scale the bounds
     *  to DPI aware &quot;component pixel space&quot; by multiplying by {@link UI#scale()}.
     *
     * @param bounds The new bounds of the component.
     *                This is relative to the component's parent.
     * @return The delegate itself, so you can chain calls to this method.
     */
    public final AbstractDelegate&lt;C&gt; setBounds( Bounds bounds ) {
<span class="nc" id="L510">        return setBounds(</span>
<span class="nc" id="L511">                (int) UI.scale(bounds.location().x()),</span>
<span class="nc" id="L512">                (int) UI.scale(bounds.location().y()),</span>
<span class="nc" id="L513">                bounds.size().width().map(UI::scale).map(Number::intValue).orElse(0),</span>
<span class="nc" id="L514">                bounds.size().height().map(UI::scale).map(Number::intValue).orElse(0)</span>
            );
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the bounds of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBounds(Rectangle)} for more information.
     *  &lt;/p&gt;
     *  &lt;b&gt;Important:&lt;/b&gt; The supplied {@link Rectangle} is interpreted as &quot;being in developer pixel space&quot;
     *  without any scaling factor applied to it. And so this method will scale the bounds
     *  to DPI aware &quot;component pixel space&quot; by multiplying by {@link UI#scale()}.
     *
     *  @param bounds The new bounds of the component.
     *                  This is relative to the component's parent.
     * @return The delegate itself, so you can chain calls to this method.
     */
    public final AbstractDelegate&lt;C&gt; setBounds( Rectangle bounds ) {
<span class="nc" id="L534">        _component().setBounds(UI.scale(bounds));</span>
<span class="nc" id="L535">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the bounds of the component in the form of an immutable {@link Bounds} value object.
     *  The bounds consist of a location and a size which are relative to the component's parent.
     *  &lt;p&gt;
     *  See {@link Component#getBounds()} for more information.
     *  &lt;/p&gt;
     *  &lt;b&gt;Important:&lt;/b&gt; The returned {@link Rectangle} is scaled to &quot;developer pixel space&quot;
     *  and not necessarily in &quot;component pixel space&quot;.
     *
     *  @return The bounds of the component in scaling agnostic &quot;developer pixel space&quot;.
     *          This is relative to the component's parent.
     */
    public final Bounds getBounds() {
<span class="nc" id="L552">        Rectangle rec = _component().getBounds();</span>
<span class="nc" id="L553">        return Bounds.of(UI.unscale(rec.x), UI.unscale(rec.y), UI.unscale(rec.width), UI.unscale(rec.height));</span>
    }

    /**
     *  You can use this method to access a specific {@link UI.ComponentArea} of the component,
     *  which is useful if you do custom painting.
     *  This method returns an {@link Optional} value, which means that the
     *  component area may not be present.
     *  The {@link swingtree.UI.ComponentArea#BORDER} for example, may not be present
     *  in case of there not being a border width defined through {@link UIForAnySwing#withStyle(Styler)}.
     *  &lt;p&gt;
     *  See {@link ComponentExtension#getComponentArea(UI.ComponentArea)} for more information.
     *  &lt;/p&gt;
     *
     * @param area The component area to access.
     * @return An optional value that contains the component area if it is present.
     */
    public Optional&lt;Shape&gt; shapeOf( UI.ComponentArea area ) {
<span class="nc" id="L571">        return ComponentExtension.from(_component()).getComponentArea(area);</span>
    }

    /**
     *  Allows you to set the preferred size of the component in DPI agnostic &quot;developer pixels&quot;,
     *  which are automatically converted to DPI aware &quot;component pixels&quot; using {@link UI#scale()}.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The preferred size of the component.
     *  @return The delegate itself.
     *  @deprecated Use {@link #setPrefSize(Size)} instead of this method.
     */
    @Deprecated
    public final AbstractDelegate&lt;C&gt; setPrefSize( Dimension size ) {
<span class="nc" id="L588">        _scaleAndSetPrefSize(size);</span>
<span class="nc" id="L589">        return this;</span>
    }

    /**
     *  Allows you to set the preferred size of the component in DPI agnostic &quot;developer pixels&quot;,
     *  which are automatically converted to DPI aware &quot;component pixels&quot; using {@link UI#scale()}.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied size is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied size automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param size The preferred size of the component in developer pixel size.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefSize( Size size ) {
<span class="nc" id="L609">        _scaleAndSetPrefSize(size.toDimension());</span>
<span class="nc" id="L610">        return this;</span>
    }

    /**
     *  Allows you to set the preferred width and height of the component in DPI agnostic &quot;developer pixels&quot;,
     *  which are automatically converted to DPI aware &quot;component pixels&quot; using {@link UI#scale()}.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied size is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied width and height automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param width The preferred width of the component in developer pixels (not scaled for high DPI).
     *  @param height The preferred height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefSize( int width, int height ) {
<span class="nc" id="L631">        _scaleAndSetPrefSize(new Dimension(width, height));</span>
<span class="nc" id="L632">        return this;</span>
    }

    private void _scaleAndSetPrefSize( Dimension size ) {
<span class="nc" id="L636">        _component().setPreferredSize(UI.scale(size));</span>
<span class="nc" id="L637">    }</span>

    /**
     *  Allows you to set the preferred width of the component in DPI agnostic &quot;developer pixels&quot;,
     *  which are automatically converted to DPI aware &quot;component pixels&quot; using {@link UI#scale()}.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The preferred width of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefWidth( int width ) {
<span class="nc" id="L651">        Dimension size = _component().getPreferredSize();</span>
<span class="nc" id="L652">        _component().setPreferredSize(new Dimension(UI.scale(width), size.height));</span>
<span class="nc" id="L653">        return this;</span>
    }

    /**
     *  Allows you to set the preferred height of the component in DPI agnostic &quot;developer pixels&quot;,
     *  which are automatically converted to DPI aware &quot;component pixels&quot; using {@link UI#scale()}.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The preferred height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefHeight( int height ) {
<span class="nc" id="L668">        Dimension size = _component().getPreferredSize();</span>
<span class="nc" id="L669">        _component().setPreferredSize(new Dimension(size.width, UI.scale(height)));</span>
<span class="nc" id="L670">        return this;</span>
    }

    /**
     *  Exposes the preferred size of the component in DPI agnostic &quot;developer pixels&quot; which are
     *  computed by dividing the already scaled preferred component width and height 
     *  in &quot;component pixels&quot; by the {@link UI#scale()} factor.&lt;br&gt;
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getPreferredSize()} for more information.
     *  &lt;/p&gt;
     *  @return The preferred size of the component scaled to &quot;developer pixel size&quot;.
     */
    public final Size getPrefSize() {
<span class="nc" id="L684">        return Size.of(UI.unscale(_component().getPreferredSize()));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The minimum size of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     *  @deprecated Use {@link #setMinSize(Size)} instead!
     */
    @Deprecated
    public final AbstractDelegate&lt;C&gt; setMinSize( Dimension size ) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">        _component().setMinimumSize(size == null ? null : UI.scale(size));</span>
<span class="nc" id="L702">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum size of the component &lt;b&gt;in developer pixel size&lt;/b&gt;.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information 
     *  about the meaning of this property.
     *  &lt;/p&gt;
     *  Also note that the supplied size is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied size automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param size The minimum size of the component in developer pixel size,
     *              or {@link Size#unknown()} to set the minimum size to being &quot;undefined&quot;/&quot;null&quot;.
     *  @return The delegate itself.
     *  @throws NullPointerException if the supplied size is null.
     */
    public final AbstractDelegate&lt;C&gt; setMinSize( Size size ) {
<span class="nc" id="L725">        Objects.requireNonNull(size, &quot;Use Size.unknown() instead of null to represent the absence of a size.&quot;);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if ( size.equals(Size.unknown()) )</span>
<span class="nc" id="L727">            _component().setMinimumSize(null);</span>
        else
<span class="nc" id="L729">            _component().setMinimumSize(UI.scale(size.toDimension()));</span>
<span class="nc" id="L730">        return this;</span>
    }

    /**
     *  This method allows you to set the minimum size of the delegated component
     *  in &quot;developer pixels&quot; instead of &quot;component pixels&quot;.
     *  The dimension you supply to this method will be scale to &quot;component pixels&quot; for you, so you
     *  don't have to rely on component pixel space in your code (which varies depending on the {@link UI#scale()}).
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The minimum width of the component in developer pixels (not scaled for high DPI).
     *  @param height The minimum height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinSize( int width, int height ) {
<span class="nc" id="L748">        _component().setMinimumSize(new Dimension(UI.scale(width), UI.scale(height)));</span>
<span class="nc" id="L749">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum width of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The minimum width of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinWidth( int width ) {
<span class="nc" id="L764">        Dimension size = _component().getMinimumSize();</span>
<span class="nc" id="L765">        _component().setMinimumSize(new Dimension(UI.scale(width), size.height));</span>
<span class="nc" id="L766">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum height of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The minimum height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinHeight( int height ) {
<span class="nc" id="L781">        Dimension size = _component().getMinimumSize();</span>
<span class="nc" id="L782">        _component().setMinimumSize(new Dimension(size.width, UI.scale(height)));</span>
<span class="nc" id="L783">        return this;</span>
    }

    /**
     *  Exposes the minimum size of the component in DPI agnostic &quot;developer pixels&quot; which are
     *  computed by dividing the already scaled minimum component width and height 
     *  in &quot;component pixels&quot; by the {@link UI#scale()} factor.&lt;br&gt;
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getMinimumSize()} for more information.
     *  &lt;/p&gt;
     *  @return The minimum size of the component.
     */
    public final Size getMinSize() {
<span class="nc" id="L797">        return Size.of(UI.unscale(_component().getMinimumSize()));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The maximum size of the component.
     *  @return The delegate itself.
     */
    @Deprecated
    public final AbstractDelegate&lt;C&gt; setMaxSize( Dimension size ) {
<span class="nc bnc" id="L813" title="All 2 branches missed.">        _component().setMaximumSize(size == null ? null : UI.scale(size));</span>
<span class="nc" id="L814">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied size is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied size automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param size The maximum size of the component in developer pixel size,
     *              or {@link Size#unknown()} to set the maximum size to being &quot;undefined&quot;/&quot;null&quot;.
     *  @return The delegate itself.
     *  @throws NullPointerException if the supplied size is {@code null}.
     */
    public final AbstractDelegate&lt;C&gt; setMaxSize( Size size ) {
<span class="nc" id="L836">        Objects.requireNonNull(size, &quot;Use Size.unknown() instead of null to represent the absence of a size.&quot;);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if ( size.equals(Size.unknown()) )</span>
<span class="nc" id="L838">            _component().setMaximumSize(null);</span>
        else
<span class="nc" id="L840">            _component().setMaximumSize(UI.scale(size.toDimension()));</span>
<span class="nc" id="L841">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum size of the component in &quot;developer pixel&quot;.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied size is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied size automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param width The maximum width of the component in developer pixels (not scaled for high DPI).
     *  @param height The maximum height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxSize( int width, int height ) {
<span class="nc" id="L862">        _component().setMaximumSize(UI.scale(new Dimension(width, height)));</span>
<span class="nc" id="L863">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum width of the component in &quot;developer pixel&quot;.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied width is treated as being measured in &quot;developer pixel size&quot;, 
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied width automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *  
     *  @param width The maximum width of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxWidth( int width ) {
<span class="nc" id="L883">        Dimension size = _component().getMaximumSize();</span>
<span class="nc" id="L884">        _component().setMaximumSize(new Dimension(UI.scale(width), size.height));</span>
<span class="nc" id="L885">        return this;</span>
    }

    /**
     *  Takes a new maximum height for the component in &quot;developer pixel&quot; and applies it as &quot;component pixels&quot;.
     *  This means that the supplied height will be scaled to dynamic &quot;component pixels&quot;
     *  through multiplication with the {@link UI#scale()} factor.&lt;br&gt;
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  Also note that the supplied height is treated as being measured in &quot;developer pixel size&quot;,
     *  which are defined as pixels &lt;b&gt;without&lt;/b&gt; the UI scaling factor applied to them.&lt;br&gt;
     *  This method will scale the supplied height automatically for you, and therefore you as a developer
     *  may define dimensions in your GUI code consistently, without sacrificing dynamic DPI scaling.
     *
     *  @param height The maximum height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxHeight( int height ) {
<span class="nc" id="L906">        Dimension size = _component().getMaximumSize();</span>
<span class="nc" id="L907">        _component().setMaximumSize(new Dimension(size.width, UI.scale(height)));</span>
<span class="nc" id="L908">        return this;</span>
    }

    /**
     *  Exposes the maximum size of the component in DPI agnostic &quot;developer pixels&quot; which are
     *  computed by dividing the already scaled maximum width and height of the component
     *  in &quot;component pixels&quot; by the {@link UI#scale()} factor.&lt;br&gt;
     *  The maximum size of a component is used by the layout manager to determine 
     *  the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getMaximumSize()} for more information.
     *  &lt;/p&gt;
     *  @return The maximum size of the component in &quot;developer pixels&quot;.
     */
    public final Size getMaxSize() {
<span class="nc" id="L923">        return Size.of(UI.unscale(_component().getMaximumSize()));</span>
    }

    /**
     *  You can use this method to set the size of the component in &quot;developer pixel&quot;,
     *  meaning that the supplied dimensions will be scaled to dynamic &quot;component pixels&quot;
     *  using the {@link UI#scale()} factor.&lt;br&gt;
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The size of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     *  @deprecated Use {@link #setSize(Size)} instead of this method!
     */
    @Deprecated
    public final AbstractDelegate&lt;C&gt; setSize( Dimension size ) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">        _component().setSize(size == null ? null : UI.scale(size));</span>
<span class="nc" id="L942">        return this;</span>
    }

    /**
     *  Takes a new {@link Size} for the component in &quot;developer pixel&quot; and applies it as &quot;component pixels&quot;.
     *  This means that the supplied dimensions will be scaled to dynamic &quot;component pixels&quot;
     *  through multiplication with the {@link UI#scale()} factor.&lt;br&gt;
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The size of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setSize( Size size ) {
<span class="nc" id="L958">        Objects.requireNonNull(size);</span>
<span class="nc" id="L959">        _component().setSize(UI.scale(size.toDimension()));</span>
<span class="nc" id="L960">        return this;</span>
    }

    /**
     *  Takes two new width and height for the component in &quot;developer pixel&quot; and applies it as &quot;component pixels&quot;.
     *  This means that the supplied dimensions will be scaled to dynamic &quot;component pixels&quot;
     *  through multiplication with the {@link UI#scale()} factor.&lt;br&gt;
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The width of the component in developer pixels (not scaled for high DPI).
     *  @param height The height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setSize( int width, int height ) {
<span class="nc" id="L977">        _component().setSize(UI.scale(new Dimension(width, height)));</span>
<span class="nc" id="L978">        return this;</span>
    }

    /**
     *  Takes a new width for the underlying component in &quot;developer pixel&quot; and applies it as &quot;component pixels&quot;.
     *  This means that the supplied width will be scaled to dynamic &quot;component pixels&quot;
     *  through multiplication with the {@link UI#scale()} factor.&lt;br&gt;
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The regular size of a component is typically managed and set by the layout manager of a component.
     *  So you may not want to set this in most cases...
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The width of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setWidth( int width ) {
<span class="nc" id="L995">        Dimension size = _component().getSize();</span>
<span class="nc" id="L996">        _component().setSize(new Dimension(UI.scale(width), size.height));</span>
<span class="nc" id="L997">        return this;</span>
    }

    /**
     *  You can use this method to set the height of the delegated component in &quot;developer pixel&quot;.
     *  The value you pass to this method will be scaled by {@link UI#scale(int)} and then set.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The height of the component in developer pixels (not scaled for high DPI).
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setHeight( int height ) {
<span class="nc" id="L1012">        Dimension size = _component().getSize();</span>
<span class="nc" id="L1013">        _component().setSize(new Dimension(size.width, UI.scale(height)));</span>
<span class="nc" id="L1014">        return this;</span>
    }

    /**
     *  Exposes the size of the delegated component in &quot;developer pixel&quot;.
     *  Theis property is typically managed and set by the layout manager.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The size of the component.
     */
    public final Size getSize() {
<span class="nc" id="L1026">        return Size.of(UI.unscale(_component().getSize()));</span>
    }

    /**
     *  Exposes the width of the underlying component in &quot;developer pixel&quot;.
     *  Theis property is typically managed and set by the layout manager.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The width of the component in developer pixels (not scaled for high DPI).
     */
    public final int getWidth() {
<span class="nc" id="L1038">        return UI.unscale(_component().getSize().width);</span>
    }

    /**
     *  Exposes the height of the component in &quot;developer pixel&quot; pixel.
     *  Theis property is typically managed and set by the layout manager.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The height of the component in developer pixels (not scaled for high DPI).
     */
    public final int getHeight() {
<span class="nc" id="L1050">        return UI.unscale(_component().getSize().height);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the {@link UI.Cursor} of the component.
     *
     * @param cursor The {@link UI.Cursor} which should be set.
     * @return The delegate itself.
     * @throws NullPointerException if the supplied enum instance is {@code null}!
     */
    public final AbstractDelegate&lt;C&gt; setCursor( UI.Cursor cursor ) {
<span class="nc" id="L1062">        Objects.requireNonNull(cursor);</span>
<span class="nc" id="L1063">        _component().setCursor(Cursor.getPredefinedCursor(cursor.type));</span>
<span class="nc" id="L1064">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the {@link Cursor} of the component.
     * @param cursor The {@link Cursor} which should be set.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setCursor( Cursor cursor ) {
<span class="nc" id="L1074">        _component().setCursor(cursor);</span>
<span class="nc" id="L1075">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the {@link Cursor} of the component.
     * @return The {@link Cursor} of the component.
     */
    public final Cursor getCursor() {
<span class="nc" id="L1084">        return _component().getCursor();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the tooltip of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setToolTipText(String)} for more information.
     *  &lt;/p&gt;
     * @param text  The tooltip text.
     * @return The delegate itself.
     * @throws NullPointerException If the text is null, use an empty string to model the absence of a tooltip.
     */
    public final AbstractDelegate&lt;C&gt; setTooltip( String text ) {
<span class="nc" id="L1099">        Objects.requireNonNull(text, &quot;Use an empty string instead of null to represent the absence of a tooltip.&quot;);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        _component().setToolTipText( text.isEmpty() ? null : text );</span>
<span class="nc" id="L1101">        return this;</span>
    }

    /**
     *  Exposes the tooltip {@link String} of the component or
     *  an empty {@link String} if the component does not have a tooltip.
     *  Note that this method will never return {@code null}.
     *  &lt;p&gt;
     *  See {@link JComponent#getToolTipText()} for more information.
     *  &lt;/p&gt;
     * @return The tooltip text or an empty {@link String} if this component
     *         does not have a tooltip, &lt;b&gt;but {@code null} is never returned&lt;/b&gt;!
     */
    public final String getTooltip() {
<span class="nc" id="L1115">        String nullableToolTip = _component().getToolTipText();</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        return nullableToolTip == null ? &quot;&quot; : nullableToolTip;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently enable or disable the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setEnabled(boolean)} for more information.
     *  &lt;/p&gt;
     *  @param enabled True if the component should be enabled, false otherwise.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setEnabled( boolean enabled ) {
<span class="nc" id="L1130">        _component().setEnabled(enabled);</span>
<span class="nc" id="L1131">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is enabled.
     *  &lt;p&gt;
     *  See {@link JComponent#isEnabled()} for more information.
     *  &lt;/p&gt;
     *  @return True if the component is enabled, false otherwise.
     */
    public final boolean isEnabled() {
<span class="nc" id="L1143">        return _component().isEnabled();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently enable or disable the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setVisible(boolean)} for more information.
     *  &lt;/p&gt;
     *  @param visible True if the component should be visible, false otherwise.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setVisible( boolean visible ) {
<span class="nc" id="L1157">        _component().setVisible(visible);</span>
<span class="nc" id="L1158">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is visible.
     *  &lt;p&gt;
     *  See {@link JComponent#isVisible()} for more information.
     *  &lt;/p&gt;
     *  @return True if the component is visible, false otherwise.
     */
    public final boolean isVisible() {
<span class="nc" id="L1170">        return _component().isVisible();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is opaque.
     *  &lt;p&gt;
     *  See {@link JComponent#isOpaque()} for more information.
     *  &lt;/p&gt;
     * @return True if the component is opaque, false otherwise.
     */
    public final boolean isOpaque() {
<span class="nc" id="L1182">        return _component().isOpaque();</span>
    }

    /**
     *  Use this to query the UI's component tree and find any {@link JComponent}
     *  of a particular type and id (the name of the component).
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param id The ide of the {@link JComponent} which should be found in the swing tree.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, String id ) {
<span class="fc" id="L1195">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1196">        Objects.requireNonNull(id);</span>
<span class="fc" id="L1197">        return this.find( type, c -&gt; ComponentExtension.from(c).hasId(id) );</span>
    }

    /**
     *  Use this to query the UI's component tree and find any {@link JComponent}
     *  of a particular type and id (the name of the component).
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param id The ide of the {@link JComponent} which should be found in the swing tree.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, Enum&lt;?&gt; id ) {
<span class="nc" id="L1210">        Objects.requireNonNull(type);</span>
<span class="nc" id="L1211">        Objects.requireNonNull(id);</span>
<span class="nc" id="L1212">        return this.find( type, c -&gt; ComponentExtension.from(c).hasId(id) );</span>
    }

    /**
     *  Use this to query the UI's component tree and find any {@link JComponent}
     *  based on a specific type and a predicate which is used to test
     *  if a particular component in the tree is the one you are looking for.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param predicate The predicate which should be used to test the {@link JComponent}.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L1226">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1227">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L1228">        return _guiTraverser.find(type, predicate)</span>
<span class="fc" id="L1229">                .findFirst()</span>
<span class="fc" id="L1230">                .map(OptionalUI::ofNullable)</span>
<span class="fc" id="L1231">                .orElse(OptionalUI.empty());</span>
    }

    /**
     *  Use this to query the UI's component tree and find all {@link JComponent}s
     *  based on a specific type and a predicate which is used to test
     *  if a particular component in the tree is the one you are looking for.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param predicate The predicate which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and predicate.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAll( Class&lt;T&gt; type, Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L1245">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1246">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L1247">        return _guiTraverser.find(type, predicate).collect(Collectors.toList());</span>
    }

    /**
     *  Use this to query the UI's component tree and find all {@link JComponent}s
     *  of a particular type and also that belong to a particular style group.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param group The style group which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and group.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAllByGroup( Class&lt;T&gt; type, String group ) {
<span class="fc" id="L1260">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1261">        Objects.requireNonNull(group);</span>
<span class="fc" id="L1262">        return this.findAll( type, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  Use this to query the UI's component tree and find all {@link JComponent}s
     *  that belong to a particular style group.
     *
     * @param group The style group which should be used to check if a particular {@link JComponent} belongs to it.
     * @return A list of {@link JComponent} instances which all have the given style group.
     * @throws NullPointerException If the group is null.
     */
    public final List&lt;JComponent&gt; findAllByGroup( String group ) {
<span class="nc" id="L1274">        Objects.requireNonNull(group);</span>
<span class="nc" id="L1275">        return this.findAll( JComponent.class, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }


    /**
     *  Use this to query the UI's component tree and find all {@link JComponent}s
     *  of a particular type and also that belong to a particular style group.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param group The style group which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and predicate.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAllByGroup( Class&lt;T&gt; type, Enum&lt;?&gt; group ) {
<span class="nc" id="L1289">        Objects.requireNonNull(type);</span>
<span class="nc" id="L1290">        Objects.requireNonNull(group);</span>
<span class="nc" id="L1291">        return this.findAll( type, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  Use this to query the UI's component tree and find all {@link JComponent}s
     *  that belong to a particular style group.
     *
     * @param group The style group which should be used to check if a particular {@link JComponent} belongs to it.
     * @return A list of {@link JComponent} instances which all have the given style group.
     */
    public final List&lt;JComponent&gt; findAllByGroup( Enum&lt;?&gt; group ) {
<span class="nc" id="L1302">        Objects.requireNonNull(group);</span>
<span class="nc" id="L1303">        return this.findAll( JComponent.class, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  A common use case is to render something on top of the {@link UI.ComponentArea#BODY}
     *  of the component using the {@link Graphics2D} instance of the component.
     *  This method allows you to attach a paint task to the component, which
     *  the EDT will process in the next repaint event cycle, and remove when the animation expires.
     *  This ensures that custom rendering
     *  is not erased by a potential repaint of the component after a user event.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy button animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *          double r = 300 * status.progress();
     *          double x = it.mouseX() - r / 2;
     *          double y = it.mouseY() - r / 2;
     *          it.paint(status, g -&gt; {
     *              g.setColor(new Color(1f, 1f, 0f, (float) (1 - status.progress())));
     *              g.fillOval((int) x, (int) y, (int) r, (int) r);
     *          });
     *      }))
     *  }&lt;/pre&gt;
     *  You may also be interested in doing style animations, if so, maybe consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event based styling animations
     *  and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to see how to do 2 state switch based styling animations.
     *
     * @param status The current animation progress status, which is important so that the rendering can be synchronized with the animation.
     * @param painter The rendering task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void paint( AnimationStatus status, Painter painter ) {
<span class="nc" id="L1335">        Objects.requireNonNull(status);</span>
<span class="nc" id="L1336">        Objects.requireNonNull(painter);</span>
<span class="nc" id="L1337">        paint(UI.ComponentArea.BODY, status, painter);</span>
<span class="nc" id="L1338">    }</span>

    /**
     *  A common use case is to render something on top of the component
     *  using the {@link Graphics2D} instance of the component.
     *  This method allows you to attach a paint task to the component, which
     *  the EDT will process in the next repaint event cycle, and remove when the animation expires.
     *  This ensures that custom rendering
     *  is not erased by a potential repaint of the component after a user event. &lt;br&gt;
     *  Additionally, you can specify the area of the component which should be painted.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a button animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *          double r = 300 * status.progress();
     *          double x = it.mouseX() - r / 2;
     *          double y = it.mouseY() - r / 2;
     *          it.paint(UI.ComponentArea.BORDER, state, g -&gt; {
     *              g.setColor(new Color(1f, 1f, 0f, (float) (1 - status.progress())));
     *              g.fillOval((int) x, (int) y, (int) r, (int) r);
     *          });
     *      }))
     *  }&lt;/pre&gt;
     *  You may also be interested in doing style animations, if so, maybe consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event based styling animations
     *  and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to see how to do 2 state switch based styling animations.
     *
     * @param area The area of the component which should be painted.
     * @param status The current animation progress status,
     *               which needs to be provided so that the rendering can be synchronized with the animation.
     * @param painter The rendering task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void paint( UI.ComponentArea area, AnimationStatus status, Painter painter ) {
<span class="nc" id="L1372">        Objects.requireNonNull(area);</span>
<span class="nc" id="L1373">        Objects.requireNonNull(status);</span>
<span class="nc" id="L1374">        Objects.requireNonNull(painter);</span>
<span class="nc" id="L1375">        this.paint(area, UI.Layer.BORDER, status, painter);</span>
<span class="nc" id="L1376">    }</span>

    /**
     *  A common use case is to render something on top of the {@link UI.ComponentArea#BODY}
     *  of the component using the {@link Graphics2D} instance of the component.
     *  This method allows you to attach a paint task to the component, which
     *  the EDT will process in the next repaint event cycle, and remove when the animation expires.
     *  This ensures that custom rendering is not erased by a potential repaint
     *  of the component after a user event.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy button animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *          double r = 300 * status.progress();
     *          double x = it.mouseX() - r / 2;
     *          double y = it.mouseY() - r / 2;
     *          it.paint(UI.Layer.CONTENT, status, g -&gt; {
     *              g.setColor(new Color(1f, 1f, 0f, (float) (1 - status.progress())));
     *              g.fillOval((int) x, (int) y, (int) r, (int) r);
     *          });
     *      }))
     *  }&lt;/pre&gt;
     *  You may also be interested in doing style animations, if so, maybe consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event based styling animations
     *  and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to see how to do 2 state switch based styling animations.
     *
     * @param layer The layer of the component which should be painted on.
     * @param status The current animation progress status, which is important so that the rendering can be synchronized with the animation.
     * @param painter The rendering task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void paint( UI.Layer layer, AnimationStatus status, Painter painter ) {
<span class="nc" id="L1408">        this.paint(UI.ComponentArea.BODY, layer, status, painter);</span>
<span class="nc" id="L1409">    }</span>

    /**
     *  A common use case is to render something on top of the component
     *  using the {@link Graphics2D} instance used by the component to render itself.
     *  This method allows you to attach a paint task to the component, which
     *  the EDT will process in the next repaint event cycle, and remove when the animation expires.
     *  This ensures that custom rendering
     *  is not erased by a potential repaint of the component after a user event. &lt;br&gt;
     *  Additionally, you can specify the area of the component which should be painted
     *  as well as a layer onto which the painter should paint.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a button animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *          double r = 300 * status.progress();
     *          double x = it.mouseX() - r / 2;
     *          double y = it.mouseY() - r / 2;
     *          it.paint(UI.ComponentArea.BODY, UI.Layer.CONTENT, state, g -&gt; {
     *              g.setColor(new Color(1f, 1f, 0f, (float) (1 - status.progress())));
     *              g.fillOval((int) x, (int) y, (int) r, (int) r);
     *          });
     *      }))
     *  }&lt;/pre&gt;
     *  You may also be interested in doing style animations, if so, maybe consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event based styling animations
     *  and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to see how to do 2 state switch based styling animations.
     *
     * @param area The area of the component which should be painted.
     * @param layer The layer of the component which should be painted.
     * @param status The current animation progress status,
     *               which needs to be provided so that the rendering can be synchronized with the animation.
     * @param painter An implementation of a simple functional interface receiving a
     *                {@link Graphics2D} instance for doing paint operations...
     */
    public final void paint( UI.ComponentArea area, UI.Layer layer, AnimationStatus status, Painter painter ) {
<span class="nc" id="L1446">        Objects.requireNonNull(status);</span>
<span class="nc" id="L1447">        Objects.requireNonNull(painter);</span>
<span class="nc" id="L1448">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the rendering later in the paint method of a custom border implementation!
<span class="nc" id="L1450">            ComponentExtension.from(_component).addAnimatedPainter(status, layer, area, painter);</span>
<span class="nc" id="L1451">        });</span>
<span class="nc" id="L1452">    }</span>

    /**
     *  Use this method to delegate to the parent of the component.
     *  This is useful if you want to apply a style or animation
     *  to the parent of a component which just received an event,
     *  like a mouse click event.
     *  &lt;p&gt;
     *  Here is an example demonstrating how
     *  to apply a style to the parent of a component when it is clicked:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it
     *          .parentDelegate( parent -&gt; parent
     *              .style( style -&gt; style
     *                  .borderWidth(6)
     *                  .borderColor(Color.RED)
     *                  .borderRadius(60)
     *              )
     *          )
     *      )
     *  }&lt;/pre&gt; &lt;br&gt;
     *  And here another more advanced example demonstrating how to do animated
     *  painting on the parent of a component that is being dragged away:
     *  &lt;pre&gt;{@code
     *  label(&quot;Drag me away&quot;)
     *  .withDragAway( conf -&gt; conf
     *      .onDragStart( it -&gt; {
     *          it.parentDelegate( parent -&gt; parent
     *              .animateFor(1, TimeUnit.SECONDS, status -&gt; {
     *                  double r = 320 * status.fadeOut();
     *                  double x = it.getEvent().getDragOrigin().getX() - r / 2;
     *                  double y = it.getEvent().getDragOrigin().getY() - r / 2;
     *                  parent.paint(status, g -&gt; {
     *                      g.setColor(new Color(0f, 1f, 1f, (float) status.fadeIn()));
     *                      g.fillOval((int) x, (int) y, (int) r, (int) r);
     *                  });
     *              })
     *          );
     *      })
     *  )
     *  }&lt;/pre&gt;
     *  The paint method draws a circle around the drag origin of the drag event
     *  which gets smaller and more opaque as the animation progresses
     *  for a duration of 1 second. &lt;br&gt;
     *  &lt;p&gt;
     *  You may also be interested in doing style animations, if so, maybe consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event
     *  based styling animations and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)}
     *  to see how to do 2 state switch based styling animations.
     *
     * @param action The action which should be executed on the delegate of the parent component.
     */
    public final void parentDelegate( sprouts.Action&lt;AbstractDelegate&lt;JComponent&gt;&gt; action ) {
<span class="nc" id="L1506">        Objects.requireNonNull(action);</span>
<span class="nc" id="L1507">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
<span class="nc" id="L1508">            Container parent = _component().getParent();</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">            if ( parent instanceof JComponent ) {</span>
                try {
<span class="nc" id="L1511">                    AbstractDelegate&lt;JComponent&gt; delegate = new AbstractDelegate&lt;&gt;( false, (JComponent) parent, (JComponent) parent );</span>
<span class="nc" id="L1512">                    action.accept(delegate);</span>
<span class="nc" id="L1513">                } catch( Exception e ) {</span>
<span class="nc" id="L1514">                    log.error(SwingTree.get().logMarker(), &quot;Error while processing parent delegate!&quot;, e);</span>
<span class="nc" id="L1515">                }</span>
            } else {
<span class="nc" id="L1517">                log.warn(SwingTree.get().logMarker(), &quot;Parent of component is not a JComponent, cannot apply parent delegate!&quot;);</span>
            }
<span class="nc" id="L1519">        });</span>
<span class="nc" id="L1520">    }</span>

    /**
     *  A common use case is to animate the style of a component when a user event occurs.
     *  This method allows you to dispatch a styling animation to the EDT
     *  which will cause the component style to updated repeatedly until the animation expires.
     *  Because animation styles are applied last, it is guaranteed not to be overwritten by
     *  other {@link Styler} lambdas.
     *  Note that the provided styling will be removed automatically when the animation expires,
     *  so no manual cleanup is required.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy styling animation:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *    .onMouseClick( it -&gt; it.animateStyleFor(2, TimeUnit.SECONDS, (state, style) -&gt;
     *        .borderWidthAt(UI.Edge.BOTTOM, (int)(6 * state.progress()) )
     *        .borderColor( new Color(0f, 1f, 1f, (float) (1 - state.progress())) )
     *        .borderRadius( (int)(60 * state.progress()) )
     *    ))
     *  }&lt;/pre&gt;
     *  &lt;b&gt;You can achieve the same effect using {@link #animateFor(LifeTime, Animation)}
     *  and {@link #style(AnimationStatus, Styler)} as follows:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *    .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *        it.style(status, style -&gt; style
     *            // This is the same as the animateStyleFor() method above!
     *        );
     *    }))
     *  }&lt;/pre&gt;
     *  Also see {@link #animateStyleFor(LifeTime, AnimatedStyler)} for a version of this method which
     *  uses a {@link LifeTime} instead of a duration.
     *  If you are interested in doing more advanced style animations, consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event
     *  based styling animations and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to
     *  see how to do 2 state switch based styling animations.
     *
     * @param duration The duration of the animation.
     * @param unit The time unit of the duration.
     * @param styler The styling animation task which should be executed on the EDT at the end of the current event cycle.
     *               It receives both the current animation state and the {@link swingtree.style.ComponentStyleDelegate}
     *               for which you can define the style properties.
     */
    public final void animateStyleFor( double duration, TimeUnit unit, AnimatedStyler&lt;C&gt; styler ) {
<span class="fc" id="L1564">        Objects.requireNonNull(unit);</span>
<span class="fc" id="L1565">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1566">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the styling later in the paint method of a custom border implementation!
<span class="fc" id="L1568">            this.animateFor(duration, unit, status -&gt;</span>
<span class="fc" id="L1569">                ComponentExtension.from(_component).addAnimatedStyler(status, conf -&gt; styler.style(status, conf))</span>
            );
<span class="fc" id="L1571">        });</span>
<span class="fc" id="L1572">    }</span>

    /**
     *  A common use case is to animate the style of a component when a user event occurs.
     *  This method allows you to dispatch a styling animation to the EDT
     *  which will cause the component style to updated repeatedly until the animation expires.
     *  Because animation styles are applied last, it is guaranteed not to be overwritten by
     *  other {@link Styler} lambdas.
     *  Note that the provided styling will be removed automatically when the animation expires,
     *  so no manual cleanup is required.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy styling animation:
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *    .onMouseClick( it -&gt; it.animateStyleFor(UI.lifetime(2, TimeUnit.SECONDS), (state, style) -&gt;
     *        .borderWidthAt(UI.Edge.BOTTOM, (int)(6 * state.progress()) )
     *        .borderColor( new Color(0f, 1f, 1f, (float) (1 - state.progress())) )
     *        .borderRadius( (int)(60 * state.progress()) )
     *    ))
     *  }&lt;/pre&gt;
     *  &lt;b&gt;Not that the effect of this method can also be modelled using {@link #animateFor(LifeTime, Animation)}
     *  and {@link #style(AnimationStatus, Styler)} as follows:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *    UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *    .onMouseClick( it -&gt; it.animateFor(UI.lifetime(2, TimeUnit.SECONDS), status -&gt; {
     *        it.style(status, style -&gt; style
     *            // This is the same as the animateStyleFor() method above!
     *        );
     *    }))
     *  }&lt;/pre&gt;
     *  Also see {@link #animateStyleFor(double, TimeUnit, AnimatedStyler)} for a version of this method which uses a {@link LifeTime} instead of a duration.
     *  If you are interested in doing more advanced style animations, consider taking a look at
     *  {@link UIForAnySwing#withTransitoryStyle(sprouts.Observable, LifeTime, AnimatedStyler)} to see how to do event based styling animations
     *  and {@link UIForAnySwing#withTransitionalStyle(Val, LifeTime, AnimatedStyler)} to see how to do 2 state switch based styling animations.
     *
     * @param lifetime The lifetime of the animation.
     *                 The animation will be removed automatically when the lifetime expires.
     * @param styler The styling animation task which should be executed on the EDT at the end of the current event cycle.
     *               It receives both the current animation state and the {@link swingtree.style.ComponentStyleDelegate}
     *               for which you can define the style properties.
     */
    public final void animateStyleFor( LifeTime lifetime, AnimatedStyler&lt;C&gt; styler ) {
<span class="nc" id="L1614">        Objects.requireNonNull(lifetime);</span>
<span class="nc" id="L1615">        Objects.requireNonNull(styler);</span>
<span class="nc" id="L1616">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the styling later in the paint method of a custom border implementation!
<span class="nc" id="L1618">            this.animateFor(lifetime, status -&gt;</span>
<span class="nc" id="L1619">                ComponentExtension.from(_component).addAnimatedStyler(status, conf -&gt; styler.style(status, conf))</span>
            );
<span class="nc" id="L1621">        });</span>
<span class="nc" id="L1622">    }</span>

    /**
     *  A common use case is to style the component based on the current animation state.
     *  This method allows you to dispatch a styling task to the EDT
     *  which will be executed before the next component repaint.
     *  Because animation styles are applied last, it is guaranteed not to be overwritten by
     *  other styles.
     *  The provided styling will be removed when the animation expires.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy styling animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, status -&gt; {
     *          it.style(status, style -&gt; style
     *              .borderWidth((int)(10 * status.progress()))
     *              .borderColor(new Color(1f, 1f, 0f, (float) (1 - status.progress())))
     *              .borderRadius((int)(100 * status.progress()))
     *          );
     *      }))
     *  }&lt;/pre&gt;
     *
     * @param state The current animation state, which is important so that the styling can be synchronized with the animation.
     * @param styler The styling task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void style(AnimationStatus state, Styler&lt;C&gt; styler ) {
<span class="fc" id="L1648">        Objects.requireNonNull(state);</span>
<span class="fc" id="L1649">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1650">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the styling later in the paint method of a custom border implementation!
<span class="fc" id="L1652">            ComponentExtension.from(_component).addAnimatedStyler(state, styler);</span>
<span class="fc" id="L1653">        });</span>
<span class="fc" id="L1654">    }</span>

    /**
     *  Exposes access the animation builder API, where you can define the conditions
     *  under which the animation should be executed and then dispatch the animation to the EDT
     *  through the {@link AnimationDispatcher#go(Animation)} method.
     *
     *  @param duration The duration of the animation.
     *  @param unit The time unit of the duration.
     *  @return An {@link AnimationDispatcher} instance which can be used to define how the animation should be executed.
     */
    public final AnimationDispatcher animateFor(double duration, TimeUnit unit ) {
<span class="fc" id="L1666">        Objects.requireNonNull(unit);</span>
<span class="fc" id="L1667">        return AnimationDispatcher.animateFor(LifeTime.of(duration, unit), _component());</span>
    }

    /**
     *  Exposes access the animation builder API, where you can define the conditions
     *  under which the animation should be executed and then dispatch the animation to the EDT
     *  through the {@link AnimationDispatcher#go(Animation)} method.
     *
     *  @param lifeTime The lifetime of the animation.
     *  @return An {@link AnimationDispatcher} instance which can be used to define how the animation should be executed.
     */
    public final AnimationDispatcher animateFor(LifeTime lifeTime ) {
<span class="nc" id="L1679">        Objects.requireNonNull(lifeTime);</span>
<span class="nc" id="L1680">        return AnimationDispatcher.animateFor(lifeTime, _component());</span>
    }

    /**
     *  Use this to schedule and run the provided animation
     *  to be executed on the EDT.
     *  A single animation iteration may be executed multiple times
     *  for the given duration in order to achieve a smooth transition. &lt;br&gt;
     *  Here an example of how to use this method
     *  on a &quot;Save&quot; button:
     *  &lt;pre&gt;{@code
     *  UI.button(&quot;Save&quot;).withPrefSize(400, 400)
     *  .onMouseClick( it -&gt; it
     *    .animateFor(
     *      UI.lifetime(1, TimeUnit.SECONDS)
     *      .startingIn( 0.5, TimeUnit.SECONDS )
     *    )
     *    .go( myAnimation )
     *  )
     *  }&lt;/pre&gt;
     *
     *
     *  @param lifeTime The lifetime of the animation.
     *  @param animation The animation that should be executed.
     */
    public final void animateFor( LifeTime lifeTime, Animation animation ) {
<span class="nc" id="L1706">        Objects.requireNonNull(lifeTime);</span>
<span class="nc" id="L1707">        Objects.requireNonNull(animation);</span>
<span class="nc" id="L1708">        AnimationDispatcher.animateFor(lifeTime, _component()).go(animation);</span>
<span class="nc" id="L1709">    }</span>

    /**
     *  Use this to schedule and run the provided animation
     *  to be executed on the EDT.
     *  A single animation iteration may be executed multiple times
     *  for the given duration in order to achieve a smooth transition.
     *
     *  @param duration The duration of the animation.
     *  @param unit The time unit of the duration.
     *  @param animation The animation that should be executed.
     */
    public final void animateFor( double duration, TimeUnit unit, Animation animation ) {
<span class="fc" id="L1722">        Objects.requireNonNull(unit);</span>
<span class="fc" id="L1723">        Objects.requireNonNull(animation);</span>
<span class="fc" id="L1724">        this.animateFor(duration, unit).go(animation);</span>
<span class="fc" id="L1725">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>