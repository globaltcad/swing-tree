<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDelegate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">AbstractDelegate.java</span></div><h1>AbstractDelegate.java</h1><pre class="source lang-java linenums">package swingtree;

import swingtree.animation.Animator;
import swingtree.animation.Animation;
import swingtree.animation.AnimationState;
import swingtree.animation.LifeTime;
import swingtree.style.ComponentExtension;
import swingtree.api.Painter;
import swingtree.api.Styler;

import javax.swing.*;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *  Extensions of this class delegate a component
 *  as well as provide useful methods for trying the tree of the components
 *  in which the delegated component is contained. &lt;br&gt;
 *  Instances of this class are passed to various user event {@link Action} handlers.
 *  You can use this to change the state of the component, schedule animations
 *  for the component or query the tree of the components.
 *
 * @param &lt;C&gt; The type of the component that is delegated.
 */
abstract class AbstractDelegate&lt;C extends JComponent&gt;
{
    private final GuiTraverser _guiTraverser; // the traverser object that allows us to query the component tree
    private final C _component;

    /**
     * @param component The component that is delegated.
     * @param handle A component that is used as a starting point for traversing the component tree,
     *               usually the same component as the one that is delegated.
     */
<span class="fc" id="L43">    AbstractDelegate( C component, JComponent handle ) {</span>
<span class="fc" id="L44">        _guiTraverser = new GuiTraverser(Objects.requireNonNull(handle));</span>
<span class="fc" id="L45">        _component    = Objects.requireNonNull(component);</span>
<span class="fc" id="L46">    }</span>

<span class="fc" id="L48">    protected C _component() { return _component; }</span>

    protected List&lt;JComponent&gt; _siblingsSource() {
<span class="fc" id="L51">        return Optional.ofNullable(_component.getParent())</span>
<span class="fc" id="L52">                .map(Container::getComponents)</span>
<span class="fc" id="L53">                .map(Arrays::stream)</span>
<span class="fc" id="L54">                .orElseGet(Stream::empty)</span>
<span class="fc" id="L55">                .filter(c -&gt; c instanceof JComponent)</span>
<span class="fc" id="L56">                .map(c -&gt; (JComponent) c)</span>
<span class="fc" id="L57">                .collect(Collectors.toList());</span>
    }

    /**
     *  This is a delegate to the underlying component, but not every method of the component
     *  is delegated. This method allows you to access the underlying component directly.
     *  &lt;p&gt;
     *  Note that this method expects that the accessing thread is the event dispatch thread,
     *  not the application thread.
     *  If you want to access the component from the application thread, you should use &lt;br&gt;
     *  {@code UI.run(() -&gt; delegate.component())}.
     *
     * @return The underlying component.
     */
    public final C get() {
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L73">            throw new IllegalStateException(</span>
                    &quot;You can only access the component from the GUI thread. &quot; +
                    &quot;Use 'UI.run(() -&gt; delegate.component())' to access the component from the application thread.&quot;
                );
<span class="fc" id="L77">        return _component();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently access the x-coordinate of the component relative to its parent.
     *
     * @return The x-coordinate of the component relative to its parent.
     */
<span class="nc" id="L86">    public final int getX() { return _component().getX(); }</span>

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently access the y-coordinate of the component relative to its parent.
     *
     * @return The y-coordinate of the component relative to its parent.
     */
<span class="nc" id="L94">    public final int getY() { return _component().getY(); }</span>

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently access the location of the component relative to its parent
     *  in the form of a {@link Point} object.
     *  The value returned by this method is equal to the value returned by
     *  {@link #getX()} and {@link #getY()}.
     *
     * @return The location of the component relative to its parent.
     */
<span class="nc" id="L105">    public final Point getLocation() { return _component().getLocation(); }</span>

    /**
     *  This is class a delegate API, which means that it represents
     *  the API of a wrapped component. This method allows you to access
     *  the parent of the underlying component.
     *  In essence, this is a delegate to {@link Component#getParent()}. &lt;br&gt;
     *
     * @return The parent {@link Container} of the underlying component.
     */
<span class="nc" id="L115">    public final Container getParent() { return _component().getParent(); }</span>

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param color The color that should be used to paint the background of the component.
     *              If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *              the background color of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackground( Color color ) {
<span class="nc" id="L131">        _component().setBackground(color);</span>
<span class="nc" id="L132">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( double r, double g, double b ) {
<span class="nc" id="L149">        return setBackgroundColor(r, g, b, 1.0);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @param a The alpha component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( double r, double g, double b, double a ) {
<span class="nc" id="L167">        return setBackground(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( int r, int g, int b ) {
<span class="nc" id="L184">        return setBackgroundColor(r, g, b, 255);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the background color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBackground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @param a The alpha component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setBackgroundColor( int r, int g, int b, int a ) {
<span class="nc" id="L202">        return setBackground(new Color(r, g, b, a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the background color of the component.
     *  &lt;p&gt;
     *  See {@link Component#getBackground()} for more information.
     *  &lt;/p&gt;
     *
     * @return The background color of the component.
     */
    public final Color getBackground() {
<span class="nc" id="L215">        return _component().getBackground();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param color The color that should be used to paint the foreground of the component.
     *              If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *              the foreground color of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForeground( Color color ) {
<span class="nc" id="L232">        _component().setForeground(color);</span>
<span class="nc" id="L233">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the foreground color of the component.
     *  &lt;p&gt;
     *  See {@link Component#getForeground()} for more information.
     *  &lt;/p&gt;
     *
     * @return The foreground color of the component.
     */
    public final Color getForeground() {
<span class="nc" id="L246">        return _component().getForeground();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( double r, double g, double b ) {
<span class="nc" id="L263">        return setForegroundColor(r, g, b, 1.0);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as a double between 0 and 1.
     * @param g The green component of the color as a double between 0 and 1.
     * @param b The blue component of the color as a double between 0 and 1.
     * @param a The alpha component of the color as a double between 0 and 1.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( double r, double g, double b, double a ) {
<span class="nc" id="L281">        return setForeground(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( int r, int g, int b ) {
<span class="nc" id="L298">        return setForegroundColor(r, g, b, 255);</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the foreground color of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setForeground(Color)} for more information.
     *  &lt;/p&gt;
     *
     * @param r The red component of the color as an integer between 0 and 255.
     * @param g The green component of the color as an integer between 0 and 255.
     * @param b The blue component of the color as an integer between 0 and 255.
     * @param a The alpha component of the color as an integer between 0 and 255.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setForegroundColor( int r, int g, int b, int a ) {
<span class="nc" id="L316">        return setForeground(new Color(r, g, b, a));</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the font of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setFont(Font)} for more information.
     *  &lt;/p&gt;
     *
     * @param font The font that should be used to paint the text of the component.
     *             If this parameter is &lt;code&gt;null&lt;/code&gt; then this component will inherit
     *             the font of its parent.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setFont( Font font ) {
<span class="nc" id="L333">        _component().setFont(font);</span>
<span class="nc" id="L334">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the font of the component.
     *  &lt;p&gt;
     *  See {@link Component#getFont()} for more information.
     *  &lt;/p&gt;
     *
     * @return The font of the component.
     */
    public final Font getFont() {
<span class="nc" id="L347">        return _component().getFont();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the bounds of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBounds(int, int, int, int)} for more information.
     *  &lt;/p&gt;
     *
     *  @param x The x coordinate of the new location of the component.
     *           This is relative to the component's parent.
     *  @param y The y coordinate of the new location of the component.
     *           This is relative to the component's parent.
     *  @param width The new width of the component.
     *  @param height The new height of the component.
     *  @return The delegate itself, so you can chain calls to this method.
     */
    public final AbstractDelegate&lt;C&gt; setBounds( int x, int y, int width, int height ) {
<span class="nc" id="L367">        _component().setBounds(x, y, width, height);</span>
<span class="nc" id="L368">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the bounds of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link Component#setBounds(Rectangle)} for more information.
     *  &lt;/p&gt;
     *
     *  @param bounds The new bounds of the component.
     *                  This is relative to the component's parent.
     * @return The delegate itself, so you can chain calls to this method.
     */
    public final AbstractDelegate&lt;C&gt; setBounds( Rectangle bounds ) {
<span class="nc" id="L384">        _component().setBounds(bounds);</span>
<span class="nc" id="L385">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the bounds of the component.
     *  &lt;p&gt;
     *  See {@link Component#getBounds()} for more information.
     *  &lt;/p&gt;
     *
     *  @return The bounds of the component.
     *          This is relative to the component's parent.
     */
    public final Rectangle getBounds() {
<span class="nc" id="L399">        return _component().getBounds();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the preferred size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The preferred size of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefSize( Dimension size ) {
<span class="nc" id="L414">        _component().setPreferredSize(size);</span>
<span class="nc" id="L415">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the preferred size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The preferred width of the component.
     *  @param height The preferred height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefSize( int width, int height ) {
<span class="nc" id="L431">        _component().setPreferredSize(new Dimension(width, height));</span>
<span class="nc" id="L432">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the preferred width of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The preferred width of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefWidth( int width ) {
<span class="nc" id="L447">        Dimension size = _component().getPreferredSize();</span>
<span class="nc" id="L448">        _component().setPreferredSize(new Dimension(width, size.height));</span>
<span class="nc" id="L449">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the preferred height of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setPreferredSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The preferred height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setPrefHeight( int height ) {
<span class="nc" id="L464">        Dimension size = _component().getPreferredSize();</span>
<span class="nc" id="L465">        _component().setPreferredSize(new Dimension(size.width, height));</span>
<span class="nc" id="L466">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the preferred size of the component.
     *  The preferred size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getPreferredSize()} for more information.
     *  &lt;/p&gt;
     *  @return The preferred size of the component.
     */
    public final Dimension getPrefSize() {
<span class="nc" id="L479">        return _component().getPreferredSize();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The minimum size of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinSize( Dimension size ) {
<span class="nc" id="L494">        _component().setMinimumSize(size);</span>
<span class="nc" id="L495">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The minimum width of the component.
     *  @param height The minimum height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinSize( int width, int height ) {
<span class="nc" id="L511">        _component().setMinimumSize(new Dimension(width, height));</span>
<span class="nc" id="L512">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum width of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The minimum width of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinWidth( int width ) {
<span class="nc" id="L527">        Dimension size = _component().getMinimumSize();</span>
<span class="nc" id="L528">        _component().setMinimumSize(new Dimension(width, size.height));</span>
<span class="nc" id="L529">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the minimum height of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMinimumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The minimum height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMinHeight( int height ) {
<span class="nc" id="L544">        Dimension size = _component().getMinimumSize();</span>
<span class="nc" id="L545">        _component().setMinimumSize(new Dimension(size.width, height));</span>
<span class="nc" id="L546">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the minimum size of the component.
     *  The minimum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getMinimumSize()} for more information.
     *  &lt;/p&gt;
     *  @return The minimum size of the component.
     */
    public final Dimension getMinSize() {
<span class="nc" id="L559">        return _component().getMinimumSize();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The maximum size of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxSize( Dimension size ) {
<span class="nc" id="L574">        _component().setMaximumSize(size);</span>
<span class="nc" id="L575">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The maximum width of the component.
     *  @param height The maximum height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxSize( int width, int height ) {
<span class="nc" id="L591">        _component().setMaximumSize(new Dimension(width, height));</span>
<span class="nc" id="L592">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum width of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The maximum width of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxWidth( int width ) {
<span class="nc" id="L607">        Dimension size = _component().getMaximumSize();</span>
<span class="nc" id="L608">        _component().setMaximumSize(new Dimension(width, size.height));</span>
<span class="nc" id="L609">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the maximum height of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setMaximumSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The maximum height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setMaxHeight( int height ) {
<span class="nc" id="L624">        Dimension size = _component().getMaximumSize();</span>
<span class="nc" id="L625">        _component().setMaximumSize(new Dimension(size.width, height));</span>
<span class="nc" id="L626">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the maximum size of the component.
     *  The maximum size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getMaximumSize()} for more information.
     *  &lt;/p&gt;
     *  @return The maximum size of the component.
     */
    public final Dimension getMaxSize() {
<span class="nc" id="L639">        return _component().getMaximumSize();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param size The size of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setSize( Dimension size ) {
<span class="nc" id="L654">        _component().setSize(size);</span>
<span class="nc" id="L655">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the size of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The width of the component.
     *  @param height The height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setSize( int width, int height ) {
<span class="nc" id="L671">        _component().setSize(new Dimension(width, height));</span>
<span class="nc" id="L672">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the width of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param width The width of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setWidth( int width ) {
<span class="nc" id="L687">        Dimension size = _component().getSize();</span>
<span class="nc" id="L688">        _component().setSize(new Dimension(width, size.height));</span>
<span class="nc" id="L689">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the height of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#setSize(Dimension)} for more information.
     *  &lt;/p&gt;
     *  @param height The height of the component.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setHeight( int height ) {
<span class="nc" id="L704">        Dimension size = _component().getSize();</span>
<span class="nc" id="L705">        _component().setSize(new Dimension(size.width, height));</span>
<span class="nc" id="L706">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the size of the component.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The size of the component.
     */
    public final Dimension getSize() {
<span class="nc" id="L719">        return _component().getSize();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the width of the component.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The width of the component.
     */
    public final int getWidth() {
<span class="nc" id="L732">        return _component().getSize().width;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the height of the component.
     *  The size is used by the layout manager to determine the size of the component.
     *  &lt;p&gt;
     *  See {@link Component#getSize()} for more information.
     *  &lt;/p&gt;
     *  @return The height of the component.
     */
    public final int getHeight() {
<span class="nc" id="L745">        return _component().getSize().height;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the {@link UI.Cursor} of the component.
     *
     * @param cursor The {@link UI.Cursor} which should be set.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setCursor( UI.Cursor cursor ) {
<span class="nc" id="L756">        _component().setCursor(Cursor.getPredefinedCursor(cursor.type));</span>
<span class="nc" id="L757">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the {@link Cursor} of the component.
     * @param cursor The {@link Cursor} which should be set.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setCursor( Cursor cursor ) {
<span class="nc" id="L767">        _component().setCursor(cursor);</span>
<span class="nc" id="L768">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the {@link Cursor} of the component.
     * @return The {@link Cursor} of the component.
     */
    public final Cursor getCursor() {
<span class="nc" id="L777">        return _component().getCursor();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently set the tooltip of the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setToolTipText(String)} for more information.
     *  &lt;/p&gt;
     * @param text  The tooltip text.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setTooltip( String text ) {
<span class="nc" id="L791">        _component().setToolTipText(text);</span>
<span class="nc" id="L792">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently get the tooltip of the component.
     *  &lt;p&gt;
     *  See {@link JComponent#getToolTipText()} for more information.
     *  &lt;/p&gt;
     * @return The tooltip text.
     */
    public final String getTooltip() {
<span class="nc" id="L804">        return _component().getToolTipText();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently enable or disable the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setEnabled(boolean)} for more information.
     *  &lt;/p&gt;
     *  @param enabled True if the component should be enabled, false otherwise.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setEnabled( boolean enabled ) {
<span class="nc" id="L818">        _component().setEnabled(enabled);</span>
<span class="nc" id="L819">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is enabled.
     *  &lt;p&gt;
     *  See {@link JComponent#isEnabled()} for more information.
     *  &lt;/p&gt;
     *  @return True if the component is enabled, false otherwise.
     */
    public final boolean isEnabled() {
<span class="nc" id="L831">        return _component().isEnabled();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently enable or disable the component.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setVisible(boolean)} for more information.
     *  &lt;/p&gt;
     *  @param visible True if the component should be visible, false otherwise.
     *  @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setVisible( boolean visible ) {
<span class="nc" id="L845">        _component().setVisible(visible);</span>
<span class="nc" id="L846">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is visible.
     *  &lt;p&gt;
     *  See {@link JComponent#isVisible()} for more information.
     *  &lt;/p&gt;
     *  @return True if the component is visible, false otherwise.
     */
    public final boolean isVisible() {
<span class="nc" id="L858">        return _component().isVisible();</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently make the component opaque or transparent.
     *  This method returns the delegate itself, so you can chain calls to this method.
     *  &lt;p&gt;
     *  See {@link JComponent#setOpaque(boolean)} for more information.
     *  &lt;/p&gt;
     * @param opaque True if the component should be opaque, false otherwise.
     * @return The delegate itself.
     */
    public final AbstractDelegate&lt;C&gt; setOpaque( boolean opaque ) {
<span class="nc" id="L872">        _component().setOpaque(opaque);</span>
<span class="nc" id="L873">        return this;</span>
    }

    /**
     *  As a delegate to the underlying component, you can use this method to
     *  conveniently check if the component is opaque.
     *  &lt;p&gt;
     *  See {@link JComponent#isOpaque()} for more information.
     *  &lt;/p&gt;
     * @return True if the component is opaque, false otherwise.
     */
    public final boolean isOpaque() {
<span class="nc" id="L885">        return _component().isOpaque();</span>
    }

    /**
     *  Use this to query the UI tree and find any {@link JComponent}
     *  of a particular type and id (the name of the component).
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param id The ide of the {@link JComponent} which should be found in the swing tree.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, String id ) {
<span class="fc" id="L898">        return this.find( type, c -&gt; Objects.equals(c.getName(), id) );</span>
    }

    /**
     *  Use this to query the UI tree and find any {@link JComponent}
     *  of a particular type and id (the name of the component).
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param id The ide of the {@link JComponent} which should be found in the swing tree.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, Enum&lt;?&gt; id ) {
<span class="nc" id="L911">        return this.find( type, id.getClass().getSimpleName() + &quot;.&quot; + id.name() );</span>
    }

    /**
     *  Use this to query the UI tree and find any {@link JComponent}
     *  based on a specific type and a predicate which is used to test
     *  if a particular component in the tree is the one you are looking for.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param predicate The predicate which should be used to test the {@link JComponent}.
     * @return An {@link Optional} instance which may or may not contain the requested component.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; OptionalUI&lt;T&gt; find( Class&lt;T&gt; type, Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L925">        return _guiTraverser.find(type, predicate)</span>
<span class="fc" id="L926">                .findFirst()</span>
<span class="fc" id="L927">                .map(OptionalUI::ofNullable)</span>
<span class="fc" id="L928">                .orElse(OptionalUI.empty());</span>
    }

    /**
     *  Use this to query the UI tree and find all {@link JComponent}s
     *  based on a specific type and a predicate which is used to test
     *  if a particular component in the tree is the one you are looking for.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param predicate The predicate which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and predicate.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAll( Class&lt;T&gt; type, Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L942">        return _guiTraverser.find(type, predicate).collect(Collectors.toList());</span>
    }

    /**
     *  Use this to query the UI tree and find all {@link JComponent}s
     *  of a particular type and also that belong to a particular style group.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param group The style group which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and group.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAllByGroup( Class&lt;T&gt; type, String group ) {
<span class="fc" id="L955">        return this.findAll( type, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  Use this to query the UI tree and find all {@link JComponent}s
     *  that belong to a particular style group.
     *
     * @param group The style group which should be used to check if a particular {@link JComponent} belongs to it.
     * @return A list of {@link JComponent} instances which all have the given style group.
     */
    public final List&lt;JComponent&gt; findAllByGroup( String group ) {
<span class="nc" id="L966">        return this.findAll( JComponent.class, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }


    /**
     *  Use this to query the UI tree and find all {@link JComponent}s
     *  of a particular type and also that belong to a particular style group.
     *
     * @param type The {@link JComponent} type which should be found in the swing tree.
     * @param group The style group which should be used to test the {@link JComponent}.
     * @return A list of {@link JComponent} instances which match the given type and predicate.
     * @param &lt;T&gt; The type parameter of the component which should be found.
     */
    public final &lt;T extends JComponent&gt; List&lt;T&gt; findAllByGroup( Class&lt;T&gt; type, Enum&lt;?&gt; group ) {
<span class="nc" id="L980">        return this.findAll( type, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  Use this to query the UI tree and find all {@link JComponent}s
     *  that belong to a particular style group.
     *
     * @param group The style group which should be used to check if a particular {@link JComponent} belongs to it.
     * @return A list of {@link JComponent} instances which all have the given style group.
     */
    public final List&lt;JComponent&gt; findAllByGroup( Enum&lt;?&gt; group ) {
<span class="nc" id="L991">        return this.findAll( JComponent.class, c -&gt; ComponentExtension.from(c).belongsToGroup(group) );</span>
    }

    /**
     *  A common use case is to render something on top of the component
     *  using the {@link Graphics2D} instance of the component.
     *  This method allows you to attach a paint task to the component, which
     *  the EDT will process in the next repaint event cycle, and remove when the animation expires.
     *  This ensures that custom rendering
     *  is not erased by a potential repaint of the component after a user event.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy button animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, state -&gt; {
     *          double r = 300 * state.progress() * it.scale();
     *          double x = it.mouseX() - r / 2;
     *          double y = it.mouseY() - r / 2;
     *          it.paint(state, g -&gt; {
     *              g.setColor(new Color(1f, 1f, 0f, (float) (1 - state.progress())));
     *              g.fillOval((int) x, (int) y, (int) r, (int) r);
     *          });
     *      }))
     *  }&lt;/pre&gt;
     *
     * @param state The current animation state, which is important so that the rendering can be synchronized with the animation.
     * @param painter The rendering task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void paint( AnimationState state, Painter painter ) {
<span class="nc" id="L1020">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the rendering later in the paint method of a custom border implementation!
<span class="nc" id="L1022">            ComponentExtension.from(_component).addAnimationPainter(state, painter);</span>
<span class="nc" id="L1023">        });</span>
<span class="nc" id="L1024">    }</span>

    /**
     *  A common use case is to style the component based on the current animation state.
     *  This method allows you to dispatch a styling task to the EDT
     *  which will be executed before the next component repaint.
     *  Because animation styles are applied last, it is guaranteed not to be overwritten by
     *  other styles.
     *  The provided styling will be removed when the animation expires.
     *  &lt;p&gt;
     *  Here is an example of how to use this method as part of a fancy styling animation:
     *  &lt;pre&gt;{@code
     *      UI.button(&quot;Click me&quot;).withPrefSize(400, 400)
     *      .onMouseClick( it -&gt; it.animateFor(2, TimeUnit.SECONDS, state -&gt; {
     *          it.style(state, style -&gt; style
     *              .borderWidth((int)(10 * state.progress()))
     *              .borderColor(new Color(1f, 1f, 0f, (float) (1 - state.progress())))
     *              .borderRadius((int)(100 * state.progress()))
     *          );
     *      }))
     *  }&lt;/pre&gt;
     *
     * @param state The current animation state, which is important so that the styling can be synchronized with the animation.
     * @param styler The styling task which should be executed on the EDT at the end of the current event cycle.
     */
    public final void style( AnimationState state, Styler&lt;C&gt; styler ) {
<span class="fc" id="L1050">        UI.run(()-&gt;{ // This method might be called by the application thread, so we need to run on the EDT!</span>
            // We do the styling later in the paint method of a custom border implementation!
<span class="fc" id="L1052">            ComponentExtension.from(_component).addAnimationStyler(state, styler);</span>
<span class="fc" id="L1053">        });</span>
<span class="fc" id="L1054">    }</span>

    /**
     *  Exposes access the animation builder API, where you can define the conditions
     *  under which the animation should be executed and then dispatch the animation to the EDT
     *  through the {@link Animator#go(Animation)} method.
     *
     *  @param duration The duration of the animation.
     *  @param unit The time unit of the duration.
     *  @return An {@link Animator} instance which can be used to define how the animation should be executed.
     */
    public final Animator animateFor( double duration, TimeUnit unit ) {
<span class="fc" id="L1066">        return Animator.animateFor(LifeTime.of(duration, unit), _component());</span>
    }

    /**
     *  Exposes access the animation builder API, where you can define the conditions
     *  under which the animation should be executed and then dispatch the animation to the EDT
     *  through the {@link Animator#go(Animation)} method.
     *
     *  @param lifeTime The lifetime of the animation.
     *  @return An {@link Animator} instance which can be used to define how the animation should be executed.
     */
    public final Animator animateFor( LifeTime lifeTime ) {
<span class="nc" id="L1078">        return Animator.animateFor(lifeTime, _component());</span>
    }

    /**
     *  Use this to schedule and run the provided animation
     *  to be executed on the EDT.
     *  A single animation iteration may be executed multiple times
     *  for the given duration in order to achieve a smooth transition. &lt;br&gt;
     *  Here an example of how to use this method
     *  on a &quot;Save&quot; button:
     *  &lt;pre&gt;{@code
     *  UI.button(&quot;Save&quot;).withPrefSize(400, 400)
     *  .onMouseClick( it -&gt; it
     *    .animateFor(
     *      UI.lifetime(1, TimeUnit.SECONDS)
     *      .startingIn( 0.5, TimeUnit.SECONDS )
     *    )
     *    .go( myAnimation )
     *  )
     *  }&lt;/pre&gt;
     *
     *
     *  @param lifeTime The lifetime of the animation.
     *  @param animation The animation that should be executed.
     */
    public final void animateFor( LifeTime lifeTime, Animation animation ) {
<span class="nc" id="L1104">        Animator.animateFor(lifeTime, _component()).go(animation);</span>
<span class="nc" id="L1105">    }</span>

    /**
     *  Use this to schedule and run the provided animation
     *  to be executed on the EDT.
     *  A single animation iteration may be executed multiple times
     *  for the given duration in order to achieve a smooth transition.
     *
     *  @param duration The duration of the animation.
     *  @param unit The time unit of the duration.
     *  @param animation The animation that should be executed.
     */
    public final void animateFor( double duration, TimeUnit unit, Animation animation ) {
<span class="fc" id="L1118">        this.animateFor(duration, unit).go(animation);</span>
<span class="fc" id="L1119">    }</span>

    /**
     *  The number returned by this method is used to scale the UI
     *  to ensure that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  Use it inside custom {@link Painter} implementations (see {@link #paint(AnimationState, Painter)})
     *  to scale custom {@link Graphics2D} painting operations.
     *
     * @return The current UI scale factor, which is used to scale the UI
     *         for high resolution displays (high dots-per-inch, or DPI).
     */
<span class="nc" id="L1130">    public float getScale() { return UI.scale(); }</span>

    /**
     *  The number returned by this method is used to scale the UI
     *  to ensure that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  Use it inside custom {@link Painter} implementations (see {@link #paint(AnimationState, Painter)})
     *  to scale custom {@link Graphics2D} painting operations.
     *
     * @return The current UI scale factor, which is used to scale the UI
     *         for high resolution displays (high dots-per-inch, or DPI).
     */
<span class="nc" id="L1141">    public float scale() { return UI.scale(); }</span>

    /**
     *  Use this method inside custom {@link Painter} implementations (see {@link #paint(AnimationState, Painter)})
     *  to scale an {@code int} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code int} value to scale.
     *  @return The scaled {@code int} value.
     */
<span class="nc" id="L1150">    public int scale( int value ) { return UI.scale(value); }</span>

    /**
     *  Use this method inside custom {@link Painter} implementations (see {@link #paint(AnimationState, Painter)})
     *  to scale a {@code float} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code float} value to scale.
     *  @return The scaled {@code float} value.
     */
<span class="nc" id="L1159">    public float scale( float value ) { return UI.scale(value); }</span>

    /**
     *  Use this method inside custom {@link Painter} implementations (see {@link #paint(AnimationState, Painter)})
     *  to scale a {@code double} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code double} value to scale.
     *  @return The scaled {@code double} value.
     */
<span class="nc" id="L1168">    public double scale( double value ) { return UI.scale(value); }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>