<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForScrollPanels.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForScrollPanels.java</span></div><h1>UIForScrollPanels.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.*;
import sprouts.impl.SequenceDiff;
import sprouts.impl.SequenceDiffOwner;
import swingtree.api.mvvm.EntryViewModel;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.components.JScrollPanels;
import swingtree.layout.AddConstraint;

import javax.swing.*;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

/**
 *  A builder node for {@link JScrollPanels}, a custom SwingTree component,
 *  which is similar to a {@link JList} but with the ability to interact with
 *  the individual components in the list.
 *
 * @param &lt;P&gt; The type of the component which this builder node wraps.
 * @author Daniel Nepp
 */
public class UIForScrollPanels&lt;P extends JScrollPanels&gt; extends UIForAnyScrollPane&lt;UIForScrollPanels&lt;P&gt;, P&gt;
{
<span class="fc" id="L33">    private static final Logger log = LoggerFactory.getLogger(UIForScrollPanels.class);</span>
    private final BuilderState&lt;P&gt; _state;

    /**
     * Extensions of the {@link  UIForAnySwing} always wrap
     * a single component for which they are responsible.
     *
     * @param state The {@link BuilderState} modelling how the underlying component is build.
     */
<span class="fc" id="L42">    protected UIForScrollPanels( BuilderState&lt;P&gt; state ) {</span>
<span class="fc" id="L43">        Objects.requireNonNull(state);</span>
<span class="fc" id="L44">        _state = state;</span>
<span class="fc" id="L45">    }</span>

    @Override
    protected BuilderState&lt;P&gt; _state() {
<span class="fc" id="L49">        return _state;</span>
    }

    @Override
    protected UIForScrollPanels&lt;P&gt; _newBuilderWithState( BuilderState&lt;P&gt; newState ) {
<span class="fc" id="L54">        return new UIForScrollPanels&lt;&gt;(newState);</span>
    }

    @Override
    protected void _addComponentTo(P thisComponent, JComponent addedComponent, @Nullable AddConstraint constraints) {
<span class="fc" id="L59">        Objects.requireNonNull(addedComponent);</span>

<span class="fc" id="L61">        EntryViewModel entry = _entryModel();</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if ( constraints == null )</span>
<span class="fc" id="L63">            thisComponent.addEntry( entry, m -&gt; UI.of(addedComponent) );</span>
        else
<span class="nc" id="L65">            thisComponent.addEntry( constraints, entry, m -&gt; UI.of(addedComponent) );</span>
<span class="fc" id="L66">    }</span>

    private static EntryViewModel _entryModel() {
<span class="fc" id="L69">        Var&lt;Boolean&gt; selected = Var.of(false);</span>
<span class="fc" id="L70">        Var&lt;Integer&gt; position = Var.of(0);</span>
<span class="fc" id="L71">        return new EntryViewModel() {</span>
<span class="fc" id="L72">            @Override public Var&lt;Boolean&gt; isSelected() { return selected; }</span>
<span class="fc" id="L73">            @Override public Var&lt;Integer&gt; position() { return position; }</span>
        };
    }

    private static &lt;M&gt; M _modelFetcher(int i, Vals&lt;M&gt; vals) {
<span class="fc" id="L78">        M v = vals.at(i).get();</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if ( v instanceof EntryViewModel ) ((EntryViewModel) v).position().set(i);</span>
<span class="fc" id="L80">        return v;</span>
    }

    private static &lt;M&gt; M _entryFetcher(int i, Vals&lt;M&gt; vals) {
<span class="fc" id="L84">        M v = _modelFetcher(i, vals);</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        return ( v != null ? (M) v : (M)_entryModel() );</span>
    }

    @Override
    protected &lt;M&gt; void _addViewableProps(
            Vals&lt;M&gt; models, @Nullable AddConstraint attr, ModelToViewConverter&lt;M&gt; viewSupplier, P thisComponent
    ) {
<span class="fc" id="L92">        BiConsumer&lt;Integer, Vals&lt;M&gt;&gt; addAllAt = (index, vals) -&gt; {</span>
<span class="fc" id="L93">            boolean allAreEntries = vals.stream().allMatch( v -&gt; v instanceof EntryViewModel );</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if ( allAreEntries ) {</span>
<span class="fc" id="L95">                List&lt;EntryViewModel&gt; entries = (List) vals.toList();</span>
<span class="fc" id="L96">                thisComponent.addAllEntriesAt(index, attr, entries, (ViewSupplier&lt;EntryViewModel&gt;) viewSupplier);</span>
<span class="fc" id="L97">            }</span>
            else
<span class="fc bfc" id="L99" title="All 2 branches covered.">                for ( int i = 0; i&lt; vals.size(); i++ ) {</span>
<span class="fc" id="L100">                    int finalI = i;</span>
<span class="fc" id="L101">                    thisComponent.addEntryAt(</span>
<span class="fc" id="L102">                            finalI + index, attr,</span>
<span class="fc" id="L103">                            _entryModel(),</span>
<span class="fc" id="L104">                            m -&gt; viewSupplier.createViewFor(_entryFetcher(finalI,vals))</span>
                        );
                }
<span class="fc" id="L107">        };</span>

<span class="fc" id="L109">        _onShow( models, thisComponent, (c, delegate) -&gt; {</span>
<span class="fc" id="L110">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L111">            Tuple&lt;M&gt; tupleOfModels = Tuple.of(delegate.currentValues().type(), delegate.currentValues());</span>
<span class="fc" id="L112">            int delegateIndex = delegate.index().orElse(-1);</span>
<span class="fc" id="L113">            SequenceChange changeType = delegate.change();</span>
<span class="fc" id="L114">            int removeCount = delegate.oldValues().size();</span>
<span class="fc" id="L115">            int addCount = delegate.newValues().size();</span>
<span class="fc" id="L116">            int maxChange = Math.max(removeCount, addCount);</span>
<span class="fc" id="L117">            _update(c, attr, changeType, delegateIndex, maxChange, tupleOfModels, viewSupplier);</span>
<span class="fc" id="L118">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L119">        });</span>
<span class="fc" id="L120">        addAllAt.accept(0,models);</span>
<span class="fc" id="L121">    }</span>

    private static &lt;M&gt; M _modelFetcher(int i, Tuple&lt;M&gt; tuple) {
<span class="fc" id="L124">        M v = tuple.get(i);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if ( v instanceof EntryViewModel ) ((EntryViewModel) v).position().set(i);</span>
<span class="fc" id="L126">        return v;</span>
    }

    private static &lt;M&gt; M _entryFetcher(int i, Tuple&lt;M&gt; tuple) {
<span class="fc" id="L130">        M v = _modelFetcher(i, tuple);</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        return ( v != null ? (M) v : (M)_entryModel() );</span>
    }

    private &lt;M&gt; void _addAllEntriesAt(
            @Nullable AddConstraint attr,
            JScrollPanels thisComponent,
            int index,
            Iterable&lt;M&gt; iterable,
            ViewSupplier&lt;M&gt; viewSupplier
    ) {
<span class="fc" id="L141">        boolean allAreEntries = StreamSupport.stream(iterable.spliterator(), false).allMatch( v -&gt; v instanceof EntryViewModel );</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if ( allAreEntries ) {</span>
<span class="fc" id="L143">            List&lt;EntryViewModel&gt; entries = StreamSupport.stream(iterable.spliterator(), false).map(v -&gt; (EntryViewModel)v).collect(Collectors.toList());</span>
<span class="fc" id="L144">            thisComponent.addAllEntriesAt(index, attr, entries, (ViewSupplier&lt;EntryViewModel&gt;) viewSupplier);</span>
<span class="fc" id="L145">        }</span>
        else {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            Tuple&lt;M&gt; tuple = (iterable instanceof Tuple) ? (Tuple&lt;M&gt;) iterable : (Tuple&lt;M&gt;) Tuple.of(Object.class, (Iterable&lt;Object&gt;) iterable);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for ( int i = 0; i&lt; tuple.size(); i++ ) {</span>
<span class="fc" id="L149">                int finalI = i;</span>
<span class="fc" id="L150">                thisComponent.addEntryAt(</span>
                    i + index, attr,
<span class="fc" id="L152">                    _entryModel(),</span>
<span class="fc" id="L153">                    m -&gt; viewSupplier.createViewFor(_entryFetcher(finalI,tuple))</span>
                );
            }
        }
<span class="fc" id="L157">    }</span>

    private &lt;M&gt; void _addAllEntriesAt(
            @Nullable AddConstraint attr,
            JScrollPanels thisComponent,
            int index,
            Tuple&lt;M&gt; models,
            Function&lt;Integer, ViewHandle&lt;M&gt;&gt; lensSupplier,
            ViewSupplier&lt;ViewHandle&lt;M&gt;&gt; viewSupplier
    ) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for ( int i = 0; i&lt; models.size(); i++ ) {</span>
<span class="fc" id="L168">            ViewHandle&lt;M&gt; viewable = lensSupplier.apply(index+i);</span>
<span class="fc" id="L169">            thisComponent.addEntryAt(</span>
                    i + index, attr,
<span class="fc" id="L171">                    _entryModel(),</span>
<span class="fc" id="L172">                    m -&gt; viewSupplier.createViewFor(viewable)</span>
            );
        }
<span class="fc" id="L175">    }</span>

    private &lt;M&gt; void _setAllEntriesAt(
        @Nullable AddConstraint attr,
        JScrollPanels thisComponent,
        int index,
        Iterable&lt;M&gt; iterable,
        ViewSupplier&lt;M&gt; viewSupplier
    ) {
<span class="fc" id="L184">        boolean allAreEntries = StreamSupport.stream(iterable.spliterator(), false).allMatch( v -&gt; v instanceof EntryViewModel );</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if ( allAreEntries ) {</span>
<span class="fc" id="L186">            List&lt;EntryViewModel&gt; entries = StreamSupport.stream(iterable.spliterator(), false).map(v -&gt; (EntryViewModel)v).collect(Collectors.toList());</span>
<span class="fc" id="L187">            thisComponent.setAllEntriesAt(index, attr, entries, (ViewSupplier&lt;EntryViewModel&gt;) viewSupplier);</span>
<span class="fc" id="L188">        }</span>
        else {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            Tuple&lt;M&gt; tuple = (iterable instanceof Tuple) ? (Tuple&lt;M&gt;) iterable : (Tuple&lt;M&gt;) Tuple.of(Object.class, (Iterable&lt;Object&gt;) iterable);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            for (int i = 0; i &lt; tuple.size(); i++) {</span>
<span class="fc" id="L192">                int finalI = i;</span>
<span class="fc" id="L193">                thisComponent.setEntryAt(</span>
                    i + index, attr,
<span class="fc" id="L195">                    _entryModel(),</span>
<span class="fc" id="L196">                    m -&gt; viewSupplier.createViewFor(_entryFetcher(finalI, tuple))</span>
                );
            }
        }
<span class="fc" id="L200">    }</span>

    private &lt;M&gt; void _setAllEntriesAt(
            @Nullable AddConstraint attr,
            JScrollPanels thisComponent,
            int index,
            int size,
            Function&lt;Integer, ViewHandle&lt;M&gt;&gt; lensSupplier,
            ViewSupplier&lt;ViewHandle&lt;M&gt;&gt; viewSupplier
    ) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L211">            ViewHandle&lt;M&gt; viewable = lensSupplier.apply(index+i);</span>
<span class="fc" id="L212">            thisComponent.setEntryAt(</span>
                    i + index, attr,
<span class="fc" id="L214">                    _entryModel(),</span>
<span class="fc" id="L215">                    m -&gt; viewSupplier.createViewFor(viewable)</span>
            );
        }
<span class="fc" id="L218">    }</span>

    @Override
    protected &lt;M&gt; void _addViewableProps(
            Val&lt;Tuple&lt;M&gt;&gt; models, 
            @Nullable AddConstraint attr, 
            ModelToViewConverter&lt;M&gt; viewSupplier,
            P thisComponent 
    ) {
<span class="fc" id="L227">        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (models.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L229">            lastDiffRef.set(((SequenceDiffOwner)models.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L230">        _onShow( models, thisComponent, (c, tupleOfModels) -&gt; {</span>
<span class="fc" id="L231">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L232">            SequenceDiff diff = null;</span>
<span class="fc" id="L233">            SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            if (tupleOfModels instanceof SequenceDiffOwner)</span>
<span class="fc" id="L235">                diff = ((SequenceDiffOwner)tupleOfModels).differenceFromPrevious().orElse(null);</span>
<span class="fc" id="L236">            lastDiffRef.set(diff);</span>

<span class="pc bpc" id="L238" title="2 of 6 branches missed.">            if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) ) {</span>
<span class="fc" id="L239">                c.removeAllEntries();</span>
<span class="fc" id="L240">                _addAllEntriesAt(attr, c, 0, tupleOfModels, viewSupplier);</span>
            } else {
<span class="fc" id="L242">                int index = diff.index().orElse(-1);</span>
<span class="fc" id="L243">                int count = diff.size();</span>
<span class="fc" id="L244">                _update(c, attr, diff.change(), index, count, tupleOfModels, viewSupplier);</span>
            }
<span class="fc" id="L246">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L247">        });</span>
<span class="fc" id="L248">        models.ifPresent( (tupleOfModels) -&gt; {</span>
<span class="fc" id="L249">            thisComponent.removeAllEntries();</span>
<span class="fc" id="L250">            _addAllEntriesAt(attr, thisComponent, 0, tupleOfModels, viewSupplier);</span>
<span class="fc" id="L251">        });</span>
<span class="fc" id="L252">    }</span>

    @Override
    protected &lt;M&gt; void _addViewableProps(
            Var&lt;Tuple&lt;M&gt;&gt; propertyOfModels,
            @Nullable AddConstraint attr,
            ModelToViewConverter&lt;ViewHandle&lt;M&gt;&gt; viewSupplier,
            P scrollPanels
    ) {
<span class="fc" id="L261">        Function&lt;Integer, ViewHandle&lt;M&gt;&gt; lensSupplier = index -&gt; ViewHandle.of(propertyOfModels, index, scrollPanels);</span>
<span class="fc" id="L262">        AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (propertyOfModels.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L264">            lastDiffRef.set(((SequenceDiffOwner)propertyOfModels.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L265">        _onShowDelegated( propertyOfModels, scrollPanels, (thisComponent, delegate) -&gt; {</span>
<span class="fc" id="L266">            Tuple&lt;M&gt; oldModels = delegate.oldValue().orElseThrowUnchecked();</span>
<span class="fc" id="L267">            Tuple&lt;M&gt; newModels = delegate.currentValue().orElseThrowUnchecked();</span>
<span class="fc" id="L268">            viewSupplier.rememberCurrentViewsForReuse();</span>
<span class="fc" id="L269">            SequenceDiff diff = null;</span>
<span class="fc" id="L270">            SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">            if (newModels instanceof SequenceDiffOwner &amp;&amp; oldModels instanceof SequenceDiffOwner) {</span>
<span class="fc" id="L272">                diff = ((SequenceDiffOwner)newModels).differenceFromPrevious().orElse(null);</span>
            }
<span class="fc" id="L274">            lastDiffRef.set(diff);</span>

<span class="pc bpc" id="L276" title="2 of 6 branches missed.">            if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) ) {</span>
<span class="fc" id="L277">                thisComponent.removeAllEntries();</span>
<span class="fc" id="L278">                _addAllEntriesAt(attr, thisComponent, 0, newModels, lensSupplier, viewSupplier);</span>
            } else {
<span class="fc" id="L280">                int index = diff.index().orElse(-1);</span>
<span class="fc" id="L281">                int count = diff.size();</span>
<span class="fc" id="L282">                _update(thisComponent, attr, diff.change(), index, count, newModels, lensSupplier, viewSupplier);</span>
            }
<span class="fc" id="L284">            viewSupplier.clearCurrentViews();</span>
<span class="fc" id="L285">        });</span>
<span class="fc" id="L286">        propertyOfModels.ifPresent( (tupleOfModels) -&gt; {</span>
<span class="fc" id="L287">            scrollPanels.removeAllEntries();</span>
<span class="fc" id="L288">            _addAllEntriesAt(attr, scrollPanels, 0, tupleOfModels, lensSupplier, viewSupplier);</span>
<span class="fc" id="L289">        });</span>
<span class="fc" id="L290">    }</span>

    private &lt;M&gt; void _update(
            P c,
            @Nullable AddConstraint attr,
            SequenceChange change,
            int index,
            int count,
            Tuple&lt;M&gt; tupleOfModels,
            ModelToViewConverter&lt;M&gt; viewSupplier
    ) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if ( index &lt; 0 ) {</span>
            // We do a simple re-build
<span class="fc" id="L303">            c.removeAllEntries();</span>
<span class="fc" id="L304">            _addAllEntriesAt(attr, c, 0, tupleOfModels, viewSupplier);</span>
        } else {
<span class="pc bpc" id="L306" title="2 of 7 branches missed.">            switch (change) {</span>
                case SET:
<span class="fc" id="L308">                    Tuple&lt;M&gt; slice = tupleOfModels.sliceAt(index, count);</span>
<span class="fc" id="L309">                    _setAllEntriesAt(attr, c, index, slice, viewSupplier);</span>
<span class="fc" id="L310">                    break;</span>
                case ADD:
<span class="fc" id="L312">                    _addAllEntriesAt(attr, c, index, tupleOfModels.sliceAt(index, count), viewSupplier);</span>
<span class="fc" id="L313">                    break;</span>
                case REMOVE:
<span class="fc" id="L315">                    c.removeEntriesAt(index, count);</span>
<span class="fc" id="L316">                    break;</span>
                case RETAIN: // Only keep the elements in the range.
                    // Remove trailing components:
<span class="fc" id="L319">                    c.removeEntriesAt(index + count, c.getNumberOfEntries() - (index + count));</span>
                    // Remove leading components:
<span class="fc" id="L321">                    c.removeEntriesAt(0, index);</span>
<span class="fc" id="L322">                    break;</span>
                case CLEAR:
<span class="fc" id="L324">                    c.removeAllEntries();</span>
<span class="fc" id="L325">                    break;</span>
                case NONE:
<span class="nc" id="L327">                    break;</span>
                default:
<span class="nc" id="L329">                    log.error(&quot;Unknown change type: {}&quot;, change, new Throwable());</span>
                    // We do a simple rebuild:
<span class="nc" id="L331">                    c.removeAllEntries();</span>
<span class="nc" id="L332">                    _addAllEntriesAt(attr, c, 0, tupleOfModels, viewSupplier);</span>
            }
        }
<span class="fc" id="L335">    }</span>

    private &lt;M&gt; void _update(
            P c,
            @Nullable AddConstraint attr,
            SequenceChange change,
            int index,
            int count,
            Tuple&lt;M&gt; newModels,
            Function&lt;Integer, ViewHandle&lt;M&gt;&gt; lensSupplier,
            ModelToViewConverter&lt;ViewHandle&lt;M&gt;&gt; viewSupplier
    ) {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if ( index &lt; 0 ) {</span>
            // We do a simple re-build
<span class="nc" id="L349">            c.removeAllEntries();</span>
<span class="nc" id="L350">            _addAllEntriesAt(attr, c, 0, newModels, lensSupplier, viewSupplier);</span>
        } else {
<span class="pc bpc" id="L352" title="2 of 7 branches missed.">            switch (change) {</span>
                case SET:
<span class="fc" id="L354">                    _setAllEntriesAt(attr, c, index, count, lensSupplier, viewSupplier);</span>
<span class="fc" id="L355">                    break;</span>
                case ADD:
<span class="fc" id="L357">                    _addAllEntriesAt(attr, c, index, newModels.sliceAt(index, count), lensSupplier, viewSupplier);</span>
<span class="fc" id="L358">                    break;</span>
                case REMOVE:
<span class="fc" id="L360">                    c.removeEntriesAt(index, count);</span>
<span class="fc" id="L361">                    break;</span>
                case RETAIN: // Only keep the elements in the range.
                    // Remove trailing components:
<span class="fc" id="L364">                    c.removeEntriesAt(index + count, c.getNumberOfEntries() - (index + count));</span>
                    // Remove leading components:
<span class="fc" id="L366">                    c.removeEntriesAt(0, index);</span>
<span class="fc" id="L367">                    break;</span>
                case CLEAR:
<span class="fc" id="L369">                    c.removeAllEntries();</span>
<span class="fc" id="L370">                    break;</span>
                case NONE:
<span class="nc" id="L372">                    break;</span>
                default:
<span class="nc" id="L374">                    log.error(&quot;Unknown change type: {}&quot;, change, new Throwable());</span>
                    // We do a simple rebuild:
<span class="nc" id="L376">                    c.removeAllEntries();</span>
<span class="nc" id="L377">                    _addAllEntriesAt(attr, c, 0, newModels, lensSupplier, viewSupplier);</span>
            }
        }
<span class="fc" id="L380">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>