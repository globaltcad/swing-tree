<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForTabbedPane.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForTabbedPane.java</span></div><h1>UIForTabbedPane.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.Action;
import sprouts.*;
import sprouts.impl.SequenceDiff;
import sprouts.impl.SequenceDiffOwner;
import swingtree.api.mvvm.TabSupplier;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.Color;
import java.awt.Component;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 *  A SwingTree builder node designed for configuring {@link JTabbedPane} instances.
 *
 * @param &lt;P&gt; The type of the {@link JTabbedPane} instance that this builder node configures.
 */
public final class UIForTabbedPane&lt;P extends JTabbedPane&gt; extends UIForAnySwing&lt;UIForTabbedPane&lt;P&gt;, P&gt;
{
<span class="fc" id="L36">    private static final Logger log = LoggerFactory.getLogger(UIForTabbedPane.class);</span>

<span class="fc" id="L38">    private static final Tab TAB_ERROR = UI.tab(&quot;Error Tab&quot;);</span>
<span class="fc" id="L39">    private static final Tab TAB_NULL = UI.tab(&quot;Empty Tab&quot;);</span>

    private final BuilderState&lt;P&gt; _state;

    /**
     * {@link UIForAnySwing} (sub)types always wrap
     * a single component for which they are responsible.
     *
     * @param state The {@link BuilderState} modelling how the component is built.
     */
<span class="fc" id="L49">    UIForTabbedPane( BuilderState&lt;P&gt; state ) {</span>
<span class="fc" id="L50">        Objects.requireNonNull(state);</span>
<span class="fc" id="L51">        _state = state.withMutator(thisComponent -&gt; {</span>
<span class="fc" id="L52">            thisComponent.setModel(ExtraState.of(thisComponent));</span>
<span class="fc" id="L53">        });</span>
<span class="fc" id="L54">    }</span>

    @Override
    protected BuilderState&lt;P&gt; _state() {
<span class="fc" id="L58">        return _state;</span>
    }

    @Override
    protected UIForTabbedPane&lt;P&gt; _newBuilderWithState(BuilderState&lt;P&gt; newState ) {
<span class="fc" id="L63">        return new UIForTabbedPane&lt;&gt;(newState);</span>
    }

    /**
     *  Adds an action to be performed when a mouse click is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was clicked and whether the clicked tab is selected.
     *
     * @param onClick The action to be performed when a tab is clicked.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseClick( Action&lt;TabDelegate&gt; onClick ) {
<span class="fc" id="L77">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L78">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L79">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseClicked(MouseEvent e) {
<span class="fc" id="L81">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L82">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L83" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L84">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L86">                                        onClick.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L87">                                    } catch (Exception ex) {</span>
<span class="nc" id="L88">                                        log.error(&quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="fc" id="L89">                                    }</span>
<span class="fc" id="L90">                                });</span>
<span class="fc" id="L91">                        }</span>
                    });
<span class="fc" id="L93">               })</span>
<span class="fc" id="L94">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse press is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was pressed and whether the pressed tab is selected.
     *
     * @param onPress The action to be performed when a tab is pressed.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMousePress( Action&lt;TabDelegate&gt; onPress ) {
<span class="fc" id="L108">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="fc" id="L109">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L110">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mousePressed(MouseEvent e) {
<span class="fc" id="L112">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L113">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L115">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L117">                                        onPress.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L118">                                    } catch (Exception ex) {</span>
<span class="nc" id="L119">                                        log.error(&quot;Error while executing action on tab press!&quot;, ex);</span>
<span class="fc" id="L120">                                    }</span>
<span class="fc" id="L121">                                });</span>
<span class="fc" id="L122">                        }</span>
                    });
<span class="fc" id="L124">               })</span>
<span class="fc" id="L125">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse release is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was released and whether the released tab is selected.
     *
     * @param onRelease The action to be performed when a tab is released.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseRelease( Action&lt;TabDelegate&gt; onRelease ) {
<span class="fc" id="L139">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="fc" id="L140">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L141">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseReleased(MouseEvent e) {
<span class="fc" id="L143">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L144">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L146">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L148">                                        onRelease.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L149">                                    } catch (Exception ex) {</span>
<span class="nc" id="L150">                                        log.error(&quot;Error while executing action on tab release!&quot;, ex);</span>
<span class="fc" id="L151">                                    }</span>
<span class="fc" id="L152">                                });</span>
<span class="fc" id="L153">                        }</span>
                    });
<span class="fc" id="L155">               })</span>
<span class="fc" id="L156">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse enter is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was entered and whether the entered tab is selected.
     *
     * @param onEnter The action to be performed when a tab is entered.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseEnter( Action&lt;TabDelegate&gt; onEnter ) {
<span class="fc" id="L170">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L171">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L172">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="fc" id="L174">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L175">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L177">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L179">                                        onEnter.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L180">                                    } catch (Exception ex) {</span>
<span class="nc" id="L181">                                        log.error(&quot;Error while executing action on tab enter!&quot;, ex);</span>
<span class="fc" id="L182">                                    }</span>
<span class="fc" id="L183">                                });</span>
<span class="fc" id="L184">                        }</span>
                    });
<span class="fc" id="L186">               })</span>
<span class="fc" id="L187">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse exit is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was exited and whether the exited tab is selected.
     *
     * @param onExit The action to be performed when a tab is exited.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseExit( Action&lt;TabDelegate&gt; onExit ) {
<span class="fc" id="L201">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L202">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L203">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="fc" id="L205">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L206">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L207" title="2 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L208">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L210">                                        onExit.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L211">                                    } catch (Exception ex) {</span>
<span class="nc" id="L212">                                        log.error(&quot;Error while executing action on tab exit!&quot;, ex);</span>
<span class="fc" id="L213">                                    }</span>
<span class="fc" id="L214">                                });</span>
<span class="fc" id="L215">                        }</span>
                    });
<span class="fc" id="L217">               })</span>
<span class="fc" id="L218">               ._this();</span>
    }

    /**
     *  Sets the selected tab based on the given index.
     * @param index The index of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( int index ) {
<span class="nc" id="L227">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L228">                   thisComponent.setSelectedIndex(index);</span>
<span class="nc" id="L229">               })</span>
<span class="nc" id="L230">               ._this();</span>
    }

    /**
     *  Dynamically sets the selected tab based on the given index property.
     *  So when the index property changes, the selected tab will change accordingly.
     * @param index The index property of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( Val&lt;Integer&gt; index ) {
<span class="nc" id="L240">        NullUtil.nullArgCheck( index, &quot;index&quot;, Val.class );</span>
<span class="nc" id="L241">        NullUtil.nullPropertyCheck( index, &quot;index&quot;, &quot;Null is not a valid state for modelling a selected index.&quot; );</span>
<span class="nc" id="L242">        return _withOnShow( index, (thisComponent,i) -&gt; {</span>
<span class="nc" id="L243">                    thisComponent.setSelectedIndex(i);</span>
<span class="nc" id="L244">               })</span>
<span class="nc" id="L245">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L246">                    thisComponent.setSelectedIndex(index.get());</span>
<span class="nc" id="L247">                })</span>
<span class="nc" id="L248">               ._this();</span>
    }

    /**
     *  Binds the given index property to the selection index of the tabbed pane,
     *  which means that when the index property changes, the selected tab will change accordingly
     *  and when the user selects a different tab, the index property will be updated accordingly.
     * @param index The index property of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( Var&lt;Integer&gt; index ) {
<span class="fc" id="L259">        NullUtil.nullArgCheck( index, &quot;index&quot;, Var.class );</span>
<span class="fc" id="L260">        NullUtil.nullPropertyCheck( index, &quot;index&quot;, &quot;Null is not a valid state for modelling a selected index.&quot; );</span>
<span class="fc" id="L261">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L262">                    ExtraState state = ExtraState.of(thisComponent);</span>
<span class="pc bpc" id="L263" title="3 of 4 branches missed.">                    if ( state.selectedTabIndex != null &amp;&amp; state.selectedTabIndex != index )</span>
<span class="nc" id="L264">                        log.warn(</span>
                            &quot;Trying to bind a new property '&quot;+index+&quot;' &quot; +
                            &quot;to the index of tabbed pane '&quot;+thisComponent+&quot;' &quot; +
<span class="nc" id="L267">                            &quot;even though the previously specified property '&quot;+state.selectedTabIndex+&quot;' is &quot; +</span>
                            &quot;already bound to it. &quot; +
                            &quot;The previous property will be replaced now!&quot;,
                            new Throwable()
                        );

<span class="fc" id="L273">                    state.selectedTabIndex = index;</span>
<span class="fc" id="L274">               })</span>
<span class="fc" id="L275">               ._withOnShow( index, (thisComponent,i) -&gt; {</span>
<span class="fc" id="L276">                   ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L277">                   thisComponent.setSelectedIndex(i);</span>
<span class="fc" id="L278">                   state.selectionListeners.forEach( l -&gt; l.accept(i) );</span>
<span class="fc" id="L279">               })</span>
<span class="fc" id="L280">               ._with( thisComponent -&gt; {</span>
<span class="fc" id="L281">                   _onChange(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
<span class="fc" id="L282">                       ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L283">                       index.set(From.VIEW, thisComponent.getSelectedIndex());</span>
<span class="fc" id="L284">                       state.selectionListeners.forEach(l -&gt; l.accept(thisComponent.getSelectedIndex()) );</span>
<span class="fc" id="L285">                   }));</span>
<span class="fc" id="L286">                   thisComponent.setSelectedIndex(index.get());</span>
<span class="fc" id="L287">               })</span>
<span class="fc" id="L288">               ._this();</span>
    }

    /**
     *  Defines the tab placement side based on the given {@link swingtree.UI.Side} enum,
     *  which maps directly to the {@link JTabbedPane#setTabPlacement(int)} method.
     *
     * @param side The position to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withTabPlacementAt( UI.Side side ) {
<span class="fc" id="L299">        NullUtil.nullArgCheck(side, &quot;side&quot;, UI.Side.class );</span>
<span class="fc" id="L300">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L301">                    thisComponent.setTabPlacement(side.forTabbedPane());</span>
<span class="fc" id="L302">               })</span>
<span class="fc" id="L303">               ._this();</span>
    }

    /**
     *  Binds the supplied property to the tab placement of the tabbed pane.
     *  This means that when the property changes, the tab placement will change accordingly.
     *  The {@link swingtree.UI.Side} enum maps directly to the {@link JTabbedPane#setTabPlacement(int)} method.
     *
     * @param side The position property to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withTabPlacementAt( Val&lt;UI.Side&gt; side ) {
<span class="nc" id="L315">        NullUtil.nullArgCheck(side, &quot;side&quot;, Var.class);</span>
<span class="nc" id="L316">        return _withOnShow( side, (thisComponent,v) -&gt; {</span>
<span class="nc" id="L317">                    thisComponent.setTabPlacement(v.forTabbedPane());</span>
<span class="nc" id="L318">               })</span>
<span class="nc" id="L319">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L320">                    thisComponent.setTabPlacement(side.get().forTabbedPane());</span>
<span class="nc" id="L321">                })</span>
<span class="nc" id="L322">               ._this();</span>
    }

    /**
     *  Defines the overflow policy based on the given {@link swingtree.UI.OverflowPolicy} enum,
     *  which maps directly to the {@link JTabbedPane#setTabLayoutPolicy(int)} method.
     *  The overflow policy must either be {@link swingtree.UI.OverflowPolicy#SCROLL} or
     *  {@link swingtree.UI.OverflowPolicy#WRAP}.
     *  The {@link swingtree.UI.OverflowPolicy#SCROLL} policy will make the tabs scrollable
     *  when there are too many tabs to fit in the tabbed pane.
     *  The {@link swingtree.UI.OverflowPolicy#WRAP} policy will make the tabs wrap to the next line
     *  when there are too many tabs to fit in the tabbed pane.
     *
     * @param policy The overflow policy to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withOverflowPolicy( UI.OverflowPolicy policy ) {
<span class="nc" id="L339">        NullUtil.nullArgCheck( policy, &quot;policy&quot;, UI.OverflowPolicy.class );</span>
<span class="nc" id="L340">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L341">                    thisComponent.setTabLayoutPolicy(policy.forTabbedPane());</span>
<span class="nc" id="L342">               })</span>
<span class="nc" id="L343">               ._this();</span>
    }

    /**
     *  Binds the supplied enum property to the overflow policy of the tabbed pane.
     *  When the item of the property changes, the overflow policy will change accordingly.
     *  The {@link swingtree.UI.OverflowPolicy} enum maps directly to the
     *  {@link JTabbedPane#setTabLayoutPolicy(int)} method.
     *
     * @param policy The overflow policy property to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withOverflowPolicy( Val&lt;UI.OverflowPolicy&gt; policy ) {
<span class="nc" id="L356">        NullUtil.nullArgCheck(policy, &quot;policy&quot;, Var.class);</span>
<span class="nc" id="L357">        return _withOnShow( policy, (thisComponent,v) -&gt; {</span>
<span class="nc" id="L358">                    thisComponent.setTabLayoutPolicy(v.forTabbedPane());</span>
<span class="nc" id="L359">               })</span>
<span class="nc" id="L360">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L361">                    thisComponent.setTabLayoutPolicy(policy.orElseThrowUnchecked().forTabbedPane());</span>
<span class="nc" id="L362">                })</span>
<span class="nc" id="L363">               ._this();</span>
    }

    private Supplier&lt;Integer&gt; _indexFinderFor(
        WeakReference&lt;P&gt; paneRef,
        WeakReference&lt;JComponent&gt; contentRef
    ) {
<span class="fc" id="L370">        return ()-&gt;{</span>
<span class="fc" id="L371">            P foundPane = paneRef.get();</span>
<span class="fc" id="L372">            JComponent foundContent = contentRef.get();</span>
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">            if ( foundPane != null &amp;&amp; foundContent != null ) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                for ( int i = 0; i &lt; foundPane.getTabCount(); i++ ) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                    if ( foundContent == foundPane.getComponentAt(i) ) return i;</span>
                }
            }
<span class="nc" id="L378">            return -1;</span>
        };
    }

    /**
     *  Adds a tab to the tabbed pane based on the given {@link Tab} configuration.
     *  The tab will be added to the end of the tab list.
     *
     * @param tab The tab to add to the tabbed pane.
     * @return This builder node.
     * @throws NullPointerException if the given tab is null.
     */
    public final UIForTabbedPane&lt;P&gt; add( Tab tab )
    {
<span class="fc" id="L392">        Objects.requireNonNull(tab);</span>
<span class="fc" id="L393">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L394">            JComponent dummyContent = new JPanel();</span>
<span class="fc" id="L395">            WeakReference&lt;P&gt; paneRef = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L396">            WeakReference&lt;JComponent&gt; contentRef = new WeakReference&lt;&gt;(tab.contents().orElse(dummyContent));</span>
<span class="fc" id="L397">            Supplier&lt;Integer&gt; indexFinder = _indexFinderFor(paneRef, contentRef);</span>
<span class="fc" id="L398">            tab.onSelection()</span>
<span class="fc" id="L399">               .ifPresent(onSelection -&gt;</span>
<span class="fc" id="L400">                   thisComponent.addChangeListener(e -&gt; {</span>
<span class="nc" id="L401">                       JTabbedPane tabbedPane = paneRef.get();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                       if ( tabbedPane == null ) return;</span>
<span class="nc" id="L403">                       int index = indexFinder.get();</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">                       if ( index &gt;= 0 &amp;&amp; index == tabbedPane.getSelectedIndex() )</span>
<span class="nc" id="L405">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L407">                                   onSelection.accept(new ComponentDelegate&lt;&gt;(tabbedPane, e));</span>
<span class="nc" id="L408">                               } catch (Exception ex) {</span>
<span class="nc" id="L409">                                   log.error(&quot;Error while executing action on tab selection!&quot;, ex);</span>
<span class="nc" id="L410">                               }</span>
<span class="nc" id="L411">                           });</span>
<span class="nc" id="L412">                   })</span>
               );

<span class="fc" id="L415">            TabMouseClickListener mouseListener = new TabMouseClickListener(thisComponent, indexFinder, tab.onMouseClick().orElse(null));</span>

            // Initial tab setup:
<span class="fc" id="L418">            _doWithoutListeners(thisComponent, ()-&gt; {</span>
<span class="fc" id="L419">                boolean hasSelectionBoolProp = tab.isSelected().isPresent();</span>
<span class="fc" id="L420">                ExtraState.of(thisComponent).doSilentlyIfAlreadyHasSelectionOrIf(hasSelectionBoolProp, ()-&gt;{</span>
<span class="fc" id="L421">                    thisComponent.addTab(</span>
<span class="fc" id="L422">                        tab.title().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L423">                        tab.icon().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L424">                        tab.contents().orElse(dummyContent),</span>
<span class="fc" id="L425">                        tab.tip().map(Val::orElseNull).orElse(null)</span>
                    );
<span class="fc" id="L427">                });</span>
<span class="fc" id="L428">            });</span>
<span class="fc" id="L429">            tab.isEnabled().ifPresent( isEnabled -&gt; thisComponent.setEnabledAt(indexFinder.get(), isEnabled.get()) );</span>
<span class="fc" id="L430">            tab.isSelected().ifPresent( isSelected -&gt; {</span>
<span class="fc" id="L431">                ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L432">                _selectTabFromModelling(thisComponent, indexFinder.get(), isSelected.get());</span>
<span class="pc bpc" id="L433" title="2 of 4 branches missed.">                if ( isSelected instanceof Var &amp;&amp; isSelected.isMutable() ) {</span>
<span class="fc" id="L434">                    Var&lt;Boolean&gt; isSelectedMut = (Var&lt;Boolean&gt;) isSelected;</span>
<span class="fc" id="L435">                    state.selectionListeners.add(i -&gt; {</span>
<span class="fc" id="L436">                        boolean isNowSelected = _isSuppliedTabIndexSelected(indexFinder, i);</span>
<span class="fc" id="L437">                        isSelectedMut.set(From.VIEW, isNowSelected);</span>
<span class="fc" id="L438">                    });</span>
                }
            /*
                The above listener will ensure that the isSelected property of the tab is updated when
                the selection index property changes.
             */
<span class="fc" id="L444">            });</span>

            // Now on to binding:
<span class="fc" id="L447">            tab.title()     .ifPresent( title      -&gt; _onShow(title,      thisComponent, (c,t) -&gt; c.setTitleAt(indexFinder.get(), t)) );</span>
<span class="fc" id="L448">            tab.icon()      .ifPresent( icon       -&gt; _onShow(icon,       thisComponent, (c,i) -&gt; c.setIconAt(indexFinder.get(), i)) );</span>
<span class="fc" id="L449">            tab.tip()       .ifPresent( tip        -&gt; _onShow(tip,        thisComponent, (c,t) -&gt; c.setToolTipTextAt(indexFinder.get(), t)) );</span>
<span class="fc" id="L450">            tab.isEnabled() .ifPresent( enabled    -&gt; _onShow(enabled,    thisComponent, (c,e) -&gt; c.setEnabledAt(indexFinder.get(), e)) );</span>
<span class="fc" id="L451">            tab.isSelected().ifPresent( isSelected -&gt; _onShow(isSelected, thisComponent, (c,s) -&gt; _selectTab(c, indexFinder.get(), s) ));</span>

<span class="fc" id="L453">            tab.headerContents().ifPresent( c -&gt;</span>
<span class="fc" id="L454">                    thisComponent</span>
<span class="fc" id="L455">                    .setTabComponentAt(</span>
<span class="fc" id="L456">                        thisComponent.getTabCount()-1,</span>
<span class="fc" id="L457">                        _buildTabHeader( tab, mouseListener )</span>
                    )
                );
<span class="fc" id="L460">        })</span>
<span class="fc" id="L461">        ._this();</span>
    }

    /**
     * Dynamically generates tabs for items in a {@link Vals} list and automatically updates them
     * when the items change. The items are typically view model instances, but can be any type.
     * &lt;p&gt;
     * The provided {@link TabSupplier} lambda is invoked with each item from the list,
     * returning a {@link Tab} to be added to the {@link JTabbedPane} wrapped by this builder.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; Binding tabs to a {@link Vals} list assumes no other tabs are present.
     * &lt;p&gt;
     * &lt;b&gt;Usage:&lt;/b&gt;
     * &lt;pre&gt;{@code
     *     UI.panel()
     *      .add(
     *          UI.tabbedPane().addAll(tabs, model -&gt;
     *              switch(model.type()) {
     *                  case LOGIN -&gt; UI.tab(&quot;Login&quot;).add(..);
     *                  case ABOUT -&gt; UI.tab(&quot;About&quot;).add(..);
     *                  case SETTINGS -&gt; UI.tab(&quot;Settings&quot;).add(..);
     *              }
     *          )
     *      )
     * }&lt;/pre&gt;
     *
     * @param &lt;M&gt;         The type of items in the {@link Vals} list.
     * @param tabModels   A list of items, typically view model instances.
     * @param tabSupplier A lambda to generate a {@link Tab} for each item.
     * @return This instance, allowing for builder-style method chaining.
     */
    public &lt;M&gt; UIForTabbedPane&lt;P&gt; addAll(Vals&lt;M&gt; tabModels, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L493">        Objects.requireNonNull(tabModels, &quot;tabModels&quot;);</span>
<span class="fc" id="L494">        Objects.requireNonNull(tabSupplier, &quot;tabSupplier&quot;);</span>
<span class="fc" id="L495">        return _with(thisComponent -&gt; {</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if ( thisComponent.getTabCount() &gt; 0 ) {</span>
<span class="nc" id="L497">                log.warn(</span>
                    &quot;Trying to bind a list of tabs to a tabbed pane that already has tabs. \n&quot; +
                    &quot;Manually defined tabs existing along with bound tabs is not supported. \n&quot; +
                    &quot;The manually defined tabs will be removed now!&quot;,
                    new Throwable() // Stack trace so that a user can see where this warning was triggered.
                );
<span class="nc" id="L503">                _doWithoutListeners(thisComponent, thisComponent::removeAll);</span>
            }
<span class="fc" id="L505">            _onShow(tabModels, thisComponent, (pane, delegate) -&gt; {</span>
<span class="fc" id="L506">                _updateTabs(pane, delegate, tabSupplier);</span>
<span class="fc" id="L507">            });</span>

<span class="fc" id="L509">            tabModels.forEach(v -&gt; _addTabAt(thisComponent.getTabCount(), v, tabSupplier, thisComponent));</span>
<span class="fc" id="L510">        })._this();</span>
    }

    private &lt;M&gt; void _updateTabs(P pane, ValsDelegate&lt;M&gt; delegate, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L514">        Vals&lt;M&gt; newValues = delegate.newValues();</span>
<span class="fc" id="L515">        Vals&lt;M&gt; oldValues = delegate.oldValues();</span>
<span class="fc" id="L516">        int index = delegate.index().orElse(-1);</span>

<span class="pc bpc" id="L518" title="2 of 6 branches missed.">        switch (delegate.change()) {</span>
            case SET:
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L521">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L522">                    pane.removeAll();</span>
<span class="nc" id="L523">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L525" title="All 2 branches covered.">                    for (int i = 0; i &lt; newValues.size(); i++) {</span>
<span class="fc" id="L526">                        int position = index + i;</span>
<span class="fc" id="L527">                        _updateTabAt(position, newValues.at(i).orElseNull(), tabSupplier, pane);</span>
                    }
                }
<span class="fc" id="L530">                break;</span>
            case ADD:
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L533">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L534">                    pane.removeAll();</span>
<span class="nc" id="L535">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L537" title="All 2 branches covered.">                    for (int i = 0; i &lt; newValues.size(); i++) {</span>
<span class="fc" id="L538">                        int position = index + i;</span>
<span class="fc" id="L539">                        _addTabAt(position, newValues.at(i).orElseNull(), tabSupplier, pane);</span>
                    }
                }
<span class="fc" id="L542">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
<span class="nc" id="L545">                    log.error(&quot;Missing index for change type: {}&quot;, delegate.change(), new Throwable());</span>
<span class="nc" id="L546">                    pane.removeAll();</span>
<span class="nc" id="L547">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L549" title="All 2 branches covered.">                    for (int i = 0; i &lt; oldValues.size(); i++) {</span>
<span class="fc" id="L550">                        _removeTabAt(index, pane);</span>
                    }
                }
<span class="fc" id="L553">                break;</span>
            case CLEAR:
<span class="fc" id="L555">                pane.removeAll();</span>
<span class="fc" id="L556">                break;</span>
            case NONE:
<span class="nc" id="L558">                break;</span>
            default:
<span class="nc" id="L560">                log.error(&quot;Unknown change type: {}&quot;, delegate.change(), new Throwable());</span>
                // We do a simple rebuild:
<span class="nc" id="L562">                pane.removeAll();</span>
<span class="nc" id="L563">                delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
        }

<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (pane.getTabCount() != delegate.currentValues().size()) {</span>
<span class="nc" id="L567">            log.warn(</span>
                &quot;Broken binding to view model list detected! \n&quot; +
                &quot;TabbedPane tab count '{}' does not match tab models list of size '{}'. \n&quot; +
                &quot;A possible cause for this is that tabs were {} this '{}' \n&quot; +
                &quot;directly, instead of through the property list binding. \n&quot; +
                &quot;However, this could also be a bug in the UI framework.&quot;,
<span class="nc" id="L573">                pane.getComponentCount(),</span>
<span class="nc" id="L574">                delegate.currentValues().size(),</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                pane.getTabCount() &gt; delegate.currentValues().size() ? &quot;added to&quot; : &quot;removed from&quot;,</span>
                pane,
                new Throwable()
            );
        }
<span class="fc" id="L580">    }</span>

    /**
     * Dynamically generates tabs for items in a {@link Tuple} {@link Val} and automatically updates them
     * when the items change. The tuple items are typically view model instances, but can be any type.
     * &lt;p&gt;
     * The provided {@link TabSupplier} lambda is invoked with each item from the tuple,
     * returning a {@link Tab} to be added to the {@link JTabbedPane} wrapped by this builder.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; Binding tabs to a {@link Tuple} {@link Val} assumes no other tabs are present.
     * &lt;p&gt;
     * &lt;b&gt;Usage:&lt;/b&gt;
     * &lt;pre&gt;{@code
     *     UI.panel()
     *      .add(
     *          UI.tabbedPane().addAll(tabs, model -&gt;
     *              switch(model.type()) {
     *                  case LOGIN -&gt; UI.tab(&quot;Login&quot;).add(..);
     *                  case ABOUT -&gt; UI.tab(&quot;About&quot;).add(..);
     *                  case SETTINGS -&gt; UI.tab(&quot;Settings&quot;).add(..);
     *              }
     *          )
     *      )
     * }&lt;/pre&gt;
     *
     * @param &lt;M&gt;         The type of items in the form of a {@link Tuple} wrapped by a {@link Val}.
     * @param tabModels   A list of items, typically view model instances.
     * @param tabSupplier A lambda to generate a {@link Tab} for each item.
     * @return This instance, allowing for builder-style method chaining.
     */
    public &lt;M&gt; UIForTabbedPane&lt;P&gt; addAll(Val&lt;Tuple&lt;M&gt;&gt; tabModels, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L611">        Objects.requireNonNull(tabModels, &quot;tabModels&quot;);</span>
<span class="fc" id="L612">        Objects.requireNonNull(tabSupplier, &quot;tabSupplier&quot;);</span>
<span class="fc" id="L613">        return _with(thisComponent -&gt; {</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">            if ( thisComponent.getTabCount() &gt; 0 ) {</span>
<span class="nc" id="L615">                log.warn(</span>
                    &quot;Trying to bind a tuple of tabs to a tabbed pane that already has tabs. \n&quot; +
                    &quot;Manually defined tabs existing along with bound tabs is not supported. \n&quot; +
                    &quot;The manually defined tabs will be removed now!&quot;,
                    new Throwable() // Stack trace so that a user can see where this warning was triggered.
                );
<span class="nc" id="L621">                _doWithoutListeners(thisComponent, thisComponent::removeAll);</span>
            }
<span class="fc" id="L623">            AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">            if (tabModels.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L625">                lastDiffRef.set(((SequenceDiffOwner)tabModels.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L626">            _onShow(tabModels, thisComponent, (pane, tupleOfModels) -&gt; {</span>
<span class="fc" id="L627">                _updateTabs(pane, tupleOfModels, lastDiffRef, tabSupplier);</span>
<span class="fc" id="L628">            });</span>

<span class="fc" id="L630">            tabModels.get().forEach(v -&gt; _addTabAt(thisComponent.getTabCount(), v, tabSupplier, thisComponent));</span>
<span class="fc" id="L631">        })._this();</span>
    }

    private  &lt;M&gt; void _updateTabs(P pane, Tuple&lt;M&gt; tupleOfModels, AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L635">        SequenceDiff diff = null;</span>
<span class="fc" id="L636">        SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (tupleOfModels instanceof SequenceDiffOwner)</span>
<span class="fc" id="L638">            diff = ((SequenceDiffOwner)tupleOfModels).differenceFromPrevious().orElse(null);</span>
<span class="fc" id="L639">        lastDiffRef.set(diff);</span>

<span class="pc bpc" id="L641" title="2 of 6 branches missed.">        if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) ) {</span>
<span class="fc" id="L642">            pane.removeAll();</span>
<span class="fc" id="L643">            tupleOfModels.forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
        } else {
<span class="pc bpc" id="L645" title="2 of 7 branches missed.">            switch (diff.change()) {</span>
                case SET:
<span class="fc bfc" id="L647" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L648">                        int position = diff.index().orElse(0) + i;</span>
<span class="fc" id="L649">                        _updateTabAt(position, tupleOfModels.get(position), tabSupplier, pane);</span>
                    }
<span class="fc" id="L651">                    break;</span>
                case ADD:
<span class="fc bfc" id="L653" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L654">                        int position = diff.index().orElse(0) + i;</span>
<span class="fc" id="L655">                        _addTabAt(position, tupleOfModels.get(position), tabSupplier, pane);</span>
                    }
<span class="fc" id="L657">                    break;</span>
                case REMOVE:
<span class="fc bfc" id="L659" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L660">                        _removeTabAt(diff.index().orElse(0), pane);</span>
                    }
<span class="fc" id="L662">                    break;</span>
                case RETAIN:
<span class="fc" id="L664">                    int currentNumberOfTabs = pane.getTabCount();</span>
<span class="fc" id="L665">                    int firstToRemove = diff.index().orElse(0);</span>
<span class="fc" id="L666">                    int lastToRemove = currentNumberOfTabs - (firstToRemove + diff.size());</span>
                    //remove the first n tabs
<span class="fc bfc" id="L668" title="All 2 branches covered.">                    for (int i = 0; i &lt; firstToRemove; i++) {</span>
<span class="fc" id="L669">                        _removeTabAt(0, pane);</span>
                    }
                    // remove the last n tabs
<span class="fc bfc" id="L672" title="All 2 branches covered.">                    for (int i = 0; i &lt; lastToRemove; i++) {</span>
<span class="fc" id="L673">                        _removeTabAt(diff.size(), pane);</span>
                    }
<span class="fc" id="L675">                    break;</span>
                case CLEAR:
<span class="fc" id="L677">                    pane.removeAll();</span>
<span class="fc" id="L678">                    break;</span>
                case NONE:
<span class="nc" id="L680">                    break;</span>
                default:
<span class="nc" id="L682">                    log.error(&quot;Unknown change type: {}&quot;, diff.change(), new Throwable());</span>
                    // We do a simple rebuild:
<span class="nc" id="L684">                    pane.removeAll();</span>
<span class="nc" id="L685">                    tupleOfModels.forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
            }
        }

<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        if (pane.getTabCount() != tupleOfModels.size()) {</span>
<span class="nc" id="L690">            log.warn(</span>
                &quot;Broken binding to view model tuple detected! \n&quot; +
                &quot;TabbedPane tab count '{}' does not match tab models tuple of size '{}'. \n&quot; +
                &quot;A possible cause for this is that tabs were {} this '{}' \n&quot; +
                &quot;directly, instead of through the property tuple binding. \n&quot; +
                &quot;However, this could also be a bug in the UI framework.&quot;,
<span class="nc" id="L696">                pane.getComponentCount(),</span>
<span class="nc" id="L697">                tupleOfModels.size(),</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                pane.getTabCount() &gt; tupleOfModels.size() ? &quot;added to&quot; : &quot;removed from&quot;,</span>
                pane,
                new Throwable()
            );
        }
<span class="fc" id="L703">    }</span>

    private void _doWithoutListeners( P thisComponent, Runnable r ) {
<span class="fc" id="L706">        ChangeListener[] listeners = thisComponent.getChangeListeners();</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for ( ChangeListener l : listeners ) thisComponent.removeChangeListener(l);</span>
<span class="fc" id="L708">        r.run();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for ( ChangeListener l : listeners ) thisComponent.addChangeListener(l);</span>
        /*
            This is important because the tabbed pane will fire a change event when a tab is added.
            This is not desirable because the tabbed pane is not yet fully initialized at that point.
        */
<span class="fc" id="L714">    }</span>

    private void _selectTab( P thisComponent, int tabIndex, boolean isSelected ) {
<span class="fc" id="L717">        ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">        int selectedIndex = ( isSelected ? tabIndex : thisComponent.getSelectedIndex() );</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if ( state.selectedTabIndex != null )</span>
<span class="fc" id="L720">            state.selectedTabIndex.set(From.VIEW, selectedIndex);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        else if ( isSelected )</span>
<span class="fc" id="L722">            thisComponent.setSelectedIndex(selectedIndex);</span>

<span class="fc" id="L724">        state.selectionListeners.forEach(l -&gt; l.accept(selectedIndex));</span>
<span class="fc" id="L725">    }</span>

    private void _selectTabFromModelling( P thisComponent, int tabIndex, boolean isSelected ) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        int selectedIndex = ( isSelected ? tabIndex : thisComponent.getSelectedIndex() );</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if ( isSelected )</span>
<span class="fc" id="L730">            thisComponent.setSelectedIndex(selectedIndex);</span>
<span class="fc" id="L731">    }</span>

    private JComponent _buildTabHeader( Tab tab, TabMouseClickListener mouseListener )
    {
<span class="fc" id="L735">        return</span>
<span class="fc" id="L736">            tab.title().map( title -&gt;</span>
                // We want both title and user component in the header!
<span class="fc" id="L738">                UI.panel(&quot;fill, ins 0&quot;).withBackground(new Color(0,0,0,0))</span>
<span class="pc" id="L739">                .applyIfPresent( tab.tip().map( tip -&gt; panel -&gt; panel.withTooltip(tip) ) )</span>
<span class="fc" id="L740">                .peek( it -&gt; {</span>
<span class="fc" id="L741">                    it.addMouseListener(mouseListener);</span>
<span class="fc" id="L742">                    mouseListener.addOwner(it);</span>
<span class="fc" id="L743">                })</span>
<span class="fc" id="L744">                .add(&quot;shrink&quot;,</span>
<span class="fc" id="L745">                    UI.label(title).withBackground(new Color(0,0,0,0))</span>
<span class="pc" id="L746">                    .applyIfPresent( tab.tip().map( tip -&gt; label -&gt; label.withTooltip(tip) ) )</span>
<span class="fc" id="L747">                    .peek( it -&gt; {</span>
<span class="fc" id="L748">                        it.addMouseListener(mouseListener);</span>
<span class="fc" id="L749">                        mouseListener.addOwner(it);</span>
<span class="fc" id="L750">                    })</span>
                )
<span class="fc" id="L752">                .add(&quot;grow&quot;, tab.headerContents().orElse(new JPanel()))</span>
<span class="fc" id="L753">                .getComponent()</span>
            )
<span class="fc" id="L755">            .map( p -&gt; (JComponent) p )</span>
<span class="fc" id="L756">            .orElse(tab.headerContents().orElse(new JPanel()));</span>
    }

    private class TabMouseClickListener extends MouseAdapter
    {
<span class="fc" id="L761">        private final List&lt;WeakReference&lt;JComponent&gt;&gt; ownerRefs = new ArrayList&lt;&gt;();</span>
        private final WeakReference&lt;JTabbedPane&gt; paneRef;
        private final Supplier&lt;Integer&gt; indexFinder;
        private final @Nullable Action&lt;ComponentDelegate&lt;JTabbedPane, MouseEvent&gt;&gt; mouseClickAction;


        private TabMouseClickListener(
            JTabbedPane pane,
            Supplier&lt;Integer&gt; indexFinder,
            @Nullable Action&lt;ComponentDelegate&lt;JTabbedPane, MouseEvent&gt;&gt; mouseClickAction
<span class="fc" id="L771">        ) {</span>
<span class="fc" id="L772">            this.paneRef = new WeakReference&lt;&gt;(pane);</span>
<span class="fc" id="L773">            this.indexFinder = Objects.requireNonNull(indexFinder);</span>
<span class="fc" id="L774">            this.mouseClickAction = mouseClickAction;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if ( mouseClickAction != null ) {</span>
<span class="fc" id="L776">                pane.addMouseListener(new java.awt.event.MouseAdapter() {</span>
                    @Override
                    public void mouseClicked( MouseEvent e ) {
<span class="nc" id="L779">                        JTabbedPane pane = paneRef.get();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">                        if ( pane == null ) return;</span>
<span class="nc" id="L781">                        int indexOfThis = indexOfThisTab();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                        if ( indexOfThis &lt; 0 ) return;</span>
<span class="nc" id="L783">                        int indexClicked = pane.indexAtLocation(e.getX(), e.getY());</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                        if ( indexClicked &lt; 0 ) return;</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                        if ( indexOfThis == indexClicked )</span>
<span class="nc" id="L786">                            _runInApp(()-&gt; {</span>
                                try {
<span class="nc" id="L788">                                    mouseClickAction.accept(new ComponentDelegate&lt;&gt;(pane, e));</span>
<span class="nc" id="L789">                                } catch (Exception ex) {</span>
<span class="nc" id="L790">                                    log.error(&quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="nc" id="L791">                                }</span>
<span class="nc" id="L792">                            });</span>
<span class="nc" id="L793">                    }</span>
                });
            }
<span class="fc" id="L796">        }</span>

        private void doAction( JTabbedPane pane, MouseEvent e ) {
<span class="nc" id="L799">            Point p = e.getPoint();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if ( e.getSource() != pane ) {</span>
               // We need to find the point relative to the tabbed pane:
<span class="nc" id="L802">                p = traversePosition((Component) e.getSource(), pane, p);</span>
            }
<span class="nc" id="L804">            int indexOfThis = indexOfThisTab();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if ( indexOfThis &lt; 0 ) return;</span>
<span class="nc" id="L806">            int indexClicked = pane.indexAtLocation(p.x, p.y);</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if ( indexClicked &lt; 0 ) return;</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">            if ( indexOfThis == indexClicked &amp;&amp; mouseClickAction != null )</span>
<span class="nc" id="L809">                _runInApp(()-&gt; {</span>
                    try {
<span class="nc" id="L811">                        mouseClickAction.accept(new ComponentDelegate&lt;&gt;(pane, e));</span>
<span class="nc" id="L812">                    } catch (Exception ex) {</span>
<span class="nc" id="L813">                        log.error(&quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="nc" id="L814">                    }</span>
<span class="nc" id="L815">                });</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if ( indexOfThis &lt; pane.getTabCount() )</span>
<span class="nc" id="L817">                pane.setSelectedIndex(indexOfThis);</span>
<span class="nc" id="L818">        }</span>

        private int indexOfThisTab() {
<span class="nc" id="L821">            return indexFinder.get();</span>
        }

<span class="fc" id="L824">        public void addOwner(JComponent c) { this.ownerRefs.add(new WeakReference&lt;&gt;(c)); }</span>

        @Override
        public void mouseClicked( MouseEvent e ) {
<span class="nc" id="L828">            JTabbedPane pane = this.paneRef.get();</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if ( pane == null ) {</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                for ( WeakReference&lt;JComponent&gt; compRef : this.ownerRefs) {</span>
<span class="nc" id="L831">                    JComponent owner = compRef.get();</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                    if ( owner != null )</span>
<span class="nc" id="L833">                        owner.removeMouseListener(this);</span>
<span class="nc" id="L834">                }</span>
            }
<span class="nc" id="L836">            else doAction( pane, e );</span>
<span class="nc" id="L837">        }</span>
    }

    /**
     *  If we click on a subcomponent on the header we need to traverse
     *  upwards to find the click position relative to the tabbed pane!
     *  Otherwise we don't know where the click went.
     *
     * @param current The component where we currently have the relative position {@code p}.
     * @param end The component at which we end traversal when it is the same as the current.
     * @param p The relative position to the current component.
     * @return The relative position to the end component!
     */
    private static Point traversePosition( Component current, Component end, Point p ) {
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if ( current == end ) return p;</span>
<span class="nc" id="L852">        Component parent = current.getParent();</span>
<span class="nc" id="L853">        Point relativeToParent = SwingUtilities.convertPoint(current, p, parent);</span>
<span class="nc" id="L854">        return traversePosition(parent, end, relativeToParent);</span>
    }

    /**
     * Adds an {@link Action} to the underlying {@link JTabbedPane}
     * through an {@link javax.swing.event.ChangeListener},
     * which will be called when the state of the tabbed pane changes.
     * For more information see {@link JTabbedPane#addChangeListener(javax.swing.event.ChangeListener)}.
     *
     * @param onChange The {@link Action} that will be called through the underlying change event.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForTabbedPane&lt;P&gt; onChange( Action&lt;ComponentDelegate&lt;P, ChangeEvent&gt;&gt; onChange ) {
<span class="fc" id="L867">        NullUtil.nullArgCheck(onChange, &quot;onChange&quot;, Action.class);</span>
<span class="fc" id="L868">        return _with( thisComponent -&gt; {</span>
<span class="pc" id="L869">                    _onChange(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
                        try {
<span class="nc" id="L871">                            onChange.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L872">                        } catch (Exception ex) {</span>
<span class="nc" id="L873">                            log.error(&quot;Error while executing action on tab change!&quot;, ex);</span>
<span class="nc" id="L874">                        }</span>
<span class="nc" id="L875">                    }));</span>
<span class="fc" id="L876">                })</span>
<span class="fc" id="L877">                ._this();</span>
    }

    private void _onChange( P thisComponent, Consumer&lt;ChangeEvent&gt; action ) {
<span class="fc" id="L881">        thisComponent.addChangeListener(action::accept);</span>
<span class="fc" id="L882">    }</span>

    private &lt;M&gt; void _addTabAt(int index, @Nullable M m, TabSupplier&lt;M&gt; tabSupplier, P p) {
<span class="fc" id="L885">        Tab tab = _createTab(m, tabSupplier);</span>

<span class="fc" id="L887">        JComponent dummyContent = new JPanel();</span>
<span class="fc" id="L888">        WeakReference&lt;P&gt; paneRef = new WeakReference&lt;&gt;(p);</span>
<span class="fc" id="L889">        WeakReference&lt;JComponent&gt; contentRef = new WeakReference&lt;&gt;(tab.contents().orElse(dummyContent));</span>
<span class="fc" id="L890">        Supplier&lt;Integer&gt; indexFinder = _indexFinderFor(paneRef, contentRef);</span>

<span class="fc" id="L892">        tab.onSelection()</span>
<span class="fc" id="L893">            .ifPresent(onSelection -&gt;</span>
<span class="nc" id="L894">                p.addChangeListener(e -&gt; {</span>
<span class="nc" id="L895">                    JTabbedPane tabbedPane = paneRef.get();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">                    if (tabbedPane == null) return;</span>
<span class="nc" id="L897">                    int i = indexFinder.get();</span>
<span class="nc bnc" id="L898" title="All 4 branches missed.">                    if (i &gt;= 0 &amp;&amp; i == tabbedPane.getSelectedIndex())</span>
<span class="nc" id="L899">                        _runInApp(() -&gt; {</span>
                            try {
<span class="nc" id="L901">                                onSelection.accept(new ComponentDelegate&lt;&gt;(tabbedPane, e));</span>
<span class="nc" id="L902">                            } catch (Exception ex) {</span>
<span class="nc" id="L903">                                log.error(&quot;Error while executing action on tab selection!&quot;, ex);</span>
<span class="nc" id="L904">                            }</span>
<span class="nc" id="L905">                        });</span>
<span class="nc" id="L906">                })</span>
            );

<span class="fc" id="L909">        TabMouseClickListener mouseListener = new TabMouseClickListener(p, indexFinder, tab.onMouseClick().orElse(null));</span>

        // Initial tab setup:
<span class="fc" id="L912">        p.insertTab(</span>
<span class="fc" id="L913">            tab.title().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L914">            tab.icon().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L915">            tab.contents().orElse(dummyContent),</span>
<span class="fc" id="L916">            tab.tip().map(Val::orElseNull).orElse(null),</span>
            index
        );
<span class="pc" id="L919">        tab.isEnabled().ifPresent(isEnabled -&gt; p.setEnabledAt(indexFinder.get(), isEnabled.get()));</span>
<span class="fc" id="L920">        tab.isSelected().ifPresent(isSelected -&gt; {</span>
<span class="nc" id="L921">            ExtraState state = ExtraState.of(p);</span>
<span class="nc" id="L922">            _selectTabFromModelling(p, indexFinder.get(), isSelected.get());</span>
<span class="nc bnc" id="L923" title="All 4 branches missed.">            if (isSelected instanceof Var &amp;&amp; isSelected.isMutable()) {</span>
<span class="nc" id="L924">                Var&lt;Boolean&gt; isSelectedMut = (Var&lt;Boolean&gt;) isSelected;</span>
<span class="nc" id="L925">                state.selectionListeners.add(i -&gt; {</span>
<span class="nc" id="L926">                    boolean isNowSelected = _isSuppliedTabIndexSelected(indexFinder, i);</span>
<span class="nc" id="L927">                    isSelectedMut.set(From.VIEW, isNowSelected);</span>
<span class="nc" id="L928">                });</span>
            }
            /*
                The above listener will ensure that the isSelected property of the tab is updated when
                the selection index property changes.
             */
<span class="nc" id="L934">        });</span>

        // Now on to binding:
<span class="pc" id="L937">        tab.title().ifPresent(title -&gt; _onShow(title, p, (c, t) -&gt; c.setTitleAt(indexFinder.get(), t)));</span>
<span class="pc" id="L938">        tab.icon().ifPresent(icon -&gt; _onShow(icon, p, (c, i) -&gt; c.setIconAt(indexFinder.get(), i)));</span>
<span class="pc" id="L939">        tab.tip().ifPresent(tip -&gt; _onShow(tip, p, (c, t) -&gt; c.setToolTipTextAt(indexFinder.get(), t)));</span>
<span class="pc" id="L940">        tab.isEnabled().ifPresent(enabled -&gt; _onShow(enabled, p, (c, e) -&gt; c.setEnabledAt(indexFinder.get(), e)));</span>
<span class="pc" id="L941">        tab.isSelected().ifPresent(isSelected -&gt; _onShow(isSelected, p, (c, s) -&gt; _selectTab(c, indexFinder.get(), s)));</span>

<span class="pc" id="L943">        tab.headerContents().ifPresent(c -&gt; p.setTabComponentAt(index, _buildTabHeader(tab, mouseListener)));</span>
<span class="fc" id="L944">    }</span>

    private static boolean _isSuppliedTabIndexSelected(Supplier&lt;Integer&gt; indexOfCurrent, int newIndex) {
<span class="fc bfc" id="L947" title="All 4 branches covered.">        return newIndex &gt;= 0 &amp;&amp; Objects.equals(newIndex, indexOfCurrent.get());</span>
    }

    private &lt;M&gt; void _updateTabAt(int index, @Nullable M m, TabSupplier&lt;M&gt; tabSupplier, P p) {
<span class="fc" id="L951">        _removeTabAt(index, p);</span>
<span class="fc" id="L952">        _addTabAt(index, m, tabSupplier, p);</span>
<span class="fc" id="L953">    }</span>

    private void _removeTabAt(int index, P p) {
<span class="fc" id="L956">        p.removeTabAt(index);</span>
<span class="fc" id="L957">    }</span>

    private &lt;M&gt; Tab _createTab( @Nullable M m, TabSupplier&lt;M&gt; tabSupplier ) {
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">        if (m == null)</span>
<span class="nc" id="L961">            return UIForTabbedPane.TAB_NULL;</span>

        try {
<span class="fc" id="L964">            Tab tab = tabSupplier.createTabFor(m);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">            if ( tab == null ) {</span>
<span class="fc" id="L966">                log.warn(&quot;Tab supplier returned null for '{}'.&quot;, m, new Throwable());</span>
<span class="fc" id="L967">                return UIForTabbedPane.TAB_NULL;</span>
            }
<span class="fc" id="L969">            return tab;</span>
<span class="fc" id="L970">        } catch (Exception e) {</span>
<span class="fc" id="L971">            log.error(&quot;Error while creating tab for '{}'.&quot;, m, e);</span>
<span class="fc" id="L972">            return UIForTabbedPane.TAB_ERROR;</span>
        }
    }

<span class="fc" id="L976">    private static class ExtraState extends DefaultSingleSelectionModel</span>
    {
        static ExtraState of( JTabbedPane pane ) {
<span class="fc" id="L979">            return ComponentExtension.from(pane)</span>
<span class="fc" id="L980">                    .getOrSet(ExtraState.class, ExtraState::new);</span>
        }

<span class="fc" id="L983">        final List&lt;Consumer&lt;Integer&gt;&gt; selectionListeners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L984">        private @Nullable Var&lt;Integer&gt; selectedTabIndex = null;</span>
<span class="fc" id="L985">        private boolean ignoreChanges = false;</span>

        @Override public void setSelectedIndex(int index) {
<span class="fc bfc" id="L988" title="All 2 branches covered.">            if ( ignoreChanges )</span>
<span class="fc" id="L989">                return;</span>
<span class="fc" id="L990">            super.setSelectedIndex(index);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            if ( selectedTabIndex != null )</span>
<span class="fc" id="L992">                selectedTabIndex.set(From.VIEW, index);</span>

<span class="fc" id="L994">            selectionListeners.forEach(l -&gt; l.accept(index));</span>
<span class="fc" id="L995">        }</span>
        @Override public void clearSelection() {
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if ( ignoreChanges )</span>
<span class="nc" id="L998">                return;</span>
<span class="nc" id="L999">            super.clearSelection();</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if ( selectedTabIndex != null )</span>
<span class="nc" id="L1001">                selectedTabIndex.set(From.VIEW, -1);</span>
<span class="nc" id="L1002">        }</span>

        private void doSilentlyIfAlreadyHasSelectionOrIf(boolean condition, Runnable action) {
<span class="pc bpc" id="L1005" title="1 of 4 branches missed.">            ignoreChanges = ( condition || this.selectedTabIndex != null );</span>
            try {
<span class="fc" id="L1007">                action.run();</span>
            } finally {
<span class="fc" id="L1009">                ignoreChanges = false;</span>
            }
<span class="fc" id="L1011">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>