<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForTabbedPane.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForTabbedPane.java</span></div><h1>UIForTabbedPane.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.*;
import sprouts.Action;
import sprouts.impl.SequenceDiff;
import sprouts.impl.SequenceDiffOwner;
import swingtree.api.mvvm.TabSupplier;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 *  A SwingTree builder node designed for configuring {@link JTabbedPane} instances.
 *
 * @param &lt;P&gt; The type of the {@link JTabbedPane} instance that this builder node configures.
 */
public final class UIForTabbedPane&lt;P extends JTabbedPane&gt; extends UIForAnySwing&lt;UIForTabbedPane&lt;P&gt;, P&gt;
{
<span class="fc" id="L33">    private static final Logger log = LoggerFactory.getLogger(UIForTabbedPane.class);</span>

<span class="fc" id="L35">    private static final Tab TAB_ERROR = UI.tab(&quot;Error Tab&quot;);</span>
<span class="fc" id="L36">    private static final Tab TAB_NULL = UI.tab(&quot;Empty Tab&quot;);</span>

    private final BuilderState&lt;P&gt; _state;

    /**
     * {@link UIForAnySwing} (sub)types always wrap
     * a single component for which they are responsible.
     *
     * @param state The {@link BuilderState} modelling how the component is built.
     */
<span class="fc" id="L46">    UIForTabbedPane( BuilderState&lt;P&gt; state ) {</span>
<span class="fc" id="L47">        Objects.requireNonNull(state);</span>
<span class="fc" id="L48">        _state = state.withMutator(thisComponent -&gt; {</span>
<span class="fc" id="L49">            thisComponent.setModel(ExtraState.of(thisComponent));</span>
<span class="fc" id="L50">        });</span>
<span class="fc" id="L51">    }</span>

    @Override
    protected BuilderState&lt;P&gt; _state() {
<span class="fc" id="L55">        return _state;</span>
    }

    @Override
    protected UIForTabbedPane&lt;P&gt; _newBuilderWithState(BuilderState&lt;P&gt; newState ) {
<span class="fc" id="L60">        return new UIForTabbedPane&lt;&gt;(newState);</span>
    }

    /**
     *  Adds an action to be performed when a mouse click is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was clicked and whether the clicked tab is selected.
     *
     * @param onClick The action to be performed when a tab is clicked.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseClick( Action&lt;TabDelegate&gt; onClick ) {
<span class="fc" id="L74">        NullUtil.nullArgCheck(onClick, &quot;onClick&quot;, Action.class);</span>
<span class="fc" id="L75">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L76">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseClicked(MouseEvent e) {
<span class="fc" id="L78">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L79">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L80" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L81">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L83">                                        onClick.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L84">                                    } catch (Exception ex) {</span>
<span class="nc" id="L85">                                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="fc" id="L86">                                    }</span>
<span class="fc" id="L87">                                });</span>
<span class="fc" id="L88">                        }</span>
                    });
<span class="fc" id="L90">               })</span>
<span class="fc" id="L91">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse press is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was pressed and whether the pressed tab is selected.
     *
     * @param onPress The action to be performed when a tab is pressed.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMousePress( Action&lt;TabDelegate&gt; onPress ) {
<span class="fc" id="L105">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Action.class);</span>
<span class="fc" id="L106">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L107">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mousePressed(MouseEvent e) {
<span class="fc" id="L109">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L110">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L112">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L114">                                        onPress.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L115">                                    } catch (Exception ex) {</span>
<span class="nc" id="L116">                                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab press!&quot;, ex);</span>
<span class="fc" id="L117">                                    }</span>
<span class="fc" id="L118">                                });</span>
<span class="fc" id="L119">                        }</span>
                    });
<span class="fc" id="L121">               })</span>
<span class="fc" id="L122">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse release is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was released and whether the released tab is selected.
     *
     * @param onRelease The action to be performed when a tab is released.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseRelease( Action&lt;TabDelegate&gt; onRelease ) {
<span class="fc" id="L136">        NullUtil.nullArgCheck(onRelease, &quot;onRelease&quot;, Action.class);</span>
<span class="fc" id="L137">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L138">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseReleased(MouseEvent e) {
<span class="fc" id="L140">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L141">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L143">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L145">                                        onRelease.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L146">                                    } catch (Exception ex) {</span>
<span class="nc" id="L147">                                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab release!&quot;, ex);</span>
<span class="fc" id="L148">                                    }</span>
<span class="fc" id="L149">                                });</span>
<span class="fc" id="L150">                        }</span>
                    });
<span class="fc" id="L152">               })</span>
<span class="fc" id="L153">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse enter is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was entered and whether the entered tab is selected.
     *
     * @param onEnter The action to be performed when a tab is entered.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseEnter( Action&lt;TabDelegate&gt; onEnter ) {
<span class="fc" id="L167">        NullUtil.nullArgCheck(onEnter, &quot;onEnter&quot;, Action.class);</span>
<span class="fc" id="L168">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L169">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseEntered(MouseEvent e) {
<span class="fc" id="L171">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L172">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L173" title="2 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L174">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L176">                                        onEnter.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L177">                                    } catch (Exception ex) {</span>
<span class="nc" id="L178">                                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab enter!&quot;, ex);</span>
<span class="fc" id="L179">                                    }</span>
<span class="fc" id="L180">                                });</span>
<span class="fc" id="L181">                        }</span>
                    });
<span class="fc" id="L183">               })</span>
<span class="fc" id="L184">               ._this();</span>
    }

    /**
     *  Adds an action to be performed when a mouse exit is detected on a tab.
     *  The action will receive a {@link TabDelegate} instance which
     *  not only delegates the current tabbed pane and mouse event, but also
     *  tells the action which tab was exited and whether the exited tab is selected.
     *
     * @param onExit The action to be performed when a tab is exited.
     * @return This builder node.
     * @throws NullPointerException if the given action is null.
     */
    public final UIForTabbedPane&lt;P&gt; onTabMouseExit( Action&lt;TabDelegate&gt; onExit ) {
<span class="fc" id="L198">        NullUtil.nullArgCheck(onExit, &quot;onExit&quot;, Action.class);</span>
<span class="fc" id="L199">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L200">                    thisComponent.addMouseListener(new MouseAdapter() {</span>
                        @Override public void mouseExited(MouseEvent e) {
<span class="fc" id="L202">                            int indexOfTab = thisComponent.indexAtLocation(e.getX(), e.getY());</span>
<span class="fc" id="L203">                            int tabCount = thisComponent.getTabCount();</span>
<span class="pc bpc" id="L204" title="2 of 4 branches missed.">                            if ( indexOfTab &gt;= 0 &amp;&amp; indexOfTab &lt; tabCount )</span>
<span class="fc" id="L205">                                _runInApp(() -&gt; {</span>
                                    try {
<span class="fc" id="L207">                                        onExit.accept(new TabDelegate(thisComponent, e));</span>
<span class="nc" id="L208">                                    } catch (Exception ex) {</span>
<span class="nc" id="L209">                                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab exit!&quot;, ex);</span>
<span class="fc" id="L210">                                    }</span>
<span class="fc" id="L211">                                });</span>
<span class="fc" id="L212">                        }</span>
                    });
<span class="fc" id="L214">               })</span>
<span class="fc" id="L215">               ._this();</span>
    }

    /**
     *  Sets the selected tab based on the given index.
     * @param index The index of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( int index ) {
<span class="nc" id="L224">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L225">                   thisComponent.setSelectedIndex(index);</span>
<span class="nc" id="L226">               })</span>
<span class="nc" id="L227">               ._this();</span>
    }

    /**
     *  Dynamically sets the selected tab based on the given index property.
     *  So when the index property changes, the selected tab will change accordingly.
     * @param index The index property of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( Val&lt;Integer&gt; index ) {
<span class="nc" id="L237">        NullUtil.nullArgCheck( index, &quot;index&quot;, Val.class );</span>
<span class="nc" id="L238">        NullUtil.nullPropertyCheck( index, &quot;index&quot;, &quot;Null is not a valid state for modelling a selected index.&quot; );</span>
<span class="nc" id="L239">        return _withOnShow( index, (thisComponent,i) -&gt; {</span>
<span class="nc" id="L240">                    thisComponent.setSelectedIndex(i);</span>
<span class="nc" id="L241">               })</span>
<span class="nc" id="L242">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L243">                    thisComponent.setSelectedIndex(index.get());</span>
<span class="nc" id="L244">                })</span>
<span class="nc" id="L245">               ._this();</span>
    }

    /**
     *  Binds the given index property to the selection index of the tabbed pane,
     *  which means that when the index property changes, the selected tab will change accordingly
     *  and when the user selects a different tab, the index property will be updated accordingly.
     * @param index The index property of the tab to select.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withSelectedIndex( Var&lt;Integer&gt; index ) {
<span class="fc" id="L256">        NullUtil.nullArgCheck( index, &quot;index&quot;, Var.class );</span>
<span class="fc" id="L257">        NullUtil.nullPropertyCheck( index, &quot;index&quot;, &quot;Null is not a valid state for modelling a selected index.&quot; );</span>
<span class="fc" id="L258">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L259">                    ExtraState state = ExtraState.of(thisComponent);</span>
<span class="pc bpc" id="L260" title="3 of 4 branches missed.">                    if ( state.selectedTabIndex != null &amp;&amp; state.selectedTabIndex != index )</span>
<span class="nc" id="L261">                        log.warn(SwingTree.get().logMarker(),</span>
                                &quot;Trying to bind a new property '{}' to the index of tabbed pane '{}' even &quot; +
                                &quot;though the previously specified property '{}' is already bound to it. &quot; +
                                &quot;The previous property will be replaced now!&quot;,
<span class="nc" id="L265">                                index, thisComponent, state.selectedTabIndex,</span>
                                new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                            );

<span class="fc" id="L269">                    state.selectedTabIndex = index;</span>
<span class="fc" id="L270">               })</span>
<span class="fc" id="L271">               ._withOnShow( index, (thisComponent,i) -&gt; {</span>
<span class="fc" id="L272">                   ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L273">                   thisComponent.setSelectedIndex(i);</span>
<span class="fc" id="L274">                   state.selectionListeners.forEach( l -&gt; l.accept(i) );</span>
<span class="fc" id="L275">               })</span>
<span class="fc" id="L276">               ._with( thisComponent -&gt; {</span>
<span class="fc" id="L277">                   _onChange(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
<span class="fc" id="L278">                       ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L279">                       index.set(From.VIEW, thisComponent.getSelectedIndex());</span>
<span class="fc" id="L280">                       state.selectionListeners.forEach(l -&gt; l.accept(thisComponent.getSelectedIndex()) );</span>
<span class="fc" id="L281">                   }));</span>
<span class="fc" id="L282">                   thisComponent.setSelectedIndex(index.get());</span>
<span class="fc" id="L283">               })</span>
<span class="fc" id="L284">               ._this();</span>
    }

    /**
     *  Defines the tab placement side based on the given {@link swingtree.UI.Side} enum,
     *  which maps directly to the {@link JTabbedPane#setTabPlacement(int)} method.
     *
     * @param side The position to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withTabPlacementAt( UI.Side side ) {
<span class="fc" id="L295">        NullUtil.nullArgCheck(side, &quot;side&quot;, UI.Side.class );</span>
<span class="fc" id="L296">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L297">                    thisComponent.setTabPlacement(side.forTabbedPane());</span>
<span class="fc" id="L298">               })</span>
<span class="fc" id="L299">               ._this();</span>
    }

    /**
     *  Binds the supplied property to the tab placement of the tabbed pane.
     *  This means that when the property changes, the tab placement will change accordingly.
     *  The {@link swingtree.UI.Side} enum maps directly to the {@link JTabbedPane#setTabPlacement(int)} method.
     *
     * @param side The position property to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withTabPlacementAt( Val&lt;UI.Side&gt; side ) {
<span class="nc" id="L311">        NullUtil.nullArgCheck(side, &quot;side&quot;, Var.class);</span>
<span class="nc" id="L312">        return _withOnShow( side, (thisComponent,v) -&gt; {</span>
<span class="nc" id="L313">                    thisComponent.setTabPlacement(v.forTabbedPane());</span>
<span class="nc" id="L314">               })</span>
<span class="nc" id="L315">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L316">                    thisComponent.setTabPlacement(side.get().forTabbedPane());</span>
<span class="nc" id="L317">                })</span>
<span class="nc" id="L318">               ._this();</span>
    }

    /**
     *  Defines the overflow policy based on the given {@link swingtree.UI.OverflowPolicy} enum,
     *  which maps directly to the {@link JTabbedPane#setTabLayoutPolicy(int)} method.
     *  The overflow policy must either be {@link swingtree.UI.OverflowPolicy#SCROLL} or
     *  {@link swingtree.UI.OverflowPolicy#WRAP}.
     *  The {@link swingtree.UI.OverflowPolicy#SCROLL} policy will make the tabs scrollable
     *  when there are too many tabs to fit in the tabbed pane.
     *  The {@link swingtree.UI.OverflowPolicy#WRAP} policy will make the tabs wrap to the next line
     *  when there are too many tabs to fit in the tabbed pane.
     *
     * @param policy The overflow policy to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withOverflowPolicy( UI.OverflowPolicy policy ) {
<span class="nc" id="L335">        NullUtil.nullArgCheck( policy, &quot;policy&quot;, UI.OverflowPolicy.class );</span>
<span class="nc" id="L336">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L337">                    thisComponent.setTabLayoutPolicy(policy.forTabbedPane());</span>
<span class="nc" id="L338">               })</span>
<span class="nc" id="L339">               ._this();</span>
    }

    /**
     *  Binds the supplied enum property to the overflow policy of the tabbed pane.
     *  When the item of the property changes, the overflow policy will change accordingly.
     *  The {@link swingtree.UI.OverflowPolicy} enum maps directly to the
     *  {@link JTabbedPane#setTabLayoutPolicy(int)} method.
     *
     * @param policy The overflow policy property to use for the tabs.
     * @return This builder node.
     */
    public final UIForTabbedPane&lt;P&gt; withOverflowPolicy( Val&lt;UI.OverflowPolicy&gt; policy ) {
<span class="nc" id="L352">        NullUtil.nullArgCheck(policy, &quot;policy&quot;, Var.class);</span>
<span class="nc" id="L353">        return _withOnShow( policy, (thisComponent,v) -&gt; {</span>
<span class="nc" id="L354">                    thisComponent.setTabLayoutPolicy(v.forTabbedPane());</span>
<span class="nc" id="L355">               })</span>
<span class="nc" id="L356">                ._with( thisComponent -&gt; {</span>
<span class="nc" id="L357">                    thisComponent.setTabLayoutPolicy(policy.orElseThrowUnchecked().forTabbedPane());</span>
<span class="nc" id="L358">                })</span>
<span class="nc" id="L359">               ._this();</span>
    }

    private Supplier&lt;Integer&gt; _indexFinderFor(
        WeakReference&lt;P&gt; paneRef,
        WeakReference&lt;JComponent&gt; contentRef
    ) {
<span class="fc" id="L366">        return ()-&gt;{</span>
<span class="fc" id="L367">            P foundPane = paneRef.get();</span>
<span class="fc" id="L368">            JComponent foundContent = contentRef.get();</span>
<span class="pc bpc" id="L369" title="2 of 4 branches missed.">            if ( foundPane != null &amp;&amp; foundContent != null ) {</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                for ( int i = 0; i &lt; foundPane.getTabCount(); i++ ) {</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                    if ( foundContent == foundPane.getComponentAt(i) ) return i;</span>
                }
            }
<span class="nc" id="L374">            return -1;</span>
        };
    }

    /**
     *  Adds a tab to the tabbed pane based on the given {@link Tab} configuration.
     *  The tab will be added to the end of the tab list.
     *
     * @param tab The tab to add to the tabbed pane.
     * @return This builder node.
     * @throws NullPointerException if the given tab is null.
     */
    public final UIForTabbedPane&lt;P&gt; add( Tab tab )
    {
<span class="fc" id="L388">        Objects.requireNonNull(tab);</span>
<span class="fc" id="L389">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L390">            JComponent dummyContent = new JPanel();</span>
<span class="fc" id="L391">            WeakReference&lt;P&gt; paneRef = new WeakReference&lt;&gt;(thisComponent);</span>
<span class="fc" id="L392">            WeakReference&lt;JComponent&gt; contentRef = new WeakReference&lt;&gt;(tab.contents().orElse(dummyContent));</span>
<span class="fc" id="L393">            Supplier&lt;Integer&gt; indexFinder = _indexFinderFor(paneRef, contentRef);</span>
<span class="fc" id="L394">            tab.onSelection()</span>
<span class="fc" id="L395">               .ifPresent(onSelection -&gt;</span>
<span class="fc" id="L396">                   thisComponent.addChangeListener(e -&gt; {</span>
<span class="nc" id="L397">                       JTabbedPane tabbedPane = paneRef.get();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                       if ( tabbedPane == null ) return;</span>
<span class="nc" id="L399">                       int index = indexFinder.get();</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">                       if ( index &gt;= 0 &amp;&amp; index == tabbedPane.getSelectedIndex() )</span>
<span class="nc" id="L401">                           _runInApp(()-&gt;{</span>
                               try {
<span class="nc" id="L403">                                   onSelection.accept(new ComponentDelegate&lt;&gt;(tabbedPane, e));</span>
<span class="nc" id="L404">                               } catch (Exception ex) {</span>
<span class="nc" id="L405">                                   log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab selection!&quot;, ex);</span>
<span class="nc" id="L406">                               }</span>
<span class="nc" id="L407">                           });</span>
<span class="nc" id="L408">                   })</span>
               );

<span class="fc" id="L411">            TabMouseClickListener mouseListener = new TabMouseClickListener(thisComponent, indexFinder, tab.onMouseClick().orElse(null));</span>

            // Initial tab setup:
<span class="fc" id="L414">            _doWithoutListeners(thisComponent, ()-&gt; {</span>
<span class="fc" id="L415">                boolean hasSelectionBoolProp = tab.isSelected().isPresent();</span>
<span class="fc" id="L416">                ExtraState.of(thisComponent).doSilentlyIfAlreadyHasSelectionOrIf(hasSelectionBoolProp, ()-&gt;{</span>
<span class="fc" id="L417">                    thisComponent.addTab(</span>
<span class="fc" id="L418">                        tab.title().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L419">                        tab.icon().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L420">                        tab.contents().orElse(dummyContent),</span>
<span class="fc" id="L421">                        tab.tip().map(Val::orElseNull).orElse(null)</span>
                    );
<span class="fc" id="L423">                });</span>
<span class="fc" id="L424">            });</span>
<span class="fc" id="L425">            tab.isEnabled().ifPresent( isEnabled -&gt; thisComponent.setEnabledAt(indexFinder.get(), isEnabled.get()) );</span>
<span class="fc" id="L426">            tab.isSelected().ifPresent( isSelected -&gt; {</span>
<span class="fc" id="L427">                ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc" id="L428">                _selectTabFromModelling(thisComponent, indexFinder.get(), isSelected.get());</span>
<span class="pc bpc" id="L429" title="2 of 4 branches missed.">                if ( isSelected instanceof Var &amp;&amp; isSelected.isMutable() ) {</span>
<span class="fc" id="L430">                    Var&lt;Boolean&gt; isSelectedMut = (Var&lt;Boolean&gt;) isSelected;</span>
<span class="fc" id="L431">                    state.selectionListeners.add(i -&gt; {</span>
<span class="fc" id="L432">                        boolean isNowSelected = _isSuppliedTabIndexSelected(indexFinder, i);</span>
<span class="fc" id="L433">                        isSelectedMut.set(From.VIEW, isNowSelected);</span>
<span class="fc" id="L434">                    });</span>
                }
            /*
                The above listener will ensure that the isSelected property of the tab is updated when
                the selection index property changes.
             */
<span class="fc" id="L440">            });</span>

            // Now on to binding:
<span class="fc" id="L443">            tab.title()     .ifPresent( title      -&gt; _onShow(title,      thisComponent, (c,t) -&gt; c.setTitleAt(indexFinder.get(), t)) );</span>
<span class="fc" id="L444">            tab.icon()      .ifPresent( icon       -&gt; _onShow(icon,       thisComponent, (c,i) -&gt; c.setIconAt(indexFinder.get(), i)) );</span>
<span class="fc" id="L445">            tab.tip()       .ifPresent( tip        -&gt; _onShow(tip,        thisComponent, (c,t) -&gt; c.setToolTipTextAt(indexFinder.get(), t)) );</span>
<span class="fc" id="L446">            tab.isEnabled() .ifPresent( enabled    -&gt; _onShow(enabled,    thisComponent, (c,e) -&gt; c.setEnabledAt(indexFinder.get(), e)) );</span>
<span class="fc" id="L447">            tab.isSelected().ifPresent( isSelected -&gt; _onShow(isSelected, thisComponent, (c,s) -&gt; _selectTab(c, indexFinder.get(), s) ));</span>

<span class="fc" id="L449">            tab.headerContents().ifPresent( c -&gt;</span>
<span class="fc" id="L450">                    thisComponent</span>
<span class="fc" id="L451">                    .setTabComponentAt(</span>
<span class="fc" id="L452">                        thisComponent.getTabCount()-1,</span>
<span class="fc" id="L453">                        _buildTabHeader( tab, mouseListener )</span>
                    )
                );
<span class="fc" id="L456">        })</span>
<span class="fc" id="L457">        ._this();</span>
    }

    /**
     * Dynamically generates tabs for items in a {@link Vals} list and automatically updates them
     * when the items change. The items are typically view model instances, but can be any type.
     * &lt;p&gt;
     * The provided {@link TabSupplier} lambda is invoked with each item from the list,
     * returning a {@link Tab} to be added to the {@link JTabbedPane} wrapped by this builder.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; Binding tabs to a {@link Vals} list assumes no other tabs are present.
     * &lt;p&gt;
     * &lt;b&gt;Usage:&lt;/b&gt;
     * &lt;pre&gt;{@code
     *     UI.panel()
     *      .add(
     *          UI.tabbedPane().addAll(tabs, model -&gt;
     *              switch(model.type()) {
     *                  case LOGIN -&gt; UI.tab(&quot;Login&quot;).add(..);
     *                  case ABOUT -&gt; UI.tab(&quot;About&quot;).add(..);
     *                  case SETTINGS -&gt; UI.tab(&quot;Settings&quot;).add(..);
     *              }
     *          )
     *      )
     * }&lt;/pre&gt;
     *
     * @param &lt;M&gt;         The type of items in the {@link Vals} list.
     * @param tabModels   A list of items, typically view model instances.
     * @param tabSupplier A lambda to generate a {@link Tab} for each item.
     * @return This instance, allowing for builder-style method chaining.
     */
    public &lt;M&gt; UIForTabbedPane&lt;P&gt; addAll(Vals&lt;M&gt; tabModels, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L489">        Objects.requireNonNull(tabModels, &quot;tabModels&quot;);</span>
<span class="fc" id="L490">        Objects.requireNonNull(tabSupplier, &quot;tabSupplier&quot;);</span>
<span class="fc" id="L491">        return _with(thisComponent -&gt; {</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if ( thisComponent.getTabCount() &gt; 0 ) {</span>
<span class="nc" id="L493">                log.warn(SwingTree.get().logMarker(),</span>
                    &quot;Trying to bind a list of tabs to a tabbed pane that already has tabs. \n&quot; +
                    &quot;Manually defined tabs existing along with bound tabs is not supported. \n&quot; +
                    &quot;The manually defined tabs will be removed now!&quot;,
                    new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                );
<span class="nc" id="L499">                _doWithoutListeners(thisComponent, thisComponent::removeAll);</span>
            }
<span class="fc" id="L501">            _onShow(tabModels, thisComponent, (pane, delegate) -&gt; {</span>
<span class="fc" id="L502">                _updateTabs(pane, delegate, tabSupplier);</span>
<span class="fc" id="L503">            });</span>

<span class="fc" id="L505">            tabModels.forEach(v -&gt; _addTabAt(thisComponent.getTabCount(), v, tabSupplier, thisComponent));</span>
<span class="fc" id="L506">        })._this();</span>
    }

    private &lt;M&gt; void _updateTabs(P pane, ValsDelegate&lt;M&gt; delegate, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L510">        Vals&lt;M&gt; newValues = delegate.newValues();</span>
<span class="fc" id="L511">        Vals&lt;M&gt; oldValues = delegate.oldValues();</span>
<span class="fc" id="L512">        int index = delegate.index().orElse(-1);</span>

<span class="pc bpc" id="L514" title="2 of 6 branches missed.">        switch (delegate.change()) {</span>
            case SET:
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
                    // Some things were set, but we don't know where exactly
<span class="nc" id="L518">                    pane.removeAll();</span>
<span class="nc" id="L519">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L521" title="All 2 branches covered.">                    for (int i = 0; i &lt; newValues.size(); i++) {</span>
<span class="fc" id="L522">                        int position = index + i;</span>
<span class="fc" id="L523">                        _updateTabAt(position, newValues.at(i).orElseNull(), tabSupplier, pane);</span>
                    }
                }
<span class="fc" id="L526">                break;</span>
            case ADD:
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
                    // Some things were added, but we don't know where exactly
<span class="nc" id="L530">                    pane.removeAll();</span>
<span class="nc" id="L531">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L533" title="All 2 branches covered.">                    for (int i = 0; i &lt; newValues.size(); i++) {</span>
<span class="fc" id="L534">                        int position = index + i;</span>
<span class="fc" id="L535">                        _addTabAt(position, newValues.at(i).orElseNull(), tabSupplier, pane);</span>
                    }
                }
<span class="fc" id="L538">                break;</span>
            case REMOVE:
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                if ( index &lt; 0 ) {</span>
                    // Some things were removed, but we don't know where exactly
<span class="nc" id="L542">                    pane.removeAll();</span>
<span class="nc" id="L543">                    delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
                } else {
<span class="fc bfc" id="L545" title="All 2 branches covered.">                    for (int i = 0; i &lt; oldValues.size(); i++) {</span>
<span class="fc" id="L546">                        _removeTabAt(index, pane);</span>
                    }
                }
<span class="fc" id="L549">                break;</span>
            case CLEAR:
<span class="fc" id="L551">                pane.removeAll();</span>
<span class="fc" id="L552">                break;</span>
            case NONE:
<span class="nc" id="L554">                break;</span>
            default:
<span class="nc" id="L556">                log.warn(SwingTree.get().logMarker(),</span>
                        &quot;Unknown change type: {}&quot;,
<span class="nc" id="L558">                        delegate.change(), new Throwable(&quot;Stack trace for debugging purposes.&quot;)</span>
                    );
                // We do a simple rebuild:
<span class="nc" id="L561">                pane.removeAll();</span>
<span class="nc" id="L562">                delegate.currentValues().forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
        }

<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        if (pane.getTabCount() != delegate.currentValues().size()) {</span>
<span class="nc" id="L566">            log.warn(SwingTree.get().logMarker(),</span>
                &quot;Broken binding to view model list detected! \n&quot; +
                &quot;TabbedPane tab count '{}' does not match tab models list of size '{}'. \n&quot; +
                &quot;A possible cause for this is that tabs were {} this '{}' \n&quot; +
                &quot;directly, instead of through the property list binding. \n&quot; +
                &quot;However, this could also be a bug in the UI framework.&quot;,
<span class="nc" id="L572">                pane.getComponentCount(),</span>
<span class="nc" id="L573">                delegate.currentValues().size(),</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                pane.getTabCount() &gt; delegate.currentValues().size() ? &quot;added to&quot; : &quot;removed from&quot;,</span>
                pane,
                new Throwable(&quot;Stack trace for debugging purposes.&quot;)
            );
        }
<span class="fc" id="L579">    }</span>

    /**
     * Dynamically generates tabs for items in a {@link Tuple} {@link Val} and automatically updates them
     * when the items change. The tuple items are typically view model instances, but can be any type.
     * &lt;p&gt;
     * The provided {@link TabSupplier} lambda is invoked with each item from the tuple,
     * returning a {@link Tab} to be added to the {@link JTabbedPane} wrapped by this builder.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; Binding tabs to a {@link Tuple} {@link Val} assumes no other tabs are present.
     * &lt;p&gt;
     * &lt;b&gt;Usage:&lt;/b&gt;
     * &lt;pre&gt;{@code
     *     UI.panel()
     *      .add(
     *          UI.tabbedPane().addAll(tabs, model -&gt;
     *              switch(model.type()) {
     *                  case LOGIN -&gt; UI.tab(&quot;Login&quot;).add(..);
     *                  case ABOUT -&gt; UI.tab(&quot;About&quot;).add(..);
     *                  case SETTINGS -&gt; UI.tab(&quot;Settings&quot;).add(..);
     *              }
     *          )
     *      )
     * }&lt;/pre&gt;
     *
     * @param &lt;M&gt;         The type of items in the form of a {@link Tuple} wrapped by a {@link Val}.
     * @param tabModels   A list of items, typically view model instances.
     * @param tabSupplier A lambda to generate a {@link Tab} for each item.
     * @return This instance, allowing for builder-style method chaining.
     */
    public &lt;M&gt; UIForTabbedPane&lt;P&gt; addAll(Val&lt;Tuple&lt;M&gt;&gt; tabModels, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L610">        Objects.requireNonNull(tabModels, &quot;tabModels&quot;);</span>
<span class="fc" id="L611">        Objects.requireNonNull(tabSupplier, &quot;tabSupplier&quot;);</span>
<span class="fc" id="L612">        return _with(thisComponent -&gt; {</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            if ( thisComponent.getTabCount() &gt; 0 ) {</span>
<span class="nc" id="L614">                log.warn(SwingTree.get().logMarker(),</span>
                    &quot;Trying to bind a tuple of tabs to a tabbed pane that already has tabs. \n&quot; +
                    &quot;Manually defined tabs existing along with bound tabs is not supported. \n&quot; +
                    &quot;The manually defined tabs will be removed now!&quot;,
                    new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                );
<span class="nc" id="L620">                _doWithoutListeners(thisComponent, thisComponent::removeAll);</span>
            }
<span class="fc" id="L622">            AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef = new AtomicReference&lt;&gt;(null);</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">            if (tabModels.get() instanceof SequenceDiffOwner)</span>
<span class="fc" id="L624">                lastDiffRef.set(((SequenceDiffOwner)tabModels.get()).differenceFromPrevious().orElse(null));</span>
<span class="fc" id="L625">            _onShow(tabModels, thisComponent, (pane, tupleOfModels) -&gt; {</span>
<span class="fc" id="L626">                _updateTabs(pane, tupleOfModels, lastDiffRef, tabSupplier);</span>
<span class="fc" id="L627">            });</span>

<span class="fc" id="L629">            tabModels.get().forEach(v -&gt; _addTabAt(thisComponent.getTabCount(), v, tabSupplier, thisComponent));</span>
<span class="fc" id="L630">        })._this();</span>
    }

    private  &lt;M&gt; void _updateTabs(P pane, Tuple&lt;M&gt; tupleOfModels, AtomicReference&lt;@Nullable SequenceDiff&gt; lastDiffRef, TabSupplier&lt;M&gt; tabSupplier) {
<span class="fc" id="L634">        SequenceDiff diff = null;</span>
<span class="fc" id="L635">        SequenceDiff lastDiff = lastDiffRef.get();</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if (tupleOfModels instanceof SequenceDiffOwner)</span>
<span class="fc" id="L637">            diff = ((SequenceDiffOwner)tupleOfModels).differenceFromPrevious().orElse(null);</span>
<span class="fc" id="L638">        lastDiffRef.set(diff);</span>

<span class="pc bpc" id="L640" title="2 of 6 branches missed.">        if ( diff == null || ( lastDiff == null || !diff.isDirectSuccessorOf(lastDiff) ) ) {</span>
<span class="fc" id="L641">            pane.removeAll();</span>
<span class="fc" id="L642">            tupleOfModels.forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
        } else {
<span class="pc bpc" id="L644" title="2 of 7 branches missed.">            switch (diff.change()) {</span>
                case SET:
<span class="fc bfc" id="L646" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L647">                        int position = diff.index().orElse(0) + i;</span>
<span class="fc" id="L648">                        _updateTabAt(position, tupleOfModels.get(position), tabSupplier, pane);</span>
                    }
<span class="fc" id="L650">                    break;</span>
                case ADD:
<span class="fc bfc" id="L652" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L653">                        int position = diff.index().orElse(0) + i;</span>
<span class="fc" id="L654">                        _addTabAt(position, tupleOfModels.get(position), tabSupplier, pane);</span>
                    }
<span class="fc" id="L656">                    break;</span>
                case REMOVE:
<span class="fc bfc" id="L658" title="All 2 branches covered.">                    for (int i = 0; i &lt; diff.size(); i++) {</span>
<span class="fc" id="L659">                        _removeTabAt(diff.index().orElse(0), pane);</span>
                    }
<span class="fc" id="L661">                    break;</span>
                case RETAIN:
<span class="fc" id="L663">                    int currentNumberOfTabs = pane.getTabCount();</span>
<span class="fc" id="L664">                    int firstToRemove = diff.index().orElse(0);</span>
<span class="fc" id="L665">                    int lastToRemove = currentNumberOfTabs - (firstToRemove + diff.size());</span>
                    //remove the first n tabs
<span class="fc bfc" id="L667" title="All 2 branches covered.">                    for (int i = 0; i &lt; firstToRemove; i++) {</span>
<span class="fc" id="L668">                        _removeTabAt(0, pane);</span>
                    }
                    // remove the last n tabs
<span class="fc bfc" id="L671" title="All 2 branches covered.">                    for (int i = 0; i &lt; lastToRemove; i++) {</span>
<span class="fc" id="L672">                        _removeTabAt(diff.size(), pane);</span>
                    }
<span class="fc" id="L674">                    break;</span>
                case CLEAR:
<span class="fc" id="L676">                    pane.removeAll();</span>
<span class="fc" id="L677">                    break;</span>
                case NONE:
<span class="nc" id="L679">                    break;</span>
                default:
<span class="nc" id="L681">                    log.warn(SwingTree.get().logMarker(),</span>
                            &quot;Unknown change type: {}&quot;,
<span class="nc" id="L683">                            diff.change(), new Throwable(&quot;Stack trace for debugging purposes.&quot;)</span>
                        );
                    // We do a simple rebuild:
<span class="nc" id="L686">                    pane.removeAll();</span>
<span class="nc" id="L687">                    tupleOfModels.forEach(value -&gt; _addTabAt(pane.getTabCount(), value, tabSupplier, pane));</span>
            }
        }

<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if (pane.getTabCount() != tupleOfModels.size()) {</span>
<span class="nc" id="L692">            log.warn(SwingTree.get().logMarker(),</span>
                &quot;Broken binding to view model tuple detected! \n&quot; +
                &quot;TabbedPane tab count '{}' does not match tab models tuple of size '{}'. \n&quot; +
                &quot;A possible cause for this is that tabs were {} this '{}' \n&quot; +
                &quot;directly, instead of through the property tuple binding. \n&quot; +
                &quot;However, this could also be a bug in the UI framework.&quot;,
<span class="nc" id="L698">                pane.getComponentCount(),</span>
<span class="nc" id="L699">                tupleOfModels.size(),</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                pane.getTabCount() &gt; tupleOfModels.size() ? &quot;added to&quot; : &quot;removed from&quot;,</span>
                pane,
                new Throwable(&quot;Stack trace for debugging purposes.&quot;)
            );
        }
<span class="fc" id="L705">    }</span>

    private void _doWithoutListeners( P thisComponent, Runnable r ) {
<span class="fc" id="L708">        ChangeListener[] listeners = thisComponent.getChangeListeners();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for ( ChangeListener l : listeners ) thisComponent.removeChangeListener(l);</span>
<span class="fc" id="L710">        r.run();</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        for ( ChangeListener l : listeners ) thisComponent.addChangeListener(l);</span>
        /*
            This is important because the tabbed pane will fire a change event when a tab is added.
            This is not desirable because the tabbed pane is not yet fully initialized at that point.
        */
<span class="fc" id="L716">    }</span>

    private void _selectTab( P thisComponent, int tabIndex, boolean isSelected ) {
<span class="fc" id="L719">        ExtraState state = ExtraState.of(thisComponent);</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        int selectedIndex = ( isSelected ? tabIndex : thisComponent.getSelectedIndex() );</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        if ( state.selectedTabIndex != null )</span>
<span class="fc" id="L722">            state.selectedTabIndex.set(From.VIEW, selectedIndex);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        else if ( isSelected )</span>
<span class="fc" id="L724">            thisComponent.setSelectedIndex(selectedIndex);</span>

<span class="fc" id="L726">        state.selectionListeners.forEach(l -&gt; l.accept(selectedIndex));</span>
<span class="fc" id="L727">    }</span>

    private void _selectTabFromModelling( P thisComponent, int tabIndex, boolean isSelected ) {
<span class="fc bfc" id="L730" title="All 2 branches covered.">        int selectedIndex = ( isSelected ? tabIndex : thisComponent.getSelectedIndex() );</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if ( isSelected )</span>
<span class="fc" id="L732">            thisComponent.setSelectedIndex(selectedIndex);</span>
<span class="fc" id="L733">    }</span>

    private JComponent _buildTabHeader( Tab tab, TabMouseClickListener mouseListener )
    {
<span class="fc" id="L737">        return</span>
<span class="fc" id="L738">            tab.title().map( title -&gt;</span>
                // We want both title and user component in the header!
<span class="fc" id="L740">                UI.panel(&quot;fill, ins 0&quot;).withBackground(new Color(0,0,0,0))</span>
<span class="pc" id="L741">                .applyIfPresent( tab.tip().map( tip -&gt; panel -&gt; panel.withTooltip(tip) ) )</span>
<span class="fc" id="L742">                .peek( it -&gt; {</span>
<span class="fc" id="L743">                    it.addMouseListener(mouseListener);</span>
<span class="fc" id="L744">                    mouseListener.addOwner(it);</span>
<span class="fc" id="L745">                })</span>
<span class="fc" id="L746">                .add(&quot;shrink&quot;,</span>
<span class="fc" id="L747">                    UI.label(title).withBackground(new Color(0,0,0,0))</span>
<span class="pc" id="L748">                    .applyIfPresent( tab.tip().map( tip -&gt; label -&gt; label.withTooltip(tip) ) )</span>
<span class="fc" id="L749">                    .peek( it -&gt; {</span>
<span class="fc" id="L750">                        it.addMouseListener(mouseListener);</span>
<span class="fc" id="L751">                        mouseListener.addOwner(it);</span>
<span class="fc" id="L752">                    })</span>
                )
<span class="fc" id="L754">                .add(&quot;grow&quot;, tab.headerContents().orElse(new JPanel()))</span>
<span class="fc" id="L755">                .getComponent()</span>
            )
<span class="fc" id="L757">            .map( p -&gt; (JComponent) p )</span>
<span class="fc" id="L758">            .orElse(tab.headerContents().orElse(new JPanel()));</span>
    }

    private class TabMouseClickListener extends MouseAdapter
    {
<span class="fc" id="L763">        private final List&lt;WeakReference&lt;JComponent&gt;&gt; ownerRefs = new ArrayList&lt;&gt;();</span>
        private final WeakReference&lt;JTabbedPane&gt; paneRef;
        private final Supplier&lt;Integer&gt; indexFinder;
        private final @Nullable Action&lt;ComponentDelegate&lt;JTabbedPane, MouseEvent&gt;&gt; mouseClickAction;


        private TabMouseClickListener(
            JTabbedPane pane,
            Supplier&lt;Integer&gt; indexFinder,
            @Nullable Action&lt;ComponentDelegate&lt;JTabbedPane, MouseEvent&gt;&gt; mouseClickAction
<span class="fc" id="L773">        ) {</span>
<span class="fc" id="L774">            this.paneRef = new WeakReference&lt;&gt;(pane);</span>
<span class="fc" id="L775">            this.indexFinder = Objects.requireNonNull(indexFinder);</span>
<span class="fc" id="L776">            this.mouseClickAction = mouseClickAction;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            if ( mouseClickAction != null ) {</span>
<span class="fc" id="L778">                pane.addMouseListener(new java.awt.event.MouseAdapter() {</span>
                    @Override
                    public void mouseClicked( MouseEvent e ) {
<span class="nc" id="L781">                        JTabbedPane pane = paneRef.get();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                        if ( pane == null ) return;</span>
<span class="nc" id="L783">                        int indexOfThis = indexOfThisTab();</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                        if ( indexOfThis &lt; 0 ) return;</span>
<span class="nc" id="L785">                        int indexClicked = pane.indexAtLocation(e.getX(), e.getY());</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                        if ( indexClicked &lt; 0 ) return;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                        if ( indexOfThis == indexClicked )</span>
<span class="nc" id="L788">                            _runInApp(()-&gt; {</span>
                                try {
<span class="nc" id="L790">                                    mouseClickAction.accept(new ComponentDelegate&lt;&gt;(pane, e));</span>
<span class="nc" id="L791">                                } catch (Exception ex) {</span>
<span class="nc" id="L792">                                    log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="nc" id="L793">                                }</span>
<span class="nc" id="L794">                            });</span>
<span class="nc" id="L795">                    }</span>
                });
            }
<span class="fc" id="L798">        }</span>

        private void doAction( JTabbedPane pane, MouseEvent e ) {
<span class="nc" id="L801">            Point p = e.getPoint();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if ( e.getSource() != pane ) {</span>
               // We need to find the point relative to the tabbed pane:
<span class="nc" id="L804">                p = traversePosition((Component) e.getSource(), pane, p);</span>
            }
<span class="nc" id="L806">            int indexOfThis = indexOfThisTab();</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if ( indexOfThis &lt; 0 ) return;</span>
<span class="nc" id="L808">            int indexClicked = pane.indexAtLocation(p.x, p.y);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            if ( indexClicked &lt; 0 ) return;</span>
<span class="nc bnc" id="L810" title="All 4 branches missed.">            if ( indexOfThis == indexClicked &amp;&amp; mouseClickAction != null )</span>
<span class="nc" id="L811">                _runInApp(()-&gt; {</span>
                    try {
<span class="nc" id="L813">                        mouseClickAction.accept(new ComponentDelegate&lt;&gt;(pane, e));</span>
<span class="nc" id="L814">                    } catch (Exception ex) {</span>
<span class="nc" id="L815">                        log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab click!&quot;, ex);</span>
<span class="nc" id="L816">                    }</span>
<span class="nc" id="L817">                });</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if ( indexOfThis &lt; pane.getTabCount() )</span>
<span class="nc" id="L819">                pane.setSelectedIndex(indexOfThis);</span>
<span class="nc" id="L820">        }</span>

        private int indexOfThisTab() {
<span class="nc" id="L823">            return indexFinder.get();</span>
        }

<span class="fc" id="L826">        public void addOwner(JComponent c) { this.ownerRefs.add(new WeakReference&lt;&gt;(c)); }</span>

        @Override
        public void mouseClicked( MouseEvent e ) {
<span class="nc" id="L830">            JTabbedPane pane = this.paneRef.get();</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if ( pane == null ) {</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                for ( WeakReference&lt;JComponent&gt; compRef : this.ownerRefs) {</span>
<span class="nc" id="L833">                    JComponent owner = compRef.get();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                    if ( owner != null )</span>
<span class="nc" id="L835">                        owner.removeMouseListener(this);</span>
<span class="nc" id="L836">                }</span>
            }
<span class="nc" id="L838">            else doAction( pane, e );</span>
<span class="nc" id="L839">        }</span>
    }

    /**
     *  If we click on a subcomponent on the header we need to traverse
     *  upwards to find the click position relative to the tabbed pane!
     *  Otherwise we don't know where the click went.
     *
     * @param current The component where we currently have the relative position {@code p}.
     * @param end The component at which we end traversal when it is the same as the current.
     * @param p The relative position to the current component.
     * @return The relative position to the end component!
     */
    private static Point traversePosition( Component current, Component end, Point p ) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if ( current == end ) return p;</span>
<span class="nc" id="L854">        Component parent = current.getParent();</span>
<span class="nc" id="L855">        Point relativeToParent = SwingUtilities.convertPoint(current, p, parent);</span>
<span class="nc" id="L856">        return traversePosition(parent, end, relativeToParent);</span>
    }

    /**
     * Adds an {@link Action} to the underlying {@link JTabbedPane}
     * through an {@link javax.swing.event.ChangeListener},
     * which will be called when the state of the tabbed pane changes.
     * For more information see {@link JTabbedPane#addChangeListener(javax.swing.event.ChangeListener)}.
     *
     * @param onChange The {@link Action} that will be called through the underlying change event.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final UIForTabbedPane&lt;P&gt; onChange( Action&lt;ComponentDelegate&lt;P, ChangeEvent&gt;&gt; onChange ) {
<span class="fc" id="L869">        NullUtil.nullArgCheck(onChange, &quot;onChange&quot;, Action.class);</span>
<span class="fc" id="L870">        return _with( thisComponent -&gt; {</span>
<span class="pc" id="L871">                    _onChange(thisComponent, e -&gt; _runInApp(()-&gt;{</span>
                        try {
<span class="nc" id="L873">                            onChange.accept(new ComponentDelegate&lt;&gt;(thisComponent, e));</span>
<span class="nc" id="L874">                        } catch (Exception ex) {</span>
<span class="nc" id="L875">                            log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab change!&quot;, ex);</span>
<span class="nc" id="L876">                        }</span>
<span class="nc" id="L877">                    }));</span>
<span class="fc" id="L878">                })</span>
<span class="fc" id="L879">                ._this();</span>
    }

    private void _onChange( P thisComponent, Consumer&lt;ChangeEvent&gt; action ) {
<span class="fc" id="L883">        thisComponent.addChangeListener(action::accept);</span>
<span class="fc" id="L884">    }</span>

    private &lt;M&gt; void _addTabAt(int index, @Nullable M m, TabSupplier&lt;M&gt; tabSupplier, P p) {
<span class="fc" id="L887">        Tab tab = _createTab(m, tabSupplier);</span>

<span class="fc" id="L889">        JComponent dummyContent = new JPanel();</span>
<span class="fc" id="L890">        WeakReference&lt;P&gt; paneRef = new WeakReference&lt;&gt;(p);</span>
<span class="fc" id="L891">        WeakReference&lt;JComponent&gt; contentRef = new WeakReference&lt;&gt;(tab.contents().orElse(dummyContent));</span>
<span class="fc" id="L892">        Supplier&lt;Integer&gt; indexFinder = _indexFinderFor(paneRef, contentRef);</span>

<span class="fc" id="L894">        tab.onSelection()</span>
<span class="fc" id="L895">            .ifPresent(onSelection -&gt; {</span>
<span class="nc" id="L896">                OnSelectionMultiplexer.of(p).set(index, e -&gt; {</span>
<span class="nc" id="L897">                    JTabbedPane tabbedPane = paneRef.get();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">                    if (tabbedPane == null) return;</span>
<span class="nc" id="L899">                    int i = indexFinder.get();</span>
<span class="nc bnc" id="L900" title="All 4 branches missed.">                    if (i &gt;= 0 &amp;&amp; i == tabbedPane.getSelectedIndex())</span>
<span class="nc" id="L901">                        _runInApp(() -&gt; {</span>
                            try {
<span class="nc" id="L903">                                onSelection.accept(new ComponentDelegate&lt;&gt;(tabbedPane, e));</span>
<span class="nc" id="L904">                            } catch (Exception ex) {</span>
<span class="nc" id="L905">                                log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab selection!&quot;, ex);</span>
<span class="nc" id="L906">                            }</span>
<span class="nc" id="L907">                        });</span>
<span class="nc" id="L908">                });</span>
<span class="nc" id="L909">            });</span>

<span class="fc" id="L911">        TabMouseClickListener mouseListener = new TabMouseClickListener(p, indexFinder, tab.onMouseClick().orElse(null));</span>

        // Initial tab setup:
<span class="fc" id="L914">        p.insertTab(</span>
<span class="fc" id="L915">            tab.title().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L916">            tab.icon().map(Val::orElseNull).orElse(null),</span>
<span class="fc" id="L917">            tab.contents().orElse(dummyContent),</span>
<span class="fc" id="L918">            tab.tip().map(Val::orElseNull).orElse(null),</span>
            index
        );
<span class="pc" id="L921">        tab.isEnabled().ifPresent(isEnabled -&gt; p.setEnabledAt(indexFinder.get(), isEnabled.get()));</span>
<span class="fc" id="L922">        tab.isSelected().ifPresent(isSelected -&gt; {</span>
<span class="nc" id="L923">            ExtraState state = ExtraState.of(p);</span>
<span class="nc" id="L924">            _selectTabFromModelling(p, indexFinder.get(), isSelected.get());</span>
<span class="nc bnc" id="L925" title="All 4 branches missed.">            if (isSelected instanceof Var &amp;&amp; isSelected.isMutable()) {</span>
<span class="nc" id="L926">                Var&lt;Boolean&gt; isSelectedMut = (Var&lt;Boolean&gt;) isSelected;</span>
<span class="nc" id="L927">                state.selectionListeners.add(i -&gt; {</span>
<span class="nc" id="L928">                    boolean isNowSelected = _isSuppliedTabIndexSelected(indexFinder, i);</span>
<span class="nc" id="L929">                    isSelectedMut.set(From.VIEW, isNowSelected);</span>
<span class="nc" id="L930">                });</span>
            }
            /*
                The above listener will ensure that the isSelected property of the tab is updated when
                the selection index property changes.
             */
<span class="nc" id="L936">        });</span>

        // Now on to binding:
<span class="pc" id="L939">        tab.title().ifPresent(title -&gt; _onShow(title, p, (c, t) -&gt; c.setTitleAt(indexFinder.get(), t)));</span>
<span class="pc" id="L940">        tab.icon().ifPresent(icon -&gt; _onShow(icon, p, (c, i) -&gt; c.setIconAt(indexFinder.get(), i)));</span>
<span class="pc" id="L941">        tab.tip().ifPresent(tip -&gt; _onShow(tip, p, (c, t) -&gt; c.setToolTipTextAt(indexFinder.get(), t)));</span>
<span class="pc" id="L942">        tab.isEnabled().ifPresent(enabled -&gt; _onShow(enabled, p, (c, e) -&gt; c.setEnabledAt(indexFinder.get(), e)));</span>
<span class="pc" id="L943">        tab.isSelected().ifPresent(isSelected -&gt; _onShow(isSelected, p, (c, s) -&gt; _selectTab(c, indexFinder.get(), s)));</span>

<span class="pc" id="L945">        tab.headerContents().ifPresent(c -&gt; p.setTabComponentAt(index, _buildTabHeader(tab, mouseListener)));</span>
<span class="fc" id="L946">    }</span>

    private static final class OnSelectionMultiplexer implements ChangeListener {
        static OnSelectionMultiplexer of(JTabbedPane pane) {
<span class="nc" id="L950">            ComponentExtension&lt;JTabbedPane&gt; extension = ComponentExtension.from(pane);</span>
<span class="nc" id="L951">            OnSelectionMultiplexer found = extension.getOrSet(OnSelectionMultiplexer.class, ()-&gt;new OnSelectionMultiplexer(pane));</span>
<span class="nc" id="L952">            return found;</span>
        }

<span class="nc" id="L955">        private final Map&lt;Integer, ChangeListener&gt; _subListeners = new HashMap&lt;&gt;();</span>

<span class="nc" id="L957">        private OnSelectionMultiplexer(JTabbedPane pane) {</span>
<span class="nc" id="L958">            pane.addChangeListener(this);</span>
<span class="nc" id="L959">        }</span>

        void set(int index, ChangeListener listener) {
<span class="nc" id="L962">            _subListeners.put(index, listener);</span>
<span class="nc" id="L963">        }</span>

        private void _cleanup(JTabbedPane pane) {
<span class="nc" id="L966">            int numberOfTabs = pane.getTabCount();</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            for ( int i : new ArrayList&lt;&gt;(_subListeners.keySet()) ) {</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">                if ( i &lt; 0 || i &gt;= numberOfTabs ) {</span>
<span class="nc" id="L969">                    _subListeners.remove(i);</span>
                }
<span class="nc" id="L971">            }</span>
<span class="nc" id="L972">        }</span>

        @Override
        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L976">            _cleanup((JTabbedPane)e.getSource());</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">            for ( ChangeListener listener : _subListeners.values() ) {</span>
                try {
<span class="nc" id="L979">                    listener.stateChanged(e);</span>
<span class="nc" id="L980">                } catch (Exception ex) {</span>
<span class="nc" id="L981">                    log.error(SwingTree.get().logMarker(), &quot;Error while executing action on tab selection!&quot;, ex);</span>
<span class="nc" id="L982">                }</span>
<span class="nc" id="L983">            }</span>
<span class="nc" id="L984">        }</span>
    }

    private static boolean _isSuppliedTabIndexSelected(Supplier&lt;Integer&gt; indexOfCurrent, int newIndex) {
<span class="fc bfc" id="L988" title="All 4 branches covered.">        return newIndex &gt;= 0 &amp;&amp; Objects.equals(newIndex, indexOfCurrent.get());</span>
    }

    private &lt;M&gt; void _updateTabAt(int index, @Nullable M m, TabSupplier&lt;M&gt; tabSupplier, P p) {
<span class="fc" id="L992">        _removeTabAt(index, p);</span>
<span class="fc" id="L993">        _addTabAt(index, m, tabSupplier, p);</span>
<span class="fc" id="L994">    }</span>

    private void _removeTabAt(int index, P p) {
<span class="fc" id="L997">        p.removeTabAt(index);</span>
<span class="fc" id="L998">    }</span>

    private &lt;M&gt; Tab _createTab( @Nullable M m, TabSupplier&lt;M&gt; tabSupplier ) {
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">        if (m == null)</span>
<span class="nc" id="L1002">            return UIForTabbedPane.TAB_NULL;</span>

        try {
<span class="fc" id="L1005">            Tab tab = tabSupplier.createTabFor(m);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            if ( tab == null ) {</span>
<span class="fc" id="L1007">                log.warn(SwingTree.get().logMarker(),</span>
                        &quot;Tab supplier returned null for '{}'.&quot;,
                        m, new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                    );
<span class="fc" id="L1011">                return UIForTabbedPane.TAB_NULL;</span>
            }
<span class="fc" id="L1013">            return tab;</span>
<span class="fc" id="L1014">        } catch (Exception e) {</span>
<span class="fc" id="L1015">            log.error(SwingTree.get().logMarker(), &quot;Error while creating tab for '{}'.&quot;, m, e);</span>
<span class="fc" id="L1016">            return UIForTabbedPane.TAB_ERROR;</span>
        }
    }

<span class="fc" id="L1020">    private static class ExtraState extends DefaultSingleSelectionModel</span>
    {
        static ExtraState of( JTabbedPane pane ) {
<span class="fc" id="L1023">            return ComponentExtension.from(pane)</span>
<span class="fc" id="L1024">                    .getOrSet(ExtraState.class, ExtraState::new);</span>
        }

<span class="fc" id="L1027">        final List&lt;Consumer&lt;Integer&gt;&gt; selectionListeners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1028">        private @Nullable Var&lt;Integer&gt; selectedTabIndex = null;</span>
<span class="fc" id="L1029">        private boolean ignoreChanges = false;</span>

        @Override public void setSelectedIndex(int index) {
<span class="fc bfc" id="L1032" title="All 2 branches covered.">            if ( ignoreChanges )</span>
<span class="fc" id="L1033">                return;</span>
<span class="fc" id="L1034">            super.setSelectedIndex(index);</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">            if ( selectedTabIndex != null )</span>
<span class="fc" id="L1036">                selectedTabIndex.set(From.VIEW, index);</span>

<span class="fc" id="L1038">            selectionListeners.forEach(l -&gt; l.accept(index));</span>
<span class="fc" id="L1039">        }</span>
        @Override public void clearSelection() {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            if ( ignoreChanges )</span>
<span class="nc" id="L1042">                return;</span>
<span class="nc" id="L1043">            super.clearSelection();</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            if ( selectedTabIndex != null )</span>
<span class="nc" id="L1045">                selectedTabIndex.set(From.VIEW, -1);</span>
<span class="nc" id="L1046">        }</span>

        private void doSilentlyIfAlreadyHasSelectionOrIf(boolean condition, Runnable action) {
<span class="pc bpc" id="L1049" title="1 of 4 branches missed.">            ignoreChanges = ( condition || this.selectedTabIndex != null );</span>
            try {
<span class="fc" id="L1051">                action.run();</span>
            } finally {
<span class="fc" id="L1053">                ignoreChanges = false;</span>
            }
<span class="fc" id="L1055">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>