<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UI.java</span></div><h1>UI.java</h1><pre class="source lang-java linenums">package swingtree;

import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import sprouts.Event;
import sprouts.*;
import swingtree.animation.Animator;
import swingtree.animation.LifeTime;
import swingtree.api.*;
import swingtree.api.model.BasicTableModel;
import swingtree.api.model.TableListDataSource;
import swingtree.api.model.TableMapDataSource;
import swingtree.components.JBox;
import swingtree.components.JIcon;
import swingtree.components.JScrollPanels;
import swingtree.components.JSplitButton;
import swingtree.dialogs.ConfirmAnswer;
import swingtree.dialogs.ConfirmDialogBuilder;
import swingtree.dialogs.MessageDialogBuilder;
import swingtree.layout.LayoutConstraint;
import swingtree.style.*;
import swingtree.threading.EventProcessor;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.plaf.DimensionUIResource;
import javax.swing.plaf.InsetsUIResource;
import javax.swing.plaf.UIResource;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumnModel;
import javax.swing.text.JTextComponent;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.geom.RoundRectangle2D;
import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 *  This class is a static API for exposing swing tree builder types for wrapping
 *  and assembling various {@link JComponent} types to form a UI tree.
 *  Instances of these builder type expose an API based on chained methods
 *  designed around functional interfaces to enable building UI tree structures for Swing
 *  in an HTML-like nested fashion while also keeping a high degree of control and transparency
 *  by peeking into the underlying swing components or registering user actions through lambdas.
 *  Swing tree works especially well alongside {@link MigLayout}s,
 *  which is why this general purpose {@link LayoutManager} is integrated into this library.
 *  Simply pass {@link String} constraints to the {@link UIForAnySwing#withLayout(String, String)}
 *  and any given {@link UIForAnySwing#add(String, UIForAnySwing[])} method
 *  or variant of, to make use of mig layouts.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 */
public final class UI extends UILayoutConstants
{
    /**
     *  An enum set of all the available swing cursors which
     *  map to the cursor type id.
     *  This exists simply because swing was created before enums were added to Java.
     */
<span class="fc" id="L70">    public enum Cursor</span>
    {
<span class="fc" id="L72">        HAND(java.awt.Cursor.HAND_CURSOR),</span>
<span class="fc" id="L73">        MOVE(java.awt.Cursor.MOVE_CURSOR),</span>
<span class="fc" id="L74">        CROSS(java.awt.Cursor.CROSSHAIR_CURSOR),</span>
<span class="fc" id="L75">        DEFAULT(java.awt.Cursor.DEFAULT_CURSOR),</span>
<span class="fc" id="L76">        WAIT(java.awt.Cursor.WAIT_CURSOR),</span>
<span class="fc" id="L77">        TEXT(java.awt.Cursor.TEXT_CURSOR),</span>
<span class="fc" id="L78">        RESIZE_EAST(java.awt.Cursor.E_RESIZE_CURSOR),</span>
<span class="fc" id="L79">        RESIZE_WEST(java.awt.Cursor.W_RESIZE_CURSOR),</span>
<span class="fc" id="L80">        RESIZE_SOUTH(java.awt.Cursor.S_RESIZE_CURSOR),</span>
<span class="fc" id="L81">        RESIZE_NORTH(java.awt.Cursor.N_RESIZE_CURSOR),</span>
<span class="fc" id="L82">        RESIZE_NORTH_WEST(java.awt.Cursor.NW_RESIZE_CURSOR),</span>
<span class="fc" id="L83">        RESIZE_NORTH_EAST(java.awt.Cursor.NE_RESIZE_CURSOR),</span>
<span class="fc" id="L84">        RESIZE_SOUTH_WEST(java.awt.Cursor.SE_RESIZE_CURSOR),</span>
<span class="fc" id="L85">        RESIZE_SOUTH_EAST(java.awt.Cursor.SE_RESIZE_CURSOR);</span>

        final int type;

<span class="fc" id="L89">        Cursor( int type ) { this.type = type; }</span>

<span class="fc" id="L91">        public java.awt.Cursor toAWTCursor() { return java.awt.Cursor.getPredefinedCursor(type); }</span>
    }

    /**
     *  A general purpose enum describing if something is never, always or sometimes active.
     *  This is mostly used to configure the scroll bar policy for UI components with scroll behaviour.
     */
<span class="fc" id="L98">    public enum Active { NEVER, AS_NEEDED, ALWAYS }</span>

    /**
     *  All UI components are at their core rectangular, meaning they
     *  always have exactly 4 uniquely identifiable sides.
     *  This enum is used to target specific sides of a {@link JComponent}
     *  in various API methods like for example {@link UIForTabbedPane#withTabPlacementAt(Side)}
     *  or the tapped pane factory method {@link UI#tabbedPane(Side)}.
     */
<span class="fc" id="L107">    public enum Side {</span>
<span class="fc" id="L108">        TOP, LEFT, BOTTOM, RIGHT;</span>
        int forTabbedPane() {
<span class="pc bpc" id="L110" title="1 of 5 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L111">                case TOP   : return JTabbedPane.TOP;</span>
<span class="fc" id="L112">                case LEFT  : return JTabbedPane.LEFT;</span>
<span class="fc" id="L113">                case BOTTOM: return JTabbedPane.BOTTOM;</span>
<span class="fc" id="L114">                case RIGHT : return JTabbedPane.RIGHT;</span>
            }
<span class="nc" id="L116">            throw new RuntimeException();</span>
        }

        String toDirectionString() {
<span class="nc bnc" id="L120" title="All 5 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L121">                case TOP   : return &quot;north&quot;;</span>
<span class="nc" id="L122">                case LEFT  : return &quot;west&quot;;</span>
<span class="nc" id="L123">                case BOTTOM: return &quot;south&quot;;</span>
<span class="nc" id="L124">                case RIGHT : return &quot;east&quot;;</span>
            }
<span class="nc" id="L126">            throw new RuntimeException();</span>
        }

        String toMigAlign() {
<span class="nc bnc" id="L130" title="All 5 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L131">                case TOP   : return &quot;top&quot;;</span>
<span class="nc" id="L132">                case LEFT  : return &quot;left&quot;;</span>
<span class="nc" id="L133">                case BOTTOM: return &quot;bottom&quot;;</span>
<span class="nc" id="L134">                case RIGHT : return &quot;right&quot;;</span>
            }
<span class="nc" id="L136">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Overflow policy of UI components.
     */
<span class="fc" id="L143">    public enum OverflowPolicy {</span>
<span class="fc" id="L144">        WRAP, SCROLL;</span>

        int forTabbedPane() {
<span class="nc bnc" id="L147" title="All 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L148">                case WRAP  : return JTabbedPane.WRAP_TAB_LAYOUT;</span>
<span class="nc" id="L149">                case SCROLL: return JTabbedPane.SCROLL_TAB_LAYOUT;</span>
            }
<span class="nc" id="L151">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Vertical or horizontal alignment.
     */
<span class="fc" id="L158">    public enum Align {</span>
<span class="fc" id="L159">        HORIZONTAL, VERTICAL;</span>

        int forSlider() {
<span class="pc bpc" id="L162" title="1 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L163">                case HORIZONTAL: return JSlider.HORIZONTAL;</span>
<span class="fc" id="L164">                case VERTICAL  : return JSlider.VERTICAL;</span>
            }
<span class="nc" id="L166">            throw new RuntimeException();</span>
        }
        int forProgressBar() {
<span class="pc bpc" id="L169" title="1 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L170">                case HORIZONTAL: return JProgressBar.HORIZONTAL;</span>
<span class="fc" id="L171">                case VERTICAL  : return JProgressBar.VERTICAL;</span>
            }
<span class="nc" id="L173">            throw new RuntimeException();</span>
        }
        int forSeparator() {
<span class="pc bpc" id="L176" title="2 of 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L177">                case HORIZONTAL: return JSeparator.HORIZONTAL;</span>
<span class="fc" id="L178">                case VERTICAL  : return JSeparator.VERTICAL;</span>
            }
<span class="nc" id="L180">            throw new RuntimeException();</span>
        }
        int forSplitPane() {
<span class="pc bpc" id="L183" title="1 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L184">                case HORIZONTAL: return JSplitPane.VERTICAL_SPLIT;</span>
<span class="fc" id="L185">                case VERTICAL:   return JSplitPane.HORIZONTAL_SPLIT;</span>
            }
<span class="nc" id="L187">            throw new RuntimeException();</span>
        }
        int forToolBar() {
<span class="nc bnc" id="L190" title="All 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L191">                case HORIZONTAL: return JToolBar.HORIZONTAL;</span>
<span class="nc" id="L192">                case VERTICAL  : return JToolBar.VERTICAL;</span>
            }
<span class="nc" id="L194">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Different positions along a vertically aligned UI component.
     */
<span class="fc" id="L201">    public enum VerticalAlignment {</span>
<span class="fc" id="L202">        TOP, CENTER, BOTTOM;</span>

        public int forSwing() {
<span class="pc bpc" id="L205" title="2 of 4 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L206">                case TOP:    return SwingConstants.TOP;</span>
<span class="nc" id="L207">                case CENTER: return SwingConstants.CENTER;</span>
<span class="fc" id="L208">                case BOTTOM: return SwingConstants.BOTTOM;</span>
            }
<span class="nc" id="L210">            throw new RuntimeException();</span>
        }
        public float forY() {
<span class="nc bnc" id="L213" title="All 4 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L214">                case TOP:    return 0f;</span>
<span class="nc" id="L215">                case CENTER: return 0.5f;</span>
<span class="nc" id="L216">                case BOTTOM: return 1f;</span>
            }
<span class="nc" id="L218">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Different positions along a horizontally aligned UI component.
     */
<span class="fc" id="L225">    public enum HorizontalAlignment</span>
    {
<span class="fc" id="L227">        LEFT, CENTER, RIGHT, LEADING, TRAILING;</span>

        public final int forSwing() {
<span class="pc bpc" id="L230" title="1 of 6 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L231">                case LEFT:     return SwingConstants.LEFT;</span>
<span class="fc" id="L232">                case CENTER:   return SwingConstants.CENTER;</span>
<span class="fc" id="L233">                case RIGHT:    return SwingConstants.RIGHT;</span>
<span class="fc" id="L234">                case LEADING:  return SwingConstants.LEADING;</span>
<span class="fc" id="L235">                case TRAILING: return SwingConstants.TRAILING;</span>
            }
<span class="nc" id="L237">            throw new RuntimeException();</span>
        }
        public final float forX() {
<span class="nc bnc" id="L240" title="All 4 branches missed.">            switch ( this ) {</span>
                case LEFT: case LEADING:
<span class="nc" id="L242">                    return 0f;</span>
                case CENTER:
<span class="nc" id="L244">                    return 0.5f;</span>
                case RIGHT: case TRAILING:
<span class="nc" id="L246">                    return 1f;</span>
            }
<span class="nc" id="L248">            throw new RuntimeException();</span>
        }

        public final int forFlowLayout() {
<span class="pc bpc" id="L252" title="5 of 6 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L253">                case LEFT:     return FlowLayout.LEFT;</span>
<span class="fc" id="L254">                case CENTER:   return FlowLayout.CENTER;</span>
<span class="nc" id="L255">                case RIGHT:    return FlowLayout.RIGHT;</span>
<span class="nc" id="L256">                case LEADING:  return FlowLayout.LEADING;</span>
<span class="nc" id="L257">                case TRAILING: return FlowLayout.TRAILING;</span>
            }
<span class="nc" id="L259">            throw new RuntimeException();</span>
        }
    }

    /**
     *  The logical combination of a vertical and horizontal alignment.
     */
<span class="fc" id="L266">    public enum Alignment {</span>
<span class="fc" id="L267">        TOP_LEFT,    TOP_CENTER, TOP_RIGHT, TOP_LEADING, TOP_TRAILING,</span>
<span class="fc" id="L268">        CENTER_LEFT, CENTER, CENTER_RIGHT, CENTER_LEADING, CENTER_TRAILING,</span>
<span class="fc" id="L269">        BOTTOM_LEFT, BOTTOM_CENTER, BOTTOM_RIGHT, BOTTOM_LEADING, BOTTOM_TRAILING;</span>

        public VerticalAlignment getVertical() {
<span class="pc bpc" id="L272" title="3 of 4 branches missed.">            switch ( this ) {</span>
                case TOP_LEFT: case TOP_CENTER: case TOP_RIGHT: case TOP_LEADING: case TOP_TRAILING:
<span class="fc" id="L274">                    return VerticalAlignment.TOP;</span>
                case CENTER_LEFT: case CENTER: case CENTER_RIGHT: case CENTER_LEADING: case CENTER_TRAILING:
<span class="nc" id="L276">                    return VerticalAlignment.CENTER;</span>
                case BOTTOM_LEFT: case BOTTOM_CENTER: case BOTTOM_RIGHT: case BOTTOM_LEADING: case BOTTOM_TRAILING:
<span class="nc" id="L278">                    return VerticalAlignment.BOTTOM;</span>
            }
<span class="nc" id="L280">            throw new RuntimeException();</span>
        }

        public HorizontalAlignment getHorizontal() {
<span class="pc bpc" id="L284" title="5 of 6 branches missed.">            switch ( this ) {</span>
                case TOP_LEFT: case CENTER_LEFT: case BOTTOM_LEFT:
<span class="nc" id="L286">                    return HorizontalAlignment.LEFT;</span>
                case TOP_CENTER: case CENTER: case BOTTOM_CENTER:
<span class="nc" id="L288">                    return HorizontalAlignment.CENTER;</span>
                case TOP_RIGHT: case CENTER_RIGHT: case BOTTOM_RIGHT:
<span class="fc" id="L290">                    return HorizontalAlignment.RIGHT;</span>
                case TOP_LEADING: case CENTER_LEADING: case BOTTOM_LEADING:
<span class="nc" id="L292">                    return HorizontalAlignment.LEADING;</span>
                case TOP_TRAILING: case CENTER_TRAILING: case BOTTOM_TRAILING:
<span class="nc" id="L294">                    return HorizontalAlignment.TRAILING;</span>
            }
<span class="nc" id="L296">            throw new RuntimeException();</span>
        }
    }

<span class="fc" id="L300">    public enum ListData {</span>
<span class="fc" id="L301">        COLUMN_MAJOR,</span>
<span class="fc" id="L302">        ROW_MAJOR,</span>
<span class="fc" id="L303">        COLUMN_MAJOR_EDITABLE,</span>
<span class="fc" id="L304">        ROW_MAJOR_EDITABLE;</span>

        final boolean isEditable() {
<span class="pc bpc" id="L307" title="1 of 3 branches missed.">            switch ( this ) {</span>
                case COLUMN_MAJOR:
                case ROW_MAJOR:
<span class="fc" id="L310">                    return false;</span>
                case COLUMN_MAJOR_EDITABLE:
                case ROW_MAJOR_EDITABLE:
<span class="fc" id="L313">                    return true;</span>
            }
<span class="nc" id="L315">            throw new RuntimeException();</span>
        }

        final boolean isRowMajor() {
<span class="pc bpc" id="L319" title="1 of 3 branches missed.">            switch ( this ) {</span>
                case COLUMN_MAJOR:
                case COLUMN_MAJOR_EDITABLE:
<span class="fc" id="L322">                    return false;</span>
                case ROW_MAJOR:
                case ROW_MAJOR_EDITABLE:
<span class="fc" id="L325">                    return true;</span>
            }
<span class="nc" id="L327">            throw new RuntimeException();</span>
        }
    }

<span class="fc" id="L331">    public enum MapData {</span>
<span class="fc" id="L332">        EDITABLE, READ_ONLY;</span>

        final boolean isEditable() {
<span class="pc bpc" id="L335" title="2 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L336">                case EDITABLE: return true;</span>
<span class="nc" id="L337">                case READ_ONLY: return false;</span>
            }
<span class="nc" id="L339">            throw new RuntimeException();</span>
        }
    }
    /**
     *  Use this to target specific edges of a {@link JComponent} and apply
     *  custom {@link Style} properties to them.
     *  &lt;br&gt;
     *  See {@link ComponentStyleDelegate#borderWidthAt(Edge, int)}
     */
<span class="fc" id="L348">    public enum Edge</span>
    {
<span class="fc" id="L350">        TOP,    RIGHT,</span>
<span class="fc" id="L351">        BOTTOM, LEFT,</span>
<span class="fc" id="L352">        EVERY</span>
    }

    /**
     *  Instances of this enum are used to configure onto which
     *  layer a particular style configuration should be applied.
     */
<span class="fc" id="L359">    public enum Layer</span>
    {
<span class="fc" id="L361">        BACKGROUND,</span>
<span class="fc" id="L362">        CONTENT,</span>
<span class="fc" id="L363">        BORDER,</span>
<span class="fc" id="L364">        FOREGROUND</span>
    }

    /**
     *  Use these enum instances to specify the gradient type for various sub styles,
     *  like for example the gradient style API exposed by {@link ComponentStyleDelegate#borderGradient(Function)}
     *  or {@link ComponentStyleDelegate#gradient(Function)} methods (see {@link UIForAnySwing#withStyle(Styler)}).
     *
     *  {@link GradientStyle#type(GradientType)} method exposed by methods like
     *  {@link ComponentStyleDelegate#gradient(String, Function)} or {@link ComponentStyleDelegate#borderGradient(String, Function)}.
     */
<span class="fc" id="L375">    public enum GradientType</span>
    {
<span class="fc" id="L377">        LINEAR, RADIAL</span>
    }

    /**
     *  Use these enum instances to specify the gradient alignment for various sub styles,
     *  like for example the gradient style API exposed by {@link ComponentStyleDelegate#borderGradient(Function)}
     *  or {@link ComponentStyleDelegate#gradient(Function)} methods (see {@link UIForAnySwing#withStyle(Styler)}).
     *
     *  {@link GradientStyle#transition(Transition)} method exposed by methods like
     *  {@link ComponentStyleDelegate#gradient(String, Function)} or {@link ComponentStyleDelegate#borderGradient(String, Function)}.
     */
<span class="fc" id="L388">    public enum Transition</span>
    {
<span class="fc" id="L390">        TOP_LEFT_TO_BOTTOM_RIGHT, BOTTOM_LEFT_TO_TOP_RIGHT,</span>
<span class="fc" id="L391">        TOP_RIGHT_TO_BOTTOM_LEFT, BOTTOM_RIGHT_TO_TOP_LEFT,</span>

<span class="fc" id="L393">        TOP_TO_BOTTOM, LEFT_TO_RIGHT,</span>
<span class="fc" id="L394">        BOTTOM_TO_TOP, RIGHT_TO_LEFT;</span>

        /**
         * @return {@code true} if this alignment is diagonal, {@code false} otherwise.
         */
        public boolean isDiagonal() {
<span class="pc bpc" id="L400" title="2 of 8 branches missed.">            return this == TOP_LEFT_TO_BOTTOM_RIGHT || this == BOTTOM_LEFT_TO_TOP_RIGHT ||</span>
                   this == TOP_RIGHT_TO_BOTTOM_LEFT || this == BOTTOM_RIGHT_TO_TOP_LEFT;
        }
    }

    /**
     *  Use this in the style API (see {@link UIForAnySwing#withStyle(Styler)})
     *  to target specific corners of a {@link JComponent} and apply
     *  custom {@link Style} properties to them.
     *  &lt;br&gt;
     *  See {@link ComponentStyleDelegate#borderRadiusAt(Corner, int, int)}.
     */
<span class="fc" id="L412">    public enum Corner</span>
    {
<span class="fc" id="L414">        TOP_LEFT,    TOP_RIGHT,</span>
<span class="fc" id="L415">        BOTTOM_LEFT, BOTTOM_RIGHT,</span>
<span class="fc" id="L416">        EVERY</span>
    }

    /**
     *  Use this to specify the placement of an image as part of the {@link ImageStyle} through
     *  the {@link ImageStyle#placement(Placement)} method exposed by the style API (see {@link UIForAnySwing#withStyle(Styler)}).
     */
<span class="fc" id="L423">    public enum Placement</span>
    {
<span class="fc" id="L425">        TOP, LEFT, BOTTOM, RIGHT,</span>
<span class="fc" id="L426">        TOP_LEFT, TOP_RIGHT,</span>
<span class="fc" id="L427">        BOTTOM_LEFT, BOTTOM_RIGHT,</span>
<span class="fc" id="L428">        CENTER</span>
    }

<span class="fc" id="L431">    public enum Axis {</span>
        /**
         * Specifies that something is laid out left to right.
         */
<span class="fc" id="L435">        X,</span>
        /**
         * Specifies that something is laid out top to bottom.
         */
<span class="fc" id="L439">        Y,</span>
        /**
         * Specifies that something is laid out in the direction of
         * a line of text as determined by the target container's
         * {@code ComponentOrientation} property.
         */
<span class="fc" id="L445">        LINE,</span>
        /**
         * Specifies that something is laid out in the direction that
         * lines flow across a page as determined by the target container's
         * {@code ComponentOrientation} property.
         */
<span class="fc" id="L451">        PAGE;</span>

        public int forBoxLayout() {
<span class="nc bnc" id="L454" title="All 5 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L455">                case X:    return BoxLayout.X_AXIS;</span>
<span class="nc" id="L456">                case Y:    return BoxLayout.Y_AXIS;</span>
<span class="nc" id="L457">                case LINE: return BoxLayout.LINE_AXIS;</span>
<span class="nc" id="L458">                case PAGE: return BoxLayout.PAGE_AXIS;</span>
            }
<span class="nc" id="L460">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Set of enum instances defining common types of Swing look and feels.
     *  Use {@link UI#currentLookAndFeel()} to check which look and feel is currently active.
     */
<span class="fc" id="L468">    public enum LookAndFeel {</span>
<span class="fc" id="L469">        METAL,</span>
<span class="fc" id="L470">        FLAT_LAF,</span>
<span class="fc" id="L471">        NIMBUS,</span>
<span class="fc" id="L472">        OTHER;</span>

        public boolean isOneOf( LookAndFeel... lafs ) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">            for ( LookAndFeel laf : lafs )</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                if ( laf == this ) return true;</span>
<span class="fc" id="L477">            return false;</span>
        }
    }

    public static LookAndFeel currentLookAndFeel() {
        try {
<span class="fc" id="L483">            String laf = UIManager.getLookAndFeel().getClass().getName();</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (laf.contains(&quot;FlatLaf&quot;)) return LookAndFeel.FLAT_LAF;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (laf.contains(&quot;Nimbus&quot;)) return LookAndFeel.NIMBUS;</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (laf.contains(&quot;Metal&quot;)) return LookAndFeel.METAL;</span>
        }
<span class="pc" id="L488">        catch (Exception ignored) {}</span>

<span class="fc" id="L490">        return LookAndFeel.OTHER;</span>
    }

    /**
     * @return The current UI scale factor, which is used for DPI aware painting and layouts.
     */
<span class="fc" id="L496">    public static float scale() { return SwingTree.get().getUiScaleFactor(); }</span>

    /**
     * Multiplies the given float value by the user scale factor.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param value The float value to scale.
     * @return The scaled float value.
     */
    public static float scale( float value ) {
<span class="fc" id="L506">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        return (scaleFactor == 1) ? value : (value * scaleFactor);</span>
    }

    /**
     * Multiplies the given double value by the user scale factor.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param value The double value to scale.
     * @return The scaled double value.
     */
    public static double scale( double value ) {
<span class="fc" id="L518">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        return (scaleFactor == 1) ? value : (value * scaleFactor);</span>
    }

    /**
     * Multiplies the given int value by the user scale factor and rounds the result.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     * @param value The int value to scale.
     * @return The scaled int value.
     */
    public static int scale( int value ) {
<span class="fc" id="L529">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        return ( scaleFactor == 1 ? value : Math.round( value * scaleFactor ) );</span>
    }

    /**
     * Similar as {@link UI#scale(int)} but always &quot;rounds down&quot;.
     * &lt;p&gt;
     * For use in special cases. {@link UI#scale(int)} is the preferred method.
     *
     * @param value The value to scale and then round down if the scaled result is not a whole number.
     * @return The scaled and rounded down value.
     */
    public int scaleRoundedDown( int value ) {
<span class="nc" id="L542">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        return ( scaleFactor == 1 ? value : (int) (value * scaleFactor) );</span>
    }

    /**
     * Divides the given float value by the user scale factor.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param value The float value to unscale.
     * @return The unscaled float value.
     */
    public static float unscale( float value ) {
<span class="nc" id="L554">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        return (scaleFactor == 1f) ? value : (value / scaleFactor);</span>
    }

    /**
     * Divides the given int value by the user scale factor and rounds the result.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     * @param value The int value to unscale.
     * @return The unscaled int value.
     */
    public static int unscale( int value ) {
<span class="nc" id="L565">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        return (scaleFactor == 1f) ? value : Math.round( value / scaleFactor );</span>
    }

    /**
     * If user scale factor is not 1, scale the given graphics context by invoking
     * {@link Graphics2D#scale(double, double)} with user scale factor.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param g The graphics context to scale.
     */
    public static void scale( Graphics2D g ) {
<span class="nc" id="L577">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if( scaleFactor != 1f )</span>
<span class="nc" id="L579">            g.scale( scaleFactor, scaleFactor );</span>
<span class="nc" id="L580">    }</span>

    /**
     * Scales the given dimension with the user scale factor.
     * &lt;p&gt;
     * If user scale factor is 1, then the given dimension is simply returned.
     * Otherwise, a new instance of {@link Dimension} or {@link javax.swing.plaf.DimensionUIResource}
     * is returned, depending on whether the passed dimension implements {@link javax.swing.plaf.UIResource}.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param dimension The dimension to scale.
     * @return The scaled dimension.
     */
    public static Dimension scale( Dimension dimension ) {
<span class="fc" id="L594">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="pc bpc" id="L595" title="1 of 4 branches missed.">        return (dimension == null || scaleFactor == 1f)</span>
<span class="fc" id="L596">                ? dimension</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                : (dimension instanceof UIResource</span>
<span class="nc" id="L598">                    ? new DimensionUIResource( UI.scale( dimension.width ), UI.scale( dimension.height ) )</span>
<span class="fc" id="L599">                    : new Dimension          ( UI.scale( dimension.width ), UI.scale( dimension.height ) ));</span>
    }

    /**
     * Returns a rectangle from the given rectangle with the user scale factor applied.
     * &lt;p&gt;
     * If user scale factor is 1, then the given rectangle is simply returned.
     * Otherwise, a new instance of {@link Rectangle} or {@link javax.swing.plaf.UIResource} is returned.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     * @param rectangle The rectangle to scale.
     * @return The scaled rectangle.
     */
    public static Rectangle scale( Rectangle rectangle ) {
<span class="nc" id="L612">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L613" title="All 4 branches missed.">        return (rectangle == null || scaleFactor == 1f)</span>
<span class="nc" id="L614">                ? rectangle</span>
<span class="nc" id="L615">                : new Rectangle(</span>
<span class="nc" id="L616">                        UI.scale( rectangle.x ),     UI.scale( rectangle.y ),</span>
<span class="nc" id="L617">                        UI.scale( rectangle.width ), UI.scale( rectangle.height )</span>
                    );
    }

    /**
     * Returns a rectangle from the given rectangle with the user scale factor applied.
     * &lt;p&gt;
     * If user scale factor is 1, then the given rectangle is simply returned.
     * Otherwise, a new instance of {@link Rectangle} or {@link javax.swing.plaf.UIResource} is returned.
     * See {@link swingtree.SwingTree} for more information about how the user scale factor is determined.
     *
     * @param rectangle The rectangle to scale.
     * @return The scaled rectangle.
     */
    public static RoundRectangle2D scale( RoundRectangle2D rectangle ) {
<span class="fc" id="L632">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="pc bpc" id="L633" title="1 of 4 branches missed.">        if ( rectangle == null || scaleFactor == 1f ) return rectangle;</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">        if ( rectangle instanceof RoundRectangle2D.Float )</span>
<span class="nc" id="L635">            return new RoundRectangle2D.Float(</span>
<span class="nc" id="L636">                    (float) UI.scale( rectangle.getX() ),        (float) UI.scale( rectangle.getY() ),</span>
<span class="nc" id="L637">                    (float) UI.scale( rectangle.getWidth() ),    (float) UI.scale( rectangle.getHeight() ),</span>
<span class="nc" id="L638">                    (float) UI.scale( rectangle.getArcWidth() ), (float) UI.scale( rectangle.getArcHeight() )</span>
                );
        else
<span class="fc" id="L641">            return new RoundRectangle2D.Double(</span>
<span class="fc" id="L642">                    UI.scale( rectangle.getX() ),        UI.scale( rectangle.getY() ),</span>
<span class="fc" id="L643">                    UI.scale( rectangle.getWidth() ),    UI.scale( rectangle.getHeight() ),</span>
<span class="fc" id="L644">                    UI.scale( rectangle.getArcWidth() ), UI.scale( rectangle.getArcHeight() )</span>
                );
    }

    /**
     * Scales the given insets with the user scale factor.
     * &lt;p&gt;
     * If user scale factor is 1, then the given insets is simply returned.
     * Otherwise, a new instance of {@link Insets} or {@link javax.swing.plaf.InsetsUIResource}
     * is returned, depending on whether the passed dimension implements {@link javax.swing.plaf.UIResource}.
     *
     * @param insets The insets to scale.
     * @return The scaled insets.
     */
    public static Insets scale( Insets insets ) {
<span class="nc" id="L659">        float scaleFactor = SwingTree.get().getUiScaleFactor();</span>
<span class="nc bnc" id="L660" title="All 4 branches missed.">        return (insets == null || scaleFactor == 1f)</span>
<span class="nc" id="L661">                ? insets</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                : (insets instanceof UIResource</span>
<span class="nc" id="L663">                    ? new InsetsUIResource( UI.scale( insets.top ), UI.scale( insets.left ), UI.scale( insets.bottom ), UI.scale( insets.right ) )</span>
<span class="nc" id="L664">                    : new Insets          ( UI.scale( insets.top ), UI.scale( insets.left ), UI.scale( insets.bottom ), UI.scale( insets.right ) ));</span>
    }

    /**
     *  Sets a {@link StyleSheet} which will be applied to all SwingTree UIs defined in the subsequent lambda scope.
     *  This method allows to switch between different style sheets.
     *  &lt;p&gt;
     * 	You can switch to a style sheet like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(new MyCustomStyeSheet(), ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param styleSheet The style sheet to be used for all subsequent UI building operations.
     * @param scope A lambda scope in which the style sheet is active for all subsequent UI building operations.
     * @param &lt;T&gt; The type of the result of the given scope.
     * @return the result of the given scope, usually a {@link JComponent} or SwingTree UI.
     */
    public static &lt;T&gt; T use( StyleSheet styleSheet, Supplier&lt;T&gt; scope ) {
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L692">            return runAndGet( ()-&gt; use(styleSheet, scope) );</span>

<span class="fc" id="L694">        SwingTree swingTreeContext = SwingTree.get();</span>
<span class="fc" id="L695">        StyleSheet oldStyleSheet = swingTreeContext.getStyleSheet();</span>
<span class="fc" id="L696">        swingTreeContext.setStyleSheet(styleSheet);</span>
        try {
<span class="fc" id="L698">            T result = scope.get();</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">            if ( result instanceof JComponent )</span>
<span class="nc" id="L700">                ComponentExtension.from((JComponent) result).calculateApplyAndInstallStyle(true);</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">            if ( result instanceof UIForAnySwing )</span>
<span class="fc" id="L702">                ComponentExtension.from(((UIForAnySwing&lt;?,?&gt;) result).getComponent()).calculateApplyAndInstallStyle(true);</span>

<span class="fc" id="L704">            return result;</span>
        } finally {
<span class="fc" id="L706">            swingTreeContext.setStyleSheet(oldStyleSheet);</span>
        }
    }

    /**
     *  Sets the {@link EventProcessor} to be used for all subsequent UI building operations.
     *  This method allows to switch between different event processing strategies.
     *  In particular, the {@link EventProcessor#DECOUPLED} is recommended to be used for
     *  proper decoupling of the UI thread from the application logic.
     *  &lt;p&gt;
     * 	You can switch to the decoupled event processor like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(EventProcessor.DECOUPLED, ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param processor The event processor to be used for all subsequent UI building operations
     * @param scope The scope of the event processor to be used for all subsequent UI building operations.
     *              The value returned by the given scope is returned by this method.
     * @return The value returned by the given scope.
     * @param &lt;T&gt; The type of the value returned by the given scope.
     */
    public static &lt;T&gt; T use( EventProcessor processor, Supplier&lt;T&gt; scope )
    {
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L739">            return runAndGet(()-&gt; use(processor, scope));</span>

<span class="fc" id="L741">        SwingTree swingTreeContext = SwingTree.get();</span>
<span class="fc" id="L742">        EventProcessor oldProcessor = swingTreeContext.getEventProcessor();</span>
<span class="fc" id="L743">        swingTreeContext.setEventProcessor(processor);</span>
        try {
<span class="fc" id="L745">            return scope.get();</span>
        } finally {
<span class="fc" id="L747">            swingTreeContext.setEventProcessor(oldProcessor);</span>
        }
    }

    /**
     * Loads an icon from the resource folder, the classpath, a local file
     * or from cache if it has already been loaded.
     * If no icon could be found, an empty optional is returned.
     * &lt;br&gt;&lt;br&gt;
     * Also, checkout {@link SwingTree#getIconCache()} to see where the icons are cached.
     *
     * @param path The path to the icon. It can be a classpath resource or a file path.
     * @return An optional containing the icon if it could be found, an empty optional otherwise.
     */
    public static Optional&lt;ImageIcon&gt; findIcon( String path ) {
<span class="fc" id="L762">        Map&lt;String, ImageIcon&gt; cache = SwingTree.get().getIconCache();</span>
<span class="fc" id="L763">        ImageIcon icon = cache.get(path);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if ( icon == null ) {</span>
<span class="fc" id="L765">            icon = _loadIcon(path);</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            if ( icon != null )</span>
<span class="fc" id="L767">                cache.put(path, icon);</span>
        }
<span class="fc" id="L769">        return Optional.ofNullable(icon);</span>
    }

    /**
     * Loads an icon from the classpath or from a file.
     * @param path The path to the icon. It can be a classpath resource or a file path.
     * @return The icon.
     */
    public static ImageIcon _loadIcon( String path ) {
<span class="fc" id="L778">        path = path.trim();</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        if ( path.isEmpty() )</span>
<span class="fc" id="L780">            return null;</span>
        // First we make the path platform independent:
<span class="fc" id="L782">        path = path.replace('\\', '/');</span>
        // Then we try to load the icon url from the classpath:
<span class="fc" id="L784">        URL url = UI.class.getResource(path);</span>
        // We check if the url is null:
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        if ( url == null ) {</span>
            // It is, let's do some troubleshooting:
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if ( !path.startsWith(&quot;/&quot;) )</span>
<span class="fc" id="L789">                url = UI.class.getResource(&quot;/&quot; + path);</span>

<span class="fc bfc" id="L791" title="All 2 branches covered.">            if ( url == null ) // Still null? Let's try to load it as a file:</span>
                try {
<span class="fc" id="L793">                    url = new File(path).toURI().toURL();</span>
<span class="nc" id="L794">                } catch (MalformedURLException e) {</span>
<span class="nc" id="L795">                    throw new RuntimeException(e);</span>
<span class="fc" id="L796">                }</span>
        }
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if ( path.endsWith(&quot;.svg&quot;) )</span>
<span class="fc" id="L799">            return new SvgIcon(url);</span>
        else
<span class="fc" id="L801">            return new ImageIcon(Toolkit.getDefaultToolkit().createImage(url), url.toExternalForm());</span>
        /*
            Not that we explicitly use the &quot;createImage&quot; method of the toolkit here.
            This is because otherwise the image might get cached inside the toolkit,
            which is in the way of our own caching mechanism.
            (The internal caching of the toolkit is somewhat limited and we have no control over it,
            which is why we use our own cache.)
        */
    }

    private UI(){ super(); } // This is a static API

    /**
     *  Use this to create a builder for anything.
     *
     * @param component The component which should be wrapped by the builder.
     * @param &lt;T&gt; The type parameter defining the concrete type of the component.
     * @return A builder instance for the provided object, which enables fluent method chaining.
     */
    public static &lt;T extends Component&gt; UIForAnything&lt;T&gt; of( T component ) {
<span class="nc" id="L821">        NullUtil.nullArgCheck(component, &quot;component&quot;, Component.class);</span>
<span class="nc" id="L822">        return new UIForAnything&lt;&gt;(component);</span>
    }

    /**
     *  This returns an instance of a generic swing tree builder
     *  for anything extending the {@link JComponent} class.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param component The new component instance which ought to be part of the Swing UI.
     * @param &lt;T&gt; The concrete type of this new component.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( T component )
    {
<span class="fc" id="L836">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L837">        return new UIForSwing&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JPanel} type. &lt;br&gt;
     *  This method is typically used to enable declarative UI design for custom
     *  {@link JPanel} based components either within the constructor of a custom
     *  subclass, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  class MyCustomPanel extends JPanel {
     *      public MyCustomPanel() {
     *          UI.of(this)
     *          .add(UI.label(&quot;Hello Swing!&quot;))
     *          .add(UI.button(&quot;Click Me&quot;))
     *          .add(UI.button(&quot;Or Me&quot;) );
     *      }
     *  }
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  ... or as part of a UI declaration, where the custom {@link JPanel} type
     *  is added to the components tree, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.show(
     *      UI.panel()
     *      .add(
     *          new MyCustomPanel()
     *      )
     *      .add(..more stuff..)
     *  );
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *
     * @param component The {@link JPanel} instance to be wrapped by a swing tree UI builder for panel components.
     * @return A builder instance for the provided {@link JPanel}, which enables fluent method chaining.
     * @param &lt;P&gt; The type parameter of the concrete {@link JPanel} type to be wrapped.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JPanel&gt; UIForPanel&lt;P&gt; of( P component ) {
<span class="fc" id="L875">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPanel.class);</span>
<span class="fc" id="L876">        return new UIForPanel&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager.
     *  This is in essence a convenience method for {@code UI.of(new JPanel(new MigLayout()))}.
     *
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
<span class="fc" id="L886">    public static UIForPanel&lt;JPanel&gt; panel() { return of((JPanel) new Panel()).withLayout(new MigLayout(&quot;hidemode 2&quot;)); }</span>

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr ) {
<span class="fc" id="L901">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L902">        return of((JPanel) new Panel()).withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints ) {
<span class="fc" id="L918">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L919">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L920">        return of((JPanel) new Panel()).withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L938">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L939">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L940">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L941">        return of((JPanel) new Panel()).withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr ) {
<span class="fc" id="L954">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L955">        return panel(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr, String colConstraints ) {
<span class="fc" id="L971">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L972">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L973">        return of((JPanel)new Panel()).withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L991">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L992">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L993">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L994">        return of((JPanel) new Panel()).withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}. &lt;br&gt;
     *  This method is typiclly used alongside the {@link UI#LC()} factory
     *  method to create a layout attributes/constraints builder, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel(
     *          UI.LC()
     *          .insets(&quot;10 10 10 10&quot;)
     *          .debug()
     *      )
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *
     * @param attr The constraint attributes concerning the entire {@link MigLayout}
     *             in the form of a {@link LC} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr ) {
<span class="nc" id="L1019">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1020">        return panel().withLayout( attr );</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, ConstraintParser.parseColumnConstraints(colConstraints))))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LC} constants.
     * @param colConstraints The column constraints in the form of a {@link String} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr, String colConstraints ) {
<span class="nc" id="L1037">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1038">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L1039">        return of((JPanel) new Panel()).withLayout( attr, colConstraints );</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(
     *          new MigLayout(
     *              attr,
     *              ConstraintParser.parseColumnConstraints(colConstraints),
     *              ConstraintParser.parseRowConstraints(rowConstraints)
     *          )
     *      ))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LC} instance.
     * @param colConstraints The column constraints in the form of a {@link String} instance.
     * @param rowConstraints The row constraints in the form of a {@link String} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr, String colConstraints, String rowConstraints ) {
<span class="nc" id="L1063">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1064">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L1065">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="nc" id="L1066">        return of((JPanel) new Panel()).withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component with a
     *  dynamically updated set of {@link MigLayout} attributes.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( Val&lt;LayoutConstraint&gt; attr ) {
<span class="fc" id="L1080">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L1081">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L1082">        return panel(attr.get().toString()).withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JBox} instance,
     *  which is a general purpose component wrapper type with the following properties:
     *  &lt;ul&gt;
     *      &lt;li&gt;
     *          It is transparent, meaning that it does not paint its background.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The default layout manager is a {@link MigLayout}.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The insets (the space between the wrapped component and the box's border)
     *          are set to zero.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          There the gap size between the components added to the box is set to zero.
     *          So they will be tightly packed.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This method is typically used to enable declarative UI design for custom
     *  {@link JBox} based components either within the constructor of a custom
     *  subclass, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  class MyCustomBox extends JBox {
     *      public MyCustomBox() {
     *          UI.of(this)
     *          .add(UI.label(&quot;Hello Swing!&quot;))
     *          .add(UI.button(&quot;Click Me&quot;))
     *          .add(UI.button(&quot;Or Me&quot;) );
     *      }
     *  }
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  ... or as part of a UI declaration, where the custom {@link JBox} type
     *  is added to the components tree, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.show(
     *      UI.panel()
     *      .add(
     *          new MyCustomBox()
     *      )
     *      .add(..more stuff..)
     *  );
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *
     * @param component The box component type for which a builder should be created.
     * @param &lt;B&gt; THe type parameter defining the concrete {@link JBox} type.
     * @return A builder for the provided box component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;B extends JBox&gt; UIForBox&lt;B&gt; of( B component ) {
<span class="fc" id="L1141">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPanel.class);</span>
<span class="fc" id="L1142">        return new UIForBox&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox} instance,
     *  which is a general purpose component wrapper type with the following properties:
     *  &lt;ul&gt;
     *      &lt;li&gt;
     *          It is transparent, meaning that it does not paint its background.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The default layout manager is a {@link MigLayout}.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The insets (the space between the wrapped component and the box's border)
     *          are set to zero.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          There the gap size between the components added to the box is set to zero.
     *          So they will be tightly packed.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This factory method is especially useful for when you simply want to nest components
     *  tightly without having to worry about the layout manager or the background
     *  color covering the background of the parent component.
     *  &lt;br&gt;
     *  Note that you can also emulate the {@link JBox} type with a {@link JPanel} using
     *  {@code UI.panel(&quot;ins 0, gap 0&quot;).makeNonOpaque()}.
     *
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     */
<span class="fc" id="L1177">    public static UIForBox&lt;JBox&gt; box() { return of((JBox)new Box()); }</span>

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr ) {
<span class="fc" id="L1193">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">        if ( attr.isEmpty() ) attr = &quot;ins 0&quot;;</span>
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        else if ( !attr.contains(&quot;ins&quot;) ) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1196">        return box().withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr, String colConstraints ) {
<span class="fc" id="L1214">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1215">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1218">        return box().withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This factory method is especially useful for when you simply want to nest components
     *  tightly without having to worry about the layout manager or the background
     *  color covering the background of the parent component.
     *  &lt;br&gt;
     *  Note that you can also emulate the {@link JBox} type with a {@link JPanel} using
     *  &lt;pre&gt;{@code
     *      UI.panel(attr, colConstraints, rowConstraints).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1245">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1246">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1247">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1250">        return box().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints. &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  &lt;br&gt;
     *  This method allows you to pass a {@link LayoutConstraint} constants as the layout attributes,
     *  which is an instance typically chosen from the {@link UI} class constants
     *  like for example {@link UI#FILL}, {@link UI#FILL_X}, {@link UI#FILL_Y}... &lt;br&gt;
     *  A typical usage example would be: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.box(UI.FILL_X.and(UI.WRAP(2)))
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *  In this code snippet the creates a {@link JBox} with a {@link MigLayout} as its layout manager
     *  where the box will fill the parent component horizontally and
     *  the components added to the box will be wrapped after every two components.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr ) {
<span class="fc" id="L1284">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1285">        return box(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints. &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This method allows you to pass a {@link LayoutConstraint} constants as the layout attributes,
     *  which is an instance typically chosen from the {@link UI} class constants
     *  like for example {@link UI#FILL}, {@link UI#FILL_X}, {@link UI#FILL_Y}... &lt;br&gt;
     *  A typical usage example would be: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.box(UI.FILL, &quot;[shrink]6[grow]&quot;)
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *  In this code snippet the creates a {@link JBox} with a {@link MigLayout} as its layout manager
     *  where the box will fill the parent component horizontally and vertically
     *  and the first column of components will be shrunk to their preferred size
     *  and the second column will grow to fill the available space.
     *  Both columns will have a gap of 6 pixels between them.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr, String colConstraints ) {
<span class="fc" id="L1320">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1321">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1322">        return box(attr.toString(), colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1345">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L1346">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1347">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L1348">        return box(attr.toString(), colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr ) {
<span class="nc" id="L1366">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1367">        return box().withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method which may also be expressed as: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr, String colConstraints ) {
<span class="nc" id="L1393">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1394">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L1395">        return box().withLayout( attr, colConstraints )           ;</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method which may also be expressed as: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox())
     *      .peek( box -&gt; {
     *          box.setLayout(
     *              new MigLayout(
     *                  attr,
     *                  ConstraintParser.parseColumnConstraints(colConstraints),
     *                  ConstraintParser.parseRowConstraints(rowConstraints)
     *              )
     *          )
     *      })
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr, String colConstraints, String rowConstraints ) {
<span class="nc" id="L1427">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L1428">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L1429">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="nc" id="L1430">        return box().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This method allows you to dynamically determine the {@link LayoutConstraint} constants
     *  of the {@link MigLayout} instance, by passing a {@link Val} property which
     *  will be observed and its value passed to the {@link MigLayout} constructor
     *  whenever it changes.
     *  This is in essence a convenience method for:
     *  {@code UI.box().withLayout(attr.viewAsString( it -&gt; it+&quot;, ins 0&quot;))}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( Val&lt;LayoutConstraint&gt; attr ) {
<span class="nc" id="L1453">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L1454">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L1455">        return box().withLayout(attr.view( it -&gt; it.and(&quot;ins 0&quot;)));</span>
    }

    /**
     *  If you are using builders for your custom {@link JComponent},
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JComponent} types.
     * @param &lt;T&gt; The UI component type built by implementations of the provided builder.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( SwingBuilder&lt;T&gt; builder )
    {
<span class="nc" id="L1469">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, SwingBuilder.class);</span>
<span class="nc" id="L1470">        return of(builder.build());</span>
    }

    /**
     *  If you are using builders for custom {@link JMenuItem} components,
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JMenuItem} types.
     * @param &lt;M&gt; The {@link JMenuItem} type built by implementations of the provided builder.
     * @return A builder instance for a {@link JMenuItem}, which enables fluent method chaining.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( MenuBuilder&lt;M&gt; builder )
    {
<span class="nc" id="L1484">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, MenuBuilder.class);</span>
<span class="nc" id="L1485">        return new UIForMenuItem&lt;&gt;(builder.build());</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *
     * @param popup The new {@link JPopupMenu} instance which ought to be part of the Swing UI.
     * @param &lt;P&gt; The concrete type of this new component.
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
    public static &lt;P extends JPopupMenu&gt; UIForPopup&lt;P&gt; of( P popup )
    {
<span class="fc" id="L1497">        NullUtil.nullArgCheck(popup, &quot;popup&quot;, JPopupMenu.class);</span>
<span class="fc" id="L1498">        return new UIForPopup&lt;&gt;(popup);</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPopupMenu())}.
     *
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
<span class="fc" id="L1507">    public static UIForPopup&lt;JPopupMenu&gt; popupMenu() { return of(new PopupMenu()); }</span>

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *
     * @param separator The new {@link JSeparator} instance which ought to be part of the Swing UI.
     * @param &lt;S&gt; The concrete type of this new component.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static &lt;S extends JSeparator&gt; UIForSeparator&lt;S&gt; of( S separator )
    {
<span class="fc" id="L1519">        NullUtil.nullArgCheck(separator, &quot;separator&quot;, JSeparator.class);</span>
<span class="fc" id="L1520">        return new UIForSeparator&lt;&gt;(separator);</span>
    }

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator())}.
     *
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
<span class="fc" id="L1530">    public static UIForSeparator&lt;JSeparator&gt; separator() { return of(new JSeparator()); }</span>

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator(JSeparator.VERTICAL))}.
     *
     * @param align The alignment of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( Align align ) {
<span class="fc" id="L1541">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L1542">        return separator().withOrientation(align);</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JSeparator} whose
     *  alignment is dynamically determined based on a provided property.
     *
     * @param align The alignment property of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( Val&lt;Align&gt; align ) {
<span class="nc" id="L1553">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L1554">        return separator().withOrientation(align);</span>
    }

    /**
     *  This returns a {@link JButton} swing tree builder.
     *
     * @param component The button component which ought to be wrapped by the swing tree UI builder.
     * @param &lt;T&gt; The concrete type of this new component.
     * @return A basic UI {@link JButton} builder instance.
     */
    public static &lt;T extends AbstractButton&gt; UIForButton&lt;T&gt; of( T component )
    {
<span class="fc" id="L1566">        NullUtil.nullArgCheck(component, &quot;component&quot;, AbstractButton.class);</span>
<span class="fc" id="L1567">        return new UIForButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component without any text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton())}.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
<span class="fc" id="L1576">    public static UIForButton&lt;JButton&gt; button() { return of(new Button()); }</span>

    /**
     *  Use this to create a builder for the {@link JButton} UI component with the provided text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton(String text))}.
     *
     * @param text The text to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
<span class="fc" id="L1585">    public static UIForButton&lt;JButton&gt; button( String text ) { return button().withText(text); }</span>

    /**
     *  Create a builder for the {@link JButton} UI component where the text of the provided
     *  property is dynamically displayed on top.
     *
     * @param text The text property to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Val&lt;String&gt; text ) {
<span class="fc" id="L1595">        NullUtil.nullArgCheck( text, &quot;text&quot;, Val.class );</span>
<span class="fc" id="L1596">        return button().withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).peek( it -&gt; it.setIcon(icon) )}.
     *
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon ) {
<span class="nc" id="L1608">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1609">        return button().withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *
     * @param icon The icon to be displayed on top of the button.
     * @param fit The fit mode of the icon.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( ImageIcon icon, FitComponent fit ) {
<span class="nc" id="L1621">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1622">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, FitComponent.class);</span>
<span class="nc" id="L1623">        return button().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param icon The desired icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon ) {
<span class="nc" id="L1636">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1637">        return icon.find().map(UI::button).orElseGet(UI::button);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param icon The desired icon to be displayed on top of the button.
     * @param fit The fit mode of the icon.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, FitComponent fit ) {
<span class="nc" id="L1651">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1652">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, FitComponent.class);</span>
<span class="nc" id="L1653">        return icon.find().map( it -&gt; button(it, fit) ).orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top which should be scaled to the provided dimensions.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).peek( it -&gt; it.setIcon(icon) )}.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, ImageIcon icon ) {
<span class="fc" id="L1667">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L1668">        return button().withIcon(width, height, icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top which should be scaled to the provided dimensions.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The desired icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L1683">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1684">        return icon.find().map( it -&gt; button(width, height, it) ).orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a dynamically displayed icon on top.
     *  &lt;p&gt;
     *  Note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property whose value ought to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; buttonWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L1711">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1712">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="nc" id="L1713">        return button().withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover ) {
<span class="nc" id="L1725">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1726">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="nc" id="L1727">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, IconDeclaration onHover ) {
<span class="nc" id="L1741">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1742">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1743">        return icon.find()</span>
<span class="nc" id="L1744">                   .flatMap( it -&gt; onHover.find().map( it2 -&gt; button(it, it2) ) )</span>
<span class="nc" id="L1745">                   .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top
     *  which should both be scaled to the provided dimensions.
     *
     * @param width The width the icons should be scaled to.
     * @param height The height the icons should be scaled to.
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, ImageIcon icon, ImageIcon onHover ) {
<span class="fc" id="L1760">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L1761">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, ImageIcon.class);</span>
<span class="fc" id="L1762">        float scale = UI.scale();</span>

<span class="fc" id="L1764">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L1765" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L1766">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L1768">        width  = (int) (width * scale);</span>
<span class="fc" id="L1769">        height = (int) (height * scale);</span>

<span class="fc" id="L1771">        onHover = new ImageIcon(onHover.getImage().getScaledInstance(width, height, scaleHint));</span>
<span class="fc" id="L1772">        icon = new ImageIcon(icon.getImage().getScaledInstance(width, height, scaleHint));</span>
<span class="fc" id="L1773">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top
     *  which should both be scaled to the provided dimensions.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param width The width the icons should be scaled to.
     * @param height The height the icons should be scaled to.
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, IconDeclaration icon, IconDeclaration onHover ) {
<span class="nc" id="L1790">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1791">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1792">        return icon.find()</span>
<span class="nc" id="L1793">                   .flatMap( it -&gt; onHover.find().map( it2 -&gt; button(width, height, it, it2) ) )</span>
<span class="nc" id="L1794">                   .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default, an on-hover and an on-press icon displayed on top.
     *  This is in essence a convenience method for:
     *  &lt;pre&gt;{@code 
     *      UI.of(new JButton()).peek( it -&gt; {
     *          it.setIcon(icon);
     *          it.setRolloverIcon(onHover);
     *          it.setPressedIcon(onPress);
     *      })
     *  }&lt;/pre&gt;
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @param onPress The pressed icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover, Icon onPress ) {
<span class="fc" id="L1815">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L1816">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="fc" id="L1817">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Icon.class);</span>
<span class="fc" id="L1818">        return button().peek(it -&gt; it.setIcon(icon) )</span>
<span class="fc" id="L1819">                .peek(it -&gt; it.setRolloverIcon(onHover) )</span>
<span class="fc" id="L1820">                .peek(it -&gt; it.setPressedIcon(onPress) );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default, an on-hover and an on-press icon displayed on top.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @param onPress The pressed icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, IconDeclaration onHover, IconDeclaration onPress ) {
<span class="nc" id="L1835">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1836">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1837">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1838">        return icon.find()</span>
<span class="nc" id="L1839">                   .flatMap( it -&gt; onHover.find().flatMap( it2 -&gt; onPress.find().map( it3 -&gt; button(it, it2, it3) ) ) )</span>
<span class="nc" id="L1840">                   .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JSplitButton} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSplitButton())}.
     *
     * @param splitButton The split button component which ought to be wrapped by the swing tree UI builder.
     * @param &lt;B&gt; The concrete type of this new component.
     * @return A builder instance for a {@link JSplitButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JSplitButton&gt; UIForSplitButton&lt;B&gt; of( B splitButton ) {
<span class="nc" id="L1852">        NullUtil.nullArgCheck(splitButton, &quot;splitButton&quot;, JSplitButton.class);</span>
<span class="nc" id="L1853">        return new UIForSplitButton&lt;&gt;(splitButton);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s with custom text displayed ont top.
     *  The {@link JSplitButton} wrapped by the returned builder can be populated
     *  with {@link JMenuItem}s like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Displayed on button!&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;).onButtonClick( it -&gt; ... ))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JSplitButton}
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     */
    public static UIForSplitButton&lt;JSplitButton&gt; splitButton( String text ) {
<span class="fc" id="L1871">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1872">        return new UIForSplitButton&lt;&gt;((JSplitButton) new SplitButton()).withText(text);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type, and the click event is
     *  handles by an {@link Event} instance. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *      private Event clickEvent = Event.of(()-&gt;{ ... }
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *      public Event clickEvent() { return clickEvent; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection(), vm.clickEvent())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the split button, the selected enum state
     *      will be converted to strings based on the {@link Object#toString()}
     *      method. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @param clickEvent The {@link Event} which will be fired when the user clicks on the button.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     * @param &lt;E&gt; The type of the {@link Enum} representing the selectable options.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection, Event clickEvent ) {
<span class="fc" id="L1908">        return splitButton(&quot;&quot;).withSelection(selection, clickEvent);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the button is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     * @param &lt;E&gt; The type of the {@link Enum} representing the selectable options.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection ) {
<span class="fc" id="L1938">        return splitButton(&quot;&quot;).withSelection(selection);</span>
    }

    /**
     *  Use this to add entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JMenuItem} exposed by the {@link JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( String text ) {
<span class="fc" id="L1957">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1958">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add property bound entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(viewModel.getFirstButtonName()))
     *      .add(UI.splitItem(viewModel.getSecondButtonName()))
     *      .add(UI.splitItem(viewModel.getThirdButtonName()))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text property to dynamically display text on the {@link JMenuItem} exposed by the {@link swingtree.components.JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( Val&lt;String&gt; text ) {
<span class="nc" id="L1977">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1978">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add radio item entries to the {@link swingtree.components.JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitRadioItem(&quot;first&quot;))
     *      .add(UI.splitRadioItem(&quot;second&quot;))
     *      .add(UI.splitRadioItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JRadioButtonMenuItem} exposed by the {@link swingtree.components.JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JRadioButtonMenuItem}.
     */
    public static SplitItem&lt;JRadioButtonMenuItem&gt; splitRadioItem( String text ) {
<span class="fc" id="L1997">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1998">        return SplitItem.of(new JRadioButtonMenuItem(text));</span>
    }

    /**
     *  Creates a UI builder for a custom {@link JTabbedPane} type.
     *
     * @param pane The {@link JTabbedPane} type which should be used wrapped.
     * @return This instance, to allow for method chaining.
     * @param &lt;P&gt; The pane type parameter.
     */
    public static &lt;P extends JTabbedPane&gt; UIForTabbedPane&lt;P&gt; of( P pane ) {
<span class="fc" id="L2009">        NullUtil.nullArgCheck(pane, &quot;pane&quot;, JTabbedPane.class);</span>
<span class="fc" id="L2010">        return new UIForTabbedPane&lt;&gt;(pane);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTabbedPane())}.
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;one&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;two&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;three&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     *
     * @return A builder instance for a new {@link JTabbedPane}, which enables fluent method chaining.
     */
<span class="fc" id="L2029">    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane() { return of(new TabbedPane()); }</span>

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link Side} applied to the tab buttons
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.RIGHT)
     *      .add(UI.tab(&quot;first&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsSide The position of the tab buttons which may be {@link Side#TOP}, {@link Side#RIGHT}, {@link Side#BOTTOM}, {@link Side#LEFT}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Side tabsSide) {
<span class="fc" id="L2050">        NullUtil.nullArgCheck(tabsSide, &quot;tabsPosition&quot;, Side.class);</span>
<span class="fc" id="L2051">        return tabbedPane().withTabPlacementAt(tabsSide);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link OverflowPolicy} and {@link Side} applied to the tab buttons
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)} and {@link JTabbedPane#setTabPlacement(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.LEFT, OverflowPolicy.WRAP)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsSide The position of the tab buttons which may be {@link Side#TOP}, {@link Side#RIGHT}, {@link Side#BOTTOM}, {@link Side#LEFT}.
     * @param tabsPolicy The overflow policy of the tab buttons which can either be {@link OverflowPolicy#SCROLL} or {@link OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} or {@code tabsPolicy} are {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane(Side tabsSide, OverflowPolicy tabsPolicy ) {
<span class="nc" id="L2073">        NullUtil.nullArgCheck(tabsSide, &quot;tabsPosition&quot;, Side.class);</span>
<span class="nc" id="L2074">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, OverflowPolicy.class);</span>
<span class="nc" id="L2075">        return tabbedPane().withTabPlacementAt(tabsSide).withOverflowPolicy(tabsPolicy);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link OverflowPolicy} applied to the tab buttons (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(OverflowPolicy.SCROLL)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *  
     * @param tabsPolicy The overflow policy of the tab button which can either be {@link OverflowPolicy#SCROLL} or {@link OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPolicy} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( OverflowPolicy tabsPolicy ) {
<span class="nc" id="L2095">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, OverflowPolicy.class);</span>
<span class="nc" id="L2096">        return tabbedPane().withTabPlacementAt(Side.TOP).withOverflowPolicy(tabsPolicy);</span>
    }


    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectionIndex} property which should be determine the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *  Note that contrary to method {@link #tabbedPane(Var)}, this method receives a {@link Val}
     *  property which may not be changed by the GUI user. If you want to allow the user to change
     *  the selection index property state, use {@link #tabbedPane(Var)} instead.
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Val&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L2121">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectionIndex} property which should be determine the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Var&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L2142">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( String title ) {
<span class="fc" id="L2160">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class);</span>
<span class="fc" id="L2161">        return new Tab(null, null, Val.of(title), null, null, null, null, null, null);</span>
    }

    /**
     *  A factory method producing a {@link Tab} instance with the provided {@code title} property
     *  which can dynamically change the title of the tab button.
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(property1).add(UI.panel().add(..)))
     *      .add(UI.tab(property2).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(property3).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text property dynamically changing the title of the tab button when the property changes.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( Val&lt;String&gt; title ) {
<span class="fc" id="L2181">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L2182">        return new Tab(null, null, title, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(new JButton(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(new JLabel(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(new JPanel()).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param component The component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static Tab tab( JComponent component ) {
<span class="nc" id="L2200">        NullUtil.nullArgCheck(component, &quot;component&quot;, Component.class);</span>
<span class="nc" id="L2201">        return new Tab(null, component, null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(UI.button(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(UI.label(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(UI.of(...)).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param builder The builder wrapping the component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code builder} is {@code null}.
     */
    public static Tab tab( UIForAnySwing&lt;?, ?&gt; builder ) {
<span class="fc" id="L2219">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, UIForAnySwing.class);</span>
<span class="fc" id="L2220">        return new Tab(null, builder.getComponent(), null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenu} instance.
     *
     * @param component The {@link JMenu} component which should be wrapped by the swing tree UI builder designed for menus.
     * @return A builder instance for the provided {@link JMenu}, which enables fluent method chaining.
     * @param &lt;M&gt; The concrete type of the menu.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenu&gt; UIForMenu&lt;M&gt; of( M component ) {
<span class="nc" id="L2232">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenu.class);</span>
<span class="nc" id="L2233">        return new UIForMenu&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenuItem} instance.
     *
     * @param component The {@link JMenuItem} component which should be wrapped by the swing tree UI builder designed for menu items.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type parameter of the concrete menu item component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( M component ) {
<span class="fc" id="L2245">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenuItem.class);</span>
<span class="fc" id="L2246">        return new UIForMenuItem&lt;&gt;(component);</span>
    }

    /**
     *  This factory method creates a {@link JMenu} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.menuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.menuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text ) {
<span class="fc" id="L2263">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2264">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L2272">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2273">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text);</span>
    }

    /**
     *  Use this factory method to create a {@link JMenuItem} with the
     *  provided text and default icon. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.menuItem(&quot;Hello&quot;, UI.icon(&quot;path/to/icon.png&quot;))
     *    .withTip(&quot;I give info!&quot;)
     *    .onClick( it -&gt; {...} )
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Icon icon ) {
<span class="nc" id="L2291">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2292">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2293">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L2294">                    .withText(text)</span>
<span class="nc" id="L2295">                    .withIcon(icon);</span>
    }

    /**
     *  Use this factory method to create a {@link JMenuItem} with the
     *  provided text and default icon based on the provided {@link IconDeclaration}. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.menuItem(&quot;Hello&quot;, Icons.MY_ICON)
     *    .withTip(&quot;I give info!&quot;)
     *    .onClick( it -&gt; {...} )
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, IconDeclaration icon ) {
<span class="nc" id="L2313">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2314">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L2315">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L2316">                    .withText(text)</span>
<span class="nc" id="L2317">                    .withIcon(icon);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L2326">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2327">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2328">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L2329">                    .withText(text)</span>
<span class="nc" id="L2330">                    .withIcon(icon);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, IconDeclaration icon ) {
<span class="nc" id="L2339">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2340">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L2341">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L2342">                    .withText(text)</span>
<span class="nc" id="L2343">                    .withIcon(icon);</span>
    }

    /**
     *  Allows you to create a menu item with an icon property bound to it.
     *  So when the property state changes to a different icon, then so does the
     *  icon displayed on top of the menu item.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L2372">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2373">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L2374">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text).withIcon(icon);</span>
    }

    /**
     *  Allows you to create a menu item with a text property and
     *  an icon property bound to it.
     *  So when the text or con property state changes to a different text or icon, then so does the
     *  text and/or icon displayed on top of the menu item.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L2404">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2405">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L2406">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to wrap the provided {@link JRadioButtonMenuItem} instance in a SwingTree UI builder.
     *
     * @param radioMenuItem The {@link JRadioButtonMenuItem} instance to be wrapped.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type of the {@link JRadioButtonMenuItem} instance to be wrapped.
     */
    public static &lt;M extends JRadioButtonMenuItem&gt; UIForRadioButtonMenuItem&lt;M&gt; of( M radioMenuItem ) {
<span class="nc" id="L2417">        NullUtil.nullArgCheck(radioMenuItem, &quot;component&quot;, JRadioButtonMenuItem.class);</span>
<span class="nc" id="L2418">        return new UIForRadioButtonMenuItem&lt;&gt;(radioMenuItem);</span>
    }

    /**
     *  A factory method to create a plain {@link JRadioButtonMenuItem} instance. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem().onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem().onClick( it -&gt; {..} ))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem() {
<span class="nc" id="L2433">        return new UIForRadioButtonMenuItem&lt;&gt;((JRadioButtonMenuItem) new RadioButtonMenuItem());</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text ) {
<span class="nc" id="L2450">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2451">        return radioButtonMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Delete&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Edit&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JRadioButtonMenuItem} dynamically.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L2470">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2471">        return radioButtonMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with the provided text
     *  displayed on the menu button and the provided icon displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Delete&quot;, UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Edit&quot;, UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text, Icon icon ) {
<span class="nc" id="L2489">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2490">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2491">        return radioButtonMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided icon
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Delete&quot;), UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Edit&quot;), UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JRadioButtonMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */

    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L2513">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2514">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2515">        return radioButtonMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to a fixed enum value
     *  and a variable enum property which will dynamically select the menu item based on the
     *  equality of the fixed enum value and the variable enum property value. &lt;br&gt;
     *  Consider the following example code:
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Unit.SECONDS, myViewModel.unitProperty()))
     *    .add(UI.radioButtonMenuItem(Unit.MINUTES, myViewModel.unitProperty()))
     *    .add(UI.radioButtonMenuItem(Unit.HOURS,   myViewModel.unitProperty()))
     *  }&lt;/pre&gt;
     *  In this example the {@code myViewModel.unitProperty()} is a {@link Var} property of
     *  example type {@code Unit}.
     *  A given menu item will be selected if the value of the {@code myViewModel.unitProperty()}
     *  is equal to the first enum value passed to the factory method.
     *  This first enum will also be used as the text of the menu item through the {@code toString()}.
     *
     * @param state The fixed enum value which will be used as the text of the menu item and
     * @param property The variable enum property which will be used to select the menu item.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the enum.
     * @throws IllegalArgumentException if {@code state} or {@code property} are {@code null}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( E state, Var&lt;E&gt; property ) {
<span class="nc" id="L2542">        NullUtil.nullArgCheck(state, &quot;state&quot;, Enum.class);</span>
<span class="nc" id="L2543">        NullUtil.nullArgCheck(property, &quot;property&quot;, Var.class);</span>
<span class="nc" id="L2544">        return radioButtonMenuItem(state.toString()).isSelectedIf(state, property);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the radio button based menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected1 = Var.of(false);
     *    Var&lt;Boolean&gt; isSelected2 = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Make Coffee&quot;, isSelected1).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Make Tea&quot;, isSelected2).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the boolean property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2569">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2570">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2571">        return radioButtonMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the radio button based menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected1 = Var.of(false);
     *    Var&lt;Boolean&gt; isSelected2 = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Make Coffee&quot;), isSelected1).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Make Tea&quot;), isSelected2).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the {@code String} and {@code boolean}
     * properties from a view model object through
     * plain old getter methods
     * (e.g. {@code myViewModel.getTextProperty()} and {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text property whose text should dynamically be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2598">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2599">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2600">        return radioButtonMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to wrap the provided {@link JCheckBoxMenuItem} instance in a SwingTree UI builder.
     *
     * @param checkBoxMenuItem The {@link JCheckBoxMenuItem} instance to be wrapped.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type of the {@link JCheckBoxMenuItem} instance to be wrapped.
     */
    public static &lt;M extends JCheckBoxMenuItem&gt; UIForCheckBoxMenuItem&lt;M&gt; of( M checkBoxMenuItem ) {
<span class="fc" id="L2611">        NullUtil.nullArgCheck(checkBoxMenuItem, &quot;component&quot;, JCheckBoxMenuItem.class);</span>
<span class="fc" id="L2612">        return new UIForCheckBoxMenuItem&lt;&gt;(checkBoxMenuItem);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} without text
     *  displayed on top of the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem().onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem().onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem() {
<span class="nc" id="L2628">        return of(new CheckBoxMenuItem());</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text ) {
<span class="nc" id="L2645">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2646">        return checkBoxMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L2665">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2666">        return checkBoxMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with the provided text
     *  displayed on the menu button and the provided icon displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;, UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;, UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text, Icon icon ) {
<span class="nc" id="L2684">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2685">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2686">        return checkBoxMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;, isSelected).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;, isSelected).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the boolean property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2710">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2711">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2712">        return checkBoxMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided icon
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;), UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;), UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L2733">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2734">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2735">        return checkBoxMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided boolean property,
     *  dynamically determining whether the menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;), isSelected).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;), isSelected).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2760">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2761">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2762">        return checkBoxMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToolBar} instance.
     *  Using method chaining you can populate the {@link JToolBar} by like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(myToolBar)
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param component The {@link JToolBar} instance to be wrapped.
     * @param &lt;T&gt; The type of the {@link JToolBar} instance to be wrapped.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;T extends JToolBar&gt; UIForToolBar&lt;T&gt; of( T component ) {
<span class="nc" id="L2783">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToolBar.class);</span>
<span class="nc" id="L2784">        return new UIForToolBar&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToolBar} instance.
     *  Use method chaining to add buttons or other components to a {@link JToolBar} by
     *  passing them to {@link UIForToolBar} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.toolBar()
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar() {
<span class="fc" id="L2804">        return new UIForToolBar&lt;&gt;(new ToolBar());</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link Align} enum defines the orientation of the {@link JToolBar}.
     *
     * @param align The {@link Align} enum which defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( Align align ) {
<span class="nc" id="L2816">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L2817">        return new UIForToolBar&lt;&gt;((JToolBar) new ToolBar()).withOrientation(align);</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link Val} property dynamically defines
     *  the orientation of the {@link JToolBar}
     *
     * @param align The {@link Val} property which dynamically defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( Val&lt;Align&gt; align ) {
<span class="nc" id="L2830">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L2831">        return new UIForToolBar&lt;&gt;((JToolBar) new ToolBar()).withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JScrollPane} component.
     *
     * @param component The {@link JScrollPane} component which should be represented by the returned builder.
     * @param &lt;P&gt; The type parameter defining the concrete scroll pane type.
     * @return A {@link UIForScrollPane} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPane&gt; UIForScrollPane&lt;P&gt; of( P component ) {
<span class="fc" id="L2843">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="fc" id="L2844">        return new UIForScrollPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPane())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPane()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPane}, which enables fluent method chaining.
     */
<span class="fc" id="L2859">    public static UIForScrollPane&lt;JScrollPane&gt; scrollPane() { return of(new ScrollPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JScrollPanels} component.
     *
     * @param component The {@link JScrollPanels} component which should be represented by the returned builder.
     * @param &lt;P&gt; The type parameter defining the concrete scroll panels type.
     * @return A {@link UIForScrollPanels} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPanels&gt; UIForScrollPanels&lt;P&gt; of( P component ) {
<span class="fc" id="L2870">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="fc" id="L2871">        return new UIForScrollPanels&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels() {
<span class="fc" id="L2889">        return of(JScrollPanels.of(Align.VERTICAL, new Dimension(100,100)));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL)
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(Align align) {
<span class="nc" id="L2908">        return of(JScrollPanels.of(align, null));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL, new Dimension(100,100))
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @param size The size of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(Align align, Dimension size) {
<span class="nc" id="L2928">        return of(JScrollPanels.of(align, size));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSplitPane} instance.
     *
     * @param component The {@link JSplitPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JSplitPane} instance.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JSplitPane&gt; UIForSplitPane&lt;P&gt; of( P component ) {
<span class="fc" id="L2940">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSplitPane.class);</span>
<span class="fc" id="L2941">        return new UIForSplitPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment enum determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitPane(UI.Align.HORIZONTAL) // The split bar will be horizontal
     *      .withDividerAt(50)
     *      .add(UI.panel().add(...)) // top
     *      .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( Align align ) {
<span class="fc" id="L2961">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L2962">        return of((JSplitPane) new SplitPane(align)).withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment property determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.splitPane(viewModel.getAlignment())
     *    .withDividerAt(50)
     *    .add(UI.panel().add(...)) // top
     *    .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  The split pane will be updated whenever the provided property changes.
     *  &lt;br&gt;
     *  &lt;b&gt;Note:&lt;/b&gt; The provided property must not be {@code null}!
     *  Otherwise, an {@link IllegalArgumentException} will be thrown.
     *  &lt;br&gt;
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( Val&lt;Align&gt; align ) {
<span class="fc" id="L2987">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="fc" id="L2988">        NullUtil.nullPropertyCheck(align, &quot;align&quot;, &quot;Null is not a valid alignment.&quot;);</span>
<span class="fc" id="L2989">        return of((JSplitPane) new SplitPane(align.get()))</span>
<span class="fc" id="L2990">                .withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JEditorPane} instance.
     *
     * @param component The {@link JEditorPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JEditorPane} instance.
     * @return A builder instance for the provided {@link JEditorPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JEditorPane&gt; UIForEditorPane&lt;P&gt; of( P component ) {
<span class="fc" id="L3002">        NullUtil.nullArgCheck(component, &quot;component&quot;, JEditorPane.class);</span>
<span class="fc" id="L3003">        return new UIForEditorPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JEditorPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JEditorPane())}.
     *
     * @return A builder instance for a new {@link JEditorPane}, which enables fluent method chaining.
     */
<span class="fc" id="L3012">    public static UIForEditorPane&lt;JEditorPane&gt; editorPane() { return of(new EditorPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JTextPane} instance.
     *
     * @param component The {@link JTextPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JTextPane} instance.
     * @return A builder instance for the provided {@link JTextPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JTextPane&gt; UIForTextPane&lt;P&gt; of( P component ) {
<span class="nc" id="L3023">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextPane.class);</span>
<span class="nc" id="L3024">        return new UIForTextPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextPane())}.
     *
     * @return A builder instance for a new {@link JTextPane}, which enables fluent method chaining.
     */
<span class="nc" id="L3033">    public static UIForTextPane&lt;JTextPane&gt; textPane() { return of(new TextPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JSlider} instance.
     *
     * @param component The {@link JSlider} instance to create a builder for.
     * @param &lt;S&gt; The type of the {@link JSlider} instance.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;S extends JSlider&gt; UIForSlider&lt;S&gt; of( S component ) {
<span class="fc" id="L3044">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSlider.class);</span>
<span class="fc" id="L3045">        return new UIForSlider&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type determining if
     *  the slider will be aligned vertically or horizontally.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align ) {
<span class="fc" id="L3060">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L3061">        return of((JSlider) new Slider()).withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment property which dynamically
     *  determines if the property is aligned vertically or horizontally.
     *
     * @param align The alignment property determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if the {@code align} property is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( Val&lt;Align&gt; align ) {
<span class="nc" id="L3076">        NullUtil.nullArgCheck( align, &quot;align&quot;, Val.class );</span>
<span class="nc" id="L3077">        return of((JSlider) new Slider()).withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type, min slider value and max slider value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max ) {
<span class="fc" id="L3096">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L3097">        return of((JSlider) new Slider())</span>
<span class="fc" id="L3098">                    .withOrientation(align)</span>
<span class="fc" id="L3099">                    .withMin(min)</span>
<span class="fc" id="L3100">                    .withMax(max)</span>
<span class="fc" id="L3101">                    .withValue((min + max) / 2);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and initial values.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value  the initial value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, int value ) {
<span class="fc" id="L3122">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L3123">        return of((JSlider) new Slider())</span>
<span class="fc" id="L3124">                .withOrientation(align)</span>
<span class="fc" id="L3125">                .withMin(min)</span>
<span class="fc" id="L3126">                .withMax(max)</span>
<span class="fc" id="L3127">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L3148">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L3149">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="nc" id="L3150">        return of((JSlider) new Slider())</span>
<span class="nc" id="L3151">                .withOrientation(align)</span>
<span class="nc" id="L3152">                .withMin(min)</span>
<span class="nc" id="L3153">                .withMax(max)</span>
<span class="nc" id="L3154">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, Var&lt;Integer&gt; value ) {
<span class="fc" id="L3175">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L3176">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="fc" id="L3177">        return of((JSlider) new Slider())</span>
<span class="fc" id="L3178">                .withOrientation(align)</span>
<span class="fc" id="L3179">                .withMin(min)</span>
<span class="fc" id="L3180">                .withMax(max)</span>
<span class="fc" id="L3181">                .withValue(value);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JComboBox} instance.
     *
     * @param component The {@link JComboBox} instance to create a builder for.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @param &lt;C&gt; The type of the {@link JComboBox} instance.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     */
    public static &lt;E, C extends JComboBox&lt;E&gt;&gt; UIForCombo&lt;E,C&gt; of( C component ) {
<span class="fc" id="L3193">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComboBox.class);</span>
<span class="fc" id="L3194">        return new UIForCombo&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JComboBox())}.
     *
     * @return A builder instance for a new {@link JComboBox}, which enables fluent method chaining.
     */
<span class="fc" id="L3203">    public static UIForCombo&lt;Object,JComboBox&lt;Object&gt;&gt; comboBox() { return of(new ComboBox&lt;&gt;()); }</span>

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  with the provided array of elements as selectable items.
     *
     * @param items The array of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( E... items ) {
<span class="fc" id="L3216">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class);</span>
<span class="fc" id="L3217">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  with the provided array of elements as selectable items which
     *  may not be modified by the user.
     *
     * @param items The unmodifiable array of elements to be selectable in the {@link JList}.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( E... items ) {
<span class="fc" id="L3232">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class); // Unmodifiable</span>
<span class="fc" id="L3233">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(java.util.Arrays.asList(items));</span>
<span class="fc" id="L3234">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  where the provided enum based property dynamically models the selected item
     *  as well as all possible options (all the enum states).
     *  The property will be updated whenever the user
     *  selects a new item in the {@link JComboBox} and the {@link JComboBox}
     *  will be updated whenever the property changes in your code (see {@link Var#set(Object)}).
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.comboBox(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the combo box is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selectedItem A property modelling the selected item in the combo box.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem ) {
<span class="fc" id="L3268">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
        // We get an array of possible enum states from the enum class
<span class="fc" id="L3270">        return comboBox(selectedItem.type().getEnumConstants()).withSelectedItem(selectedItem);</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided list of elements as selectable items.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( java.util.List&lt;E&gt; items ) {
<span class="fc" id="L3283">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L3284">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ListBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided list of elements as selectable items which
     *  may not be modified by the user.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( java.util.List&lt;E&gt; items ) {
<span class="nc" id="L3297">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="nc" id="L3298">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(items);</span>
<span class="nc" id="L3299">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, java.util.List&lt;E&gt; items ) {
<span class="fc" id="L3315">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L3316">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3317">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ListBasedComboModel&lt;&gt;(selection, items));</span>
    }

    //___

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and mutable) items.
     *
     * @param items The {@link Vars} properties of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vars&lt;E&gt; items ) {
<span class="fc" id="L3332">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3333">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new VarsBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and immutable) items which
     *  may not be modified by the user.
     *
     * @param items The {@link sprouts.Vals} properties of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vals&lt;E&gt; items ) {
<span class="nc" id="L3346">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3347">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ValsBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vars&lt;E&gt; items ) {
<span class="fc" id="L3363">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3364">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3365">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new VarsBasedComboModel&lt;&gt;(selection, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a property list of items as a dynamically sized model for the
     *  selectable items which may not be modified by the user.
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vals&lt;E&gt; items ) {
<span class="nc" id="L3379">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3380">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L3381">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ValsBasedComboModel&lt;&gt;(selection, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array of items as a fixed-size model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The array of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, E... items ) {
<span class="fc" id="L3397">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L3398">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayBasedComboModel&lt;&gt;(var, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The property holding an array of selectable items which can be mutated by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, Var&lt;E[]&gt; items ) {
<span class="fc" id="L3414">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L3415">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayPropertyComboModel&lt;&gt;(var, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param selectedItem The property holding the current selection.
     * @param items The property holding an array of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem, Val&lt;E[]&gt; items ) {
<span class="nc" id="L3431">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="nc" id="L3432">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
<span class="nc" id="L3433">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayPropertyComboModel&lt;&gt;(selectedItem, items));</span>
    }

    /**
     *  Created a combo box UI builder node with the provided {@link ComboBoxModel}.
     *
     * @param model The model to be used by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( ComboBoxModel&lt;E&gt; model ) {
<span class="nc" id="L3444">        NullUtil.nullArgCheck(model, &quot;model&quot;, ComboBoxModel.class);</span>
<span class="nc" id="L3445">        JComboBox&lt;E&gt; c = new ComboBox&lt;E&gt;();</span>
<span class="nc" id="L3446">        c.setModel(model);</span>
<span class="nc" id="L3447">        return of(c);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSpinner} instance.
     *
     * @param spinner The {@link JSpinner} instance to create a builder for.
     *                The provided {@link JSpinner} instance must not be {@code null}.
     * @param &lt;S&gt; The type parameter of the concrete {@link JSpinner} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code spinner} is {@code null}.
     */
    public static &lt;S extends JSpinner&gt; UIForSpinner&lt;S&gt; of( S spinner ) {
<span class="fc" id="L3460">        NullUtil.nullArgCheck(spinner, &quot;spinner&quot;, JSpinner.class);</span>
<span class="fc" id="L3461">        return new UIForSpinner&lt;&gt;(spinner);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSpinner} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSpinner())}.
     *
     * @return A builder instance for a new {@link JSpinner}, which enables fluent method chaining.
     */
<span class="fc" id="L3470">    public static UIForSpinner&lt;JSpinner&gt; spinner() { return of(new Spinner()); }</span>

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@link SpinnerModel} as the model.
     *
     * @param model The {@link SpinnerModel} to be used by the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( SpinnerModel model ) {
<span class="nc" id="L3480">        NullUtil.nullArgCheck(model, &quot;model&quot;, SpinnerModel.class);</span>
<span class="nc" id="L3481">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(model) );</span>
    }

    /**
     *  Use this factory method to create a {@link JSpinner} bound to a property of any type.
     *  The property will be updated when the user modifies its value.
     *
     * @param value A property of any type which should be bound to this spinner.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( Var&lt;?&gt; value ) {
<span class="fc" id="L3492">        NullUtil.nullArgCheck(value, &quot;value&quot;, Var.class);</span>
<span class="fc" id="L3493">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the spinner should not be null!&quot;);</span>
<span class="fc" id="L3494">        return spinner().withValue(value);</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max}, default {@code value} and {@code step} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @param step The step size of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max, int step ) {
<span class="nc" id="L3508">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, step)) );</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max} and default {@code value} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max ) {
<span class="fc" id="L3521">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, 1)) );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JLabel} instance.
     *
     * @param label The {@link JLabel} instance to be used by the builder.
     * @param &lt;L&gt; The type parameter of the concrete {@link JLabel} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JLabel}, which enables fluent method chaining.
     */
    public static &lt;L extends JLabel&gt; UIForLabel&lt;L&gt; of( L label ) {
<span class="fc" id="L3532">        NullUtil.nullArgCheck(label, &quot;component&quot;, JLabel.class);</span>
<span class="fc" id="L3533">        return new UIForLabel&lt;&gt;(label);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(text)}.
     *
     * @param text The text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text ) {
<span class="fc" id="L3544">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3545">        return of((JLabel) new Label()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(text, alignment))}.
     *
     * @param text The text which should be displayed on the label.
     * @param alignment The horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text, HorizontalAlignment alignment ) {
<span class="fc" id="L3557">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3558">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, HorizontalAlignment.class);</span>
<span class="fc" id="L3559">        return of((JLabel) new Label()).withText(text).withHorizontalAlignment( alignment );</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *
     * @param text The text which should be displayed on the label.
     * @param alignment The vertical and horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text, Alignment alignment ) {
<span class="nc" id="L3570">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L3571">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, Alignment.class);</span>
<span class="nc" id="L3572">        return of((JLabel) new Label()).withText(text).withAlignment( alignment );</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(Val&lt;String&gt; text)}.
     *
     * @param text The text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Val&lt;String&gt; text ) {
<span class="fc" id="L3583">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3584">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3585">        return of((JLabel) new Label())</span>
<span class="pc bpc" id="L3586" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L3587">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(Val&lt;String&gt; text, alignment)}.
     *
     * @param text The text property which should be bound to the label.
     * @param alignment The horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Val&lt;String&gt; text, HorizontalAlignment alignment ) {
<span class="nc" id="L3599">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3600">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3601">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, HorizontalAlignment.class);</span>
<span class="nc" id="L3602">        return of((JLabel) new Label())</span>
<span class="nc bnc" id="L3603" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3604">                .withText(text)</span>
<span class="nc" id="L3605">                .withHorizontalAlignment( alignment );</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Icon icon ) {
<span class="nc" id="L3615">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L3616">        return of((JLabel) new Label()).withIcon(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *  The icon is specified by a {@link IconDeclaration} which
     *  is essentially just a path to an icon resource.
     *  If the icon cannot be found, the label will be empty.
     *  Note that loaded icons are cached, so if you load the same icon multiple times,
     *  the same icon instance will be used (see {@link SwingTree#getIconCache()}).
     *
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( IconDeclaration icon ) {
<span class="nc" id="L3631">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3632">        return icon.find().map( UI::label ).orElseGet( () -&gt; label(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon dynamically.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property which should dynamically provide a desired icon for the {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; labelWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L3658">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L3659">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;Null icons are not allowed!&quot;);</span>
<span class="nc" id="L3660">        return of((JLabel) new Label()).withIcon(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param width The width of the icon when displayed on the label.
     * @param height The height of the icon when displayed on the label.
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( int width, int height, ImageIcon icon ) {
<span class="fc" id="L3672">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L3673">        float scale = UI.scale();</span>

<span class="fc" id="L3675">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L3677">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L3679">        width  = (int) (width * scale);</span>
<span class="fc" id="L3680">        height = (int) (height * scale);</span>

<span class="fc" id="L3682">        Image scaled = icon.getImage().getScaledInstance(width, height, scaleHint);</span>
<span class="fc" id="L3683">        return of((JLabel) new Label())</span>
<span class="fc" id="L3684">                .withIcon(new ImageIcon(scaled));</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *  The icon is specified by a {@link IconDeclaration} which
     *  is essentially just a path to an icon resource.
     *  If the icon cannot be found, the label will be empty.
     *  Note that loaded icons are cached, so if you load the same icon multiple times,
     *  the same icon instance will be used (see {@link SwingTree#getIconCache()}).
     *
     * @param width The width of the icon when displayed on the label.
     * @param height The height of the icon when displayed on the label.
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L3701">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3702">        return icon.find().map( i -&gt; label(width, height, i) ).orElseGet( () -&gt; label(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a UI builder for a {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(String text).makeBold()}.
     *  @param text The text which should be displayed on the label.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( String text ) {
<span class="fc" id="L3712">        return of((JLabel) new Label()).withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a UI builder for a bound {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(Val&lt;String&gt; text).makeBold()}.
     *  @param text The text property which should be displayed on the label dynamically.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( Val&lt;String&gt; text ) {
<span class="fc" id="L3722">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3723">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3724">        return of((JLabel) new Label()).withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( String text ) {
<span class="fc" id="L3735">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3736">        return of((JLabel) new Label()).withText(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;);</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( Val&lt;String&gt; text ) {
<span class="nc" id="L3747">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3748">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3749">        return of((JLabel) new Label())</span>
<span class="nc bnc" id="L3750" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3751">                .withText(text.view( it -&gt; &quot;&lt;html&gt;&quot; + it + &quot;&lt;/html&gt;&quot;));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link swingtree.components.JIcon} instance.
     *
     * @param icon The {@link swingtree.components.JIcon} instance to be used by the builder.
     * @param &lt;I&gt; The type of the {@link swingtree.components.JIcon} instance.
     * @return A builder instance for the provided {@link swingtree.components.JIcon}, which enables fluent method chaining.
     */
    public static &lt;I extends JIcon&gt; UIForIcon&lt;I&gt; of( I icon ) {
<span class="fc" id="L3762">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, JIcon.class);</span>
<span class="fc" id="L3763">        return new UIForIcon&lt;&gt;(icon);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the provided
     *  icon displayed on it.
     *
     * @param icon The icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( Icon icon ) {
<span class="nc" id="L3775">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L3776">        return of(new JIcon(icon));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the
     *  path provided by the supplied {@link IconDeclaration} displayed on it.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param icon The icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( IconDeclaration icon ) {
<span class="nc" id="L3789">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3790">        return of(new JIcon(icon));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the
     *  provided icon scaled to the provided width and height.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param icon The icon which should be placed into a {@link JIcon} for display.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, Icon icon ) {
<span class="fc" id="L3804">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L3805">        float scale = UI.scale();</span>

<span class="fc" id="L3807">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L3808" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L3809">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L3811">        width  = (int) (width * scale);</span>
<span class="fc" id="L3812">        height = (int) (height * scale);</span>

<span class="fc" id="L3814">        Image scaled = ((ImageIcon) icon).getImage().getScaledInstance(width, height, scaleHint);</span>
<span class="fc" id="L3815">        return of(new JIcon(new ImageIcon(scaled)));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the
     *  path defined by the supplied {@link IconDeclaration} displayed on it and scaled to the
     *  provided width and height.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param icon The icon which should be placed into a {@link JIcon} for display.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L3831">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3832">        return icon.find().map( i -&gt; icon(width, height, i) ).orElseGet( () -&gt; icon(&quot;&quot;) );</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the provided
     *  path displayed on it and scaled to the provided width and height.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param iconPath The path to the icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon path is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, String iconPath ) {
<span class="fc" id="L3847">        NullUtil.nullArgCheck(iconPath, &quot;iconPath&quot;, String.class);</span>
<span class="fc" id="L3848">        return icon(width, height, findIcon(iconPath).orElse(null));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the provided
     *  path displayed on it.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param iconPath The path to the icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon path is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( String iconPath ) {
<span class="fc" id="L3861">        NullUtil.nullArgCheck(iconPath, &quot;iconPath&quot;, String.class);</span>
<span class="fc" id="L3862">        return of(new JIcon(iconPath));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text ) {
<span class="fc" id="L3874">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3875">        return of((JCheckBox) new CheckBox()).withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance where the provided
     *  text property dynamically displays its value on the checkbox.
     *
     * @param text The text property which should be bound to the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text ) {
<span class="fc" id="L3887">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3888">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3889">        return of((JCheckBox) new CheckBox())</span>
<span class="nc bnc" id="L3890" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3891">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  where the provided text property dynamically displays its value on the checkbox
     *  and the provided selection property dynamically determines whether the checkbox
     *  is selected or not.
     *
     * @param text The text property which should be bound to the checkbox.
     *             This is the text which is displayed on the checkbox.
     * @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L3907">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3908">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="nc" id="L3909">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3910">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="nc" id="L3911">        return of((JCheckBox) new CheckBox())</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L3913" title="All 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="nc" id="L3914">                .withText(text)</span>
<span class="nc" id="L3915">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the checkbox is selected or not.
     *  @param text The text which should be displayed on the checkbox.
     *  @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     *  @return A builder instance for the checkbox, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L3928">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3929">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="fc" id="L3930">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="fc" id="L3931">        return of((JCheckBox) new CheckBox())</span>
<span class="pc bpc" id="L3932" title="1 of 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="fc" id="L3933">                .withText(text)</span>
<span class="fc" id="L3934">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JCheckBox} instance.
     *
     * @param component The {@link JCheckBox} instance to be used by the builder.
     * @param &lt;B&gt; The type parameter of the concrete {@link JCheckBox} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JCheckBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided checkbox is null.
     */
    public static &lt;B extends JCheckBox&gt; UIForCheckBox&lt;B&gt; of( B component ) {
<span class="fc" id="L3946">        NullUtil.nullArgCheck(component, &quot;component&quot;, JCheckBox.class);</span>
<span class="fc" id="L3947">        return new UIForCheckBox&lt;&gt;(component);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text ) {
<span class="fc" id="L3959">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3960">        return of((JRadioButton) new RadioButton()).withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance where the provided
     *  text property dynamically displays its value on the radio button.
     *
     * @param text The text property which should be bound to the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text ) {
<span class="fc" id="L3971">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3972">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3973">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L3974" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3975">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  where the provided text property dynamically displays its value on the radio button
     *  and the provided selection property dynamically determines whether the radio button
     *  is selected or not.
     *
     * @param text The text property which should be bound to the radio button.
     *             This is the text which is displayed on the radio button.
     * @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L3991">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3992">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L3993">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3994">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L3995">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L3996" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L3997" title="All 2 branches missed.">                .applyIf(!selected.hasNoID(), it -&gt; it.id(selected.id()))</span>
<span class="nc" id="L3998">                .withText(text)</span>
<span class="nc" id="L3999">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the radio button is selected or not.
     *  @param text The text which should be displayed on the radio button.
     *  @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     *  @return A builder instance for the radio button, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L4012">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4013">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L4014">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4015">        return of((JRadioButton) new RadioButton())</span>
<span class="nc" id="L4016">                .withText(text)</span>
<span class="nc" id="L4017">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  dynamically bound to an enum based {@link sprouts.Var}
     *  instance which will be used to dynamically model the selection state of the
     *  wrapped {@link JToggleButton} type by checking
     *  weather the property matches the provided enum or not.
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.panel()
     *      .add(UI.radioButton(Size.SMALL,  vm.selection())
     *      .add(UI.radioButton(Size.MEDIUM, vm.selection())
     *      .add(UI.radioButton(Size.LARGE,  vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the radio buttons, the enums will be converted
     *      to strings using {@link Object#toString()} method.
     *      If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param state The reference {@link Enum} which this {@link JToggleButton} should represent.
     * @param selection The {@link sprouts.Var} instance which will be used
     *                  to dynamically model the selection state of the wrapped {@link JToggleButton} type.
     * @param &lt;E&gt; The type of the enum which this {@link JToggleButton} should represent.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForRadioButton&lt;JRadioButton&gt; radioButton( E state, Var&lt;E&gt; selection ) {
<span class="nc" id="L4058">        NullUtil.nullArgCheck(state, &quot;state&quot;, Enum.class);</span>
<span class="nc" id="L4059">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L4060">        NullUtil.nullPropertyCheck(selection, &quot;selection&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4061">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L4062" title="All 2 branches missed.">                .applyIf(!selection.hasNoID(), it -&gt; it.id(selection.id()))</span>
<span class="nc" id="L4063">                .isSelectedIf( state, selection );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JRadioButton} instance.
     *
     * @param component The {@link JRadioButton} instance which should be wrapped by the builder.
     * @param &lt;R&gt; The type of the {@link JRadioButton} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JRadioButton}, which enables fluent method chaining.
     */
    public static &lt;R extends JRadioButton&gt; UIForRadioButton&lt;R&gt; of( R component ) {
<span class="fc" id="L4074">        NullUtil.nullArgCheck(component, &quot;component&quot;, JRadioButton.class);</span>
<span class="fc" id="L4075">        return new UIForRadioButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a {@link JToggleButton} instance.
     *
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
<span class="fc" id="L4083">    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton() { return of((JToggleButton) new ToggleButton()); }</span>

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it.
     *
     * @param text The text which should be displayed on the toggle button.
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text ) {
<span class="fc" id="L4093">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4094">        return toggleButton().withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button.
     *  &lt;p&gt;
     *  Note that the provided text property may not be null,
     *  and it is also not permitted to contain null values,
     *  instead use an empty string instead of null.
     *
     * @param text The text property which should be bound to the toggle button.
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text ) {
<span class="nc" id="L4109">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4110">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4111">        return toggleButton()</span>
<span class="nc bnc" id="L4112" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4113">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param  isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L4123">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="nc" id="L4124">        return toggleButton()</span>
<span class="nc bnc" id="L4125" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4126">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *  @param text The text which should be displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4138">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4139">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="fc" id="L4140">        return toggleButton()</span>
<span class="fc" id="L4141">                .withText(text)</span>
<span class="fc" id="L4142">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param text The text property which should be bound to the toggle button.
     *             This is the text which is displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4155">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L4156">        NullUtil.nullArgCheck(isToggled, &quot;isToggled&quot;, Var.class);</span>
<span class="fc" id="L4157">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="pc" id="L4158">        return toggleButton()</span>
<span class="pc bpc" id="L4159" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="pc bpc" id="L4160" title="1 of 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4161">                .withText(text)</span>
<span class="nc" id="L4162">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon ) {
<span class="fc" id="L4173">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L4174">        return toggleButton().withIcon(icon);</span>
    }

    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( ImageIcon icon, FitComponent fit ) {
<span class="nc" id="L4178">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4179">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, FitComponent.class);</span>
<span class="nc" id="L4180">        return toggleButton().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for the {@link JToggleButton} UI component
     *  with an icon displayed on it scaled according to the provided width and height.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( int width, int height, ImageIcon icon ) {
<span class="fc" id="L4193">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L4194">        return toggleButton().withIcon(width, height, icon);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the icon found at the path provided by the supplied {@link IconDeclaration} displayed on top of it.
     *  Note that the icon will be cached by the {@link JToggleButton} instance, so that it will not be reloaded.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( IconDeclaration icon ) {
<span class="nc" id="L4206">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L4207">        return toggleButton().withIcon(icon);</span>
    }

    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( IconDeclaration icon, FitComponent fit ) {
<span class="nc" id="L4211">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L4212">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, FitComponent.class);</span>
<span class="nc" id="L4213">        return toggleButton().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon, Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L4226">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4227">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4228">        return toggleButton(icon)</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4230">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link IconDeclaration} based property dynamically
     *  displays the targeted image on the toggle button.
     *  &lt;p&gt;
     *  Note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L4259">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L4260">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4261">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L4262" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc" id="L4263">                .withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link IconDeclaration} property dynamically displays its targeted icon on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;IconDeclaration&gt; icon, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4292">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L4293">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4294">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4295">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L4296" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4298">                .withIcon(icon)</span>
<span class="nc" id="L4299">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToggleButton} instance.
     *
     * @param component The {@link JToggleButton} instance which should be wrapped by the builder.
     * @param &lt;B&gt; The type of the {@link JToggleButton} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JToggleButton&gt; UIForToggleButton&lt;B&gt; of( B component ) {
<span class="fc" id="L4310">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToggleButton.class);</span>
<span class="fc" id="L4311">        return new UIForToggleButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextField} instance.
     *
     * @param component The {@link JTextField} instance which should be wrapped by the builder.
     * @param &lt;F&gt; The type of the {@link JTextField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text field is null.
     */
    public static &lt;F extends JTextField&gt; UIForTextField&lt;F&gt; of( F component ) {
<span class="fc" id="L4323">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextComponent.class);</span>
<span class="fc" id="L4324">        return new UIForTextField&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( String text ) {
<span class="fc" id="L4335">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4336">        return of((JTextField) new TextField()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Val&lt;String&gt; text ) {
<span class="nc" id="L4349">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4350">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4351">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L4352" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4353">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Var&lt;String&gt; text ) {
<span class="fc" id="L4365">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L4366">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L4367">        return of((JTextField) new TextField())</span>
<span class="pc bpc" id="L4368" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L4369">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextField())}.
     *
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
<span class="fc" id="L4378">    public static UIForTextField&lt;JTextField&gt; textField() { return of((JTextField) new TextField()); }</span>

    /**
     *  A convenience method for creating a builder for a {@link JTextField} with a certain text alignment.
     *  This is a shortcut version for the following code:
     *  &lt;pre&gt;{@code
     *      UI.textField()
     *          .withTextOrientation(UI.HorizontalDirection.RIGHT);
     *  }&lt;/pre&gt;
     *
     * @param direction The text orientation type which should be used.
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( HorizontalAlignment direction ) {
<span class="nc" id="L4392">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalAlignment.class);</span>
<span class="nc" id="L4393">        return of((JTextField) new TextField()).withTextOrientation(direction);</span>
    }

    /**
     *  A convenience method for creating a builder for a {@link JTextField} with a certain text and text alignment.
     *  This is a shortcut version for the following code:
     *  &lt;pre&gt;{@code
     *      UI.textField()
     *          .withTextOrientation(UI.HorizontalDirection.LEFT)
     *          .withText(text);
     *  }&lt;/pre&gt;
     *
     * @param direction The text orientation type which should be used.
     * @param text The new text to be set for the wrapped text component type.
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( HorizontalAlignment direction, String text ) {
<span class="fc" id="L4410">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalAlignment.class);</span>
<span class="fc" id="L4411">        return of((JTextField) new TextField()).withTextOrientation(direction).withText(text);</span>
    }

    public static UIForTextField&lt;JTextField&gt; textField( HorizontalAlignment direction, Val&lt;String&gt; text ) {
<span class="nc" id="L4415">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalAlignment.class);</span>
<span class="nc" id="L4416">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4417">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4418">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L4419" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4420">                .withTextOrientation(direction)</span>
<span class="nc" id="L4421">                .withText(text);</span>
    }

    public static UIForTextField&lt;JTextField&gt; textField( HorizontalAlignment direction, Var&lt;String&gt; text ) {
<span class="fc" id="L4425">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalAlignment.class);</span>
<span class="fc" id="L4426">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L4427">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4428">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L4429" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4430">                .withTextOrientation(direction)</span>
<span class="nc" id="L4431">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field.
     *  The property is a {@link Var}, meaning that it can be modified by the user.
     *  &lt;p&gt;
     *  The number property will only receive values if the text field contains a valid number.
     *  &lt;p&gt;
     *  Also note that the provided property is not allowed to contain {@code null} values,
     *  as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number ) {
<span class="nc" id="L4449">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="nc" id="L4450">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="nc" id="L4451">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L4452" title="All 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="nc" id="L4453">                .withNumber(number);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field
     *  and a boolean property which will be set to {@code true} if the text field contains a valid number,
     *  and {@code false} otherwise.
     *  &lt;p&gt;
     *  The number property will only receive values if the text in the text field can be parsed as a number,
     *  in which case the provided {@link Var} will be set to {@code true}, otherwise it will be set to {@code false}.
     *  &lt;p&gt;
     *  Note that the two provided properties are not permitted to
     *  contain {@code null} values, as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param isValid A {@link Var} which will be set to {@code true} if the text field contains a valid number,
     *                and {@code false} otherwise.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code number} is {@code null}.
     * @throws IllegalArgumentException if {@code isValid} is {@code null}.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number, Var&lt;Boolean&gt; isValid ) {
<span class="fc" id="L4477">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="fc" id="L4478">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="fc" id="L4479">        NullUtil.nullArgCheck(isValid, &quot;isValid&quot;, Var.class);</span>
<span class="fc" id="L4480">        NullUtil.nullPropertyCheck(isValid, &quot;isValid&quot;, &quot;Please use false instead of null!&quot;);</span>
<span class="fc" id="L4481">        return of((JTextField) new TextField())</span>
<span class="pc bpc" id="L4482" title="1 of 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="fc" id="L4483">                .withNumber(number, isValid);</span>
    }


    /**
     *  Use this to create a builder for the provided {@link JFormattedTextField} instance.
     *
     * @param component The {@link JFormattedTextField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static UIForFormattedTextField of( JFormattedTextField component ) {
<span class="fc" id="L4495">        NullUtil.nullArgCheck(component, &quot;component&quot;, JFormattedTextField.class);</span>
<span class="fc" id="L4496">        return new UIForFormattedTextField(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( String text ) {
<span class="fc" id="L4507">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4508">        return of(new JFormattedTextField(text));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Val&lt;String&gt; text ) {
<span class="nc" id="L4521">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4522">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4523">        return of(new JFormattedTextField())</span>
<span class="nc bnc" id="L4524" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4525">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the formatted text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the formatted text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Var&lt;String&gt; text ) {
<span class="nc" id="L4537">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L4538">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4539">        return of(new JFormattedTextField())</span>
<span class="nc bnc" id="L4540" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4541">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JFormattedTextField())}.
     *
     * @return A builder instance for a new {@link JFormattedTextField}, which enables fluent method chaining.
     */
<span class="nc" id="L4550">    public static UIForFormattedTextField formattedTextField() { return of(new JFormattedTextField()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JPasswordField} instance.
     *
     * @param component The {@link JPasswordField} instance which should be wrapped by the builder.
     * @param &lt;F&gt; The type of the {@link JPasswordField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;F extends JPasswordField&gt; UIForPasswordField&lt;F&gt; of( F component ) {
<span class="fc" id="L4561">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPasswordField.class);</span>
<span class="fc" id="L4562">        return new UIForPasswordField&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text as the initial password.
     *
     * @param text The initial password which should be displayed on the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( String text ) {
<span class="fc" id="L4573">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4574">        return of((JPasswordField) new PasswordField()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the password field.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Val&lt;String&gt; text ) {
<span class="nc" id="L4587">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4588">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4589">        return of(new JPasswordField())</span>
<span class="nc bnc" id="L4590" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4591">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Var&lt;String&gt; text ) {
<span class="fc" id="L4603">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L4604">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L4605">        return passwordField()</span>
<span class="pc bpc" id="L4606" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L4607">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPasswordField())}.
     *
     * @return A builder instance for a new {@link JPasswordField}, which enables fluent method chaining.
     */
<span class="fc" id="L4616">    public static UIForPasswordField&lt;JPasswordField&gt; passwordField() { return of(new PasswordField()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JProgressBar} instance.
     *
     * @param component The {@link JProgressBar} instance which should be wrapped by the builder.
     * @param &lt;P&gt; The type of the {@link JProgressBar} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JProgressBar&gt; UIForProgressBar&lt;P&gt; of( P component ) {
<span class="fc" id="L4627">        NullUtil.nullArgCheck(component, &quot;component&quot;, JProgressBar.class);</span>
<span class="fc" id="L4628">        return new UIForProgressBar&lt;&gt;(component);</span>
    }

    /**
     *  A factory method for creating a progress bar builder with a default {@link JProgressBar} implementation.
     *
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
<span class="fc" id="L4636">    public static UIForProgressBar&lt;JProgressBar&gt; progressBar() { return of(new ProgressBar()); }</span>

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum and maximum values.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max ) {
<span class="nc" id="L4647">        return progressBar().withMin(min).withMax(max);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum, maximum and current value.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max, int value ) {
<span class="nc" id="L4660">        return progressBar().withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum, maximum and current value property dynamically bound to the progress bar.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value property of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L4673">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;Null is not a valid value for the value property of a progress bar.&quot;);</span>
<span class="nc" id="L4674">        return progressBar().withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum and maximum values.
     *  The alignment is a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Align align, int min, int max ) {
<span class="fc" id="L4689">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L4690">        return progressBar().withOrientation(align).withMin(min).withMax(max);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum, maximum and current value.
     *  The alignment is a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Align align, int min, int max, int value ) {
<span class="nc" id="L4706">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L4707">        return progressBar().withOrientation(align).withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum, maximum and current value property dynamically bound to the progress bar.
     *  The alignment is a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value property of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Align align, int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L4723">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L4724">        NullUtil.nullArgCheck(value, &quot;value&quot;, Val.class);</span>
<span class="nc" id="L4725">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;Null is not a valid value for the value property of a progress bar.&quot;);</span>
<span class="nc" id="L4726">        return progressBar().withOrientation(align).withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment and double based progress property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment is a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Align align, Val&lt;Double&gt; progress ) {
<span class="nc" id="L4741">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L4742">        NullUtil.nullArgCheck(progress, &quot;progress&quot;, Val.class);</span>
<span class="nc" id="L4743">        NullUtil.nullPropertyCheck(progress, &quot;progress&quot;, &quot;Null is not a valid value for the progress property of a progress bar.&quot;);</span>
<span class="nc" id="L4744">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment and double based progress property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment is a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Align align, double progress ) {
<span class="nc" id="L4759">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L4760">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment property and double based progress
     *  property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment property wraps a {@link Align} value, which may be either {@link Align#HORIZONTAL}
     *  or {@link Align#VERTICAL}.
     *  When any of the two properties change in your view model, the progress bar will be updated accordingly.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( Val&lt;Align&gt; align, Val&lt;Double&gt; progress ) {
<span class="nc" id="L4777">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L4778">        NullUtil.nullArgCheck(progress, &quot;progress&quot;, Val.class);</span>
<span class="nc" id="L4779">        NullUtil.nullPropertyCheck(progress, &quot;progress&quot;, &quot;Null is not a valid value for the progress property of a progress bar.&quot;);</span>
<span class="nc" id="L4780">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextArea} instance.
     *
     * @param area The {@link JTextArea} which should be wrapped by the builder.
     * @param &lt;A&gt; The type of the {@link JTextArea} for which the builder should be created.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static &lt;A extends JTextArea&gt; UIForTextArea&lt;A&gt; of( A area ) {
<span class="fc" id="L4791">        NullUtil.nullArgCheck(area, &quot;area&quot;, JTextArea.class);</span>
<span class="fc" id="L4792">        return new UIForTextArea&lt;&gt;(area);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text as the initial text.
     *
     * @param text The initial text which should be displayed on the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( String text ) {
<span class="fc" id="L4803">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4804">        return of((JTextArea) new TextArea()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text area.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Val&lt;String&gt; text ) {
<span class="nc" id="L4817">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4818">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4819">        return of((JTextArea) new TextArea())</span>
<span class="nc bnc" id="L4820" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4821">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Var&lt;String&gt; text ) {
<span class="fc" id="L4833">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L4834">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L4835">        return of((JTextArea) new TextArea())</span>
<span class="pc bpc" id="L4836" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L4837">                .withText(text);</span>
    }

    /**
     * @param list The {@link JList} which should be wrapped by the builder.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; of( JList&lt;E&gt; list ) {
<span class="fc" id="L4846">        NullUtil.nullArgCheck(list, &quot;list&quot;, JList.class);</span>
<span class="fc" id="L4847">        return new UIForList&lt;&gt;(list);</span>
    }

    /**
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList}.
     */
<span class="nc" id="L4854">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list() { return of(new List&lt;&gt;()); }</span>

    /**
     * @param model The model which should be used for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( ListModel&lt;E&gt; model ) {
<span class="nc" id="L4862">        NullUtil.nullArgCheck(model, &quot;model&quot;, ListModel.class);</span>
<span class="nc" id="L4863">        JList&lt;E&gt; list = new List&lt;&gt;();</span>
<span class="nc" id="L4864">        list.setModel(model);</span>
<span class="nc" id="L4865">        return of(list);</span>
    }

    /**
     *  Creates a new {@link JList} instance builder
     *  with the provided array as data model.
     *  This is functionally equivalent to {@link #listOf(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( E... elements ) {
<span class="fc" id="L4879">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Object[].class);</span>
<span class="fc" id="L4880">        return of(new List&lt;E&gt;()).withEntries( elements );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with the provided
     *  observable property list (a {@link Vals} object) as data model.
     *  When the property list changes, the {@link JList} will be updated accordingly.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided {@link Vals} as data model.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Vals&lt;E&gt; elements ) {
<span class="fc" id="L4893">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="fc" id="L4894">        return of(new List&lt;E&gt;()).withEntries( elements );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with 2 observable
     *  collections as data model, a {@link Var} property for the selection and a {@link Vals}
     *  property list for the elements.
     *  When any of the properties change, the {@link JList} will be updated accordingly,
     *  and conversely, when the {@link JList} selection changes, the properties will be updated accordingly.
     *
     * @param selection The {@link Var} property which should be bound to the selection of the {@link JList}.
     * @param elements The {@link Vals} property which should be bound to the displayed elements of the {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided arguments as data model.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Var&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="nc" id="L4910">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L4911">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="nc" id="L4912">        return list( elements ).withSelection( selection );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with 2 observable
     *  collections as data model, a {@link Val} property for the selection and a {@link Vals}
     *  property list for the elements.
     *  When any of the properties change, the {@link JList} will be updated accordingly,
     *  however, due to the usage of a read only {@link Val} property for the selection,
     *  the {@link JList} selection will not be updated when the property changes.
     *  If you want a bidirectional binding, use {@link #list(Var, Vals)} instead.
     *
     * @param selection The {@link Val} property which should be bound to the selection of the {@link JList}.
     * @param elements The {@link Vals} property which should be bound to the displayed elements of the {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided {@link Val} and {@link Vals} as data models.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Val&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="nc" id="L4930">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Val.class);</span>
<span class="nc" id="L4931">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="nc" id="L4932">        return of(new List&lt;E&gt;()).withEntries( elements ).withSelection( selection );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided array
     *  as data model.
     *  This is functionally equivalent to {@link #list(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
<span class="fc" id="L4945">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( E... elements ) { return list( elements ); }</span>

    /**
     *  Creates a new {@link JList} instance with the provided {@link List}
     *  as data model.
     *  This is functionally equivalent to {@link #listOf(java.util.List)}.
     *
     * @param entries The list of entries used for populating a new {@link JList} component.
     * @param &lt;E&gt; The type parameter defining the concrete type of the list entries.
     * @return A builder instance for a new {@link JList} with the provided {@link List} as data model.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( java.util.List&lt;E&gt; entries ) {
<span class="fc" id="L4957">        return of(new List&lt;E&gt;()).withEntries( entries );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided {@link List}
     *  as data model.
     *  This is functionally equivalent to {@link #list(java.util.List)}.
     *
     * @param entries The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided {@link List} as data model.
     */
<span class="fc" id="L4969">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( java.util.List&lt;E&gt; entries ) { return list( entries ); }</span>

    /**
     * @param table The table which should be wrapped by the builder.
     * @param &lt;T&gt; The {@link JTable} type.
     * @return A builder instance for a new {@link JTable}.
     */
    public static &lt;T extends JTable&gt; UIForTable&lt;T&gt; of( T table ) {
<span class="fc" id="L4977">        NullUtil.nullArgCheck(table, &quot;table&quot;, JTable.class);</span>
<span class="fc" id="L4978">        return new UIForTable&lt;&gt;(table);</span>
    }

    /**
     * @return A fluent builder instance for a new {@link JTable}.
     */
<span class="fc" id="L4984">    public static UIForTable&lt;JTable&gt; table() { return of(new Table()); }</span>

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a list of lists of entries.  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link java.util.List} which gets modified), the table model will not be updated automatically!
     *      Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( ListData dataFormat, TableListDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L5001">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, ListData.class);</span>
<span class="fc" id="L5002">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableListDataSource.class);</span>
<span class="fc" id="L5003">        return of((JTable) new Table()).withModel(dataFormat, dataSource);</span>
    }

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a map of column names to lists of table entries (basically a column major matrix).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *  &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *  is a {@link Map} which gets modified), the table model will not be updated automatically!
     *  Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( MapData dataFormat, TableMapDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L5021">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, ListData.class);</span>
<span class="fc" id="L5022">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableMapDataSource.class);</span>
<span class="fc" id="L5023">        return of((JTable) new Table()).withModel(dataFormat, dataSource);</span>
    }

    /**
     *  Creates a new {@link JTable} instance builder with the provided table model
     *  buildable used for creating the table model in a declarative fashion. &lt;br&gt;
     *  It is expected to be used like so:
     *  &lt;pre&gt;{@code
     *  UI.table(
     *    UI.tableModel()
     *    .colCount( () -&gt; data[0].size() )
     *    .rowCount( () -&gt; data.size() )
     *    .getsEntryAt((col, row) -&gt; data[col][row] )
     * )
     * }&lt;/pre&gt;
     * The factory method {@link #tableModel()} is used to create a builder for the table model
     * which can be passed to this method, which will call the {@link BasicTableModel.Builder#build()}
     * method on the provided builder to create the table model for the table.
     * &lt;br&gt;
     * The purpose of this pattern is to remove the necessity of implementing the {@link javax.swing.table.TableModel}
     * interface manually, which is a rather tedious task.
     * Instead, you can use ths fluent API provided by the {@link BasicTableModel.Builder} to create
     * a general purpose table model for your table.
     *
     * @param tableModelBuildable The table model builder which can be created using the {@link #tableModel()} factory method.
     * @return A builder instance for a new {@link JTable}.
     */
    public static UIForTable&lt;JTable&gt; table( Buildable&lt;BasicTableModel&gt; tableModelBuildable ) {
<span class="fc" id="L5051">        return of((JTable) new Table()).withModel(tableModelBuildable);</span>
    }

    /**
     * @param header The table header which should be wrapped by the builder.
     * @return A builder instance for a new {@link JTableHeader}.
     * @param &lt;H&gt; The type of the {@link JTableHeader} for which the builder should be created.
     */
    public static &lt;H extends TableHeader&gt; UIForTableHeader&lt;H&gt; of( H header ) {
<span class="nc" id="L5060">        NullUtil.nullArgCheck(header, &quot;header&quot;, TableHeader.class);</span>
<span class="nc" id="L5061">        return new UIForTableHeader&lt;&gt;(header);</span>
    }

    /**
     * @return A builder instance for a new {@link JTableHeader}.
     */
<span class="nc" id="L5067">    public static UIForTableHeader&lt;TableHeader&gt; tableHeader() { return of(new TableHeader()); }</span>

    /**
     * @return A functional API for building a {@link javax.swing.table.TableModel}.
     */
    public static BasicTableModel.Builder&lt;Object&gt; tableModel() {
<span class="fc" id="L5073">        return new BasicTableModel.Builder&lt;&gt;(Object.class);</span>
    }

    /**
     * @param entryType The type of the table entries.
     * @param &lt;E&gt; The type of the table entries.
     * @return A functional API for building a {@link javax.swing.table.TableModel}.
     */
    public static &lt;E&gt; BasicTableModel.Builder&lt;E&gt; tableModel(Class&lt;E&gt; entryType) {
<span class="nc" id="L5082">        return new BasicTableModel.Builder&lt;&gt;(entryType);</span>
    }

    /**
     *  Exposes a fluent builder API for creating a table renderer.&lt;br&gt;
     *  Here an example of how this would typically be used:
     * &lt;pre&gt;{@code
     *     UI.table(myModel)
     *     .withRendererForColumn(0,
     *         UI.renderTable()
     *         .when(String.class)
     *         .asText( cell -&gt; &quot;[&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;]&quot; ) )
     *     )
     *     .withRendererForColumn(1,
     *         UI.renderTable()
     *         .when(Float.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;f)&quot; ) )
     *         .when(Double.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;d)&quot; ) )
     *     );
     * }&lt;/pre&gt;
     * The above example would render the first column of the table as a string surrounded by square brackets,
     * and the second column as a float or double value surrounded by parentheses.
     * Note that the API allows you to specify how specific types of table entry values
     * should be rendered. This is done by calling the {@link Render.Builder#when(Class)} method
     * bedore calling the {@link Render.As#asText(Function)} method.
     *
     * @return A builder instance for a new {@link JTable}.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTable() {
<span class="fc" id="L5112">        return Render.forTable(Object.class, null)</span>
<span class="fc" id="L5113">                     .when(Object.class)</span>
<span class="fc" id="L5114">                     .asText( cell -&gt; cell.valueAsString().orElse(&quot;&quot;) );</span>
    }

    /**
     *  Use this to build a list cell renderer for various item types without
     *  a meaningful common super-type (see {@link #renderList(Class)}).
     *  You would typically want to use this method to render generic types where the only
     *  common type is {@link Object}, yet you want to render the item
     *  in a specific way depending on their actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(new Object[]{&quot;:-)&quot;, 42L, '§'})
     *  .withRenderer(
     *      UI.renderList()
     *      .when(String.class).asText( cell -&gt; &quot;String: &quot;+cell.getValue() )
     *      .when(Character.class).asText( cell -&gt; &quot;Char: &quot;+cell.getValue() )
     *      .when(Number.class).asText( cell -&gt; &quot;Number: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item types should be rendered.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderList() {
<span class="nc" id="L5138">        return Render.forList(Object.class, null).when(Object.class).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a list cell renderer for a specific item type and its subtype.
     *  You would typically want to use this method to render generic types like {@link Object}
     *  where you want to render the item in a specific way depending on its actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(new Number[]{1f, 42L, 4.20d})
     *  .withRenderer(
     *      UI.renderList(Number.class)
     *      .when(Integer.class).asText( cell -&gt; &quot;Integer: &quot;+cell.getValue() )
     *      .when(Long.class).asText( cell -&gt; &quot;Long: &quot;+cell.getValue() )
     *      .when(Float.class).asText( cell -&gt; &quot;Float: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param commonType The common type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item types should be rendered.
     * @param &lt;T&gt; The common super-type type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.Builder&lt;JList&lt;T&gt;, T&gt; renderList( Class&lt;T&gt; commonType ) {
<span class="pc" id="L5162">        return Render.forList(commonType, null).when(commonType).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a list cell renderer for a specific item type.
     *  What you would typically want to do is customize the text that should be displayed
     *  for a specific item type. &lt;br&gt;
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
     *  .withRenderer(
     *      UI.renderListItem(String.class)
     *      .asText(cell -&gt; cell.getValue().toLowerCase())
     *  );
     *  }&lt;/pre&gt;
     *
     * @param itemType The type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item type should be rendered.
     * @param &lt;T&gt; The type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.As&lt;JList&lt;T&gt;, T, T&gt; renderListItem( Class&lt;T&gt; itemType ) {
<span class="fc" id="L5184">        return Render.forList(itemType, null).when(itemType);</span>
    }

    /**
     *  Use this to create a generic combo box renderer for various item types without
     *  a meaningful common super-type (see {@link #renderCombo(Class)}).
     *  You would typically want to use this method to render generic types where the only
     *  common type is {@link Object}, yet you want to render the item
     *  in a specific way depending on their actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(new Object[]{&quot;:-)&quot;, 42L, '§'})
     *  .withRenderer(
     *      UI.renderCombo()
     *      .when(String.class).asText( cell -&gt; &quot;String: &quot;+cell.getValue() )
     *      .when(Character.class).asText( cell -&gt; &quot;Char: &quot;+cell.getValue() )
     *      .when(Number.class).asText( cell -&gt; &quot;Number: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @return A render builder exposing an API that allows you to configure how he passed item types should be rendered.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderCombo() {
<span class="nc" id="L5207">        return Render.forCombo(Object.class, null).when(Object.class).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to create a combo box renderer for a specific item type and its subtype.
     *  You would typically want to use this method to render generic types like {@link Object}
     *  where you want to render the item in a specific way depending on its actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(new Number[]{1f, 42L, 4.20d})
     *  .withRenderer(
     *      UI.renderCombo(Number.class)
     *      .when(Integer.class).asText( cell -&gt; &quot;Integer: &quot;+cell.getValue() )
     *      .when(Long.class).asText( cell -&gt; &quot;Long: &quot;+cell.getValue() )
     *      .when(Float.class).asText( cell -&gt; &quot;Float: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param commonType The common type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to configure how he passed item types should be rendered.
     * @param &lt;T&gt; The common super-type type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.Builder&lt;JComboBox&lt;T&gt;, T&gt; renderCombo( Class&lt;T&gt; commonType ) {
<span class="nc" id="L5230">        return Render.forCombo(commonType, null).when(commonType).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a combo box cell renderer for a specific item type.
     *  What you would typically want to do is customize the text that should be displayed
     *  for a specific item type. &lt;br&gt;
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(Size.LARGE, Size.MEDIUM, Size.SMALL)
     *  .withRenderer(
     *      UI.renderComboItem(Size.class)
     *      .asText(cell -&gt; cell.getValue().name().toLowerCase())
     *  );
     *  }&lt;/pre&gt;
     *
     * @param itemType The type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item type should be rendered.
     * @param &lt;T&gt; The type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.As&lt;JComboBox&lt;T&gt;, T, T&gt; renderComboItem( Class&lt;T&gt; itemType ) {
<span class="fc" id="L5252">        return Render.forCombo(itemType, null).when(itemType);</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L5260">        return Render.forTable(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L5268">        return Render.forList(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L5276">        return Render.forCombo(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Border border ) {
<span class="nc" id="L5284">        return renderTableWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Val&lt;Border&gt; border ) {
<span class="nc" id="L5292">        return renderTableWithBorder(border::orElseThrow);</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Border border ) {
<span class="nc" id="L5300">        return renderListWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Var&lt;Border&gt; border ) {
<span class="nc" id="L5308">        return renderListWithBorder(border::orElseThrow);</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Border border ) {
<span class="nc" id="L5316">        return renderComboWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Val&lt;Border&gt; border ) {
<span class="nc" id="L5324">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null is not a valid border.&quot;);</span>
<span class="nc" id="L5325">        return renderComboWithBorder(border::orElseThrow);</span>
    }

    /**
     *  This returns an instance of a SwingTree builder for a {@link JFrame} type.
     * @param frame The new frame instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     * @param &lt;F&gt; The concrete type of this new frame.
     */
    public static &lt;F extends JFrame&gt; UIForJFrame&lt;F&gt; of( F frame ) {
<span class="fc" id="L5335">        return new UIForJFrame&lt;&gt;(frame);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JFrame()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame() {
<span class="fc" id="L5345">        return new UIForJFrame&lt;&gt;(new JFrame());</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame} with the supplied title. &lt;br&gt;
     * @param title The title for the new frame.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame( String title ) {
<span class="fc" id="L5354">        return new UIForJFrame&lt;&gt;(new JFrame()).withTitle(title);</span>
    }

    /**
     *  This returns an instance of a SwingTree builder for a {@link JDialog} type.
     * @param dialog The new dialog instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     * @param &lt;D&gt; The concrete type of this new dialog.
     */
    public static &lt;D extends JDialog&gt; UIForJDialog&lt;D&gt; of( D dialog ) {
<span class="fc" id="L5364">        return new UIForJDialog&lt;&gt;(dialog);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JDialog()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog() {
<span class="fc" id="L5374">        return new UIForJDialog&lt;&gt;(new JDialog());</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner ) {
<span class="nc" id="L5383">        return new UIForJDialog&lt;&gt;(new JDialog(owner));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied title. &lt;br&gt;
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( String title ) {
<span class="nc" id="L5392">        return new UIForJDialog&lt;&gt;(new JDialog()).withTitle(title);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner and title. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner, String title ) {
<span class="nc" id="L5402">        return new UIForJDialog&lt;&gt;(new JDialog(owner)).withTitle(title);</span>
    }

    /**
     * A convenience method for
     * &lt;pre&gt;{@code
     *      if ( !UI.thisIsUIThread() )
     *          SwingUtilities.invokeLater(runnable);
     *      else
     *          runnable.run();
     * }&lt;/pre&gt;,
     * which causes &lt;i&gt;runnable.run()&lt;/i&gt; to be executed asynchronously on the
     * AWT event dispatching thread if this current thread is not already
     * the AWT thread.
     * The 'invokeLater' execution will happen after all pending AWT events have been processed.
     * This method should be used when an application thread needs to update the GUI.
     *
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void run( Runnable runnable ) {
<span class="fc" id="L5423">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="fc bfc" id="L5424" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L5425">            SwingUtilities.invokeLater(runnable);</span>
        else
<span class="fc" id="L5427">            runnable.run();</span>
<span class="fc" id="L5428">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeLater(Runnable)},
     * which causes a provided {@link Runnable} to be executed asynchronously on the
     * AWT event dispatching thread.  This will happen after all
     * pending AWT events have been processed.  This method should
     * be used when an application thread needs to update the GUI.
     * In the following example the &lt;code&gt;runLater&lt;/code&gt; call queues
     * the &lt;code&gt;Runnable&lt;/code&gt; lambda
     * on the event dispatching thread and
     * then prints a message.
     * &lt;pre&gt;{@code
     *  UI.run( () -&gt; System.out.println(&quot;Hello World on &quot; + Thread.currentThread()) );
     *  System.out.println(&quot;This might well be displayed before the other message.&quot;);
     * }&lt;/pre&gt;
     * If runLater is called from the event dispatching thread --
     * for example, from a JButton's ActionListener -- the &lt;code&gt;Runnable&lt;/code&gt; will
     * still be deferred until all pending events have been processed.
     * Note that if the &lt;code&gt;Runnable&lt;/code&gt; throws an uncaught exception
     * the event dispatching thread will unwind (not the current thread).
     *
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void runLater( Runnable runnable ) {
<span class="fc" id="L5454">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="fc" id="L5455">        SwingUtilities.invokeLater(runnable);</span>
<span class="fc" id="L5456">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeLater(Runnable)},
     * which causes {@link Runnable} to be executed asynchronously on the
     * AWT event dispatching thread after the specified delay.
     * This method should be used when an application thread needs to update the GUI
     * after a particular delay.
     * In the following example the &lt;code&gt;invokeLater&lt;/code&gt; call queues
     * the &lt;code&gt;Runnable&lt;/code&gt; lambda containing a print statement
     * on the event dispatching thread and
     * then prints a message.
     * &lt;pre&gt;{@code
     *  UI.runLater( 1000, () -&gt; System.out.println(&quot;Hello World on &quot; + Thread.currentThread()) );
     *  System.out.println(&quot;This might well be displayed before the other message.&quot;);
     * }&lt;/pre&gt;
     * If runLater is called from the event dispatching thread --
     * for example, from a JButton's ActionListener -- the &lt;code&gt;Runnable&lt;/code&gt; will
     * still be deferred until the specified delay has passed.
     * Note that if the &lt;code&gt;Runnable&lt;/code&gt; throws an uncaught exception
     * the event dispatching thread will unwind (not the current thread).
     *
     * @param delay The delay in milliseconds.
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void runLater( int delay, Runnable runnable ) {
<span class="nc" id="L5483">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="nc" id="L5484">        Timer timer = new Timer( delay, e -&gt; { runnable.run(); } );</span>
<span class="nc" id="L5485">        timer.setRepeats(false); // Execute only once</span>
<span class="nc" id="L5486">        timer.setInitialDelay(delay);</span>
<span class="nc" id="L5487">        timer.start();</span>
<span class="nc" id="L5488">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeLater(Runnable)},
     * which causes {@link Runnable} to be executed asynchronously on the
     * AWT event dispatching thread after the specified delay
     * has passed in the given time unit.
     * This method should be used when an application thread needs to update the GUI
     * after a particular delay.
     * In the following example the &lt;code&gt;invokeLater&lt;/code&gt; call queues
     * the &lt;code&gt;Runnable&lt;/code&gt; lambda containing a print statement
     * on the event dispatching thread and
     * then prints a message.
     * &lt;pre&gt;{@code
     *  UI.runLater( 1000, TimeUnit.MILLISECONDS, () -&gt; System.out.println(&quot;Hello World on &quot; + Thread.currentThread()) );
     *  System.out.println(&quot;This might well be displayed before the other message.&quot;);
     * }&lt;/pre&gt;
     * If runLater is called from the event dispatching thread --
     * for example, from a JButton's ActionListener -- the &lt;code&gt;Runnable&lt;/code&gt; will
     * still be deferred until the specified delay has passed.
     * Note that if the &lt;code&gt;Runnable&lt;/code&gt; throws an uncaught exception
     * the event dispatching thread will unwind (not the current thread).
     *
     * @param delay The delay in the given time unit.
     * @param unit The time unit of the delay parameter.
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void runLater( double delay, TimeUnit unit,  Runnable runnable ) {
<span class="nc" id="L5517">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="nc" id="L5518">        NullUtil.nullArgCheck(unit, &quot;unit&quot;, TimeUnit.class);</span>
<span class="nc" id="L5519">        long millis = (long) (delay * unit.toMillis(1));</span>
<span class="nc" id="L5520">        long remainderMillis = (long) (delay * unit.toMillis(1) - millis);</span>
<span class="nc" id="L5521">        long convertedDelay = TimeUnit.MILLISECONDS.convert(millis + remainderMillis, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L5522">        runLater( (int) convertedDelay, runnable );</span>
<span class="nc" id="L5523">    }</span>

    /**
     * Returns true if the current thread is an AWT event dispatching thread.
     * &lt;p&gt;
     * This method is just a cover for
     * &lt;code&gt;javax.swing.SwingUtilities.isEventDispatchThread()&lt;/code&gt;
     * and indirectly also for
     * &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt;.
     *
     * @return true if the current thread is an AWT event dispatching thread
     */
<span class="fc" id="L5535">    public static boolean thisIsUIThread() { return SwingUtilities.isEventDispatchThread(); }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeAndWait(Runnable)},
     * causes &lt;code&gt;doRun.run()&lt;/code&gt; to be executed synchronously on the
     * AWT event dispatching thread.  This call blocks until
     * all pending AWT events have been processed and (then)
     * &lt;code&gt;doRun.run()&lt;/code&gt; returns. This method should
     * be used when an application thread needs to update the GUI.
     * It shouldn't be called from the event dispatching thread.
     * Here's an example that creates a new application thread
     * that uses &lt;code&gt;invokeAndWait&lt;/code&gt; to print a string from the event
     * dispatching thread and then, when that's finished, print
     * a string from the application thread.
     * &lt;pre&gt;{@code
     *     var appThread = new Thread(() -&gt; {
     *             try {
     *                 UI.runNow(() -&gt; {
     *                    System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
     *                 });
     *             }
     *             catch (Exception e) {
     *                 e.printStackTrace();
     *             }
     *             System.out.println(&quot;Finished on &quot; + Thread.currentThread());
     *         });
     *
     *     appThread.start();
     * }&lt;/pre&gt;
     * Note that contrary to the {@link SwingUtilities#invokeAndWait(Runnable)} method,
     * this method does not throw an exception if it is called from the
     * event dispatching thread. Instead, it just executes the runnable
     * immediately.
     *
     * @param runnable the instance of {@code Runnable}
     * @see #run
     */
    public static void runNow( Runnable runnable ) {
<span class="fc" id="L5573">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
        try {
<span class="pc bpc" id="L5575" title="1 of 2 branches missed.">            if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L5576">                SwingUtilities.invokeAndWait(runnable);</span>
            else
<span class="nc" id="L5578">                runnable.run();</span>
<span class="nc" id="L5579">        } catch ( Exception e ) {</span>
<span class="nc" id="L5580">            throw new RuntimeException(e);</span>
<span class="fc" id="L5581">        }</span>
<span class="fc" id="L5582">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeAndWait(Runnable)},
     * where the runnable is a lambda expression that has a return value.
     * This causes the {@link Supplier} to be executed synchronously on the
     * AWT event dispatching thread.  This call blocks until
     * all pending AWT events have been processed and (then)
     * the {@link Supplier} returns. This method should
     * be used when an application thread needs to update the GUI a
     * get a return value from the GUI.
     * It shouldn't be called from the event dispatching thread.
     * Here's an example that creates a new application thread
     * that uses &lt;code&gt;runAndGet(..)&lt;/code&gt; to access the state of a
     * {@link javax.swing.JCheckBox} from the event dispatching thread
     * and then, when that's finished, print the state from the application thread.
     * &lt;pre&gt;{@code
     *     JCheckBox checkBox = new JCheckBox(&quot;Hello World&quot;);
     *     var appThread = new Thread(()-&gt;{
     *            try {
     *                boolean state = UI.runAndGet(() -&gt; checkBox.isSelected());
     *                System.out.println(&quot;CheckBox state is &quot; + state);
     *            }
     *            catch (Exception e) {
     *                e.printStackTrace();
     *            }
     *            System.out.println(&quot;Finished on &quot; + Thread.currentThread());
     *        });
     *     appThread.start();
     * }&lt;/pre&gt;
     * @param supplier The supplier which should be executed on the UI thread.
     * @param &lt;T&gt; The return type of the result value produced by the supplier.
     * @return The result provided by the supplier.
     */
    public static &lt;T&gt; T runAndGet( Supplier&lt;T&gt; supplier ) {
<span class="fc" id="L5617">        NullUtil.nullArgCheck(supplier, &quot;callable&quot;, Supplier.class);</span>
<span class="fc" id="L5618">        T[] ref = (T[]) new Object[1];</span>
<span class="fc" id="L5619">        runNow( () -&gt; ref[0] = supplier.get() );</span>
<span class="fc" id="L5620">        return ref[0];</span>
    }

    /**
     *  Use this to synchronize with the UI thread from a non-UI thread.
     *  After calling this method, the current thread will be blocked
     *  until the UI thread has finished executing all of its pending events.
     *  This method should only be called from the application thread
     *  and not from the UI thread.
     */
    public static void sync() {
<span class="fc" id="L5631">        runNow( () -&gt; {/*</span>
            This is a no-op, but it forces the event dispatching thread to
            process all pending events before returning.
            So when we reach this point, we know that all pending events
            have been processed.
<span class="fc" id="L5636">        */});</span>
<span class="fc" id="L5637">    }</span>

    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( 100, TimeUnit.MILLISECONDS )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setValue( it.progress() );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *  @param unit The time unit of the duration.
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor(long duration, TimeUnit unit ) {
<span class="fc" id="L5659">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="fc" id="L5660">        return Animator.animateFor( LifeTime.of(duration, unit) );</span>
    }

    /**
     *  Exposes a builder API for creating and scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( 0.1, TimeUnit.MINUTES )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *  @param unit The time unit of the duration.
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( double duration, TimeUnit unit ) {
<span class="fc" id="L5683">        return Animator.animateFor( LifeTime.of(duration, unit) );</span>
    }

    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( LifeTime.of(0.1, TimeUnit.MINUTES) )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( LifeTime duration ) {
<span class="nc" id="L5706">        return Animator.animateFor( duration );</span>
    }

    /**
     * Exposes an API for scheduling periodic animation updates
     * for a specific component whose {@link Component#repaint()}
     * method should be called after every animation update.
     * This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     * A typical usage would be:
     * &lt;pre&gt;{@code
     *    UI.animateFor( UI.lifeTime(0.1, TimeUnit.MINUTES), someComponent )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *       });
     *  }&lt;/pre&gt;
     *
     * @param duration  The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     * @param component The component which should be repainted after every animation update.
     * @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( LifeTime duration, Component component ) {
<span class="nc" id="L5730">        return Animator.animateFor( duration, component );</span>
    }

    /**
     *  A factory method for creating a {@link LifeTime} instance
     *  with the given duration and time unit.
     *  This is a convenience method for {@link LifeTime#of(long, TimeUnit)}.
     *  The {@link LifeTime} instance is an immutable value type
     *  which is used for scheduling animations, usually through
     *  {@link Animator#animateFor(LifeTime)} or the convenience methods
     *  {@link UI#animateFor(long, TimeUnit)}, {@link UI#animateFor(double, TimeUnit)},
     *  {@link UI#animateFor(LifeTime)} or {@link UI#animateFor(LifeTime, Component)}.
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *      UI.animateFor( UI.lifeTime(0.1, TimeUnit.MINUTES) )
     *      .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *      .go( it -&gt; {
     *          // do something
     *      });
     *  }&lt;/pre&gt;
     *
     * @param duration The duration of the animation.
     * @param unit The time unit of the duration.
     * @return A {@link LifeTime} instance.
     */
<span class="nc" id="L5755">    public static LifeTime lifeTime( long duration, TimeUnit unit ) { return LifeTime.of(duration, unit); }</span>

    /**
     *  Shows a conformation dialog with the given message.
     * @param message the message to show
     * @return {@code Answer.YES} if the user clicked &quot;Yes&quot;, {@code Answer.NO} if the user clicked &quot;No&quot;, {@code Answer.CANCEL} otherwise.
     */
<span class="nc" id="L5762">    public static ConfirmAnswer confirm( String message ) { return confirm(&quot;Confirm&quot;, message); }</span>

    /**
     * Shows a conformation dialog with the given message.
     *
     * @param title   the title of the dialog
     * @param message the message to show
     * @return {@code Answer.YES} if the user clicked &quot;Yes&quot;, {@code Answer.NO} if the user clicked &quot;No&quot;, {@code Answer.CANCEL} otherwise.
     */
    public static ConfirmAnswer confirm( String title, String message ) {
<span class="nc" id="L5772">        return</span>
<span class="nc" id="L5773">            ConfirmDialogBuilder.question()</span>
<span class="nc" id="L5774">            .title(title)</span>
<span class="nc" id="L5775">            .message(message)</span>
<span class="nc" id="L5776">            .show();</span>
    }

    /**
     * @return A builder for creating a confirmation dialog designed to ask a question.
     */
<span class="nc" id="L5782">    public static ConfirmDialogBuilder confirm() { return ConfirmDialogBuilder.question(); }</span>

    /**
     * @return A builder for creating a confirmation dialog designed to show an error
     *         and ask the user to confirm it through yes, no or cancel options.
     */
<span class="nc" id="L5788">    public static ConfirmDialogBuilder confirmError() { return ConfirmDialogBuilder.error(); }</span>
    
    /**
     * @return A builder for creating a confirmation dialog designed to show an info
     *         and ask the user to confirm it through yes, no or cancel options.
     */
<span class="nc" id="L5794">    public static ConfirmDialogBuilder confirmInfo() { return ConfirmDialogBuilder.info(); }</span>
    
    /**
     * @return A builder for creating a confirmation dialog designed to show a warning
     *         and ask the user to confirm it through yes, no or cancel options.
     */
<span class="nc" id="L5800">    public static ConfirmDialogBuilder confirmWarning() { return ConfirmDialogBuilder.warning(); }</span>

    /**
     * @return A builder for creating a confirmation dialog designed to show a plain message (no icon)
     *         and ask the user to confirm it through yes, no or cancel options.
     */
<span class="nc" id="L5806">    public static ConfirmDialogBuilder confirmPlain() { return ConfirmDialogBuilder.plain(); }</span>

    /**
     *  Shows an error dialog with the given message.
     * @param message The error message to show in the dialog.
     */
<span class="nc" id="L5812">    public static void error( String message ) { error(&quot;Error&quot;, message); }</span>

    /**
     * Shows an error dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The error message to show in the dialog.
     */
    public static void error( String title, String message ) {
<span class="nc" id="L5821">        error()</span>
<span class="nc" id="L5822">            .title(title)</span>
<span class="nc" id="L5823">            .message(message)</span>
<span class="nc" id="L5824">            .show();</span>
<span class="nc" id="L5825">    }</span>

    /**
     * @return A builder for creating an error dialog.
     */
<span class="nc" id="L5830">    public static MessageDialogBuilder error() { return MessageDialogBuilder.error(); }</span>

    /**
     *  Shows an info dialog with the given message.
     * @param message The message to show in the dialog.
     */
<span class="nc" id="L5836">    public static void info( String message ) { info(&quot;Info&quot;, message); }</span>

    /**
     * Shows an info dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The message to show in the dialog.
     */
    public static void info( String title, String message ) {
<span class="nc" id="L5845">        info()</span>
<span class="nc" id="L5846">            .title(title)</span>
<span class="nc" id="L5847">            .message(message)</span>
<span class="nc" id="L5848">            .show();</span>
<span class="nc" id="L5849">    }</span>

    /**
     * @return A builder for creating an info dialog.
     */
<span class="nc" id="L5854">    public static MessageDialogBuilder info() { return MessageDialogBuilder.info(); }</span>

    /**
     *  Shows a warning dialog with the given message.
     * @param message The warning message to show in the dialog.
     */
<span class="nc" id="L5860">     public static void warn( String message ) { warn(&quot;Warning&quot;, message); }</span>

    /**
     * Shows a warning dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The warning message to show in the dialog.
     */
    public static void warn( String title, String message ) {
<span class="nc" id="L5869">        warn()</span>
<span class="nc" id="L5870">            .title(title)</span>
<span class="nc" id="L5871">            .message(message)</span>
<span class="nc" id="L5872">            .show();</span>
<span class="nc" id="L5873">    }</span>

    /**
     * @return A builder for creating a warning dialog.
     */
<span class="nc" id="L5878">    public static MessageDialogBuilder warn() { return MessageDialogBuilder.warning(); }</span>

    /**
     *  Shows a dialog where the user can select a value from a list of options
     *  based on the enum type implicitly defined by the given enum based property.
     *  The selected value will be stored in said property after the user has
     *  selected a value.
     *
     * @param message The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The enum type.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String message, Var&lt;E&gt; selected ) {
<span class="nc" id="L5891">        select(&quot;Select&quot;, message, selected );</span>
<span class="nc" id="L5892">    }</span>

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The enum type.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String title, String message, Var&lt;E&gt; selected ) {
<span class="nc" id="L5906">        select(title, message, null, selected );</span>
<span class="nc" id="L5907">    }</span>

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param icon     The icon to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The type parameter defining the concrete enum type.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String title, String message, Icon icon, Var&lt;E&gt; selected ) {
<span class="nc" id="L5922">        Objects.requireNonNull( message  );</span>
<span class="nc" id="L5923">        Objects.requireNonNull( title    );</span>
<span class="nc" id="L5924">        Objects.requireNonNull( selected );</span>
<span class="nc" id="L5925">        E[] options = selected.type().getEnumConstants();</span>
<span class="nc" id="L5926">        String[] asStr = new String[options.length];</span>
<span class="nc bnc" id="L5927" title="All 2 branches missed.">        for ( int i = 0; i &lt; options.length; i++ )</span>
<span class="nc" id="L5928">            asStr[i] = options[i].toString();</span>

<span class="nc" id="L5930">        int selectedIdx = JOptionPane.showOptionDialog( null, message, title, JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, icon, asStr, asStr[0] );</span>
<span class="nc" id="L5931">        selected.set(From.VIEW,  options[selectedIdx] );</span>
<span class="nc" id="L5932">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen.
     *
     * @param component The component to show in the window.
     */
    public static void show( Component component ) {
<span class="nc" id="L5941">        Objects.requireNonNull( component );</span>
<span class="nc" id="L5942">        new UI.TestWindow( &quot;&quot;, f -&gt; component );</span>
<span class="nc" id="L5943">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen.
     *
     * @param title The title of the window.
     * @param component The component to show in the window.
     */
    public static void show( String title, Component component ) {
<span class="nc" id="L5953">        Objects.requireNonNull( component );</span>
<span class="nc" id="L5954">        new UI.TestWindow( title, f -&gt; component );</span>
<span class="nc" id="L5955">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen.
     *
     * @param ui The SwingTree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L5965">        new UI.TestWindow( &quot;&quot;, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L5966">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen.
     *
     * @param title The title of the window.
     * @param ui The SwingTree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( String title, UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L5977">        new UI.TestWindow( title, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L5978">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L5989">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L5990">        new UI.TestWindow( &quot;&quot;, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L5991">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param title The title of the window.
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( String title, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L6003">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L6004">        new UI.TestWindow( title, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L6005">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing( EventProcessor eventProcessor, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L6015">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L6016">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L6017">        show(frame -&gt; use(eventProcessor, () -&gt; uiSupplier.apply(frame)));</span>
<span class="nc" id="L6018">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in a titled {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param title The title of the window.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing( EventProcessor eventProcessor, String title, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L6029">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L6030">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L6031">        show(title, frame -&gt; use(eventProcessor, () -&gt; uiSupplier.apply(frame)));</span>
<span class="nc" id="L6032">    }</span>

    /**
     *  This enum is used to specify how an image or icon (usually a {@link SvgIcon})
     *  should be scaled to fit the
     *  dimensions of the component that it is being rendered into, like for example
     *  using the {@link SvgIcon#paintIcon(Component, Graphics, int, int, int, int)} method.
     */
<span class="fc" id="L6040">    public enum FitComponent {</span>
        /**
         *  Fit the image or icon to the width of the component.
         */
<span class="fc" id="L6044">        WIDTH,</span>
        /**
         *  Fit the image or icon to the height of the component.
         */
<span class="fc" id="L6048">        HEIGHT,</span>
        /**
         *  Fit the image or icon to the width and height of the component.
         */
<span class="fc" id="L6052">        WIDTH_AND_HEIGHT,</span>
        /**
         *  Fit the image to the largest dimension of the component.
         */
<span class="fc" id="L6056">        MAX_DIM,</span>
        /**
         *  Fit the image to the smallest dimension of the component.
         */
<span class="fc" id="L6060">        MIN_DIM,</span>
        /**
         *  Do not fit the image to the component.
         */
<span class="fc" id="L6064">        NO</span>
    }

    /**
     *  Use this to quickly create and inspect a test window for a UI component.
     */
    private static class TestWindow
    {
        private final JFrame frame;
        private final Component component;

<span class="nc" id="L6075">        private TestWindow( String title, Function&lt;JFrame, Component&gt; uiSupplier ) {</span>
<span class="nc" id="L6076">            Objects.requireNonNull( title );</span>
<span class="nc" id="L6077">            Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L6078">            this.frame = new JFrame();</span>
<span class="nc bnc" id="L6079" title="All 2 branches missed.">            if ( !title.isEmpty() ) this.frame.setTitle(title);</span>
<span class="nc" id="L6080">            frame.setLocationRelativeTo(null); // Initial centering!</span>
<span class="nc" id="L6081">            Component c = null;</span>
<span class="nc bnc" id="L6082" title="All 2 branches missed.">            if ( !UI.thisIsUIThread() ) {</span>
                try {
<span class="nc" id="L6084">                    c = UI.runAndGet(() -&gt; uiSupplier.apply(frame));</span>
<span class="nc" id="L6085">                } catch (Exception e) {</span>
<span class="nc" id="L6086">                    e.printStackTrace();</span>
<span class="nc" id="L6087">                }</span>
            }
            else
<span class="nc" id="L6090">                c = uiSupplier.apply(frame);</span>

<span class="nc" id="L6092">            this.component = c;</span>
<span class="nc" id="L6093">            frame.add(component);</span>
<span class="nc" id="L6094">            frame.pack(); // Otherwise some components resize strangely or are not shown at all...</span>
            // Make sure that the window is centered on the screen again but with the component:
<span class="nc" id="L6096">            frame.setLocationRelativeTo(null);</span>
            // We set the size to fit the component:
<span class="nc" id="L6098">            _determineSize();</span>
<span class="nc" id="L6099">            frame.setVisible(true);</span>
<span class="nc" id="L6100">        }</span>
        private void _determineSize() {
<span class="nc" id="L6102">            Dimension size = frame.getSize();</span>
<span class="nc bnc" id="L6103" title="All 2 branches missed.">            if ( size == null ) // The frame has no size! It is best to set the size to the preferred size of the component:</span>
<span class="nc" id="L6104">                size = component.getPreferredSize();</span>

<span class="nc bnc" id="L6106" title="All 2 branches missed.">            if ( size == null ) // The component has no preferred size! It is best to set the size to the minimum size of the component:</span>
<span class="nc" id="L6107">                size = component.getMinimumSize();</span>

<span class="nc bnc" id="L6109" title="All 2 branches missed.">            if ( size == null ) // The component has no minimum size! Let's just look up the size of the component:</span>
<span class="nc" id="L6110">                size = component.getSize();</span>

<span class="nc" id="L6112">            frame.setSize(size);</span>
<span class="nc" id="L6113">        }</span>
    }


    /*
        The following method and subsequent classes are used to smoothly render
        custom graphics on top of Swing components without requiring
        the user to override the paint method of the component.
        This is especially important to allow for declarative UI.
    */

    private static &lt;C extends JComponent&gt; void _paintBackground( C comp, Graphics g ) {
<span class="fc" id="L6125">        ComponentExtension.from(comp).paintBackgroundStyle( g );</span>
<span class="fc" id="L6126">    }</span>
    private static &lt;C extends JComponent&gt; void _paintForeground( C comp, Graphics g ) {
<span class="fc" id="L6128">        ComponentExtension.from(comp).paintForegroundStyle( (Graphics2D) g );</span>
<span class="fc" id="L6129">    }</span>

    /** {inheritDoc} */
<span class="fc" id="L6132">    public static class Panel extends JPanel {</span>
<span class="fc" id="L6133">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6134">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6137">    public static class Label extends JLabel {</span>
<span class="fc" id="L6138">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6139">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6142">    public static class TextField extends JTextField {</span>
<span class="fc" id="L6143">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6144">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6147">    public static class TextArea extends JTextArea {</span>
<span class="fc" id="L6148">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6149">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6152">    public static class CheckBox extends JCheckBox {</span>
<span class="fc" id="L6153">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6154">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6157">    public static class Button extends JButton {</span>
<span class="fc" id="L6158">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6159">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6162">    public static class ToggleButton extends JToggleButton {</span>
<span class="fc" id="L6163">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6164">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6167">    public static class RadioButton extends JRadioButton {</span>
<span class="fc" id="L6168">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6169">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6172">    public static class ComboBox&lt;E&gt; extends JComboBox&lt;E&gt; {</span>
<span class="fc" id="L6173">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6174">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6177">    public static class List&lt;E&gt; extends JList&lt;E&gt; {</span>
<span class="nc" id="L6178">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6179">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6182">    public static class Table extends JTable {</span>
<span class="fc" id="L6183">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6184">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
    public static class TableHeader extends JTableHeader {
        private Function&lt;Integer, String&gt; _toolTipTextSupplier;
<span class="nc" id="L6189">        public TableHeader() { super(); }</span>
<span class="nc" id="L6190">        public TableHeader(TableColumnModel model) { super(model); }</span>
        /**
         * @param toolTipTextSupplier A function which receives the column index and returns the
         *                            tool tip text for that column.
         */
        public void setToolTipsSupplier( Function&lt;Integer, String&gt; toolTipTextSupplier ) {
<span class="nc" id="L6196">            Objects.requireNonNull(toolTipTextSupplier);</span>
<span class="nc" id="L6197">            _toolTipTextSupplier = toolTipTextSupplier;</span>
<span class="nc" id="L6198">        }</span>
        /**
         * @param toolTips The tool tip texts for the columns.
         */
        public void setToolTips( String... toolTips ) {
<span class="nc" id="L6203">            Objects.requireNonNull(toolTips);</span>
<span class="nc" id="L6204">            setToolTipsSupplier( i -&gt; toolTips[i] );</span>
<span class="nc" id="L6205">        }</span>
<span class="nc" id="L6206">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6207">        @Override public void paintComponent(Graphics g) { super.paintComponent(g); _paintForeground(this, g); }</span>
        @Override public String getToolTipText(MouseEvent e) {
<span class="nc" id="L6209">            int col = columnAtPoint(e.getPoint());</span>
<span class="nc" id="L6210">            int modelCol = Optional.ofNullable(getTable())</span>
<span class="nc" id="L6211">                                    .map( t -&gt; t.convertColumnIndexToModel(col) )</span>
<span class="nc" id="L6212">                                    .orElse(col);</span>
            String retStr;
<span class="nc" id="L6214">            try { retStr = _toolTipTextSupplier.apply(modelCol); }</span>
<span class="nc" id="L6215">            catch ( NullPointerException | ArrayIndexOutOfBoundsException ex ) {</span>
<span class="nc" id="L6216">                retStr = &quot;&quot;;</span>
<span class="nc" id="L6217">            }</span>
<span class="nc bnc" id="L6218" title="All 2 branches missed.">            return  ( retStr.isEmpty() ? super.getToolTipText(e) : retStr );</span>
        }
    }
    /** {inheritDoc} */
<span class="fc" id="L6222">    public static class Slider extends JSlider {</span>
<span class="fc" id="L6223">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6224">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6227">    public static class PopupMenu extends JPopupMenu {</span>
<span class="nc" id="L6228">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6229">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6232">    public static class MenuItem extends JMenuItem {</span>
<span class="nc" id="L6233">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6234">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6237">    public static class RadioButtonMenuItem extends JRadioButtonMenuItem {</span>
<span class="nc" id="L6238">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6239">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6242">     public static class CheckBoxMenuItem extends JCheckBoxMenuItem {</span>
<span class="nc" id="L6243">         @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6244">         @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
     }
    /** {inheritDoc} */
<span class="nc" id="L6247">    public static class Menu extends JMenu {</span>
<span class="nc" id="L6248">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6249">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6252">    public static class MenuBar extends JMenuBar {</span>
<span class="nc" id="L6253">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6254">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6257">    public static class ScrollPane extends JScrollPane {</span>
<span class="nc" id="L6258">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6259">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6262">    public static class TabbedPane extends JTabbedPane {</span>
<span class="nc" id="L6263">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6264">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6267">    public static class ToolBar extends JToolBar {</span>
<span class="nc" id="L6268">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6269">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6272">    public static class ToolTip extends JToolTip {</span>
<span class="nc" id="L6273">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6274">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6277">    public static class Tree extends JTree {</span>
<span class="nc" id="L6278">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6279">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L6282">    public static class TextPane extends JTextPane {</span>
<span class="nc" id="L6283">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6284">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6287">    public static class Spinner extends JSpinner {</span>
<span class="fc" id="L6288">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6289">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
    public static class SplitPane extends JSplitPane {
<span class="fc" id="L6293">        SplitPane( Align align ) { super(align.forSplitPane()); }</span>
<span class="nc" id="L6294">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6295">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6298">    public static class PasswordField extends JPasswordField {</span>
<span class="fc" id="L6299">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6300">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6303">    public static class ProgressBar extends JProgressBar {</span>
<span class="fc" id="L6304">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="fc" id="L6305">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6308">    public static class EditorPane extends JEditorPane {</span>
<span class="nc" id="L6309">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6310">        @Override public void paintChildren(Graphics g) { super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {@inheritDoc} */
<span class="nc" id="L6313">    public static class FormattedTextField extends JFormattedTextField {</span>
<span class="nc" id="L6314">        @Override public void paint(Graphics g){ _paintBackground(this, g); super.paint(g); }</span>
<span class="nc" id="L6315">        @Override public void paintChildren(Graphics g){ super.paintChildren(g); _paintForeground(this, g); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L6318">    public static class Box extends JBox {/* Already implemented */}</span>
    /** {@inheritDoc} */
<span class="fc" id="L6320">    public static class SplitButton extends JSplitButton {/* Already implemented */}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>