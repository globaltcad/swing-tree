<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UI.java</span></div><h1>UI.java</h1><pre class="source lang-java linenums">package swingtree;

import com.alexandriasoftware.swing.JSplitButton;
import net.miginfocom.swing.MigLayout;
import sprouts.Event;
import sprouts.*;
import swingtree.animation.Animate;
import swingtree.animation.Schedule;
import swingtree.api.Buildable;
import swingtree.api.MenuBuilder;
import swingtree.api.SwingBuilder;
import swingtree.api.model.BasicTableModel;
import swingtree.api.model.TableListDataSource;
import swingtree.api.model.TableMapDataSource;
import swingtree.layout.CompAttr;
import swingtree.layout.LayoutAttr;
import swingtree.style.StyleSheet;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.table.AbstractTableModel;
import javax.swing.text.JTextComponent;
import java.awt.*;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 *  This class is a static API for exposing swing tree builder types for wrapping
 *  and assembling various {@link JComponent} types to form a UI tree.
 *  Instances of these builder type expose an API based on chained methods
 *  designed around functional interfaces to enable building UI tree structures for Swing
 *  in an HTML-like nested fashion while also keeping a high degree of control and transparency
 *  by peeking into the underlying swing components or registering user actions through lambdas.
 *  Swing tree works especially well alongside {@link MigLayout}s,
 *  which is why this general purpose {@link LayoutManager} is integrated into this library.
 *  Simply pass {@link String} constraints to the {@link UIForAnySwing#withLayout(String, String)}
 *  and any given {@link UIForAnySwing#add(String, UIForAnySwing[])} method
 *  or variant of, to make use of mig layouts.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 */
public final class UI
{
<span class="fc" id="L53">    private static final ThreadLocal&lt;Settings&gt; _SETTINGS = new ThreadLocal&lt;&gt;();</span>

    static Settings SETTINGS() {
<span class="fc" id="L56">        Settings settings = _SETTINGS.get();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if ( settings == null ) {</span>
<span class="fc" id="L58">            settings = new Settings();</span>
<span class="fc" id="L59">            _SETTINGS.set(settings);</span>
        }
<span class="fc" id="L61">        return settings;</span>
    }

    /**
     *  Sets a {@link StyleSheet} which will be applied to all SwingTree UIs defined in the subsequent lambda scope.
     *  This method allows to switch between different style sheets.
     *  &lt;p&gt;
     * 	You can switch to a style sheet like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(new MyCustomStyeSheet(), ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @return the result of the given scope, usually a {@link JComponent} or SwingTree UI.
     */
    public static &lt;T&gt; T use( StyleSheet styleSheet, Supplier&lt;T&gt; scope ) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if ( !UI.thisIsUIThread() )</span>
            try {
<span class="nc" id="L87">                return runAndGet(()-&gt; use(styleSheet, scope));</span>
<span class="nc" id="L88">            } catch (InvocationTargetException | InterruptedException e) {</span>
<span class="nc" id="L89">                throw new RuntimeException(e);</span>
            }

<span class="nc" id="L92">        Settings settings = SETTINGS();</span>
<span class="nc" id="L93">        StyleSheet oldStyleSheet = settings.getStyleSheet().orElse(null);</span>
<span class="nc" id="L94">        settings.setStyleSheet(styleSheet);</span>
        try {
<span class="nc" id="L96">            return scope.get();</span>
        } finally {
<span class="nc" id="L98">            settings.setStyleSheet(oldStyleSheet);</span>
        }
    }

    /**
     *  Sets the {@link EventProcessor} to be used for all subsequent UI building operations.
     *  This method allows to switch between different event processing strategies.
     *  In particular, the {@link DecoupledEventProcessor} is recommended to be used for
     *  proper decoupling of the UI thread from the application logic.
     *  &lt;p&gt;
     * 	You can switch to the decoupled event processor like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(EventProcessor.DECOUPLED, ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param processor The event processor to be used for all subsequent UI building operations
     * @param scope The scope of the event processor to be used for all subsequent UI building operations.
     *              The value returned by the given scope is returned by this method.
     * @return The value returned by the given scope.
     * @param &lt;T&gt; The type of the value returned by the given scope.
     */
    public static &lt;T&gt; T use( EventProcessor processor, Supplier&lt;T&gt; scope )
    {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
            try {
<span class="fc" id="L132">                return runAndGet(()-&gt; use(processor, scope));</span>
<span class="nc" id="L133">            } catch (InvocationTargetException | InterruptedException e) {</span>
<span class="nc" id="L134">                throw new RuntimeException(e);</span>
            }

<span class="fc" id="L137">        Settings settings = SETTINGS();</span>
<span class="fc" id="L138">        EventProcessor oldProcessor = settings.getEventProcessor();</span>
<span class="fc" id="L139">        settings.setEventProcessor(processor);</span>
        try {
<span class="fc" id="L141">            return scope.get();</span>
        } finally {
<span class="fc" id="L143">            settings.setEventProcessor(oldProcessor);</span>
        }
    }

    /**
     *  A fully blocking call to the decoupled thread event processor
     *  causing this thread to join its event queue
     *  so that it can continuously process events produced by the UI.
     *  &lt;p&gt;
     *  This method wither be called by the main thread of the application
     *  after the UI has been built and shown to the user, or alternatively
     *  a new thread dedicated to processing events. (things like button clicks, etc.)
     *  @throws IllegalStateException If this method is called from the UI thread.
     */
    public static void joinDecoupledEventProcessor() {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if ( thisIsUIThread() )</span>
<span class="nc" id="L159">            throw new IllegalStateException(&quot;This method must not be called from the UI thread.&quot;);</span>
<span class="nc" id="L160">        DecoupledEventProcessor.INSTANCE().join();</span>
<span class="nc" id="L161">    }</span>

    /**
     *  A fully blocking call to the decoupled thread event processor
     *  causing this thread to join its event queue
     *  so that it can continuously process events produced by the UI.
     *  &lt;p&gt;
     *  This method should be called by the main thread of the application
     *  after the UI has been built and shown to the user, or alternatively
     *  a new thread dedicated to processing events. (things like button clicks, etc.)
     *  &lt;p&gt;
     *  This method will block until an exception is thrown by the event processor.
     *  This is useful for debugging purposes.
     *  @throws InterruptedException If the thread is interrupted while waiting for the event processor to join.
     */
    public static void joinDecoupledEventProcessorUntilException() throws InterruptedException {
<span class="nc" id="L177">        DecoupledEventProcessor.INSTANCE().joinUntilException();</span>
<span class="nc" id="L178">    }</span>

    /**
     *  A fully blocking call to the decoupled thread event processor
     *  causing this thread to join its event queue
     *  so that it can process the given number of events produced by the UI.
     *  &lt;p&gt;
     *  This method should be called by the main thread of the application
     *  after the UI has been built and shown to the user, or alternatively
     *  a new thread dedicated to processing events. (things like button clicks, etc.)
     *  &lt;p&gt;
     *  This method will block until the given number of events have been processed.
     *  @param numberOfEvents The number of events to wait for.
     */
    public static void joinDecoupledEventProcessorFor(long numberOfEvents) {
<span class="fc" id="L193">        DecoupledEventProcessor.INSTANCE().joinFor(numberOfEvents);</span>
<span class="fc" id="L194">    }</span>

    /**
     *  A temporarily blocking call to the decoupled thread event processor
     *  causing this thread to join its event queue
     *  so that it can process the given number of events produced by the UI.
     *  &lt;p&gt;
     *  This method should be called by the main thread of the application
     *  after the UI has been built and shown to the user, or alternatively
     *  a new thread dedicated to processing events. (things like button clicks, etc.)
     *  &lt;p&gt;
     *  This method will block until the given number of events have been processed
     *  or an exception is thrown by the event processor.
     *  @param numberOfEvents The number of events to wait for.
     *  @throws InterruptedException If the thread is interrupted while waiting for the event processor to join.
     */
    public static void joinDecoupledEventProcessorUntilExceptionFor(long numberOfEvents) throws InterruptedException {
<span class="nc" id="L211">        DecoupledEventProcessor.INSTANCE().joinUntilExceptionFor(numberOfEvents);</span>
<span class="nc" id="L212">    }</span>

    /**
     *  A temporarily blocking call to the decoupled thread event processor
     *  causing this thread to join its event queue
     *  so that it can continuously process events produced by the UI
     *  until all events have been processed or an exception is thrown by the event processor.
     *  &lt;p&gt;
     *  This method should be called by the main thread of the application
     *  after the UI has been built and shown to the user, or alternatively
     *  a new thread dedicated to processing events. (things like button clicks, etc.)
     * @throws InterruptedException If the thread is interrupted while waiting.
     */
    public static void joinDecoupledEventProcessorUntilDoneOrException() throws InterruptedException {
<span class="fc" id="L226">        DecoupledEventProcessor.INSTANCE().joinUntilDoneOrException();</span>
<span class="fc" id="L227">    }</span>

    // Common Mig layout constants:
<span class="fc" id="L230">    public static LayoutAttr FILL     = LayoutAttr.of(&quot;fill&quot;);</span>
<span class="fc" id="L231">    public static LayoutAttr FILL_X     = LayoutAttr.of(&quot;fillx&quot;);</span>
<span class="fc" id="L232">    public static LayoutAttr FILL_Y     = LayoutAttr.of(&quot;filly&quot;);</span>
<span class="fc" id="L233">    public static LayoutAttr INS(int insets) { return LayoutAttr.of(&quot;ins &quot; + insets); }</span>
<span class="nc" id="L234">    public static LayoutAttr INSETS(int insets) { return LayoutAttr.of(&quot;insets &quot; + insets); }</span>
<span class="fc" id="L235">    public static LayoutAttr INS(int top, int left, int bottom, int right) { return LayoutAttr.of(&quot;insets &quot; + top + &quot; &quot; + left + &quot; &quot; + bottom + &quot; &quot; + right); }</span>
<span class="nc" id="L236">    public static LayoutAttr INSETS(int top, int left, int bottom, int right) { return LayoutAttr.of(&quot;insets &quot; + top + &quot; &quot; + left + &quot; &quot; + bottom + &quot; &quot; + right); }</span>
<span class="fc" id="L237">    public static LayoutAttr WRAP(int times) { return LayoutAttr.of( &quot;wrap &quot; + times ); }</span>
<span class="fc" id="L238">    public static LayoutAttr FLOW_X   = LayoutAttr.of(&quot;flowx&quot;);</span>
<span class="fc" id="L239">    public static LayoutAttr FLOW_Y   = LayoutAttr.of(&quot;flowy&quot;);</span>
<span class="fc" id="L240">    public static LayoutAttr NO_GRID  = LayoutAttr.of(&quot;nogrid&quot;);</span>
<span class="fc" id="L241">    public static LayoutAttr NO_CACHE = LayoutAttr.of(&quot;nocache&quot;);</span>
<span class="fc" id="L242">    public static LayoutAttr DEBUG    = LayoutAttr.of(&quot;debug&quot;);</span>

<span class="fc" id="L244">    public static CompAttr WRAP     = CompAttr.of(&quot;wrap&quot;);</span>
<span class="fc" id="L245">    public static CompAttr SPAN     = CompAttr.of(&quot;SPAN&quot;);</span>
<span class="nc" id="L246">    public static CompAttr SPAN( int times ) { return CompAttr.of( &quot;span &quot; + times ); }</span>
<span class="nc" id="L247">    public static CompAttr SPAN( int xTimes, int yTimes ) { return CompAttr.of( &quot;span &quot; + xTimes + &quot; &quot; + yTimes ); }</span>
<span class="nc" id="L248">    public static CompAttr SPAN_X( int times ) { return CompAttr.of( &quot;spanx &quot; + times ); }</span>
<span class="nc" id="L249">    public static CompAttr SPAN_Y( int times ) { return CompAttr.of( &quot;spany &quot; + times ); }</span>
<span class="fc" id="L250">    public static CompAttr GROW     = CompAttr.of(&quot;grow&quot;);</span>
<span class="fc" id="L251">    public static CompAttr GROW_X   = CompAttr.of(&quot;growx&quot;);</span>
<span class="fc" id="L252">    public static CompAttr GROW_Y   = CompAttr.of(&quot;growy&quot;);</span>
<span class="nc" id="L253">    public static CompAttr GROW( int weight ) { return CompAttr.of( &quot;grow &quot; + weight ); }</span>
<span class="nc" id="L254">    public static CompAttr GROW_X( int weight ) { return CompAttr.of( &quot;growx &quot; + weight ); }</span>
<span class="nc" id="L255">    public static CompAttr GROW_Y( int weight ) { return CompAttr.of( &quot;growy &quot; + weight ); }</span>
<span class="fc" id="L256">    public static CompAttr SHRINK   = CompAttr.of(&quot;shrink&quot;);</span>
<span class="fc" id="L257">    public static CompAttr SHRINK_X = CompAttr.of(&quot;shrinkx&quot;);</span>
<span class="fc" id="L258">    public static CompAttr SHRINK_Y = CompAttr.of(&quot;shrinky&quot;);</span>
<span class="nc" id="L259">    public static CompAttr SHRINK( int weight )  { return CompAttr.of(&quot;shrink &quot;+weight); }</span>
<span class="nc" id="L260">    public static CompAttr SHRINK_X( int weight )  { return CompAttr.of(&quot;shrinkx &quot;+weight); }</span>
<span class="nc" id="L261">    public static CompAttr SHRINK_Y( int weight )  { return CompAttr.of(&quot;shrinky &quot;+weight); }</span>
<span class="nc" id="L262">    public static CompAttr SHRINK_PRIO( int priority )  { return CompAttr.of(&quot;shrinkprio &quot;+priority); }</span>
<span class="fc" id="L263">    public static CompAttr PUSH     = CompAttr.of(&quot;push&quot;);</span>
<span class="fc" id="L264">    public static CompAttr PUSH_X   = CompAttr.of(&quot;pushx&quot;);</span>
<span class="fc" id="L265">    public static CompAttr PUSH_Y   = CompAttr.of(&quot;pushy&quot;);</span>
<span class="nc" id="L266">    public static CompAttr PUSH( int weight )  { return CompAttr.of(&quot;push &quot;+weight); }</span>
<span class="nc" id="L267">    public static CompAttr PUSH_X( int weight ) { return CompAttr.of(&quot;pushx &quot;+weight); }</span>
<span class="nc" id="L268">    public static CompAttr PUSH_Y( int weight ) { return CompAttr.of(&quot;pushy &quot;+weight); }</span>
<span class="nc" id="L269">    public static CompAttr SKIP( int cells ) { return CompAttr.of(&quot;skip &quot;+cells); }</span>
<span class="nc" id="L270">    public static CompAttr SPLIT( int cells ) { return CompAttr.of(&quot;split &quot;+cells); }</span>
<span class="fc" id="L271">    public static CompAttr WIDTH( int min, int pref, int max ) { return CompAttr.of(&quot;width &quot;+min+&quot;:&quot;+pref+&quot;:&quot;+max); }</span>
<span class="nc" id="L272">    public static CompAttr HEIGHT( int min, int pref, int max ) { return CompAttr.of(&quot;height &quot;+min+&quot;:&quot;+pref+&quot;:&quot;+max); }</span>
<span class="nc" id="L273">    public static CompAttr PAD( int size ) { return PAD(size, size, size, size); }</span>
<span class="nc" id="L274">    public static CompAttr PAD( int top, int left, int bottom, int right ) { return CompAttr.of(&quot;pad &quot;+top+&quot; &quot;+left+&quot; &quot;+bottom+&quot; &quot;+right); }</span>
<span class="fc" id="L275">    public static CompAttr ALIGN_CENTER = CompAttr.of(&quot;align center&quot;);</span>
<span class="fc" id="L276">    public static CompAttr ALIGN_LEFT = CompAttr.of(&quot;align left&quot;);</span>
<span class="fc" id="L277">    public static CompAttr ALIGN_RIGHT = CompAttr.of(&quot;align right&quot;);</span>
<span class="fc" id="L278">    public static CompAttr ALIGN_X_CENTER = CompAttr.of(&quot;alignx center&quot;);</span>
<span class="fc" id="L279">    public static CompAttr ALIGN_X_LEFT = CompAttr.of(&quot;alignx left&quot;);</span>
<span class="fc" id="L280">    public static CompAttr ALIGN_X_RIGHT = CompAttr.of(&quot;alignx right&quot;);</span>
<span class="fc" id="L281">    public static CompAttr ALIGN_Y_CENTER = CompAttr.of(&quot;aligny center&quot;);</span>
<span class="fc" id="L282">    public static CompAttr ALIGN_Y_BOTTOM = CompAttr.of(&quot;aligny bottom&quot;);</span>
<span class="fc" id="L283">    public static CompAttr ALIGN_Y_TOP = CompAttr.of(&quot;aligny top&quot;);</span>
<span class="nc" id="L284">    public static CompAttr ALIGN( Position pos ) { return CompAttr.of(pos.toMigAlign()); }</span>
<span class="fc" id="L285">    public static CompAttr TOP = CompAttr.of(&quot;top&quot;);</span>
<span class="fc" id="L286">    public static CompAttr BOTTOM = CompAttr.of(&quot;bottom&quot;);</span>
<span class="fc" id="L287">    public static CompAttr LEFT = CompAttr.of(&quot;left&quot;);</span>
<span class="fc" id="L288">    public static CompAttr RIGHT = CompAttr.of(&quot;right&quot;);</span>
<span class="fc" id="L289">    public static CompAttr GAP_LEFT_PUSH = CompAttr.of(&quot;gapleft push&quot;);</span>
<span class="fc" id="L290">    public static CompAttr GAP_RIGHT_PUSH = CompAttr.of(&quot;gapright push&quot;);</span>
<span class="fc" id="L291">    public static CompAttr GAP_TOP_PUSH = CompAttr.of(&quot;gaptop push&quot;);</span>
<span class="fc" id="L292">    public static CompAttr GAP_BOTTOM_PUSH = CompAttr.of(&quot;gapbottom push&quot;);</span>
<span class="fc" id="L293">    public static CompAttr DOCK_NORTH = CompAttr.of(&quot;dock north&quot;);</span>
<span class="fc" id="L294">    public static CompAttr DOCK_SOUTH = CompAttr.of(&quot;dock south&quot;);</span>
<span class="fc" id="L295">    public static CompAttr DOCK_EAST  = CompAttr.of(&quot;dock east&quot;);</span>
<span class="fc" id="L296">    public static CompAttr DOCK_WEST  = CompAttr.of(&quot;dock west&quot;);</span>
<span class="nc" id="L297">    public static CompAttr DOCK( Position pos ) { return CompAttr.of(&quot;dock &quot; + pos.toDirectionString()); }</span>

    /**
     * Loads an icon from the classpath or from a file.
     * @param path The path to the icon. It can be a classpath resource or a file path.
     * @return The icon.
     */
    public static Icon icon( String path ) {
        // First we make the path platform independent:
<span class="fc" id="L306">        path = path.replace('\\', '/');</span>
        // Then we try to load the icon url from the classpath:
<span class="fc" id="L308">        URL url = UI.class.getResource(path);</span>
        // We check if the url is null:
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if ( url == null ) {</span>
            // It is, let's do some troubleshooting:
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if ( !path.startsWith(&quot;/&quot;) )</span>
<span class="fc" id="L313">                url = UI.class.getResource(&quot;/&quot; + path);</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">            if ( url == null ) // Still null? Let's try to load it as a file:</span>
                try {
<span class="fc" id="L317">                    url = new File(path).toURI().toURL();</span>
<span class="nc" id="L318">                } catch (MalformedURLException e) {</span>
<span class="nc" id="L319">                    throw new RuntimeException(e);</span>
<span class="fc" id="L320">                }</span>
        }
<span class="fc" id="L322">        return new ImageIcon(url);</span>
    }

    private UI(){} // This is a static API

    /**
     *  An enum set of all the available swing cursors which
     *  map to the cursor type id.
     *  This exists simply because swing was created before enums were added to Java.
     */
<span class="fc" id="L332">    public enum Cursor</span>
    {
<span class="fc" id="L334">        HAND(java.awt.Cursor.HAND_CURSOR),</span>
<span class="fc" id="L335">        MOVE(java.awt.Cursor.MOVE_CURSOR),</span>
<span class="fc" id="L336">        CROSS(java.awt.Cursor.CROSSHAIR_CURSOR),</span>
<span class="fc" id="L337">        DEFAULT(java.awt.Cursor.DEFAULT_CURSOR),</span>
<span class="fc" id="L338">        WAIT(java.awt.Cursor.WAIT_CURSOR),</span>
<span class="fc" id="L339">        TEXT(java.awt.Cursor.TEXT_CURSOR),</span>
<span class="fc" id="L340">        RESIZE_EAST(java.awt.Cursor.E_RESIZE_CURSOR),</span>
<span class="fc" id="L341">        RESIZE_WEST(java.awt.Cursor.W_RESIZE_CURSOR),</span>
<span class="fc" id="L342">        RESIZE_SOUTH(java.awt.Cursor.S_RESIZE_CURSOR),</span>
<span class="fc" id="L343">        RESIZE_NORTH(java.awt.Cursor.N_RESIZE_CURSOR),</span>
<span class="fc" id="L344">        RESIZE_NORTH_WEST(java.awt.Cursor.NW_RESIZE_CURSOR),</span>
<span class="fc" id="L345">        RESIZE_NORTH_EAST(java.awt.Cursor.NE_RESIZE_CURSOR),</span>
<span class="fc" id="L346">        RESIZE_SOUTH_WEST(java.awt.Cursor.SE_RESIZE_CURSOR),</span>
<span class="fc" id="L347">        RESIZE_SOUTH_EAST(java.awt.Cursor.SE_RESIZE_CURSOR);</span>

        final int type;

<span class="fc" id="L351">        Cursor( int type ) { this.type = type; }</span>
    }

    /**
     *  The scroll policy for UI components with scroll behaviour.
     */
<span class="fc" id="L357">    public enum ScrollBarPolicy { NEVER, AS_NEEDED, ALWAYS }</span>

    /**
     *  The position of a UI component in terms of directions.
     */
<span class="fc" id="L362">    public enum Position {</span>
<span class="fc" id="L363">        TOP, LEFT, BOTTOM, RIGHT;</span>
        int forTabbedPane() {
<span class="pc bpc" id="L365" title="1 of 5 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L366">                case TOP   : return JTabbedPane.TOP;</span>
<span class="fc" id="L367">                case LEFT  : return JTabbedPane.LEFT;</span>
<span class="fc" id="L368">                case BOTTOM: return JTabbedPane.BOTTOM;</span>
<span class="fc" id="L369">                case RIGHT : return JTabbedPane.RIGHT;</span>
            }
<span class="nc" id="L371">            throw new RuntimeException();</span>
        }

        String toDirectionString() {
<span class="nc bnc" id="L375" title="All 5 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L376">                case TOP   : return &quot;north&quot;;</span>
<span class="nc" id="L377">                case LEFT  : return &quot;west&quot;;</span>
<span class="nc" id="L378">                case BOTTOM: return &quot;south&quot;;</span>
<span class="nc" id="L379">                case RIGHT : return &quot;east&quot;;</span>
            }
<span class="nc" id="L381">            throw new RuntimeException();</span>
        }

        String toMigAlign() {
<span class="nc bnc" id="L385" title="All 5 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L386">                case TOP   : return &quot;top&quot;;</span>
<span class="nc" id="L387">                case LEFT  : return &quot;left&quot;;</span>
<span class="nc" id="L388">                case BOTTOM: return &quot;bottom&quot;;</span>
<span class="nc" id="L389">                case RIGHT : return &quot;right&quot;;</span>
            }
<span class="nc" id="L391">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Overflow policy of UI components.
     */
<span class="fc" id="L398">    public enum OverflowPolicy {</span>
<span class="fc" id="L399">        WRAP, SCROLL;</span>

        int forTabbedPane() {
<span class="nc bnc" id="L402" title="All 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L403">                case WRAP  : return JTabbedPane.WRAP_TAB_LAYOUT;</span>
<span class="nc" id="L404">                case SCROLL: return JTabbedPane.SCROLL_TAB_LAYOUT;</span>
            }
<span class="nc" id="L406">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Vertical or horizontal alignment.
     */
<span class="fc" id="L413">    public enum Align {</span>
<span class="fc" id="L414">        HORIZONTAL, VERTICAL;</span>

        int forSlider() {
<span class="pc bpc" id="L417" title="1 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L418">                case HORIZONTAL: return JSlider.HORIZONTAL;</span>
<span class="fc" id="L419">                case VERTICAL  : return JSlider.VERTICAL;</span>
            }
<span class="nc" id="L421">            throw new RuntimeException();</span>
        }
        int forSeparator() {
<span class="pc bpc" id="L424" title="2 of 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L425">                case HORIZONTAL: return JSeparator.HORIZONTAL;</span>
<span class="fc" id="L426">                case VERTICAL  : return JSeparator.VERTICAL;</span>
            }
<span class="nc" id="L428">            throw new RuntimeException();</span>
        }
        int forSplitPane() {
<span class="pc bpc" id="L431" title="1 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L432">                case HORIZONTAL: return JSplitPane.VERTICAL_SPLIT;</span>
<span class="fc" id="L433">                case VERTICAL:   return JSplitPane.HORIZONTAL_SPLIT;</span>
            }
<span class="nc" id="L435">            throw new RuntimeException();</span>
        }

        int forToolBar() {
<span class="nc bnc" id="L439" title="All 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L440">                case HORIZONTAL: return JToolBar.HORIZONTAL;</span>
<span class="nc" id="L441">                case VERTICAL  : return JToolBar.VERTICAL;</span>
            }
<span class="nc" id="L443">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Different positions along a vertically aligned UI component.
     */
<span class="fc" id="L450">    public enum VerticalAlignment {</span>
<span class="fc" id="L451">        TOP, CENTER, BOTTOM;</span>

        int forSwing() {
<span class="pc bpc" id="L454" title="2 of 4 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L455">                case TOP:    return SwingConstants.TOP;</span>
<span class="nc" id="L456">                case CENTER: return SwingConstants.CENTER;</span>
<span class="fc" id="L457">                case BOTTOM: return SwingConstants.BOTTOM;</span>
            }
<span class="nc" id="L459">            throw new RuntimeException();</span>
        }
    }

    /**
     *  Different positions along a horizontally aligned UI component.
     */
<span class="fc" id="L466">    public enum HorizontalAlignment {</span>
<span class="fc" id="L467">        LEFT, CENTER, RIGHT;</span>

        public final int forSwing() {
<span class="pc bpc" id="L470" title="1 of 4 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L471">                case LEFT:   return SwingConstants.LEFT;</span>
<span class="fc" id="L472">                case CENTER: return SwingConstants.CENTER;</span>
<span class="fc" id="L473">                case RIGHT:  return SwingConstants.RIGHT;</span>
            }
<span class="nc" id="L475">            throw new RuntimeException();</span>
        }
    }

<span class="fc" id="L479">    public enum HorizontalDirection {</span>
<span class="fc" id="L480">        LEFT_TO_RIGHT, RIGHT_TO_LEFT;</span>

        public final ComponentOrientation forTextOrientation() {
<span class="pc bpc" id="L483" title="2 of 3 branches missed.">            switch ( this ) {</span>
<span class="nc" id="L484">                case LEFT_TO_RIGHT: return ComponentOrientation.LEFT_TO_RIGHT;</span>
<span class="fc" id="L485">                case RIGHT_TO_LEFT: return ComponentOrientation.RIGHT_TO_LEFT;</span>
            }
<span class="nc" id="L487">            throw new RuntimeException();</span>
        }
    }

<span class="fc" id="L491">    public enum ListData {</span>
<span class="fc" id="L492">        COLUMN_MAJOR,</span>
<span class="fc" id="L493">        ROW_MAJOR,</span>
<span class="fc" id="L494">        COLUMN_MAJOR_EDITABLE,</span>
<span class="fc" id="L495">        ROW_MAJOR_EDITABLE;</span>

        final boolean isEditable() {
<span class="pc bpc" id="L498" title="1 of 3 branches missed.">            switch ( this ) {</span>
                case COLUMN_MAJOR:
                case ROW_MAJOR:
<span class="fc" id="L501">                    return false;</span>
                case COLUMN_MAJOR_EDITABLE:
                case ROW_MAJOR_EDITABLE:
<span class="fc" id="L504">                    return true;</span>
            }
<span class="nc" id="L506">            throw new RuntimeException();</span>
        }

        final boolean isRowMajor() {
<span class="pc bpc" id="L510" title="1 of 3 branches missed.">            switch ( this ) {</span>
                case COLUMN_MAJOR:
                case COLUMN_MAJOR_EDITABLE:
<span class="fc" id="L513">                    return false;</span>
                case ROW_MAJOR:
                case ROW_MAJOR_EDITABLE:
<span class="fc" id="L516">                    return true;</span>
            }
<span class="nc" id="L518">            throw new RuntimeException();</span>
        }
    }

<span class="fc" id="L522">    public enum MapData {</span>
<span class="fc" id="L523">        EDITABLE, READ_ONLY;</span>

        final boolean isEditable() {
<span class="pc bpc" id="L526" title="2 of 3 branches missed.">            switch ( this ) {</span>
<span class="fc" id="L527">                case EDITABLE: return true;</span>
<span class="nc" id="L528">                case READ_ONLY: return false;</span>
            }
<span class="nc" id="L530">            throw new RuntimeException();</span>
        }
    }


    /**
     *  This returns an instance of a generic swing tree builder
     *  for anything extending the {@link JComponent} class.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param component The new component instance which ought to be part of the Swing UI.
     * @param &lt;T&gt; The concrete type of this new component.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( T component )
    {
<span class="fc" id="L546">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L547">        return new UIForSwing&lt;&gt;(component);</span>
    }

    /**
     *  This returns an instance of a Swing-Tree builder for a {@link JFrame} type.
     * @param frame The new frame instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     * @param &lt;F&gt; The concrete type of this new frame.
     */
    public static &lt;F extends JFrame&gt; UIForJFrame&lt;F&gt; of( F frame ) {
<span class="fc" id="L557">        return new UIForJFrame&lt;&gt;(frame);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JFrame()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame() {
<span class="fc" id="L567">        return new UIForJFrame&lt;&gt;(new JFrame());</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame} with the supplied title. &lt;br&gt;
     * @param title The title for the new frame.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame( String title ) {
<span class="fc" id="L576">        return new UIForJFrame&lt;&gt;(new JFrame()).withTitle(title);</span>
    }

    /**
     *  This returns an instance of a Swing-Tree builder for a {@link JDialog} type.
     * @param dialog The new dialog instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     * @param &lt;D&gt; The concrete type of this new dialog.
     */
    public static &lt;D extends JDialog&gt; UIForJDialog&lt;D&gt; of( D dialog ) {
<span class="fc" id="L586">        return new UIForJDialog&lt;&gt;(dialog);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JDialog()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog() {
<span class="fc" id="L596">        return new UIForJDialog&lt;&gt;(new JDialog());</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner ) {
<span class="nc" id="L605">        return new UIForJDialog&lt;&gt;(new JDialog(owner));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied title. &lt;br&gt;
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( String title ) {
<span class="nc" id="L614">        return new UIForJDialog&lt;&gt;(new JDialog()).withTitle(title);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner and title. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner, String title ) {
<span class="nc" id="L624">        return new UIForJDialog&lt;&gt;(new JDialog(owner)).withTitle(title);</span>
    }

    /**
     *  If you are using builders for your custom {@link JComponent},
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JComponent} types.
     * @param &lt;T&gt; The UI component type built by implementations of the provided builder.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( SwingBuilder&lt;T&gt; builder )
    {
<span class="nc" id="L638">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, SwingBuilder.class);</span>
<span class="nc" id="L639">        return of(builder.build());</span>
    }

    /**
     *  If you are using builders for custom {@link JMenuItem} components,
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JMenuItem} types.
     * @param &lt;M&gt; The {@link JMenuItem} type built by implementations of the provided builder.
     * @return A builder instance for a {@link JMenuItem}, which enables fluent method chaining.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( MenuBuilder&lt;M&gt; builder )
    {
<span class="nc" id="L653">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, MenuBuilder.class);</span>
<span class="nc" id="L654">        return new UIForMenuItem&lt;&gt;(builder.build());</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *
     * @param popup The new {@link JPopupMenu} instance which ought to be part of the Swing UI.
     * @param &lt;P&gt; The concrete type of this new component.
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
    public static &lt;P extends JPopupMenu&gt; UIForPopup&lt;P&gt; of( P popup )
    {
<span class="fc" id="L666">        NullUtil.nullArgCheck(popup, &quot;popup&quot;, JPopupMenu.class);</span>
<span class="fc" id="L667">        return new UIForPopup&lt;&gt;(popup);</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPopupMenu())}.
     *
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
<span class="fc" id="L676">    public static UIForPopup&lt;JPopupMenu&gt; popupMenu() { return of(new PopupMenu()); }</span>

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *
     * @param separator The new {@link JSeparator} instance which ought to be part of the Swing UI.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static &lt;S extends JSeparator&gt; UIForSeparator&lt;S&gt; of( S separator )
    {
<span class="fc" id="L687">        NullUtil.nullArgCheck(separator, &quot;separator&quot;, JSeparator.class);</span>
<span class="fc" id="L688">        return new UIForSeparator&lt;&gt;(separator);</span>
    }

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator())}.
     *
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
<span class="fc" id="L698">    public static UIForSeparator&lt;JSeparator&gt; separator() { return of(new JSeparator()); }</span>

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator(JSeparator.VERTICAL))}.
     *
     * @param align The alignment of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( Align align ) {
<span class="fc" id="L709">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L710">        return separator().with(align);</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JSeparator} whose
     *  alignment is dynamically determined based on a provided property.
     *
     * @param align The alignment property of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( Val&lt;Align&gt; align ) {
<span class="nc" id="L721">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L722">        return separator().withAlignment(align);</span>
    }

    /**
     *  This returns a {@link JButton} swing tree builder.
     *
     * @param component The button component which ought to be wrapped by the swing tree UI builder.
     * @return A basic UI {@link JButton} builder instance.
     */
    public static &lt;T extends AbstractButton&gt; UIForButton&lt;T&gt; of( T component )
    {
<span class="fc" id="L733">        NullUtil.nullArgCheck(component, &quot;component&quot;, AbstractButton.class);</span>
<span class="fc" id="L734">        return new UIForButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component without any text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton())}.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
<span class="fc" id="L743">    public static UIForButton&lt;JButton&gt; button() { return of(new Button()); }</span>

    /**
     *  Use this to create a builder for the {@link JButton} UI component with the provided text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton(String text))}.
     *
     * @param text The text to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
<span class="fc" id="L752">    public static UIForButton&lt;JButton&gt; button( String text ) { return button().withText(text); }</span>

    /**
     *  Create a builder for the {@link JButton} UI component where the text of the provided
     *  property is dynamically displayed on top.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Val&lt;String&gt; text ) {
<span class="fc" id="L761">        NullUtil.nullArgCheck( text, &quot;text&quot;, Val.class );</span>
<span class="fc" id="L762">        return button().withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).peek( it -&gt; it.setIcon(icon) )}.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon ) {
<span class="nc" id="L773">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L774">        return button().peek( it -&gt; it.setIcon(icon) );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a dynamically displayed icon on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).withIcon(icon) )}.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; buttonWithIcon( Val&lt;Icon&gt; icon ) {
<span class="nc" id="L785">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L786">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="nc" id="L787">        return button().withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover ) {
<span class="nc" id="L797">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L798">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="nc" id="L799">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top
     *  which should both be scaled to the provided dimensions.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, ImageIcon icon, ImageIcon onHover ) {
<span class="fc" id="L810">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L811">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, ImageIcon.class);</span>
<span class="fc" id="L812">        onHover = new ImageIcon(onHover.getImage().getScaledInstance(width, height, Image.SCALE_DEFAULT));</span>
<span class="fc" id="L813">        icon = new ImageIcon(icon.getImage().getScaledInstance(width, height, Image.SCALE_DEFAULT));</span>
<span class="fc" id="L814">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default, an on-hover and an on-press icon displayed on top.
     *  This is in essence a convenience method for:
     *  &lt;pre&gt;{@code 
     *      UI.of(new JButton()).peek( it -&gt; {
     *          it.setIcon(icon);
     *          it.setRolloverIcon(onHover);
     *          it.setPressedIcon(onPress);
     *      })
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover, Icon onPress ) {
<span class="fc" id="L832">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L833">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="fc" id="L834">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Icon.class);</span>
<span class="fc" id="L835">        return button().peek(it -&gt; it.setIcon(icon) )</span>
<span class="fc" id="L836">                .peek(it -&gt; it.setRolloverIcon(onHover) )</span>
<span class="fc" id="L837">                .peek(it -&gt; it.setPressedIcon(onPress) );</span>
    }

    /**
     *  Use this to create a builder for the {@link JSplitButton} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSplitButton())}.
     *
     * @return A builder instance for a {@link JSplitButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JSplitButton&gt; UIForSplitButton&lt;B&gt; of( B splitButton ) {
<span class="nc" id="L847">        NullUtil.nullArgCheck(splitButton, &quot;splitButton&quot;, JSplitButton.class);</span>
<span class="nc" id="L848">        return new UIForSplitButton&lt;&gt;(splitButton);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s with custom text displayed ont top.
     *  The {@link JSplitButton} wrapped by the returned builder can be populated
     *  with {@link JMenuItem}s like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Displayed on button!&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;).onButtonClick( it -&gt; ... ))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JSplitButton}
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     */
    public static UIForSplitButton&lt;JSplitButton&gt; splitButton( String text ) {
<span class="fc" id="L866">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L867">        return new UIForSplitButton&lt;&gt;(new JSplitButton(text));</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type, and the click event is
     *  handles by an {@link Event} instance. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *      private Event clickEvent = Event.of(()-&gt;{ ... }
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *      public Event clickEvent() { return clickEvent; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection(), vm.clickEvent())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the split button, the selected enum state
     *      will be converted to strings based on the {@link Object#toString()}
     *      method. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @param clickEvent The {@link Event} which will be fired when the user clicks on the button.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection, Event clickEvent ) {
<span class="fc" id="L902">        return splitButton(&quot;&quot;).withSelection(selection, clickEvent);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the button is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection ) {
<span class="fc" id="L931">        return splitButton(&quot;&quot;).withSelection(selection);</span>
    }

    /**
     *  Use this to add entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JMenuItem} exposed by the {@link JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( String text ) {
<span class="fc" id="L950">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L951">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add property bound entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(viewModel.getFirstButtonName()))
     *      .add(UI.splitItem(viewModel.getSecondButtonName()))
     *      .add(UI.splitItem(viewModel.getThirdButtonName()))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text property to dynamically display text on the {@link JMenuItem} exposed by the {@link JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( Val&lt;String&gt; text ) {
<span class="nc" id="L970">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L971">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add radio item entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitRadioItem(&quot;first&quot;))
     *      .add(UI.splitRadioItem(&quot;second&quot;))
     *      .add(UI.splitRadioItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JRadioButtonMenuItem} exposed by the {@link JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JRadioButtonMenuItem}.
     */
    public static SplitItem&lt;JRadioButtonMenuItem&gt; splitRadioItem( String text ) {
<span class="fc" id="L990">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L991">        return SplitItem.of(new JRadioButtonMenuItem(text));</span>
    }

    /**
     *  Creates a UI builder for a custom {@link JTabbedPane} type.
     *
     * @param pane The {@link JTabbedPane} type which should be used wrapped.
     * @return This instance, to allow for method chaining.
     * @param &lt;P&gt; The pane type parameter.
     */
    public static &lt;P extends JTabbedPane&gt; UIForTabbedPane&lt;P&gt; of( P pane ) {
<span class="fc" id="L1002">        NullUtil.nullArgCheck(pane, &quot;pane&quot;, JTabbedPane.class);</span>
<span class="fc" id="L1003">        return new UIForTabbedPane&lt;&gt;(pane);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTabbedPane())}.
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;one&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;two&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;three&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     *
     * @return A builder instance for a new {@link JTabbedPane}, which enables fluent method chaining.
     */
<span class="fc" id="L1022">    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane() { return of(new TabbedPane()); }</span>

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link Position} applied to the tab buttons
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.RIGHT)
     *      .add(UI.tab(&quot;first&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsPosition The position of the tab buttons which may be {@link Position#TOP}, {@link Position#RIGHT}, {@link Position#BOTTOM}, {@link Position#LEFT}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Position tabsPosition ) {
<span class="fc" id="L1043">        NullUtil.nullArgCheck(tabsPosition, &quot;tabsPosition&quot;, Position.class);</span>
<span class="fc" id="L1044">        return tabbedPane().with(tabsPosition);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link OverflowPolicy} and {@link Position} applied to the tab buttons 
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)} and {@link JTabbedPane#setTabPlacement(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.LEFT, OverflowPolicy.WRAP)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsPosition The position of the tab buttons which may be {@link Position#TOP}, {@link Position#RIGHT}, {@link Position#BOTTOM}, {@link Position#LEFT}.
     * @param tabsPolicy The overflow policy of the tab buttons which can either be {@link OverflowPolicy#SCROLL} or {@link OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} or {@code tabsPolicy} are {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Position tabsPosition, OverflowPolicy tabsPolicy ) {
<span class="nc" id="L1066">        NullUtil.nullArgCheck(tabsPosition, &quot;tabsPosition&quot;, Position.class);</span>
<span class="nc" id="L1067">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, OverflowPolicy.class);</span>
<span class="nc" id="L1068">        return tabbedPane().with(tabsPosition).with(tabsPolicy);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link OverflowPolicy} applied to the tab buttons (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(OverflowPolicy.SCROLL)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *  
     * @param tabsPolicy The overflow policy of the tab button which can either be {@link OverflowPolicy#SCROLL} or {@link OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPolicy} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( OverflowPolicy tabsPolicy ) {
<span class="nc" id="L1088">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, OverflowPolicy.class);</span>
<span class="nc" id="L1089">        return tabbedPane().with(Position.TOP).with(tabsPolicy);</span>
    }


    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectionIndex} property which should be determine the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *  Note that contrary to method {@link #tabbedPane(Var)}, this method receives a {@link Val}
     *  property which may not be changed by the GUI user. If you want to allow the user to change
     *  the selection index property state, use {@link #tabbedPane(Var)} instead.
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Val&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L1114">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectionIndex} property which should be determine the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Var&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L1135">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( String title ) {
<span class="fc" id="L1153">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class);</span>
<span class="fc" id="L1154">        return new Tab(null, null, Val.of(title), null, null, null, null, null, null);</span>
    }

    /**
     *  A factory method producing a {@link Tab} instance with the provided {@code title} property
     *  which can dynamically change the title of the tab button.
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(property1).add(UI.panel().add(..)))
     *      .add(UI.tab(property2).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(property3).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text property dynamically changing the title of the tab button when the property changes.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( Val&lt;String&gt; title ) {
<span class="fc" id="L1174">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1175">        return new Tab(null, null, title, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(new JButton(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(new JLabel(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(new JPanel()).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param component The component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static Tab tab( JComponent component ) {
<span class="nc" id="L1193">        NullUtil.nullArgCheck(component, &quot;component&quot;, Component.class);</span>
<span class="nc" id="L1194">        return new Tab(null, component, null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(UI.button(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(UI.label(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(UI.of(...)).with(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param builder The builder wrapping the component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code builder} is {@code null}.
     */
    public static Tab tab( UIForAnySwing&lt;?, ?&gt; builder ) {
<span class="fc" id="L1212">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, UIForAnySwing.class);</span>
<span class="fc" id="L1213">        return new Tab(null, builder.getComponent(), null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenu} instance.
     *
     * @return A builder instance for the provided {@link JMenu}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenu&gt; UIForMenu&lt;M&gt; of( M component ) {
<span class="nc" id="L1223">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenu.class);</span>
<span class="nc" id="L1224">        return new UIForMenu&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenuItem} instance.
     *
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( M component ) {
<span class="nc" id="L1234">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenuItem.class);</span>
<span class="nc" id="L1235">        return new UIForMenuItem&lt;&gt;(component);</span>
    }

    /**
     *  This factory method creates a {@link JMenu} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.menuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.menuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text ) {
<span class="fc" id="L1252">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1253">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L1261">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1262">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text);</span>
    }

    /**
     *  Use this factory method to create a {@link JMenuItem} with the
     *  provided text and default icon. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.menuItem(&quot;Hello&quot;, UI.icon(&quot;path/to/icon.png&quot;))
     *    .withTip(&quot;I give info!&quot;)
     *    .onClick( it -&gt; {...} )
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Icon icon ) {
<span class="nc" id="L1280">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1281">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1282">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L1283">                    .withText(text)</span>
<span class="nc" id="L1284">                    .withIcon(icon);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L1293">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1294">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1295">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem())</span>
<span class="nc" id="L1296">                    .withText(text)</span>
<span class="nc" id="L1297">                    .withIcon(icon);</span>
    }

    /**
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Val&lt;Icon&gt; icon ) {
<span class="nc" id="L1306">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1307">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1308">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text).withIcon(icon);</span>
    }

    /**
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Val&lt;Icon&gt; icon ) {
<span class="nc" id="L1317">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1318">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1319">        return new UIForMenuItem&lt;&gt;((JMenuItem) new MenuItem()).withText(text).withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToolBar} instance.
     *  Using method chaining you can populate the {@link JToolBar} by like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(myToolBar)
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param component The {@link JToolBar} instance to be wrapped.
     * @param &lt;T&gt; The type of the {@link JToolBar} instance to be wrapped.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;T extends JToolBar&gt; UIForToolBar&lt;T&gt; of( T component ) {
<span class="nc" id="L1340">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToolBar.class);</span>
<span class="nc" id="L1341">        return new UIForToolBar&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToolBar} instance.
     *  Use method chaining to add buttons or other components to a {@link JToolBar} by
     *  passing them to {@link UIForToolBar} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.toolBar()
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar() {
<span class="nc" id="L1361">        return new UIForToolBar&lt;&gt;(new ToolBar());</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link Align} enum defines the orientation of the {@link JToolBar}.
     *
     * @param align The {@link Align} enum which defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( Align align ) {
<span class="nc" id="L1373">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L1374">        return new UIForToolBar&lt;&gt;((JToolBar) new ToolBar()).with(align);</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link Val} property dynamically defines
     *  the orientation of the {@link JToolBar}
     *
     * @param align The {@link Val} property which dynamically defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( Val&lt;Align&gt; align ) {
<span class="nc" id="L1387">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L1388">        return new UIForToolBar&lt;&gt;((JToolBar) new ToolBar()).withAlignment(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JPanel} instance.
     *
     * @return A builder instance for the provided {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JPanel&gt; UIForPanel&lt;P&gt; of( P component ) {
<span class="fc" id="L1398">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPanel.class);</span>
<span class="fc" id="L1399">        return new UIForPanel&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager.
     *  This is in essence a convenience method for {@code UI.of(new JPanel(new MigLayout()))}.
     *
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
<span class="fc" id="L1409">    public static UIForPanel&lt;JPanel&gt; panel() { return of((JPanel) new Panel()).withLayout(new MigLayout(&quot;hidemode 2&quot;)); }</span>

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1425">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1426">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1427">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L1428">        return of((JPanel) new Panel()).withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LayoutAttr} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutAttr attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1445">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1446">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1447">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L1448">        return of((JPanel) new Panel()).withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints ) {
<span class="fc" id="L1463">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1464">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1465">        return of((JPanel) new Panel()).withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutAttr attr, String colConstraints ) {
<span class="fc" id="L1480">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1481">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1482">        return of((JPanel)new Panel()).withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr ) {
<span class="fc" id="L1497">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1498">        return of((JPanel) new Panel()).withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutAttr attr ) {
<span class="fc" id="L1510">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1511">        return panel(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component with a
     *  dynamically updated set of {@link MigLayout} attributes.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; panel( Val&lt;LayoutAttr&gt; attr ) {
<span class="fc" id="L1524">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L1525">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L1526">        return panel(attr.get().toString()).withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets
     *  based on a {@link MigLayout} as its layout manager.
     *  This factory method is especially useful for when you simply want to nest components
     *  in a {@link JPanel} without having to worry about the layout manager or the background
     *  color of the panel as it will be transparent and thus show the background of its parent.
     *  This is in essence a convenience method for {@code UI.panel(&quot;ins 0&quot;).makeNonOpaque()}.
     *
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     */
<span class="fc" id="L1539">    public static UIForPanel&lt;JPanel&gt; box() { return panel().withLayout(new MigLayout(&quot;ins 0, hidemode 2&quot;)).makeNonOpaque(); }</span>

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} based on the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints))).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; box( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1555">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1556">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1557">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1560">        return panel(attr, colConstraints, rowConstraints).makeNonOpaque();</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} based on the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints))).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LayoutAttr} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; box( LayoutAttr attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L1577">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1578">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1579">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L1580">        return box(attr.toString(), colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr+&quot;, ins 0&quot;, colConstraints))).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; box( String attr, String colConstraints ) {
<span class="fc" id="L1595">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L1596">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L1597" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L1598" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1599">        return panel(attr, colConstraints).makeNonOpaque();</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr+&quot;, ins 0&quot;, colConstraints))).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; box( LayoutAttr attr, String colConstraints ) {
<span class="fc" id="L1614">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1615">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L1616">        return box(attr.toString(), colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr+&quot;, ins 0&quot;))).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; box( String attr ) {
<span class="fc" id="L1631">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L1634">        return panel(attr).makeNonOpaque();</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets.
     *  This is in essence a convenience method for {@code UI.box(attr.toString()+&quot;, ins 0&quot;).makeNonOpaque()}.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a transparent {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; box( LayoutAttr attr ) {
<span class="fc" id="L1646">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutAttr.class);</span>
<span class="fc" id="L1647">        return box(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for a transparent {@link JPanel} without any insets and a
     *  dynamically updated set of {@link MigLayout} attributes.
     *  This is in essence a convenience method for
     *  {@code UI.of(new JPanel()).withLayout(attr.viewAsString( it -&gt; it+&quot;, ins 0&quot;))}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     */
    public static UIForPanel&lt;JPanel&gt; box( Val&lt;LayoutAttr&gt; attr ) {
<span class="nc" id="L1661">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L1662">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L1663">        return box().withLayout(attr.view( it -&gt; it.and(&quot;ins 0&quot;)));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JScrollPane} component.
     *
     * @param component The {@link JScrollPane} component which should be represented by the returned builder.
     * @return A {@link UIForScrollPane} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPane&gt; UIForScrollPane&lt;P&gt; of( P component ) {
<span class="fc" id="L1674">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="fc" id="L1675">        return new UIForScrollPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPane())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPane()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPane}, which enables fluent method chaining.
     */
<span class="fc" id="L1690">    public static UIForScrollPane&lt;JScrollPane&gt; scrollPane() { return of(new ScrollPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JScrollPanels} component.
     *
     * @param component The {@link JScrollPanels} component which should be represented by the returned builder.
     * @return A {@link UIForScrollPanels} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPanels&gt; UIForScrollPanels&lt;P&gt; of( P component ) {
<span class="fc" id="L1700">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="fc" id="L1701">        return new UIForScrollPanels&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels() {
<span class="fc" id="L1719">        return of(JScrollPanels.of(Align.VERTICAL, new Dimension(100,100)));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL)
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(Align align) {
<span class="nc" id="L1738">        return of(JScrollPanels.of(align, null));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL, new Dimension(100,100))
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @param size The size of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(Align align, Dimension size) {
<span class="nc" id="L1758">        return of(JScrollPanels.of(align, size));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSplitPane} instance.
     *
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JSplitPane&gt; UIForSplitPane&lt;P&gt; of( P component ) {
<span class="fc" id="L1768">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSplitPane.class);</span>
<span class="fc" id="L1769">        return new UIForSplitPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment enum determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitPane(UI.Align.HORIZONTAL) // The split bar will be horizontal
     *      .withDividerAt(50)
     *      .add(UI.panel().add(...)) // top
     *      .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( Align align ) {
<span class="fc" id="L1789">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L1790">        return of(new JSplitPane(align.forSplitPane()));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment property determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.splitPane(viewModel.getAlignment())
     *    .withDividerAt(50)
     *    .add(UI.panel().add(...)) // top
     *    .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  The split pane will be updated whenever the provided property changes.
     *  &lt;br&gt;
     *  &lt;b&gt;Note:&lt;/b&gt; The provided property must not be {@code null}!
     *  Otherwise, an {@link IllegalArgumentException} will be thrown.
     *  &lt;br&gt;
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( Val&lt;Align&gt; align ) {
<span class="fc" id="L1815">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="fc" id="L1816">        NullUtil.nullPropertyCheck(align, &quot;align&quot;, &quot;Null is not a valid alignment.&quot;);</span>
<span class="fc" id="L1817">        return of(new JSplitPane(align.get().forSplitPane()))</span>
<span class="fc" id="L1818">                .withAlignment(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JEditorPane} instance.
     *
     * @param component The {@link JEditorPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JEditorPane} instance.
     * @return A builder instance for the provided {@link JEditorPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JEditorPane&gt; UIForEditorPane&lt;P&gt; of( P component ) {
<span class="fc" id="L1830">        NullUtil.nullArgCheck(component, &quot;component&quot;, JEditorPane.class);</span>
<span class="fc" id="L1831">        return new UIForEditorPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JEditorPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JEditorPane())}.
     *
     * @return A builder instance for a new {@link JEditorPane}, which enables fluent method chaining.
     */
<span class="fc" id="L1840">    public static UIForEditorPane&lt;JEditorPane&gt; editorPane() { return of(new EditorPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JTextPane} instance.
     *
     * @param component The {@link JTextPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JTextPane} instance.
     * @return A builder instance for the provided {@link JTextPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JTextPane&gt; UIForTextPane&lt;P&gt; of( P component ) {
<span class="nc" id="L1851">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextPane.class);</span>
<span class="nc" id="L1852">        return new UIForTextPane&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextPane())}.
     *
     * @return A builder instance for a new {@link JTextPane}, which enables fluent method chaining.
     */
<span class="nc" id="L1861">    public static UIForTextPane&lt;JTextPane&gt; textPane() { return of(new TextPane()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JSlider} instance.
     *
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;S extends JSlider&gt; UIForSlider&lt;S&gt; of( S component ) {
<span class="fc" id="L1870">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSlider.class);</span>
<span class="fc" id="L1871">        return new UIForSlider&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type determining if
     *  the slider will be aligned vertically or horizontally.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align ) {
<span class="fc" id="L1886">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L1887">        return of((JSlider) new Slider()).with(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment property which dynamically
     *  determines if the property is aligned vertically or horizontally.
     *
     * @param align The alignment property determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if the {@code align} property is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( Val&lt;Align&gt; align ) {
<span class="nc" id="L1902">        NullUtil.nullArgCheck( align, &quot;align&quot;, Val.class );</span>
<span class="nc" id="L1903">        return of((JSlider) new Slider()).withAlignment(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type, min slider value and max slider value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max ) {
<span class="nc" id="L1922">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L1923">        return of((JSlider) new Slider())</span>
<span class="nc" id="L1924">                    .with(align)</span>
<span class="nc" id="L1925">                    .withMin(min)</span>
<span class="nc" id="L1926">                    .withMax(max)</span>
<span class="nc" id="L1927">                    .withValue((min + max) / 2);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and initial values.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value  the initial value of the slider
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, int value ) {
<span class="nc" id="L1947">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L1948">        return of((JSlider) new Slider())</span>
<span class="nc" id="L1949">                .with(align)</span>
<span class="nc" id="L1950">                .withMin(min)</span>
<span class="nc" id="L1951">                .withMax(max)</span>
<span class="nc" id="L1952">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L1972">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="nc" id="L1973">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="nc" id="L1974">        return of((JSlider) new Slider())</span>
<span class="nc" id="L1975">                .with(align)</span>
<span class="nc" id="L1976">                .withMin(min)</span>
<span class="nc" id="L1977">                .withMax(max)</span>
<span class="nc" id="L1978">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider( Align align, int min, int max, Var&lt;Integer&gt; value ) {
<span class="fc" id="L1998">        NullUtil.nullArgCheck(align, &quot;align&quot;, Align.class);</span>
<span class="fc" id="L1999">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="fc" id="L2000">        return of((JSlider) new Slider())</span>
<span class="fc" id="L2001">                .with(align)</span>
<span class="fc" id="L2002">                .withMin(min)</span>
<span class="fc" id="L2003">                .withMax(max)</span>
<span class="fc" id="L2004">                .withValue(value);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JComboBox} instance.
     *
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     */
    public static &lt;E, C extends JComboBox&lt;E&gt;&gt; UIForCombo&lt;E,C&gt; of( C component ) {
<span class="fc" id="L2013">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComboBox.class);</span>
<span class="fc" id="L2014">        return new UIForCombo&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JComboBox())}.
     *
     * @return A builder instance for a new {@link JComboBox}, which enables fluent method chaining.
     */
<span class="fc" id="L2023">    public static UIForCombo&lt;Object,JComboBox&lt;Object&gt;&gt; comboBox() { return of(new ComboBox&lt;&gt;()); }</span>

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  with the provided array of elements as selectable items.
     *
     * @param items The array of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( E... items ) {
<span class="fc" id="L2036">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class);</span>
<span class="fc" id="L2037">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  with the provided array of elements as selectable items which
     *  may not be modified by the user.
     *
     * @param items The unmodifiable array of elements to be selectable in the {@link JList}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( E... items ) {
<span class="fc" id="L2051">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class); // Unmodifiable</span>
<span class="fc" id="L2052">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(java.util.Arrays.asList(items));</span>
<span class="fc" id="L2053">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  where the provided enum based property dynamically models the selected item
     *  as well as all possible options (all the enum states).
     *  The property will be updated whenever the user
     *  selects a new item in the {@link JComboBox} and the {@link JComboBox}
     *  will be updated whenever the property changes in your code (see {@link Var#set(Object)}).
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.comboBox(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the combo box is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selectedItem A property modelling the selected item in the combo box.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem ) {
<span class="fc" id="L2087">        NullUtil.nullArgCheck(selectedItem, &quot;var&quot;, Var.class);</span>
        // We get an array of possible enum states from the enum class
<span class="fc" id="L2089">        return comboBox(selectedItem.type().getEnumConstants()).withSelectedItem(selectedItem);</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided list of elements as selectable items.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( java.util.List&lt;E&gt; items ) {
<span class="fc" id="L2101">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L2102">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ListBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided list of elements as selectable items which
     *  may not be modified by the user.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( java.util.List&lt;E&gt; items ) {
<span class="nc" id="L2115">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="nc" id="L2116">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(items);</span>
<span class="nc" id="L2117">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, java.util.List&lt;E&gt; items ) {
<span class="fc" id="L2133">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L2134">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L2135">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ListBasedComboModel&lt;&gt;(selection, items));</span>
    }

    //___

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and mutable) items.
     *
     * @param items The {@link Vars} properties of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vars&lt;E&gt; items ) {
<span class="fc" id="L2149">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L2150">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new VarsBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and immutable) items which
     *  may not be modified by the user.
     *
     * @param items The {@link sprouts.Vals} properties of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vals&lt;E&gt; items ) {
<span class="nc" id="L2163">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L2164">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ValsBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vars&lt;E&gt; items ) {
<span class="fc" id="L2180">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L2181">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L2182">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new VarsBasedComboModel&lt;&gt;(selection, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a property list of items as a dynamically sized model for the
     *  selectable items which may not be modified by the user.
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vals&lt;E&gt; items ) {
<span class="nc" id="L2196">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L2197">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L2198">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ValsBasedComboModel&lt;&gt;(selection, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array of items as a fixed-size model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The array of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, E... items ) {
<span class="fc" id="L2214">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L2215">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayBasedComboModel&lt;&gt;(var, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The property holding an array of selectable items which can be mutated by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, Var&lt;E[]&gt; items ) {
<span class="fc" id="L2231">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="fc" id="L2232">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayPropertyComboModel&lt;&gt;(var, items));</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param selectedItem The property holding the current selection.
     * @param items The property holding an array of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem, Val&lt;E[]&gt; items ) {
<span class="nc" id="L2248">        NullUtil.nullArgCheck(items, &quot;items&quot;, List.class);</span>
<span class="nc" id="L2249">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
<span class="nc" id="L2250">        return of((JComboBox&lt;E&gt;) new ComboBox&lt;E&gt;()).withModel(new ArrayPropertyComboModel&lt;&gt;(selectedItem, items));</span>
    }

    /**
     *  Created a combo box UI builder node with the provided {@link ComboBoxModel}.
     *
     * @param model The model to be used by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( ComboBoxModel&lt;E&gt; model ) {
<span class="nc" id="L2261">        NullUtil.nullArgCheck(model, &quot;model&quot;, ComboBoxModel.class);</span>
<span class="nc" id="L2262">        JComboBox&lt;E&gt; c = new ComboBox&lt;E&gt;();</span>
<span class="nc" id="L2263">        c.setModel(model);</span>
<span class="nc" id="L2264">        return of(c);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSpinner} instance.
     *
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static &lt;S extends JSpinner&gt; UIForSpinner&lt;S&gt; of( S spinner ) {
<span class="fc" id="L2273">        NullUtil.nullArgCheck(spinner, &quot;spinner&quot;, JSpinner.class);</span>
<span class="fc" id="L2274">        return new UIForSpinner&lt;&gt;(spinner);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSpinner} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSpinner())}.
     *
     * @return A builder instance for a new {@link JSpinner}, which enables fluent method chaining.
     */
<span class="fc" id="L2283">    public static UIForSpinner&lt;JSpinner&gt; spinner() { return of(new Spinner()); }</span>

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@link SpinnerModel} as the model.
     *
     * @param model The {@link SpinnerModel} to be used by the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( SpinnerModel model ) {
<span class="nc" id="L2293">        NullUtil.nullArgCheck(model, &quot;model&quot;, SpinnerModel.class);</span>
<span class="nc" id="L2294">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(model) );</span>
    }

    /**
     *  Use this factory method to create a {@link JSpinner} bound to a property of any type.
     *  The property will be updated when the user modifies its value.
     *
     * @param value A property of any type which should be bound to this spinner.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( Var&lt;?&gt; value ) {
<span class="fc" id="L2305">        NullUtil.nullArgCheck(value, &quot;value&quot;, Var.class);</span>
<span class="fc" id="L2306">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the spinner should not be null!&quot;);</span>
<span class="fc" id="L2307">        return spinner().withValue(value);</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max}, default {@code value} and {@code step} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @param step The step size of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max, int step ) {
<span class="nc" id="L2321">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, step)) );</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max} and default {@code value} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max ) {
<span class="fc" id="L2334">        return of((JSpinner) new Spinner()).peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, 1)) );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JLabel} instance.
     *
     * @param component The {@link JLabel} instance to be used by the builder.
     * @return A builder instance for the provided {@link JLabel}, which enables fluent method chaining.
     */
    public static &lt;L extends JLabel&gt; UIForLabel&lt;L&gt; of( L component ) {
<span class="fc" id="L2344">        NullUtil.nullArgCheck(component, &quot;component&quot;, JLabel.class);</span>
<span class="fc" id="L2345">        return new UIForLabel&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(text)}.
     *
     * @param text The text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text ) {
<span class="fc" id="L2356">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2357">        return of((JLabel) new Label()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(Val&lt;String&gt; text)}.
     *
     * @param text The text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Val&lt;String&gt; text ) {
<span class="fc" id="L2368">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L2369">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2370">        return of((JLabel) new Label())</span>
<span class="pc bpc" id="L2371" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L2372">                .withText(text);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Icon icon ) {
<span class="nc" id="L2382">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2383">        return of((JLabel) new Label()).with(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon dynamically.
     *
     * @param icon The icon property which should dynamically provide a desired icon for the {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; labelWithIcon( Val&lt;Icon&gt; icon ) {
<span class="nc" id="L2393">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L2394">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;Null icons are not allowed!&quot;);</span>
<span class="nc" id="L2395">        return of((JLabel) new Label()).withIcon(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param width The width of the icon when displayed on the label.
     * @param height The height of the icon when displayed on the label.
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( int width, int height, ImageIcon icon ) {
<span class="fc" id="L2407">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L2408">        return of((JLabel) new Label())</span>
<span class="fc" id="L2409">                .with(new ImageIcon(icon.getImage().getScaledInstance(width, height, Image.SCALE_DEFAULT)));</span>
    }

    /**
     *  Use this to create a UI builder for a {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(String text).makeBold()}.
     *  @param text The text which should be displayed on the label.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( String text ) {
<span class="fc" id="L2419">        return of((JLabel) new Label()).withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a UI builder for a bound {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(Val&lt;String&gt; text).makeBold()}.
     *  @param text The text property which should be displayed on the label dynamically.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( Val&lt;String&gt; text ) {
<span class="fc" id="L2429">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L2430">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2431">        return of((JLabel) new Label()).withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( String text ) {
<span class="nc" id="L2442">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2443">        return of((JLabel) new Label()).withText(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;);</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( Val&lt;String&gt; text ) {
<span class="nc" id="L2454">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2455">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2456">        return of((JLabel) new Label())</span>
<span class="nc bnc" id="L2457" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2458">                .withText(text.view( it -&gt; &quot;&lt;html&gt;&quot; + it + &quot;&lt;/html&gt;&quot;));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text ) {
<span class="fc" id="L2470">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2471">        return of((JCheckBox) new CheckBox()).withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance where the provided
     *  text property dynamically displays its value on the checkbox.
     *
     * @param text The text property which should be bound to the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text ) {
<span class="fc" id="L2483">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2484">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2485">        return of((JCheckBox) new CheckBox())</span>
<span class="nc bnc" id="L2486" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2487">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  where the provided text property dynamically displays its value on the checkbox
     *  and the provided selection property dynamically determines whether the checkbox
     *  is selected or not.
     *
     * @param text The text property which should be bound to the checkbox.
     *             This is the text which is displayed on the checkbox.
     * @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L2503">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L2504">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="nc" id="L2505">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2506">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="nc" id="L2507">        return of((JCheckBox) new CheckBox())</span>
<span class="nc bnc" id="L2508" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="nc" id="L2510">                .withText(text)</span>
<span class="nc" id="L2511">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the checkbox is selected or not.
     *  @param text The text which should be displayed on the checkbox.
     *  @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     *  @return A builder instance for the checkbox, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L2524">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2525">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="fc" id="L2526">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="fc" id="L2527">        return of((JCheckBox) new CheckBox())</span>
<span class="pc bpc" id="L2528" title="1 of 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="fc" id="L2529">                .withText(text)</span>
<span class="fc" id="L2530">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JCheckBox} instance.
     *
     * @return A builder instance for the provided {@link JCheckBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided checkbox is null.
     */
    public static &lt;B extends JCheckBox&gt; UIForCheckBox&lt;B&gt; of( B component ) {
<span class="fc" id="L2540">        NullUtil.nullArgCheck(component, &quot;component&quot;, JCheckBox.class);</span>
<span class="fc" id="L2541">        return new UIForCheckBox&lt;&gt;(component);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text ) {
<span class="fc" id="L2553">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2554">        return of((JRadioButton) new RadioButton()).withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance where the provided
     *  text property dynamically displays its value on the radio button.
     *
     * @param text The text property which should be bound to the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text ) {
<span class="fc" id="L2565">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2566">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2567">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2569">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  where the provided text property dynamically displays its value on the radio button
     *  and the provided selection property dynamically determines whether the radio button
     *  is selected or not.
     *
     * @param text The text property which should be bound to the radio button.
     *             This is the text which is displayed on the radio button.
     * @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L2585">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L2586">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L2587">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2588">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2589">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L2590" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">                .applyIf(!selected.hasNoID(), it -&gt; it.id(selected.id()))</span>
<span class="nc" id="L2592">                .withText(text)</span>
<span class="nc" id="L2593">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the radio button is selected or not.
     *  @param text The text which should be displayed on the radio button.
     *  @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     *  @return A builder instance for the radio button, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L2606">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2607">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L2608">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2609">        return of((JRadioButton) new RadioButton())</span>
<span class="nc" id="L2610">                .withText(text)</span>
<span class="nc" id="L2611">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  dynamically bound to an enum based {@link sprouts.Var}
     *  instance which will be used to dynamically model the selection state of the
     *  wrapped {@link JToggleButton} type by checking
     *  weather the property matches the provided enum or not.
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.panel()
     *      .add(UI.radioButton(Size.SMALL,  vm.selection())
     *      .add(UI.radioButton(Size.MEDIUM, vm.selection())
     *      .add(UI.radioButton(Size.LARGE,  vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the radio buttons, the enums will be converted
     *      to strings using {@link Object#toString()} method.
     *      If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param state The reference {@link Enum} which this {@link JToggleButton} should represent.
     * @param selection The {@link sprouts.Var} instance which will be used
     *                  to dynamically model the selection state of the wrapped {@link JToggleButton} type.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForRadioButton&lt;JRadioButton&gt; radioButton( E state, Var&lt;E&gt; selection ) {
<span class="nc" id="L2651">        NullUtil.nullArgCheck(state, &quot;state&quot;, Enum.class);</span>
<span class="nc" id="L2652">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L2653">        NullUtil.nullPropertyCheck(selection, &quot;selection&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2654">        return of((JRadioButton) new RadioButton())</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                .applyIf(!selection.hasNoID(), it -&gt; it.id(selection.id()))</span>
<span class="nc" id="L2656">                .isSelectedIf( state, selection );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JRadioButton} instance.
     *
     * @param component The {@link JRadioButton} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JRadioButton}, which enables fluent method chaining.
     */
    public static &lt;R extends JRadioButton&gt; UIForRadioButton&lt;R&gt; of( R component ) {
<span class="fc" id="L2666">        NullUtil.nullArgCheck(component, &quot;component&quot;, JRadioButton.class);</span>
<span class="fc" id="L2667">        return new UIForRadioButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a {@link JToggleButton} instance.
     *
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
<span class="fc" id="L2675">    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton() { return of(new JToggleButton()); }</span>

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it.
     *
     * @param text The text which should be displayed on the toggle button.
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text ) {
<span class="fc" id="L2685">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2686">        return of(new JToggleButton(text));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button.
     *
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text ) {
<span class="nc" id="L2696">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2697">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2698">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2700">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param  isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L2710">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="nc" id="L2711">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L2713">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *  @param text The text which should be displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L2725">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2726">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="fc" id="L2727">        return of(new JToggleButton())</span>
<span class="fc" id="L2728">                .withText(text)</span>
<span class="fc" id="L2729">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param text The text property which should be bound to the toggle button.
     *             This is the text which is displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L2742">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L2743">        NullUtil.nullArgCheck(isToggled, &quot;isToggled&quot;, Var.class);</span>
<span class="fc" id="L2744">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="pc" id="L2745">        return of(new JToggleButton())</span>
<span class="pc bpc" id="L2746" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="pc bpc" id="L2747" title="1 of 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L2748">                .withText(text)</span>
<span class="nc" id="L2749">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon ) {
<span class="nc" id="L2760">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2761">        return of(new JToggleButton(icon));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon, Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L2774">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2775">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2776">        return of(new JToggleButton(icon))</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L2778">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link Icon} property dynamically displays its value on the toggle button.
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;Icon&gt; icon ) {
<span class="nc" id="L2789">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L2790">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2791">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc" id="L2793">                .withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link Icon} property dynamically displays its value on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;Icon&gt; icon, Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L2806">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L2807">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2808">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L2809">        return of(new JToggleButton())</span>
<span class="nc bnc" id="L2810" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L2812">                .withIcon(icon)</span>
<span class="nc" id="L2813">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToggleButton} instance.
     *
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JToggleButton&gt; UIForToggleButton&lt;B&gt; of( B component ) {
<span class="fc" id="L2822">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToggleButton.class);</span>
<span class="fc" id="L2823">        return new UIForToggleButton&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextField} instance.
     *
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;F extends JTextField&gt; UIForTextField&lt;F&gt; of( F component ) {
<span class="fc" id="L2832">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextComponent.class);</span>
<span class="fc" id="L2833">        return new UIForTextField&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( String text ) {
<span class="fc" id="L2844">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2845">        return of((JTextField) new TextField()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Val&lt;String&gt; text ) {
<span class="nc" id="L2858">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2859">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2860">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L2861" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2862">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Var&lt;String&gt; text ) {
<span class="fc" id="L2874">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L2875">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L2876">        return of((JTextField) new TextField())</span>
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L2878">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextField())}.
     *
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
<span class="fc" id="L2887">    public static UIForTextField&lt;JTextField&gt; textField() { return of((JTextField) new TextField()); }</span>

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field.
     *  The property is a {@link Var}, meaning that it can be modified by the user.
     *  &lt;p&gt;
     *  The number property will only receive values if the text field contains a valid number.
     *
     * @param number The number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number ) {
<span class="nc" id="L2900">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="nc" id="L2901">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="nc" id="L2902">        return of((JTextField) new TextField())</span>
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="nc" id="L2904">                .withNumber(number);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field
     *  and a boolean property which will be set to {@code true} if the text field contains a valid number,
     *  and {@code false} otherwise.
     *  &lt;p&gt;
     *  The number property will only receive values if the text in the text field can be parsed as a number,
     *  in which case the provided {@link Var} will be set to {@code true}, otherwise it will be set to {@code false}.
     *
     * @param number The number property which should be bound to the text field.
     * @param isValid A {@link Var} which will be set to {@code true} if the text field contains a valid number,
     *                and {@code false} otherwise.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number, Var&lt;Boolean&gt; isValid ) {
<span class="fc" id="L2922">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="fc" id="L2923">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="fc" id="L2924">        return of((JTextField) new TextField())</span>
<span class="pc bpc" id="L2925" title="1 of 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="fc" id="L2926">                .withNumber(number, isValid);</span>
    }


    /**
     *  Use this to create a builder for the provided {@link JFormattedTextField} instance.
     *
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField of( JFormattedTextField component ) {
<span class="fc" id="L2936">        NullUtil.nullArgCheck(component, &quot;component&quot;, JFormattedTextField.class);</span>
<span class="fc" id="L2937">        return new UIForFormattedTextField(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( String text ) {
<span class="fc" id="L2948">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L2949">        return of(new JFormattedTextField(text));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Val&lt;String&gt; text ) {
<span class="nc" id="L2962">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2963">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2964">        return of(new JFormattedTextField())</span>
<span class="nc bnc" id="L2965" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2966">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the formatted text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the formatted text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Var&lt;String&gt; text ) {
<span class="nc" id="L2978">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L2979">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L2980">        return of(new JFormattedTextField())</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L2982">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JFormattedTextField())}.
     *
     * @return A builder instance for a new {@link JFormattedTextField}, which enables fluent method chaining.
     */
<span class="nc" id="L2991">    public static UIForFormattedTextField formattedTextField() { return of(new JFormattedTextField()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JPasswordField} instance.
     *
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static &lt;F extends JPasswordField&gt; UIForPasswordField&lt;F&gt; of( F component ) {
<span class="fc" id="L2999">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPasswordField.class);</span>
<span class="fc" id="L3000">        return new UIForPasswordField&lt;&gt;(component);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text as the initial password.
     *
     * @param text The initial password which should be displayed on the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( String text ) {
<span class="fc" id="L3011">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3012">        return of((JPasswordField) new PasswordField()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the password field.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Val&lt;String&gt; text ) {
<span class="nc" id="L3025">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3026">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3027">        return of(new JPasswordField())</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3029">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Var&lt;String&gt; text ) {
<span class="fc" id="L3041">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3042">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3043">        return of(new JPasswordField())</span>
<span class="pc bpc" id="L3044" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L3045">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPasswordField())}.
     *
     * @return A builder instance for a new {@link JPasswordField}, which enables fluent method chaining.
     */
<span class="nc" id="L3054">    public static UIForPasswordField&lt;JPasswordField&gt; passwordField() { return of(new JPasswordField()); }</span>

    /**
     *  Use this to create a builder for the provided {@link JTextArea} instance.
     *
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static &lt;A extends JTextArea&gt; UIForTextArea&lt;A&gt; of( A area ) {
<span class="fc" id="L3062">        NullUtil.nullArgCheck(area, &quot;area&quot;, JTextArea.class);</span>
<span class="fc" id="L3063">        return new UIForTextArea&lt;&gt;(area);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text as the initial text.
     *
     * @param text The initial text which should be displayed on the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( String text ) {
<span class="fc" id="L3074">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3075">        return of((JTextArea) new TextArea()).withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text area.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Val&lt;String&gt; text ) {
<span class="nc" id="L3088">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3089">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3090">        return of((JTextArea) new TextArea())</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3092">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Var&lt;String&gt; text ) {
<span class="fc" id="L3104">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L3105">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3106">        return of((JTextArea) new TextArea())</span>
<span class="pc bpc" id="L3107" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L3108">                .withText(text);</span>
    }

    /**
     *  A convenience method for creating a builder for a {@link JTextArea} with a certain text alignment.
     *  This is a shortcut version for the following code:
     *  &lt;pre&gt;{@code
     *      UI.textArea()
     *          .withTextOrientation(UI.HorizontalDirection.RIGHT_TO_LEFT);
     *  }&lt;/pre&gt;
     * The provided {@link UI.HorizontalDirection} translates to {@link ComponentOrientation}
     * instances which are used to align the elements or text within the wrapped {@link JTextComponent}.
     * {@link LayoutManager} and {@link Component}
     * subclasses will use this property to
     * determine how to lay out and draw components.
     *
     * @param direction The text orientation type which should be used.
     * @return A builder instance for a new {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( UI.HorizontalDirection direction ) {
<span class="nc" id="L3128">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalDirection.class);</span>
<span class="nc" id="L3129">        return of((JTextArea) new TextArea()).withTextOrientation(direction);</span>
    }

    /**
     *  A convenience method for creating a builder for a {@link JTextArea} with a certain text and text alignment.
     *  This is a shortcut version for the following code:
     *  &lt;pre&gt;{@code
     *      UI.textArea()
     *          .withTextOrientation(UI.HorizontalDirection.RIGHT_TO_LEFT)
     *          .withText(text);
     *  }&lt;/pre&gt;
     * The provided {@link UI.HorizontalDirection} translates to {@link ComponentOrientation}
     * instances which are used to align the elements or text within the wrapped {@link JTextComponent}.
     * {@link LayoutManager} and {@link Component}
     * subclasses will use this property to
     * determine how to lay out and draw components.
     *
     * @param direction The text orientation type which should be used.
     * @param text The new text to be set for the wrapped text component type.
     * @return A builder instance for a new {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( UI.HorizontalDirection direction, String text ) {
<span class="fc" id="L3151">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalDirection.class);</span>
<span class="fc" id="L3152">        return of((JTextArea) new TextArea()).withTextOrientation(direction).withText(text);</span>
    }

    public static UIForTextArea&lt;JTextArea&gt; textArea( UI.HorizontalDirection direction, Val&lt;String&gt; text ) {
<span class="nc" id="L3156">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalDirection.class);</span>
<span class="nc" id="L3157">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3158">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3159">        return of((JTextArea) new TextArea())</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3161">                .withTextOrientation(direction)</span>
<span class="nc" id="L3162">                .withText(text);</span>
    }

    public static UIForTextArea&lt;JTextArea&gt; textArea( UI.HorizontalDirection direction, Var&lt;String&gt; text ) {
<span class="fc" id="L3166">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, HorizontalDirection.class);</span>
<span class="fc" id="L3167">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L3168">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3169">        return of((JTextArea) new TextArea())</span>
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3171">                .withTextOrientation(direction)</span>
<span class="nc" id="L3172">                .withText(text);</span>
    }

    /**
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; of( JList&lt;E&gt; list ) {
<span class="fc" id="L3180">        NullUtil.nullArgCheck(list, &quot;list&quot;, JList.class);</span>
<span class="fc" id="L3181">        return new UIForList&lt;&gt;(list);</span>
    }

    /**
     * @return A builder instance for a new {@link JList}.
     */
<span class="nc" id="L3187">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list() { return of(new List&lt;&gt;()); }</span>

    /**
     * @param model The model which should be used for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( ListModel&lt;E&gt; model ) {
<span class="nc" id="L3195">        NullUtil.nullArgCheck(model, &quot;model&quot;, ListModel.class);</span>
<span class="nc" id="L3196">        JList&lt;E&gt; list = new List&lt;&gt;();</span>
<span class="nc" id="L3197">        list.setModel(model);</span>
<span class="nc" id="L3198">        return of(list);</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided array
     *  as data model.
     *  This is functionally equivalent to {@link #listOf(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( E... elements ) {
<span class="fc" id="L3212">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Object[].class);</span>
<span class="fc" id="L3213">        return of(new List&lt;E&gt;()).withEntries( elements );</span>
    }

    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Vals&lt;E&gt; elements ) {
<span class="fc" id="L3217">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="fc" id="L3218">        return of(new List&lt;E&gt;()).withEntries( elements );</span>
    }

    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Var&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="nc" id="L3222">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L3223">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="nc" id="L3224">        return of(new List&lt;E&gt;()).withEntries( elements ).withSelection( selection );</span>
    }

    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Val&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="nc" id="L3228">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Val.class);</span>
<span class="nc" id="L3229">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="nc" id="L3230">        return of(new List&lt;E&gt;()).withEntries( elements ).withSelection( selection );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided array
     *  as data model.
     *  This is functionally equivalent to {@link #list(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
<span class="fc" id="L3243">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( E... elements ) { return list( elements ); }</span>

    /**
     *  Creates a new {@link JList} instance with the provided {@link List}
     *  as data model.
     *  This is functionally equivalent to {@link #listOf(java.util.List)}.
     *
     * @return A builder instance for a new {@link JList} with the provided {@link List} as data model.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( java.util.List&lt;E&gt; entries ) {
<span class="fc" id="L3253">        return of(new List&lt;E&gt;()).withEntries( entries );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided {@link List}
     *  as data model.
     *  This is functionally equivalent to {@link #list(java.util.List)}.
     *
     * @param entries The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided {@link List} as data model.
     */
<span class="fc" id="L3265">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( java.util.List&lt;E&gt; entries ) { return list( entries ); }</span>

    /**
     * @param table The table which should be wrapped by the builder.
     * @param &lt;T&gt; The {@link JTable} type.
     * @return A builder instance for a new {@link JTable}.
     */
    public static &lt;T extends JTable&gt; UIForTable&lt;T&gt; of( T table ) {
<span class="fc" id="L3273">        NullUtil.nullArgCheck(table, &quot;table&quot;, JTable.class);</span>
<span class="fc" id="L3274">        return new UIForTable&lt;&gt;(table);</span>
    }

<span class="fc" id="L3277">    public static UIForTable&lt;JTable&gt; table() { return of(new Table()); }</span>

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a list of lists of entries.  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link java.util.List} which gets modified), the table model will not be updated automatically!
     *      Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( ListData dataFormat, TableListDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L3294">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, ListData.class);</span>
<span class="fc" id="L3295">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableListDataSource.class);</span>
<span class="fc" id="L3296">        return of((JTable) new Table()).with(dataFormat, dataSource);</span>
    }

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a map of column names to lists of table entries (basically a column major matrix).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link Map} which gets modified), the table model will not be updated automatically!
     *      Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( MapData dataFormat, TableMapDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L3314">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, ListData.class);</span>
<span class="fc" id="L3315">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableMapDataSource.class);</span>
<span class="fc" id="L3316">        return of((JTable) new Table()).with(dataFormat, dataSource);</span>
    }

    public static UIForTable&lt;JTable&gt; table( Buildable&lt;BasicTableModel&gt; tableModelBuildable ) {
<span class="fc" id="L3320">        return of((JTable) new Table()).withModel(tableModelBuildable);</span>
    }

    /**
     * @return A functional API for building a {@link javax.swing.table.TableModel}.
     */
<span class="fc" id="L3326">    public static BasicTableModel.Builder tableModel() { return new BasicTableModel.Builder(); }</span>

    public static Render.Builder&lt;JTable, Object&gt; renderTable() {
<span class="fc" id="L3329">        return Render.forTable(Object.class, null).when(Object.class).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a list cell renderer for various item types without
     *  a meaningful common super-type (see {@link #renderList(Class)}).
     *  You would typically want to use this method to render generic types where the only
     *  common type is {@link Object}, yet you want to render the item
     *  in a specific way depending on their actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(new Object[]{&quot;:-)&quot;, 42L, ''})
     *  .withRenderer(
     *      UI.renderList()
     *      .when(String.class).asText( cell -&gt; &quot;String: &quot;+cell.getValue() )
     *      .when(Character.class).asText( cell -&gt; &quot;Char: &quot;+cell.getValue() )
     *      .when(Number.class).asText( cell -&gt; &quot;Number: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item types should be rendered.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderList() {
<span class="nc" id="L3353">        return Render.forList(Object.class, null).when(Object.class).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a list cell renderer for a specific item type and its subtype.
     *  You would typically want to use this method to render generic types like {@link Object}
     *  where you want to render the item in a specific way depending on its actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(new Number[]{1f, 42L, 4.20d})
     *  .withRenderer(
     *      UI.renderList(Number.class)
     *      .when(Integer.class).asText( cell -&gt; &quot;Integer: &quot;+cell.getValue() )
     *      .when(Long.class).asText( cell -&gt; &quot;Long: &quot;+cell.getValue() )
     *      .when(Float.class).asText( cell -&gt; &quot;Float: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param commonType The common type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item types should be rendered.
     * @param &lt;T&gt; The common super-type type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.Builder&lt;JList&lt;T&gt;, T&gt; renderList( Class&lt;T&gt; commonType ) {
<span class="pc" id="L3377">        return Render.forList(commonType, null).when(commonType).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a list cell renderer for a specific item type.
     *  What you would typically want to do is customize the text that should be displayed
     *  for a specific item type. &lt;br&gt;
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.list(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
     *  .withRenderer(
     *      UI.renderListItem(String.class)
     *      .asText(cell -&gt; cell.getValue().toLowerCase())
     *  );
     *  }&lt;/pre&gt;
     *
     * @param itemType The type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item type should be rendered.
     * @param &lt;T&gt; The type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.As&lt;JList&lt;T&gt;, T, T&gt; renderListItem( Class&lt;T&gt; itemType ) {
<span class="fc" id="L3399">        return Render.forList(itemType, null).when(itemType);</span>
    }

    /**
     *  Use this to create a generic combo box renderer for various item types without
     *  a meaningful common super-type (see {@link #renderCombo(Class)}).
     *  You would typically want to use this method to render generic types where the only
     *  common type is {@link Object}, yet you want to render the item
     *  in a specific way depending on their actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(new Object[]{&quot;:-)&quot;, 42L, ''})
     *  .withRenderer(
     *      UI.renderCombo()
     *      .when(String.class).asText( cell -&gt; &quot;String: &quot;+cell.getValue() )
     *      .when(Character.class).asText( cell -&gt; &quot;Char: &quot;+cell.getValue() )
     *      .when(Number.class).asText( cell -&gt; &quot;Number: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @return A render builder exposing an API that allows you to configure how he passed item types should be rendered.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderCombo() {
<span class="nc" id="L3422">        return Render.forCombo(Object.class, null).when(Object.class).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to create a combo box renderer for a specific item type and its subtype.
     *  You would typically want to use this method to render generic types like {@link Object}
     *  where you want to render the item in a specific way depending on its actual type.
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(new Number[]{1f, 42L, 4.20d})
     *  .withRenderer(
     *      UI.renderCombo(Number.class)
     *      .when(Integer.class).asText( cell -&gt; &quot;Integer: &quot;+cell.getValue() )
     *      .when(Long.class).asText( cell -&gt; &quot;Long: &quot;+cell.getValue() )
     *      .when(Float.class).asText( cell -&gt; &quot;Float: &quot;+cell.getValue() )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param commonType The common type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to configure how he passed item types should be rendered.
     * @param &lt;T&gt; The common super-type type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.Builder&lt;JComboBox&lt;T&gt;, T&gt; renderCombo( Class&lt;T&gt; commonType ) {
<span class="nc" id="L3445">        return Render.forCombo(commonType, null).when(commonType).asText(cell-&gt;cell.valueAsString().orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to build a combo box cell renderer for a specific item type.
     *  What you would typically want to do is customize the text that should be displayed
     *  for a specific item type. &lt;br&gt;
     *  This is done like so:
     *  &lt;pre&gt;{@code
     *  UI.comboBox(Size.LARGE, Size.MEDIUM, Size.SMALL)
     *  .withRenderer(
     *      UI.renderComboItem(Size.class)
     *      .asText(cell -&gt; cell.getValue().name().toLowerCase())
     *  );
     *  }&lt;/pre&gt;
     *
     * @param itemType The type of the items which should be rendered using a custom renderer.
     * @return A render builder exposing an API that allows you to
     *          configure how he passed item type should be rendered.
     * @param &lt;T&gt; The type of the items which should be rendered.
     */
    public static &lt;T&gt; Render.As&lt;JComboBox&lt;T&gt;, T, T&gt; renderComboItem( Class&lt;T&gt; itemType ) {
<span class="fc" id="L3467">        return Render.forCombo(itemType, null).when(itemType);</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L3475">        return Render.forTable(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L3483">        return Render.forList(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param borderSupplier A lambda which provides a border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Supplier&lt;Border&gt; borderSupplier ) {
<span class="nc" id="L3491">        return Render.forCombo(Object.class, borderSupplier).when(Object.class).as(cell-&gt;{});</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Border border ) {
<span class="nc" id="L3499">        return renderTableWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JTable, Object&gt; renderTableWithBorder( Val&lt;Border&gt; border ) {
<span class="nc" id="L3507">        return renderTableWithBorder(border::orElseThrow);</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Border border ) {
<span class="nc" id="L3515">        return renderListWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JList&lt;Object&gt;, Object&gt; renderListWithBorder( Var&lt;Border&gt; border ) {
<span class="nc" id="L3523">        return renderListWithBorder(border::orElseThrow);</span>
    }

    /**
     * @param border A border for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Border border ) {
<span class="nc" id="L3531">        return renderComboWithBorder(()-&gt;border);</span>
    }

    /**
     * @param border A property holding a {@link Border} used for rendered cells.
     * @return The builder API allowing method chaining.
     */
    public static Render.Builder&lt;JComboBox&lt;Object&gt;, Object&gt; renderComboWithBorder( Val&lt;Border&gt; border ) {
<span class="nc" id="L3539">        NullUtil.nullPropertyCheck(border, &quot;border&quot;, &quot;Null is not a valid border.&quot;);</span>
<span class="nc" id="L3540">        return renderComboWithBorder(border::orElseThrow);</span>
    }

    /**
     *  Use this to create a builder for anything.
     *
     * @return A builder instance for the provided object, which enables fluent method chaining.
     */
    public static &lt;T extends Component&gt; UIForAnything&lt;T&gt; of( T component ) {
<span class="nc" id="L3549">        NullUtil.nullArgCheck(component, &quot;component&quot;, Component.class);</span>
<span class="nc" id="L3550">        return new UIForAnything&lt;&gt;(component);</span>
    }

    /**
     * A convenience method for
     * &lt;pre&gt;{@code
     *      if ( !UI.thisIsUIThread() )
     *          SwingUtilities.invokeLater(runnable);
     *      else
     *          runnable.run();
     * }&lt;/pre&gt;,
     * which causes &lt;i&gt;runnable.run()&lt;/i&gt; to be executed asynchronously on the
     * AWT event dispatching thread if this current thread is not already
     * the AWT thread.
     * The 'invokeLater' execution will happen after all pending AWT events have been processed.
     * This method should be used when an application thread needs to update the GUI.
     *
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void run( Runnable runnable ) {
<span class="fc" id="L3571">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="fc bfc" id="L3572" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L3573">            SwingUtilities.invokeLater(runnable);</span>
        else
<span class="fc" id="L3575">            runnable.run();</span>
<span class="fc" id="L3576">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeLater(Runnable)},
     * which causes &lt;i&gt;doRun.run()&lt;/i&gt; to be executed asynchronously on the
     * AWT event dispatching thread.  This will happen after all
     * pending AWT events have been processed.  This method should
     * be used when an application thread needs to update the GUI.
     * In the following example the &lt;code&gt;invokeLater&lt;/code&gt; call queues
     * the &lt;code&gt;Runnable&lt;/code&gt; object &lt;code&gt;doHelloWorld&lt;/code&gt;
     * on the event dispatching thread and
     * then prints a message.
     * &lt;pre&gt;{@code
     *  UI.run( () -&gt; System.out.println(&quot;Hello World on &quot; + Thread.currentThread()) );
     *  System.out.println(&quot;This might well be displayed before the other message.&quot;);
     * }&lt;/pre&gt;
     * If invokeLater is called from the event dispatching thread --
     * for example, from a JButton's ActionListener -- the &lt;i&gt;doRun.run()&lt;/i&gt; will
     * still be deferred until all pending events have been processed.
     * Note that if the &lt;i&gt;doRun.run()&lt;/i&gt; throws an uncaught exception
     * the event dispatching thread will unwind (not the current thread).
     *
     * @param runnable the instance of {@code Runnable}
     * @see #runNow
     */
    public static void runLater( Runnable runnable ) {
<span class="fc" id="L3602">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="fc" id="L3603">        SwingUtilities.invokeLater(runnable);</span>
<span class="fc" id="L3604">    }</span>

    /**
     * Returns true if the current thread is an AWT event dispatching thread.
     * &lt;p&gt;
     * This method is just a cover for
     * &lt;code&gt;javax.swing.SwingUtilities.isEventDispatchThread()&lt;/code&gt;
     * and indirectly also for
     * &lt;code&gt;java.awt.EventQueue.isDispatchThread()&lt;/code&gt;.
     *
     * @return true if the current thread is an AWT event dispatching thread
     */
<span class="fc" id="L3616">    public static boolean thisIsUIThread() { return SwingUtilities.isEventDispatchThread(); }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeAndWait(Runnable)},
     * causes &lt;code&gt;doRun.run()&lt;/code&gt; to be executed synchronously on the
     * AWT event dispatching thread.  This call blocks until
     * all pending AWT events have been processed and (then)
     * &lt;code&gt;doRun.run()&lt;/code&gt; returns. This method should
     * be used when an application thread needs to update the GUI.
     * It shouldn't be called from the event dispatching thread.
     * Here's an example that creates a new application thread
     * that uses &lt;code&gt;invokeAndWait&lt;/code&gt; to print a string from the event
     * dispatching thread and then, when that's finished, print
     * a string from the application thread.
     * &lt;pre&gt;{@code
     *     var appThread = new Thread(() -&gt; {
     *             try {
     *                 UI.runNow(() -&gt; {
     *                    System.out.println(&quot;Hello World on &quot; + Thread.currentThread());
     *                 });
     *             }
     *             catch (Exception e) {
     *                 e.printStackTrace();
     *             }
     *             System.out.println(&quot;Finished on &quot; + Thread.currentThread());
     *         });
     *
     *     appThread.start();
     * }&lt;/pre&gt;
     * Note that if the &lt;code&gt;Runnable.run&lt;/code&gt; method throws an
     * uncaught exception
     * (on the event dispatching thread) it's caught and rethrown, as
     * an &lt;code&gt;InvocationTargetException&lt;/code&gt;, on the caller's thread.
     *
     * @param runnable the instance of {@code Runnable}
     * @exception  InterruptedException if we're interrupted while waiting for
     *             the event dispatching thread to finish executing
     *             &lt;code&gt;doRun.run()&lt;/code&gt;
     * @exception  InvocationTargetException  if an exception is thrown
     *             while running &lt;code&gt;doRun&lt;/code&gt;
     *
     * @see #run
     */
    public static void runNow( Runnable runnable ) throws InterruptedException, InvocationTargetException {
<span class="fc" id="L3660">        NullUtil.nullArgCheck(runnable, &quot;runnable&quot;, Runnable.class);</span>
<span class="fc" id="L3661">        SwingUtilities.invokeAndWait(runnable);</span>
<span class="fc" id="L3662">    }</span>

    /**
     * A convenience method for {@link SwingUtilities#invokeAndWait(Runnable)},
     * where the runnable is a lambda expression that has a return value.
     * This causes the {@link Supplier} to be executed synchronously on the
     * AWT event dispatching thread.  This call blocks until
     * all pending AWT events have been processed and (then)
     * the {@link Supplier} returns. This method should
     * be used when an application thread needs to update the GUI a
     * get a return value from the GUI.
     * It shouldn't be called from the event dispatching thread.
     * Here's an example that creates a new application thread
     * that uses &lt;code&gt;runAndGet(..)&lt;/code&gt; to access the state of a
     * {@link javax.swing.JCheckBox} from the event dispatching thread
     * and then, when that's finished, print the state from the application thread.
     * &lt;pre&gt;{@code
     *     JCheckBox checkBox = new JCheckBox(&quot;Hello World&quot;);
     *     var appThread = new Thread(()-&gt;{
     *            try {
     *                boolean state = UI.runAndGet(() -&gt; checkBox.isSelected());
     *                System.out.println(&quot;CheckBox state is &quot; + state);
     *            }
     *            catch (Exception e) {
     *                e.printStackTrace();
     *            }
     *            System.out.println(&quot;Finished on &quot; + Thread.currentThread());
     *        });
     *     appThread.start();
     * }&lt;/pre&gt;
     *
     */
    public static &lt;T&gt; T runAndGet( Supplier&lt;T&gt; supplier ) throws InterruptedException, InvocationTargetException {
<span class="fc" id="L3695">        NullUtil.nullArgCheck(supplier, &quot;callable&quot;, Supplier.class);</span>
<span class="fc" id="L3696">        T[] ref = (T[]) new Object[1];</span>
<span class="fc" id="L3697">        runNow( () -&gt; ref[0] = supplier.get() );</span>
<span class="fc" id="L3698">        return ref[0];</span>
    }

    /**
     *  Use this to synchronize with the UI thread from a non-UI thread.
     *  After calling this method, the current thread will be blocked
     *  until the UI thread has finished executing all of its pending events.
     *  This method should only be called from the application thread
     *  and not from the UI thread.
     *
     * @throws InterruptedException if the current thread is interrupted
     * @throws InvocationTargetException if the UI thread throws an exception
     */
    public static void sync() throws InterruptedException, InvocationTargetException {
<span class="fc" id="L3712">        runNow( () -&gt; {/*</span>
            This is a no-op, but it forces the event dispatching thread to
            process all pending events before returning.
            So when we reach this point, we know that all pending events
            have been processed.
<span class="fc" id="L3717">        */});</span>
<span class="fc" id="L3718">    }</span>

    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animate#on(Schedule)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.schedule( 100, TimeUnit.MILLISECONDS )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setValue( it.progress() );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     */
    public static Animate schedule( long duration, TimeUnit unit ) {
<span class="fc" id="L3736">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="fc" id="L3737">        return Animate.on( Schedule.of(duration, unit) );</span>
    }

    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animate#on(Schedule)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.schedule( 0.1, TimeUnit.MINUTES )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     */
    public static Animate schedule( double duration, TimeUnit unit ) {
<span class="fc" id="L3756">        return Animate.on( Schedule.of(duration, unit) );</span>
    }

    /**
     *  Shows a conformation dialog with the given message.
     * @param message the message to show
     * @return true if the user clicked &quot;Yes&quot;, false otherwise
     */
<span class="nc" id="L3764">    public static boolean confirm( String message ) { return confirm(&quot;Confirm&quot;, message); }</span>

    /**
     * Shows a conformation dialog with the given message.
     *
     * @param title   the title of the dialog
     * @param message the message to show
     * @return true if the user clicked &quot;Yes&quot;, false otherwise
     */
<span class="nc" id="L3773">    public static boolean confirm( String title, String message ) { return confirm(title, message, null ); }</span>

    /**
     * Shows a conformation dialog with the given message.
     *
     * @param title   the title of the dialog
     * @param message the message to show
     * @param icon    the icon to show
     * @return true if the user clicked &quot;Yes&quot;, false otherwise
     */
    public static boolean confirm( String title, String message, Icon icon ) {
<span class="nc" id="L3784">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3785">        Objects.requireNonNull( title );</span>
<span class="nc bnc" id="L3786" title="All 2 branches missed.">        return JOptionPane.showConfirmDialog( null, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, icon ) == JOptionPane.YES_OPTION;</span>
    }

    /**
     *  Shows an error dialog with the given message.
     * @param message The error message to show in the dialog.
     */
<span class="nc" id="L3793">    public static void error( String message ) { error(&quot;Error&quot;, message); }</span>

    /**
     * Shows an error dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The error message to show in the dialog.
     */
<span class="nc" id="L3801">    public static void error( String title, String message ) { error(title, message, null ); }</span>

    /**
     * Shows an error dialog with the given message, dialog title and icon.
     *
     * @param title   The title of the dialog.
     * @param message The error message to show in the dialog.
     * @param icon    The icon to show in the dialog.
     */
    public static void error( String title, String message, Icon icon ) {
<span class="nc" id="L3811">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3812">        Objects.requireNonNull( title );</span>
<span class="nc" id="L3813">        JOptionPane.showMessageDialog( null, message, title, JOptionPane.ERROR_MESSAGE, icon );</span>
<span class="nc" id="L3814">    }</span>

    /**
     *  Shows an info dialog with the given message.
     * @param message The message to show in the dialog.
     */
<span class="nc" id="L3820">    public static void info( String message ) { info(&quot;Info&quot;, message); }</span>

    /**
     * Shows an info dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The message to show in the dialog.
     */
    public static void info( String title, String message ) {
<span class="nc" id="L3829">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3830">        Objects.requireNonNull( title );</span>
<span class="nc" id="L3831">        info(title, message, null );</span>
<span class="nc" id="L3832">    }</span>

    /**
     * Shows an info dialog with the given message, dialog title and icon.
     *
     * @param title   The title of the dialog.
     * @param message The message to show in the dialog.
     * @param icon    The icon to show in the dialog.
     */
    public static void info( String title, String message, Icon icon ) {
<span class="nc" id="L3842">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3843">        Objects.requireNonNull( title );</span>
<span class="nc" id="L3844">        JOptionPane.showMessageDialog( null, message, title, JOptionPane.INFORMATION_MESSAGE, icon );</span>
<span class="nc" id="L3845">    }</span>

    /**
     *  Shows a warning dialog with the given message.
     * @param message The warning message to show in the dialog.
     */
<span class="nc" id="L3851">     public static void warn( String message ) { warn(&quot;Warning&quot;, message); }</span>

    /**
     * Shows a warning dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The warning message to show in the dialog.
     */
<span class="nc" id="L3859">    public static void warn( String title, String message ) { warn(title, message, null ); }</span>

    /**
     * Shows a warning dialog with the given message, dialog title and icon.
     *
     * @param title   The title of the dialog.
     * @param message The warning message to show in the dialog.
     * @param icon    The icon to show in the dialog.
     */
    public static void warn( String title, String message, Icon icon ) {
<span class="nc" id="L3869">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3870">        Objects.requireNonNull( title );</span>
<span class="nc" id="L3871">        JOptionPane.showMessageDialog( null, message, title, JOptionPane.WARNING_MESSAGE, icon );</span>
<span class="nc" id="L3872">    }</span>

    /**
     *  Shows a dialog where the user can select a value from a list of options
     *  based on the enum type implicitly defined by the given enum based property.
     *  The selected value will be stored in said property after the user has
     *  selected a value.
     *
     * @param message The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String message, Var&lt;E&gt; selected ) {
<span class="nc" id="L3884">        select(&quot;Select&quot;, message, selected );</span>
<span class="nc" id="L3885">    }</span>

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String title, String message, Var&lt;E&gt; selected ) {
<span class="nc" id="L3898">        select(title, message, null, selected );</span>
<span class="nc" id="L3899">    }</span>

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param icon     The icon to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void select( String title, String message, Icon icon, Var&lt;E&gt; selected ) {
<span class="nc" id="L3913">        Objects.requireNonNull( message );</span>
<span class="nc" id="L3914">        Objects.requireNonNull( title );</span>
<span class="nc" id="L3915">        Objects.requireNonNull( selected );</span>
<span class="nc" id="L3916">        E[] options = selected.type().getEnumConstants();</span>
<span class="nc" id="L3917">        String[] asStr = new String[options.length];</span>
<span class="nc bnc" id="L3918" title="All 2 branches missed.">        for ( int i = 0; i &lt; options.length; i++ )</span>
<span class="nc" id="L3919">            asStr[i] = options[i].toString();</span>

<span class="nc" id="L3921">        int selectedIdx = JOptionPane.showOptionDialog( null, message, title, JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, icon, asStr, asStr[0] );</span>
<span class="nc" id="L3922">        selected.act( options[selectedIdx] );</span>
<span class="nc" id="L3923">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen.
     *
     * @param component The component to show in the window.
     */
    public static void show( Component component ) {
<span class="nc" id="L3932">        Objects.requireNonNull( component );</span>
<span class="nc" id="L3933">        new UI.TestWindow( &quot;&quot;, f -&gt; component );</span>
<span class="nc" id="L3934">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen.
     *
     * @param title The title of the window.
     * @param component The component to show in the window.
     */
    public static void show( String title, Component component ) {
<span class="nc" id="L3944">        Objects.requireNonNull( component );</span>
<span class="nc" id="L3945">        new UI.TestWindow( title, f -&gt; component );</span>
<span class="nc" id="L3946">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen.
     *
     * @param ui The Swing-Tree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L3956">        new UI.TestWindow( &quot;&quot;, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L3957">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen.
     *
     * @param title The title of the window.
     * @param ui The Swing-Tree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( String title, UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L3968">        new UI.TestWindow( title, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L3969">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L3980">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L3981">        new UI.TestWindow( &quot;&quot;, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L3982">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param title The title of the window.
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( String title, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L3994">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L3995">        new UI.TestWindow( title, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L3996">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing( EventProcessor eventProcessor, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L4006">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L4007">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L4008">        show(frame -&gt; use(eventProcessor, () -&gt; uiSupplier.apply(frame)));</span>
<span class="nc" id="L4009">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in a titled {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param title The title of the window.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing( EventProcessor eventProcessor, String title, Function&lt;JFrame, Component&gt; uiSupplier ) {
<span class="nc" id="L4020">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L4021">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L4022">        show(title, frame -&gt; use(eventProcessor, () -&gt; uiSupplier.apply(frame)));</span>
<span class="nc" id="L4023">    }</span>

    /**
     *  Use this to quickly create and inspect a test window for a UI component.
     */
    private static class TestWindow
    {
        private final JFrame frame;
        private final Component component;

<span class="nc" id="L4033">        private TestWindow( String title, Function&lt;JFrame, Component&gt; uiSupplier ) {</span>
<span class="nc" id="L4034">            Objects.requireNonNull( title );</span>
<span class="nc" id="L4035">            Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L4036">            this.frame = new JFrame();</span>
<span class="nc bnc" id="L4037" title="All 2 branches missed.">            if ( !title.isEmpty() ) this.frame.setTitle(title);</span>
<span class="nc" id="L4038">            frame.setLocationRelativeTo(null); // Initial centering!</span>
<span class="nc" id="L4039">            this.component = uiSupplier.apply(frame);</span>
<span class="nc" id="L4040">            frame.add(component);</span>
<span class="nc" id="L4041">            frame.pack(); // Otherwise some components resize strangely or are not shown at all...</span>
            // Make sure that the window is centered on the screen again but with the component:
<span class="nc" id="L4043">            frame.setLocationRelativeTo(null);</span>
            // We set the size to fit the component:
<span class="nc" id="L4045">            _determineSize();</span>
<span class="nc" id="L4046">            frame.setVisible(true);</span>
<span class="nc" id="L4047">        }</span>
        private void _determineSize() {
<span class="nc" id="L4049">            Dimension size = frame.getSize();</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">            if ( size == null ) // The frame has no size! It is best to set the size to the preferred size of the component:</span>
<span class="nc" id="L4051">                size = component.getPreferredSize();</span>

<span class="nc bnc" id="L4053" title="All 2 branches missed.">            if ( size == null ) // The component has no preferred size! It is best to set the size to the minimum size of the component:</span>
<span class="nc" id="L4054">                size = component.getMinimumSize();</span>

<span class="nc bnc" id="L4056" title="All 2 branches missed.">            if ( size == null ) // The component has no minimum size! Let's just look up the size of the component:</span>
<span class="nc" id="L4057">                size = component.getSize();</span>

<span class="nc" id="L4059">            frame.setSize(size);</span>
<span class="nc" id="L4060">        }</span>
    }


    /*
        The following method and subsequent classes are used to smoothly render
        custom graphics on top of Swing components without requiring
        the user to override the paint method of the component.
        This is especially important to allow for declarative UI.
    */

    private static &lt;C extends JComponent&gt; void _render( C comp, Graphics g, Runnable superPaint ) {
<span class="nc" id="L4072">        ComponentExtension.from(comp).render( g, superPaint );</span>
<span class="nc" id="L4073">    }</span>

    /** {inheritDoc} */
<span class="fc" id="L4076">    public static class Button extends JButton {</span>
<span class="nc" id="L4077">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4080">    public static class Panel extends JPanel {</span>
<span class="nc" id="L4081">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4084">    public static class Label extends JLabel {</span>
<span class="nc" id="L4085">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4088">    public static class TextField extends JTextField {</span>
<span class="nc" id="L4089">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4092">    public static class TextArea extends JTextArea {</span>
<span class="nc" id="L4093">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4096">    public static class CheckBox extends JCheckBox {</span>
<span class="nc" id="L4097">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4100">    public static class RadioButton extends JRadioButton {</span>
<span class="nc" id="L4101">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4104">    public static class ComboBox&lt;E&gt; extends JComboBox&lt;E&gt; {</span>
<span class="nc" id="L4105">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4108">    public static class List&lt;E&gt; extends JList&lt;E&gt; {</span>
<span class="nc" id="L4109">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4112">    public static class Table extends JTable {</span>
<span class="nc" id="L4113">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4116">    public static class Slider extends JSlider {</span>
<span class="nc" id="L4117">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4120">    public static class PopupMenu extends JPopupMenu {</span>
<span class="nc" id="L4121">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4124">    public static class MenuItem extends JMenuItem {</span>
<span class="nc" id="L4125">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4128">    public static class Menu extends JMenu {</span>
<span class="nc" id="L4129">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4132">    public static class MenuBar extends JMenuBar {</span>
<span class="nc" id="L4133">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4136">    public static class ScrollPane extends JScrollPane {</span>
<span class="nc" id="L4137">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4140">    public static class TabbedPane extends JTabbedPane {</span>
<span class="nc" id="L4141">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4144">    public static class ToolBar extends JToolBar {</span>
<span class="nc" id="L4145">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4148">    public static class ToolTip extends JToolTip {</span>
<span class="nc" id="L4149">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4152">    public static class Tree extends JTree {</span>
<span class="nc" id="L4153">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4156">    public static class ProgressBar extends JProgressBar {</span>
<span class="nc" id="L4157">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4160">    public static class Spinner extends JSpinner {</span>
<span class="nc" id="L4161">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4164">    public static class SplitPane extends JSplitPane {</span>
<span class="nc" id="L4165">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="nc" id="L4168">    public static class TextPane extends JTextPane {</span>
<span class="nc" id="L4169">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4172">    public static class EditorPane extends JEditorPane {</span>
<span class="nc" id="L4173">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
    /** {inheritDoc} */
<span class="fc" id="L4176">    public static class PasswordField extends JPasswordField {</span>
<span class="nc" id="L4177">        @Override public void paint(Graphics g){ _render(this, g, ()-&gt;super.paint(g)); }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>