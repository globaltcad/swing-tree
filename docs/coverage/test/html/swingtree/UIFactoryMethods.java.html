<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIFactoryMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIFactoryMethods.java</span></div><h1>UIFactoryMethods.java</h1><pre class="source lang-java linenums">package swingtree;

import com.github.weisj.jsvg.SVGDocument;
import com.github.weisj.jsvg.parser.SVGLoader;
import net.miginfocom.layout.LC;
import net.miginfocom.swing.MigLayout;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.Event;
import sprouts.*;
import swingtree.animation.Animator;
import swingtree.animation.LifeTime;
import swingtree.animation.Stride;
import swingtree.api.Configurator;
import swingtree.api.IconDeclaration;
import swingtree.api.MenuBuilder;
import swingtree.api.SwingBuilder;
import swingtree.api.model.BasicTableModel;
import swingtree.api.model.TableListDataSource;
import swingtree.api.model.TableMapDataSource;
import swingtree.components.JBox;
import swingtree.components.JIcon;
import swingtree.components.JScrollPanels;
import swingtree.components.JSplitButton;
import swingtree.dialogs.ConfirmAnswer;
import swingtree.dialogs.ConfirmDialog;
import swingtree.dialogs.MessageDialog;
import swingtree.dialogs.OptionsDialog;
import swingtree.layout.LayoutConstraint;
import swingtree.style.ComponentExtension;
import swingtree.style.StyleSheet;
import swingtree.style.SvgIcon;
import swingtree.threading.EventProcessor;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.text.JTextComponent;
import java.awt.*;
import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 *  A namespace for useful factory methods like
 *  {@link #color(String)} and {@link #font(String)},
 *  and layout constants (see {@link UILayoutConstants}).
 *  &lt;br&gt;
 *  &lt;b&gt;
 *      This class is intended to be used
 *      by the {@link UI} namespace class ONLY!
 *      &lt;br&gt;
 *      Please do not inherit or import this class
 *      in your own code, as it is not intended to be
 *      used outside of the {@link UI} namespace.
 *  &lt;/b&gt;
 */
<span class="nc" id="L66">public abstract class UIFactoryMethods extends UILayoutConstants</span>
{
<span class="fc" id="L68">    private static final Logger log = LoggerFactory.getLogger(UIFactoryMethods.class);</span>

    /**
     *  Creates a new {@link Color} object from the specified
     *  red, green and blue values.
     *
     * @param r The red value (0-255).
     * @param g The green value (0-255).
     * @param b The blue value (0-255).
     * @return The new color.
     */
    public static UI.Color color( int r, int g, int b ) {
<span class="nc" id="L80">        return UI.Color.ofRgb(r, g, b);</span>
    }

    /**
     *  Creates a new {@link Color} object from the specified
     *  red, green, blue and alpha values.
     *
     * @param r The red value (0-255).
     * @param g The green value (0-255).
     * @param b The blue value (0-255).
     * @param a The alpha value (0-255).
     * @return The new color.
     */
    public static UI.Color color( int r, int g, int b, int a ) {
<span class="fc" id="L94">        return UI.Color.ofRgba(r, g, b, a);</span>
    }

    /**
     *  Creates a new {@link Color} object from the specified
     *  red, green and blue values.
     *
     * @param r The red value (0.0-1.0).
     * @param g The green value (0.0-1.0).
     * @param b The blue value (0.0-1.0).
     * @return The new color.
     */
    public static UI.Color color( double r, double g, double b ) {
<span class="fc" id="L107">        return UI.Color.of((float) r, (float) g, (float) b);</span>
    }

    /**
     *  Creates a new {@link Color} object from the specified
     *  red, green, blue and alpha values.
     *
     * @param r The red value (0.0-1.0).
     * @param g The green value (0.0-1.0).
     * @param b The blue value (0.0-1.0).
     * @param a The alpha value (0.0-1.0).
     * @return The new color.
     */
    public static UI.Color color( double r, double g, double b, double a ) {
<span class="fc" id="L121">        return UI.Color.of((float) r, (float) g, (float) b, (float) a);</span>
    }

    /**
     *  Tries to parse the supplied string as a color value
     *  based on various formats.
     *
     * @param colorAsString The string to parse.
     * @return The parsed color.
     * @throws IllegalArgumentException If the string could not be parsed.
     * @throws NullPointerException If the string is null.
     */
    public static UI.Color color( final String colorAsString )
    {
<span class="fc" id="L135">        Objects.requireNonNull(colorAsString);</span>
<span class="fc" id="L136">        return UI.Color.of(colorAsString);</span>
    }

    /**
     * Returns the {@code Font} that the {@code fontString}
     * argument describes.
     * To ensure that this method returns the desired Font,
     * format the {@code fontString} parameter in
     * one of these ways
     *
     * &lt;ul&gt;
     * &lt;li&gt;&lt;em&gt;fontname-style-pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname-pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname-style&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname style pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname pointsize&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname style&lt;/em&gt;
     * &lt;li&gt;&lt;em&gt;fontname&lt;/em&gt;
     * &lt;/ul&gt;
     * in which &lt;i&gt;style&lt;/i&gt; is one of the four
     * case-insensitive strings:
     * {@code &quot;PLAIN&quot;}, {@code &quot;BOLD&quot;}, {@code &quot;BOLDITALIC&quot;}, or
     * {@code &quot;ITALIC&quot;}, and pointsize is a positive decimal integer
     * representation of the point size.
     * For example, if you want a font that is Arial, bold, with
     * a point size of 18, you would call this method with:
     * &quot;Arial-BOLD-18&quot;.
     * This is equivalent to calling the Font constructor :
     * {@code new Font(&quot;Arial&quot;, Font.BOLD, 18);}
     * and the values are interpreted as specified by that constructor.
     * &lt;p&gt;
     * A valid trailing decimal field is always interpreted as the pointsize.
     * Therefore a fontname containing a trailing decimal value should not
     * be used in the fontname only form.
     * &lt;p&gt;
     * If a style name field is not one of the valid style strings, it is
     * interpreted as part of the font name, and the default style is used.
     * &lt;p&gt;
     * Only one of ' ' or '-' may be used to separate fields in the input.
     * The identified separator is the one closest to the end of the string
     * which separates a valid pointsize, or a valid style name from
     * the rest of the string.
     * Null (empty) pointsize and style fields are treated
     * as valid fields with the default value for that field.
     *&lt;p&gt;
     * Some font names may include the separator characters ' ' or '-'.
     * If {@code fontString} is not formed with 3 components, e.g. such that
     * {@code style} or {@code pointsize} fields are not present in
     * {@code fontString}, and {@code fontname} also contains a
     * character determined to be the separator character
     * then these characters where they appear as intended to be part of
     * {@code fontname} may instead be interpreted as separators
     * so the font name may not be properly recognised.
     *
     * &lt;p&gt;
     * The default size is 12 and the default style is PLAIN.
     * If {@code str} does not specify a valid size, the returned
     * {@code Font} has a size of 12.  If {@code fontString} does not
     * specify a valid style, the returned Font has a style of PLAIN.
     * If you do not specify a valid font name in
     * the {@code fontString} argument, this method will return
     * a font with the family name &quot;Dialog&quot;.
     * To determine what font family names are available on
     * your system, use the
     * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.
     * If {@code fontString} is {@code null}, a new {@code Font}
     * is returned with the family name &quot;Dialog&quot;, a size of 12 and a
     * PLAIN style.
     * @param fontString the name of the font, or {@code null}
     * @return the {@code Font} object that {@code fontString} describes.
     * @throws NullPointerException if {@code fontString} is {@code null}
     */
    public static UI.Font font( String fontString ) {
<span class="nc" id="L210">        Objects.requireNonNull(fontString);</span>
<span class="nc" id="L211">        Exception potentialProblem1 = null;</span>
<span class="nc" id="L212">        Exception potentialProblem2 = null;</span>
<span class="nc" id="L213">        String mayBeProperty = System.getProperty(fontString);</span>
<span class="nc" id="L214">        UI.Font font = null;</span>
        try {
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if ( mayBeProperty == null )</span>
<span class="nc" id="L217">                font = UI.Font.of(Font.decode(fontString));</span>
<span class="nc" id="L218">        } catch( Exception e ) {</span>
<span class="nc" id="L219">            potentialProblem1 = e;</span>
<span class="nc" id="L220">        }</span>
        try {
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if ( mayBeProperty != null )</span>
<span class="nc" id="L223">                font = UI.Font.of(Font.decode(mayBeProperty));</span>
<span class="nc" id="L224">        } catch( Exception e ) {</span>
<span class="nc" id="L225">            potentialProblem2 = e;</span>
<span class="nc" id="L226">        }</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if ( font == null ) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if ( potentialProblem1 != null )</span>
<span class="nc" id="L229">                log.error(&quot;Could not parse font string '&quot; + fontString + &quot;' using 'Font.decode(String)'.&quot;, potentialProblem1);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if ( potentialProblem2 != null )</span>
<span class="nc" id="L231">                log.error(&quot;Could not parse font string '&quot; + fontString + &quot;' from 'System.getProperty(String)'.&quot;, potentialProblem2);</span>

<span class="nc" id="L233">            log.error(&quot;Could not parse font string '&quot; + fontString + &quot;' using 'Font.decode(String)' or 'System.getProperty(String)'.&quot;, new Throwable());</span>

            try {
<span class="nc" id="L236">                return UI.Font.of(fontString, UI.FontStyle.PLAIN, UI.scale(12));</span>
<span class="nc" id="L237">            } catch (Exception e) {</span>
<span class="nc" id="L238">                log.error(&quot;Could not create font with name '&quot; + fontString + &quot;' and size 12.&quot;, e);</span>
<span class="nc" id="L239">                return UI.Font.of(Font.DIALOG, UI.FontStyle.PLAIN, UI.scale(12));</span>
            }
        }
<span class="nc" id="L242">        return font;</span>
    }

    /**
     *  This returns an instance of a generic swing tree builder
     *  for anything extending the {@link JComponent} class.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param component The new component instance which ought to be part of the Swing UI.
     * @param &lt;T&gt; The concrete type of this new component.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( T component )
    {
<span class="fc" id="L256">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="fc" id="L257">        return new UIForSwing&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JPanel} type. &lt;br&gt;
     *  This method is typically used to enable declarative UI design for custom
     *  {@link JPanel} based components either within the constructor of a custom
     *  subclass, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  class MyCustomPanel extends JPanel {
     *      public MyCustomPanel() {
     *          UI.of(this)
     *          .add(UI.label(&quot;Hello Swing!&quot;))
     *          .add(UI.button(&quot;Click Me&quot;))
     *          .add(UI.button(&quot;Or Me&quot;) );
     *      }
     *  }
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  ... or as part of a UI declaration, where the custom {@link JPanel} type
     *  is added to the components tree, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.show(
     *      UI.panel()
     *      .add(
     *          new MyCustomPanel()
     *      )
     *      .add(..more stuff..)
     *  );
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *
     * @param component The {@link JPanel} instance to be wrapped by a swing tree UI builder for panel components.
     * @return A builder instance for the provided {@link JPanel}, which enables fluent method chaining.
     * @param &lt;P&gt; The type parameter of the concrete {@link JPanel} type to be wrapped.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JPanel&gt; UIForPanel&lt;P&gt; of( P component ) {
<span class="fc" id="L295">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPanel.class);</span>
<span class="fc" id="L296">        return new UIForPanel&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager.
     *  This is in essence a convenience method for {@code UI.of(new JPanel(new MigLayout()))}.
     *
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     */
    public static UIForPanel&lt;JPanel&gt; panel() {
<span class="fc" id="L307">        return _panel().withLayout(new MigLayout(&quot;hidemode 2&quot;));</span>
    }

    private static UIForPanel&lt;JPanel&gt; _panel() {
<span class="fc" id="L311">        return new UIForPanel&lt;&gt;(new BuilderState&lt;&gt;(UI.Panel.class, UI.Panel::new));</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr ) {
<span class="fc" id="L327">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L328">        return _panel().withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints ) {
<span class="fc" id="L344">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L345">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L346">        return _panel().withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L364">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L365">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L366">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L367">        return _panel().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr ) {
<span class="fc" id="L380">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L381">        return panel(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr, String colConstraints ) {
<span class="fc" id="L397">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L398">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L399">        return _panel().withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LayoutConstraint attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L417">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L418">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L419">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L420">        return _panel().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}. &lt;br&gt;
     *  This method is typiclly used alongside the {@link UI#LC()} factory
     *  method to create a layout attributes/constraints builder, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.panel(
     *          UI.LC()
     *          .insets(&quot;10 10 10 10&quot;)
     *          .debug()
     *      )
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *
     * @param attr The constraint attributes concerning the entire {@link MigLayout}
     *             in the form of a {@link LC} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr ) {
<span class="nc" id="L445">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L446">        return _panel().withLayout( attr );</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(new MigLayout(attr, ConstraintParser.parseColumnConstraints(colConstraints))))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LC} constants.
     * @param colConstraints The column constraints in the form of a {@link String} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr, String colConstraints ) {
<span class="nc" id="L463">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L464">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L465">        return _panel().withLayout( attr, colConstraints );</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPanel} UI component
     *  with a {@link MigLayout} as its layout manager and the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JPanel(
     *          new MigLayout(
     *              attr,
     *              ConstraintParser.parseColumnConstraints(colConstraints),
     *              ConstraintParser.parseRowConstraints(rowConstraints)
     *          )
     *      ))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param attr The layout attributes in the form of a {@link LC} instance.
     * @param colConstraints The column constraints in the form of a {@link String} instance.
     * @param rowConstraints The row constraints in the form of a {@link String} instance.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( LC attr, String colConstraints, String rowConstraints ) {
<span class="nc" id="L489">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L490">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L491">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="nc" id="L492">        return _panel().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for the {@link JPanel} UI component with a
     *  dynamically updated set of {@link MigLayout} constraints/attributes.
     *  This is in essence a convenience method for {@code UI.of(new JPanel()).withLayout(attr)}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JPanel}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForPanel&lt;JPanel&gt; panel( Val&lt;LayoutConstraint&gt; attr ) {
<span class="fc" id="L506">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L507">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L508">        return panel(attr.get().toString()).withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JBox} instance,
     *  which is a general purpose component wrapper type with the following properties:
     *  &lt;ul&gt;
     *      &lt;li&gt;
     *          It is transparent, meaning that it does not paint its background.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The default layout manager is a {@link MigLayout}.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The insets (the space between the wrapped component and the box's border)
     *          are set to zero.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          There the gap size between the components added to the box is set to zero.
     *          So they will be tightly packed.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This method is typically used to enable declarative UI design for custom
     *  {@link JBox} based components either within the constructor of a custom
     *  subclass, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  class MyCustomBox extends JBox {
     *      public MyCustomBox() {
     *          UI.of(this)
     *          .add(UI.label(&quot;Hello Swing!&quot;))
     *          .add(UI.button(&quot;Click Me&quot;))
     *          .add(UI.button(&quot;Or Me&quot;) );
     *      }
     *  }
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  ... or as part of a UI declaration, where the custom {@link JBox} type
     *  is added to the components tree, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.show(
     *      UI.panel()
     *      .add(
     *          new MyCustomBox()
     *      )
     *      .add(..more stuff..)
     *  );
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *
     * @param component The box component type for which a builder should be created.
     * @param &lt;B&gt; THe type parameter defining the concrete {@link JBox} type.
     * @return A builder for the provided box component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;B extends JBox&gt; UIForBox&lt;B&gt; of( B component ) {
<span class="fc" id="L567">        NullUtil.nullArgCheck(component, &quot;component&quot;, JPanel.class);</span>
<span class="fc" id="L568">        return new UIForBox&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox} instance,
     *  which is a general purpose component wrapper type with the following properties:
     *  &lt;ul&gt;
     *      &lt;li&gt;
     *          It is transparent, meaning that it does not paint its background.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The default layout manager is a {@link MigLayout}.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The insets (the spaces between the wrapped component and the box's border)
     *          are all set to zero.
     *      &lt;/li&gt;
     *      &lt;li&gt;
     *          The gap sizes between the components added to the box is set to zero.
     *          So the children of this component will be tightly packed.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This factory method is especially useful for when you simply want to nest components
     *  tightly without having to worry about the layout manager or the background
     *  color covering the background of the parent component.
     *  &lt;br&gt;
     *  Note that you can also emulate the {@link JBox} type with a {@link JPanel} using
     *  {@code UI.panel(&quot;ins 0, gap 0&quot;).makeNonOpaque()}.
     *
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     */
    public static UIForBox&lt;JBox&gt; box() {
<span class="fc" id="L604">        return new UIForBox&lt;&gt;(new BuilderState&lt;&gt;(UI.Box.class, UI.Box::new));</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  &lt;br&gt;
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr ) {
<span class="fc" id="L621">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if ( attr.isEmpty() ) attr = &quot;ins 0&quot;;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        else if ( !attr.contains(&quot;ins&quot;) ) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L624">        return box().withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr, String colConstraints ) {
<span class="fc" id="L642">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L643">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L646">        return box().withLayout(attr, colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This factory method is especially useful for when you simply want to nest components
     *  tightly without having to worry about the layout manager or the background
     *  color covering the background of the parent component.
     *  &lt;br&gt;
     *  Note that you can also emulate the {@link JBox} type with a {@link JPanel} using
     *  &lt;pre&gt;{@code
     *      UI.panel(attr, colConstraints, rowConstraints).makeNonOpaque()
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     * @param attr The layout attributes.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( String attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L673">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, String.class);</span>
<span class="fc" id="L674">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L675">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">        if (attr.isEmpty()) attr = &quot;ins 0&quot;;</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        else if (!attr.contains(&quot;ins&quot;)) attr += &quot;, ins 0&quot;;</span>
<span class="fc" id="L678">        return box().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints. &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  &lt;br&gt;
     *  This method allows you to pass a {@link LayoutConstraint} constants as the layout attributes,
     *  which is an instance typically chosen from the {@link UI} class constants
     *  like for example {@link UI#FILL}, {@link UI#FILL_X}, {@link UI#FILL_Y}... &lt;br&gt;
     *  A typical usage example would be: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.box(UI.FILL_X.and(UI.WRAP(2)))
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *  In this code snippet the creates a {@link JBox} with a {@link MigLayout} as its layout manager
     *  where the box will fill the parent component horizontally and
     *  the components added to the box will be wrapped after every two components.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr ) {
<span class="fc" id="L712">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L713">        return box(attr.toString());</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints. &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *  &lt;p&gt;
     *  This method allows you to pass a {@link LayoutConstraint} constants as the layout attributes,
     *  which is an instance typically chosen from the {@link UI} class constants
     *  like for example {@link UI#FILL}, {@link UI#FILL_X}, {@link UI#FILL_Y}... &lt;br&gt;
     *  A typical usage example would be: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.box(UI.FILL, &quot;[shrink]6[grow]&quot;)
     *      .add(..)
     *      .add(..)
     *  }&lt;/pre&gt;
     *  In this code snippet the creates a {@link JBox} with a {@link MigLayout} as its layout manager
     *  where the box will fill the parent component horizontally and vertically
     *  and the first column of components will be shrunk to their preferred size
     *  and the second column will grow to fill the available space.
     *  Both columns will have a gap of 6 pixels between them.
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @param colConstraints The layout which will be passed to the {@link MigLayout} constructor as second argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr, String colConstraints ) {
<span class="fc" id="L748">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L749">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L750">        return box(attr.toString(), colConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method for the following: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox(new MigLayout(attr, colConstraints, rowConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LayoutConstraint attr, String colConstraints, String rowConstraints ) {
<span class="fc" id="L773">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LayoutConstraint.class);</span>
<span class="fc" id="L774">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="fc" id="L775">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="fc" id="L776">        return box(attr.toString(), colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *
     * @param attr The layout attributes which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr ) {
<span class="nc" id="L794">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L795">        return box().withLayout(attr);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method which may also be expressed as: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox(new MigLayout(attr, colConstraints)))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr, String colConstraints ) {
<span class="nc" id="L820">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L821">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L822">        return box().withLayout( attr, colConstraints )           ;</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This is essentially a convenience method which may also be expressed as: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.of(new JBox())
     *      .peek( box -&gt; {
     *          box.setLayout(
     *              new MigLayout(
     *                  attr,
     *                  ConstraintParser.parseColumnConstraints(colConstraints),
     *                  ConstraintParser.parseRowConstraints(rowConstraints)
     *              )
     *          )
     *      })
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Please note that the {@link JBox} type is in no way related to the {@link BoxLayout}!
     *  The term &lt;i&gt;box&lt;/i&gt; is referring to the purpose of this component, which
     *  is to tightly store and wrap other sub-components seamlessly...&lt;/b&gt;
     *
     * @param attr The layout attributes in the form of a {@link LayoutConstraint} constants.
     * @param colConstraints The column constraints.
     * @param rowConstraints The row constraints.
     * @return A builder instance for a transparent {@link JBox}, which enables fluent method chaining.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( LC attr, String colConstraints, String rowConstraints ) {
<span class="nc" id="L854">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, LC.class);</span>
<span class="nc" id="L855">        NullUtil.nullArgCheck(colConstraints, &quot;colConstraints&quot;, String.class);</span>
<span class="nc" id="L856">        NullUtil.nullArgCheck(rowConstraints, &quot;rowConstraints&quot;, String.class);</span>
<span class="nc" id="L857">        return box().withLayout(attr, colConstraints, rowConstraints);</span>
    }

    /**
     *  Use this to create a builder for a {@link JBox}, a generic component wrapper type
     *  which is transparent and without any insets as well as with a {@link MigLayout}
     *  as its layout manager.
     *  This is conceptually the same as a
     *  transparent {@link JPanel} without any insets
     *  and a {@link MigLayout} constructed using the provided constraints.
     *  This method allows you to dynamically determine the {@link LayoutConstraint} constants
     *  of the {@link MigLayout} instance, by passing a {@link Val} property which
     *  will be observed and its value passed to the {@link MigLayout} constructor
     *  whenever it changes.
     *  This is in essence a convenience method for:
     *  {@code UI.box().withLayout(attr.viewAsString( it -&gt; it+&quot;, ins 0&quot;))}.
     *
     * @param attr The layout attributes property which will be passed to the {@link MigLayout} constructor as first argument.
     * @return A builder instance for a new {@link JBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code attr} is {@code null}.
     * @see &lt;a href=&quot;http://www.miglayout.com/QuickStart.pdf&quot;&gt;Quick Start Guide&lt;/a&gt;
     */
    public static UIForBox&lt;JBox&gt; box( Val&lt;LayoutConstraint&gt; attr ) {
<span class="nc" id="L880">        NullUtil.nullArgCheck(attr, &quot;attr&quot;, Val.class);</span>
<span class="nc" id="L881">        NullUtil.nullPropertyCheck(attr, &quot;attr&quot;, &quot;Null is not a valid layout attribute.&quot;);</span>
<span class="nc" id="L882">        return box().withLayout(attr.view( it -&gt; it.and(&quot;ins 0&quot;)));</span>
    }

    /**
     *  If you are using builders for your custom {@link JComponent},
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JComponent} types.
     * @param &lt;T&gt; The UI component type built by implementations of the provided builder.
     * @return A basic UI builder instance wrapping any {@link JComponent}.
     */
    public static &lt;T extends JComponent&gt; UIForSwing&lt;T&gt; of( SwingBuilder&lt;T&gt; builder )
    {
<span class="nc" id="L896">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, SwingBuilder.class);</span>
<span class="nc" id="L897">        return new UIForSwing&lt;&gt;(new BuilderState&lt;&gt;((Class&lt;T&gt;) JComponent.class, ()-&gt;builder.build()));</span>
    }

    /**
     *  If you are using builders for custom {@link JMenuItem} components,
     *  implement this to allow the {@link UI} API to call the {@link SwingBuilder#build()}
     *  method for you.
     *
     * @param builder A builder for custom {@link JMenuItem} types.
     * @param &lt;M&gt; The {@link JMenuItem} type built by implementations of the provided builder.
     * @return A builder instance for a {@link JMenuItem}, which enables fluent method chaining.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( MenuBuilder&lt;M&gt; builder )
    {
<span class="nc" id="L911">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, MenuBuilder.class);</span>
<span class="nc" id="L912">        return new UIForMenuItem&lt;&gt;(new BuilderState&lt;&gt;(builder.build()));</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *
     * @param popup The new {@link JPopupMenu} instance which ought to be part of the Swing UI.
     * @param &lt;P&gt; The concrete type of this new component.
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
    public static &lt;P extends JPopupMenu&gt; UIForPopup&lt;P&gt; of( P popup )
    {
<span class="nc" id="L924">        NullUtil.nullArgCheck(popup, &quot;popup&quot;, JPopupMenu.class);</span>
<span class="nc" id="L925">        return new UIForPopup&lt;&gt;(new BuilderState&lt;&gt;(popup));</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JPopupMenu} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPopupMenu())}.
     *
     * @return A builder instance for a {@link JPopupMenu}, which enables fluent method chaining.
     */
    public static UIForPopup&lt;JPopupMenu&gt; popupMenu() {
<span class="pc" id="L935">        return new UIForPopup&lt;&gt;(new BuilderState&lt;&gt;(UI.PopupMenu.class, ()-&gt;new UI.PopupMenu()));</span>
    }

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *
     * @param separator The new {@link JSeparator} instance which ought to be part of the Swing UI.
     * @param &lt;S&gt; The concrete type of this new component.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static &lt;S extends JSeparator&gt; UIForSeparator&lt;S&gt; of( S separator )
    {
<span class="nc" id="L948">        NullUtil.nullArgCheck(separator, &quot;separator&quot;, JSeparator.class);</span>
<span class="nc" id="L949">        return new UIForSeparator&lt;&gt;(new BuilderState&lt;&gt;(separator));</span>
    }

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator())}.
     *
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator() {
<span class="fc" id="L960">        return new UIForSeparator&lt;&gt;(new BuilderState&lt;&gt;(JSeparator.class, ()-&gt;new JSeparator()));</span>
    }

    /**
     *  This returns an instance of a {@link UIForSeparator} builder
     *  responsible for building a {@link JSeparator} by exposing helpful utility methods for it.
     *  This is in essence a convenience method for {@code UI.of(new JSeparator(JSeparator.VERTICAL))}.
     *
     * @param align The alignment of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( UI.Align align ) {
<span class="fc" id="L972">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L973">        return separator().withOrientation(align);</span>
    }

    /**
     *  Use this to create a swing tree builder node for the {@link JSeparator} whose
     *  alignment is dynamically determined based on a provided property.
     *
     * @param align The alignment property of the separator which may either be horizontal or vertical.
     * @return A {@link UIForSeparator} UI builder instance which wraps the {@link JSeparator} and exposes helpful methods.
     */
    public static UIForSeparator&lt;JSeparator&gt; separator( Val&lt;UI.Align&gt; align ) {
<span class="nc" id="L984">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L985">        return separator().withOrientation(align);</span>
    }

    /**
     *  This returns a {@link JButton} swing tree builder.
     *
     * @param component The button component which ought to be wrapped by the swing tree UI builder.
     * @param &lt;T&gt; The concrete type of this new component.
     * @return A basic UI {@link JButton} builder instance.
     */
    public static &lt;T extends AbstractButton&gt; UIForButton&lt;T&gt; of( T component )
    {
<span class="fc" id="L997">        NullUtil.nullArgCheck(component, &quot;component&quot;, AbstractButton.class);</span>
<span class="fc" id="L998">        return new UIForButton&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component without any text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton())}.
     *
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button() {
<span class="fc" id="L1008">        return new UIForButton&lt;&gt;(new BuilderState&lt;&gt;(UI.Button.class, ()-&gt;new UI.Button()));</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component with the provided text displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton(String text))}.
     *
     * @param text The text to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
<span class="fc" id="L1018">    public static UIForButton&lt;JButton&gt; button( String text ) { return button().withText(text); }</span>

    /**
     *  Create a builder for the {@link JButton} UI component where the text of the provided
     *  property is dynamically displayed on top.
     *
     * @param text The text property to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Val&lt;String&gt; text ) {
<span class="fc" id="L1028">        NullUtil.nullArgCheck( text, &quot;text&quot;, Val.class );</span>
<span class="fc" id="L1029">        return button().withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).peek( it -&gt; it.setIcon(icon) )}.
     *
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon ) {
<span class="nc" id="L1041">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1042">        return button().withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *
     * @param icon The icon to be displayed on top of the button.
     * @param fit The fit mode of the icon.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( ImageIcon icon, UI.FitComponent fit ) {
<span class="nc" id="L1054">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1055">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, UI.FitComponent.class);</span>
<span class="nc" id="L1056">        return button().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param icon The desired icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon ) {
<span class="nc" id="L1069">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1070">        return icon.find().map(UI::button).orElseGet(UI::button);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param icon The desired icon to be displayed on top of the button.
     * @param fit The fit mode of the icon.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, UI.FitComponent fit ) {
<span class="nc" id="L1084">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1085">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, UI.FitComponent.class);</span>
<span class="nc" id="L1086">        return icon.find().map( it -&gt; button(it, fit) ).orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top which should be scaled to the provided dimensions.
     *  This is in essence a convenience method for {@code UI.of(new JButton()).peek( it -&gt; it.setIcon(icon) )}.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, ImageIcon icon ) {
<span class="fc" id="L1100">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L1101">        return button().withIcon(width, height, icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with an icon displayed on top which should be scaled to the provided dimensions.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The desired icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L1116">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1117">        return icon.find().map( it -&gt; button(width, height, it) ).orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a dynamically displayed icon on top.
     *  &lt;p&gt;
     *  Note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property whose value ought to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; buttonWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L1144">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1145">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="nc" id="L1146">        return button().withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover ) {
<span class="nc" id="L1158">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1159">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="nc" id="L1160">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, IconDeclaration onHover ) {
<span class="nc" id="L1174">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1175">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1176">        return icon.find()</span>
<span class="nc" id="L1177">                .flatMap( it -&gt; onHover.find().map( it2 -&gt; button(it, it2) ) )</span>
<span class="nc" id="L1178">                .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top
     *  which should both be scaled to the provided dimensions.
     *
     * @param width The width the icons should be scaled to.
     * @param height The height the icons should be scaled to.
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, ImageIcon icon, ImageIcon onHover ) {
<span class="fc" id="L1193">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L1194">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, ImageIcon.class);</span>
<span class="fc" id="L1195">        float scale = UI.scale();</span>

<span class="fc" id="L1197">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L1199">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L1201">        width  = (int) (width * scale);</span>
<span class="fc" id="L1202">        height = (int) (height * scale);</span>

<span class="fc" id="L1204">        onHover = new ImageIcon(onHover.getImage().getScaledInstance(width, height, scaleHint));</span>
<span class="fc" id="L1205">        icon = new ImageIcon(icon.getImage().getScaledInstance(width, height, scaleHint));</span>
<span class="fc" id="L1206">        return button(icon, onHover, onHover);</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default icon as well as a hover icon displayed on top
     *  which should both be scaled to the provided dimensions.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param width The width the icons should be scaled to.
     * @param height The height the icons should be scaled to.
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( int width, int height, IconDeclaration icon, IconDeclaration onHover ) {
<span class="nc" id="L1223">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1224">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1225">        return icon.find()</span>
<span class="nc" id="L1226">                .flatMap( it -&gt; onHover.find().map( it2 -&gt; button(width, height, it, it2) ) )</span>
<span class="nc" id="L1227">                .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default, an on-hover and an on-press icon displayed on top.
     *  This is in essence a convenience method for:
     *  &lt;pre&gt;{@code
     *      UI.of(new JButton()).peek( it -&gt; {
     *          it.setIcon(icon);
     *          it.setRolloverIcon(onHover);
     *          it.setPressedIcon(onPress);
     *      })
     *  }&lt;/pre&gt;
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @param onPress The pressed icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( Icon icon, Icon onHover, Icon onPress ) {
<span class="fc" id="L1248">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L1249">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, Icon.class);</span>
<span class="fc" id="L1250">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, Icon.class);</span>
<span class="fc" id="L1251">        return button().peek(it -&gt; it.setIcon(icon) )</span>
<span class="fc" id="L1252">                .peek(it -&gt; it.setRolloverIcon(onHover) )</span>
<span class="fc" id="L1253">                .peek(it -&gt; it.setPressedIcon(onPress) );</span>
    }

    /**
     *  Use this to create a builder for the {@link JButton} UI component
     *  with a default, an on-hover and an on-press icon displayed on top.
     *  The icons are determined based on the provided {@link IconDeclaration}
     *  instances which is conceptually merely a resource paths to the icons.
     *
     * @param icon The default icon to be displayed on top of the button.
     * @param onHover The hover icon to be displayed on top of the button.
     * @param onPress The pressed icon to be displayed on top of the button.
     * @return A builder instance for a {@link JButton}, which enables fluent method chaining.
     */
    public static UIForButton&lt;JButton&gt; button( IconDeclaration icon, IconDeclaration onHover, IconDeclaration onPress ) {
<span class="nc" id="L1268">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1269">        NullUtil.nullArgCheck(onHover, &quot;onHover&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1270">        NullUtil.nullArgCheck(onPress, &quot;onPress&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1271">        return icon.find()</span>
<span class="nc" id="L1272">                .flatMap( it -&gt; onHover.find().flatMap( it2 -&gt; onPress.find().map( it3 -&gt; button(it, it2, it3) ) ) )</span>
<span class="nc" id="L1273">                .orElseGet( UI::button );</span>
    }

    /**
     *  Use this to create a builder for the {@link JSplitButton} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSplitButton())}.
     *
     * @param splitButton The split button component which ought to be wrapped by the swing tree UI builder.
     * @param &lt;B&gt; The concrete type of this new component.
     * @return A builder instance for a {@link JSplitButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JSplitButton&gt; UIForSplitButton&lt;B&gt; of( B splitButton ) {
<span class="fc" id="L1285">        NullUtil.nullArgCheck(splitButton, &quot;splitButton&quot;, JSplitButton.class);</span>
<span class="fc" id="L1286">        return new UIForSplitButton&lt;&gt;(new BuilderState&lt;&gt;(splitButton));</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s with custom text displayed ont top.
     *  The {@link JSplitButton} wrapped by the returned builder can be populated
     *  with {@link JMenuItem}s like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Displayed on button!&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;).onButtonClick( it -&gt; ... ))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JSplitButton}
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     */
    public static UIForSplitButton&lt;JSplitButton&gt; splitButton( String text ) {
<span class="fc" id="L1304">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1305">        return new UIForSplitButton&lt;&gt;(new BuilderState&lt;&gt;(JSplitButton.class, UI.SplitButton::new))</span>
<span class="fc" id="L1306">                .withText(text);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type, and the click event is
     *  handles by an {@link Event} instance. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *      private Event clickEvent = Event.of(()-&gt;{ ... }
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *      public Event clickEvent() { return clickEvent; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection(), vm.clickEvent())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the split button, the selected enum state
     *      will be converted to strings based on the {@link Object#toString()}
     *      method. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @param clickEvent The {@link Event} which will be fired when the user clicks on the button.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     * @param &lt;E&gt; The type of the {@link Enum} representing the selectable options.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection, Event clickEvent ) {
<span class="fc" id="L1342">        return splitButton(&quot;&quot;).withSelection(selection, clickEvent);</span>
    }

    /**
     *  Use this to build {@link JSplitButton}s where the selectable options
     *  are represented by an {@link Enum} type. &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.splitButton(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the button is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selection The {@link Var} which holds the currently selected {@link Enum} value.
     *                  This will be updated when the user selects a new value.
     * @return A UI builder instance wrapping a {@link JSplitButton}.
     * @param &lt;E&gt; The type of the {@link Enum} representing the selectable options.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForSplitButton&lt;JSplitButton&gt; splitButton( Var&lt;E&gt; selection ) {
<span class="fc" id="L1372">        return splitButton(&quot;&quot;).withSelection(selection);</span>
    }

    /**
     *  Use this to add entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(&quot;first&quot;))
     *      .add(UI.splitItem(&quot;second&quot;))
     *      .add(UI.splitItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JMenuItem} exposed by the {@link JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( String text ) {
<span class="fc" id="L1391">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1392">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add property bound entries to the {@link JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitItem(viewModel.getFirstButtonName()))
     *      .add(UI.splitItem(viewModel.getSecondButtonName()))
     *      .add(UI.splitItem(viewModel.getThirdButtonName()))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text property to dynamically display text on the {@link JMenuItem} exposed by the {@link swingtree.components.JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JMenuItem}.
     */
    public static SplitItem&lt;JMenuItem&gt; splitItem( Val&lt;String&gt; text ) {
<span class="nc" id="L1411">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1412">        return SplitItem.of(text);</span>
    }

    /**
     *  Use this to add radio item entries to the {@link swingtree.components.JSplitButton} by
     *  passing {@link SplitItem} instances to {@link UIForSplitButton} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitButton(&quot;Button&quot;)
     *      .add(UI.splitRadioItem(&quot;first&quot;))
     *      .add(UI.splitRadioItem(&quot;second&quot;))
     *      .add(UI.splitRadioItem(&quot;third&quot;))
     *  }&lt;/pre&gt;
     *  You can also use the {@link SplitItem} wrapper class to wrap
     *  useful action lambdas for the split item.
     *
     * @param text The text displayed on the {@link JRadioButtonMenuItem} exposed by the {@link swingtree.components.JSplitButton}s {@link JPopupMenu}.
     * @return A new {@link SplitItem} wrapping a simple {@link JRadioButtonMenuItem}.
     */
    public static SplitItem&lt;JRadioButtonMenuItem&gt; splitRadioItem( String text ) {
<span class="fc" id="L1431">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1432">        return SplitItem.of(new JRadioButtonMenuItem(text));</span>
    }

    /**
     *  Creates a UI builder for a custom {@link JTabbedPane} type.
     *
     * @param pane The {@link JTabbedPane} type which should be used wrapped.
     * @return This instance, to allow for method chaining.
     * @param &lt;P&gt; The pane type parameter.
     */
    public static &lt;P extends JTabbedPane&gt; UIForTabbedPane&lt;P&gt; of( P pane ) {
<span class="fc" id="L1443">        NullUtil.nullArgCheck(pane, &quot;pane&quot;, JTabbedPane.class);</span>
<span class="fc" id="L1444">        return new UIForTabbedPane&lt;&gt;(new BuilderState&lt;&gt;(pane));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTabbedPane())}.
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;one&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;two&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;three&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     *
     * @return A builder instance for a new {@link JTabbedPane}, which enables fluent method chaining.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane() {
<span class="fc" id="L1464">        return new UIForTabbedPane&lt;&gt;(new BuilderState&lt;&gt;(JTabbedPane.class, UI.TabbedPane::new));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link UI.Side} applied to the tab buttons
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.RIGHT)
     *      .add(UI.tab(&quot;first&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsSide The position of the tab buttons which may be {@link UI.Side#TOP}, {@link UI.Side#RIGHT}, {@link UI.Side#BOTTOM}, {@link UI.Side#LEFT}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( UI.Side tabsSide) {
<span class="fc" id="L1486">        NullUtil.nullArgCheck(tabsSide, &quot;tabsPosition&quot;, UI.Side.class);</span>
<span class="fc" id="L1487">        return tabbedPane().withTabPlacementAt(tabsSide);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link UI.OverflowPolicy} and {@link UI.Side} applied to the tab buttons
     *  (see {@link JTabbedPane#setTabLayoutPolicy(int)} and {@link JTabbedPane#setTabPlacement(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(Position.LEFT, OverflowPolicy.WRAP)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsSide The position of the tab buttons which may be {@link UI.Side#TOP}, {@link UI.Side#RIGHT}, {@link UI.Side#BOTTOM}, {@link UI.Side#LEFT}.
     * @param tabsPolicy The overflow policy of the tab buttons which can either be {@link UI.OverflowPolicy#SCROLL} or {@link UI.OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPosition} or {@code tabsPolicy} are {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane(UI.Side tabsSide, UI.OverflowPolicy tabsPolicy ) {
<span class="nc" id="L1509">        NullUtil.nullArgCheck(tabsSide, &quot;tabsPosition&quot;, UI.Side.class);</span>
<span class="nc" id="L1510">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, UI.OverflowPolicy.class);</span>
<span class="nc" id="L1511">        return tabbedPane().withTabPlacementAt(tabsSide).withOverflowPolicy(tabsPolicy);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@link UI.OverflowPolicy} applied to the tab buttons (see {@link JTabbedPane#setTabLayoutPolicy(int)}).
     *  In order to add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(OverflowPolicy.SCROLL)
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param tabsPolicy The overflow policy of the tab button which can either be {@link UI.OverflowPolicy#SCROLL} or {@link UI.OverflowPolicy#WRAP}.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code tabsPolicy} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( UI.OverflowPolicy tabsPolicy ) {
<span class="nc" id="L1531">        NullUtil.nullArgCheck(tabsPolicy, &quot;tabsPolicy&quot;, UI.OverflowPolicy.class);</span>
<span class="nc" id="L1532">        return tabbedPane().withTabPlacementAt(UI.Side.TOP).withOverflowPolicy(tabsPolicy);</span>
    }


    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectedIndex} property which should be determined the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *  Note that contrary to method {@link #tabbedPane(Var)}, this method receives a {@link Val}
     *  property which may not be changed by the GUI user. If you want to allow the user to change
     *  the selection index property state, use {@link #tabbedPane(Var)} instead.
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Val&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L1557">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTabbedPane} UI component
     *  with the provided {@code selectedIndex} property which should determine the
     *  tab selection of the {@link JTabbedPane} dynamically.
     *  To add tabs to this builder use the tab object returned by {@link #tab(String)}
     *  like so:
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane(vm.getSelectionIndex())
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param selectedIndex The index of the tab to select.
     * @return A builder instance wrapping a new {@link JTabbedPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selectedIndex} is {@code null}.
     */
    public static UIForTabbedPane&lt;JTabbedPane&gt; tabbedPane( Var&lt;Integer&gt; selectedIndex ) {
<span class="nc" id="L1578">        return tabbedPane().withSelectedIndex(selectedIndex);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(&quot;First&quot;).add(UI.panel().add(..)))
     *      .add(UI.tab(&quot;second&quot;).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(&quot;third&quot;).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( String title ) {
<span class="fc" id="L1596">        NullUtil.nullArgCheck(title, &quot;title&quot;, String.class);</span>
<span class="fc" id="L1597">        return new Tab(null, null, Val.of(title), null, null, null, null, null, null);</span>
    }

    /**
     *  A factory method producing a {@link Tab} instance with the provided {@code title} property
     *  which can dynamically change the title of the tab button.
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(property1).add(UI.panel().add(..)))
     *      .add(UI.tab(property2).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(property3).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param title The text property dynamically changing the title of the tab button when the property changes.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code title} is {@code null}.
     */
    public static Tab tab( Val&lt;String&gt; title ) {
<span class="fc" id="L1617">        NullUtil.nullArgCheck(title, &quot;title&quot;, Val.class);</span>
<span class="fc" id="L1618">        return new Tab(null, null, title, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(new JButton(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(new JLabel(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(new JPanel()).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param component The component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static Tab tab( JComponent component ) {
<span class="nc" id="L1636">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComponent.class);</span>
<span class="nc" id="L1637">        return new Tab(null, component, null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to add tabs to a {@link JTabbedPane} by
     *  passing {@link Tab} instances to {@link UIForTabbedPane} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.tabbedPane()
     *      .add(UI.tab(UI.button(&quot;X&quot;)).add(UI.panel().add(..)))
     *      .add(UI.tab(UI.label(&quot;Hi!&quot;)).withTip(&quot;I give info!&quot;).add(UI.label(&quot;read me&quot;)))
     *      .add(UI.tab(UI.of(...)).withIcon(someIcon).add(UI.button(&quot;click me&quot;)))
     *  }&lt;/pre&gt;
     *
     * @param builder The builder wrapping the component displayed on the tab button.
     * @return A {@link Tab} instance containing everything needed to be added to a {@link JTabbedPane}.
     * @throws IllegalArgumentException if {@code builder} is {@code null}.
     */
    public static Tab tab( UIForAnySwing&lt;?, ?&gt; builder ) {
<span class="fc" id="L1655">        NullUtil.nullArgCheck(builder, &quot;builder&quot;, UIForAnySwing.class);</span>
<span class="fc" id="L1656">        return new Tab(null, builder.getComponent(), null, null, null, null, null, null, null);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenu} instance.
     *
     * @param component The {@link JMenu} component which should be wrapped by the swing tree UI builder designed for menus.
     * @return A builder instance for the provided {@link JMenu}, which enables fluent method chaining.
     * @param &lt;M&gt; The concrete type of the menu.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenu&gt; UIForMenu&lt;M&gt; of( M component ) {
<span class="nc" id="L1668">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenu.class);</span>
<span class="nc" id="L1669">        return new UIForMenu&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  A convenient factory method for creating a declarative
     *  builder object for a plain {@link JMenu} component.
     *
     * @return A SwingTree builder node for the {@link JMenu} type.
     */
    public static UIForMenu&lt;JMenu&gt; menu() {
<span class="nc" id="L1679">        return new UIForMenu&lt;&gt;(new BuilderState&lt;&gt;(JMenu.class, UI.Menu::new));</span>
    }

    /**
     *  A convenient factory method for creating a declarative
     *  builder object for a {@link JMenu} component
     *  initialized with the provided text.
     *
     * @param text The text displayed on the menu.
     * @return A SwingTree builder node for the {@link JMenu} type.
     */
    public static UIForMenu&lt;JMenu&gt; menu( String text ) {
<span class="nc" id="L1691">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1692">        return menu().withText(text);</span>
    }

    /**
     *  A convenient factory method for creating a declarative
     *  builder object for a {@link JMenu} component
     *  bound to the supplied text property.
     *  Note that whenever the text property changes, the text
     *  displayed on the menu will be updated accordingly.
     *
     * @param text The text property dynamically changing the text displayed on the menu.
     * @return A SwingTree builder node for the {@link JMenu} type.
     */
    public static UIForMenu&lt;JMenu&gt; menu( Val&lt;String&gt; text ) {
<span class="nc" id="L1706">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1707">        return menu().withText(text);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JMenuItem} instance.
     *
     * @param component The {@link JMenuItem} component which should be wrapped by the swing tree UI builder designed for menu items.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type parameter of the concrete menu item component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;M extends JMenuItem&gt; UIForMenuItem&lt;M&gt; of( M component ) {
<span class="fc" id="L1719">        NullUtil.nullArgCheck(component, &quot;component&quot;, JMenuItem.class);</span>
<span class="fc" id="L1720">        return new UIForMenuItem&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  A convenient factory method for creating a declarative
     *  builder object for a the {@link JMenuItem} component type.&lt;br&gt;
     *  Menu items are usually passed to {@link JMenu}s or {@link JPopupMenu}s
     *  like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.menu()
     *  .add(UI.menuItem(&quot;Delete&quot;).onClick( it-&gt;{..} ))
     *  .add(UI.menuItem(&quot;Save&quot;).onClick( it-&gt;{..} ))
     *  .add(UI.menuItem(&quot;Exit&quot;).onClick( it-&gt;{..} ))
     *  }&lt;/pre&gt;
     *  See also {@link #menu()} and {@link #menu(String)}
     *  or {@link #popupMenu()} for related factory methods.
     *
     * @return A SwingTree builder node for the {@link JMenuItem} type.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem() {
<span class="fc" id="L1740">        return new UIForMenuItem&lt;&gt;(new BuilderState&lt;&gt;(JMenuItem.class, UI.MenuItem::new));</span>
    }

    /**
     *  This factory method creates a {@link JMenu} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.menuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.menuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text ) {
<span class="fc" id="L1757">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1758">        return menuItem().withText(text);</span>
    }

    /**
     *  This factory method creates a {@link JMenuItem} with the provided text property
     *  bound to the menu item. So when the property state changes to a different text,
     *  then so does the text displayed on the menu item. &lt;br&gt;
     *  A {@link JMenuItem} is typically used as part of {@link JMenu}s or {@link JPopupMenu}s.
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *  UI.popupMenu()
     *  .add(UI.menuItem(viewModel.actionName1()).onClick( it -&gt; {..} ))
     *  .add(UI.menuItem(viewModel.actionName2()).onClick( it -&gt; {..} ))
     *  }&lt;/pre&gt;
     *
     *
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L1778">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1779">        return menuItem().withText(text);</span>
    }

    /**
     *  Use this factory method to create a {@link JMenuItem} with the
     *  provided text and default icon. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.menuItem(&quot;Hello&quot;, UI.icon(&quot;path/to/icon.png&quot;))
     *    .withTip(&quot;I give info!&quot;)
     *    .onClick( it -&gt; {...} )
     *  }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Icon icon ) {
<span class="fc" id="L1797">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L1798">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L1799">        return menuItem()</span>
<span class="fc" id="L1800">                .withText(text)</span>
<span class="fc" id="L1801">                .withIcon(icon);</span>
    }

    /**
     *  Use this factory method to create a {@link JMenuItem} with the
     *  provided text and default icon based on the provided {@link IconDeclaration}. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.menuItem(&quot;Hello&quot;, Icons.MY_ICON)
     *    .withTip(&quot;I give info!&quot;)
     *    .onClick( it -&gt; {...} )
     *  }&lt;/pre&gt;
     *  Note that a {@link JMenuItem} is typically used as part of {@link JMenu}s or {@link JPopupMenu}s.
     *  See also {@link #menu()}, {@link #menu(String)} or {@link #popupMenu()} for related factory methods.
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, IconDeclaration icon ) {
<span class="nc" id="L1821">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1822">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1823">        return menuItem()</span>
<span class="nc" id="L1824">                .withText(text)</span>
<span class="nc" id="L1825">                .withIcon(icon);</span>
    }

    /**
     *  A factory method for creating a {@link JMenuItem} with an icon and the supplied text
     *  property uni-directionally bound to the menu item. &lt;br&gt;
     *  When the text property changes, the text displayed on the menu item will be updated accordingly.
     *
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L1838">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1839">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L1840">        return menuItem()</span>
<span class="nc" id="L1841">                .withText(text)</span>
<span class="nc" id="L1842">                .withIcon(icon);</span>
    }

    /**
     *  A factory method for creating a {@link JMenuItem} with an icon and the supplied text
     *  property uni-directionally bound to the menu item. &lt;br&gt;
     *  When the text property changes in the view model,
     *  the text displayed on the menu item will be updated accordingly.
     *
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, IconDeclaration icon ) {
<span class="nc" id="L1856">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1857">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L1858">        return menuItem()</span>
<span class="nc" id="L1859">                .withText(text)</span>
<span class="nc" id="L1860">                .withIcon(icon);</span>
    }

    /**
     *  Allows you to create a menu item with an icon property bound to it.
     *  So when the property state changes to a different icon, then so does the
     *  icon displayed on top of the menu item.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight and error tolerant value based object that merely
     *  models the resource location of the icon. It can exist even if the target
     *  icon is not yet loaded or does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view models,
     *  where the icon resources may not be available, but you still want to test
     *  the behaviour of your view model.
     *
     * @param text The text which should be displayed on the wrapped {@link JMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( String text, Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L1890">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1891">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1892">        return menuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  Allows you to create a menu item with a text property and
     *  an icon property bound to it.
     *  So when the text or con property state changes to a different text or icon, then so does the
     *  text and/or icon displayed on top of the menu item.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight and error tolerant value based object that merely
     *  models the resource location of the icon. It can exist even if the target
     *  icon is not yet loaded or does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view models,
     *  where the icon resources may not be available, but you still want to test
     *  the behaviour of your view model.
     *
     * @param text The text property which should be displayed on the wrapped {@link JMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JMenuItem}.
     * @return A builder instance for the provided {@link JMenuItem}, which enables fluent method chaining.
     */
    public static UIForMenuItem&lt;JMenuItem&gt; menuItem( Val&lt;String&gt; text, Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L1923">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1924">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L1925">        return menuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to wrap the provided {@link JRadioButtonMenuItem} instance in a SwingTree UI builder.
     *
     * @param radioMenuItem The {@link JRadioButtonMenuItem} instance to be wrapped.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type of the {@link JRadioButtonMenuItem} instance to be wrapped.
     */
    public static &lt;M extends JRadioButtonMenuItem&gt; UIForRadioButtonMenuItem&lt;M&gt; of( M radioMenuItem ) {
<span class="nc" id="L1936">        NullUtil.nullArgCheck(radioMenuItem, &quot;component&quot;, JRadioButtonMenuItem.class);</span>
<span class="nc" id="L1937">        return new UIForRadioButtonMenuItem&lt;&gt;(new BuilderState&lt;&gt;(radioMenuItem));</span>
    }

    /**
     *  A factory method to create a plain {@link JRadioButtonMenuItem} instance. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem().onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem().onClick( it -&gt; {..} ))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem() {
<span class="nc" id="L1952">        return new UIForRadioButtonMenuItem&lt;&gt;(new BuilderState&lt;&gt;(JRadioButtonMenuItem.class, UI.RadioButtonMenuItem::new));</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text ) {
<span class="nc" id="L1969">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L1970">        return radioButtonMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Delete&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Edit&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JRadioButtonMenuItem} dynamically.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L1989">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L1990">        return radioButtonMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with the provided text
     *  displayed on the menu button and the provided icon displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Delete&quot;, UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Edit&quot;, UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text, Icon icon ) {
<span class="nc" id="L2008">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2009">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2010">        return radioButtonMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided icon
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Delete&quot;), UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Edit&quot;), UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JRadioButtonMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */

    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L2032">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2033">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2034">        return radioButtonMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} bound to a fixed enum value
     *  and a variable enum property which will dynamically select the menu item based on the
     *  equality of the fixed enum value and the variable enum property value. &lt;br&gt;
     *  Consider the following example code:
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Unit.SECONDS, myViewModel.unitProperty()))
     *    .add(UI.radioButtonMenuItem(Unit.MINUTES, myViewModel.unitProperty()))
     *    .add(UI.radioButtonMenuItem(Unit.HOURS,   myViewModel.unitProperty()))
     *  }&lt;/pre&gt;
     *  In this example the {@code myViewModel.unitProperty()} is a {@link Var} property of
     *  example type {@code Unit}.
     *  A given menu item will be selected if the value of the {@code myViewModel.unitProperty()}
     *  is equal to the first enum value passed to the factory method.
     *  This first enum will also be used as the text of the menu item through the {@code toString()}.
     *
     * @param state The fixed enum value which will be used as the text of the menu item and
     * @param property The variable enum property which will be used to select the menu item.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the enum.
     * @throws IllegalArgumentException if {@code state} or {@code property} are {@code null}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( E state, Var&lt;E&gt; property ) {
<span class="nc" id="L2061">        NullUtil.nullArgCheck(state, &quot;state&quot;, Enum.class);</span>
<span class="nc" id="L2062">        NullUtil.nullArgCheck(property, &quot;property&quot;, Var.class);</span>
<span class="nc" id="L2063">        return radioButtonMenuItem(state.toString()).isSelectedIf(state, property);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the radio button based menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected1 = Var.of(false);
     *    Var&lt;Boolean&gt; isSelected2 = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(&quot;Make Coffee&quot;, isSelected1).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(&quot;Make Tea&quot;, isSelected2).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the boolean property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text which should be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( String text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2088">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2089">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2090">        return radioButtonMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to create a {@link JRadioButtonMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the radio button based menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected1 = Var.of(false);
     *    Var&lt;Boolean&gt; isSelected2 = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Make Coffee&quot;), isSelected1).onClick( it -&gt; {..} ))
     *    .add(UI.radioButtonMenuItem(Val.of(&quot;Make Tea&quot;), isSelected2).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the {@code String} and {@code boolean}
     * properties from a view model object through
     * plain old getter methods
     * (e.g. {@code myViewModel.getTextProperty()} and {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text property whose text should dynamically be displayed on the wrapped {@link JRadioButtonMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JRadioButtonMenuItem}, which enables fluent method chaining.
     */
    public static UIForRadioButtonMenuItem&lt;JRadioButtonMenuItem&gt; radioButtonMenuItem( Val&lt;String&gt; text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2117">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2118">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2119">        return radioButtonMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to wrap the provided {@link JCheckBoxMenuItem} instance in a SwingTree UI builder.
     *
     * @param checkBoxMenuItem The {@link JCheckBoxMenuItem} instance to be wrapped.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     * @param &lt;M&gt; The type of the {@link JCheckBoxMenuItem} instance to be wrapped.
     */
    public static &lt;M extends JCheckBoxMenuItem&gt; UIForCheckBoxMenuItem&lt;M&gt; of( M checkBoxMenuItem ) {
<span class="fc" id="L2130">        NullUtil.nullArgCheck(checkBoxMenuItem, &quot;component&quot;, JCheckBoxMenuItem.class);</span>
<span class="fc" id="L2131">        return new UIForCheckBoxMenuItem&lt;&gt;(new BuilderState&lt;&gt;(checkBoxMenuItem));</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} without text
     *  displayed on top of the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem().onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem().onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem() {
<span class="nc" id="L2147">        return new UIForCheckBoxMenuItem&lt;&gt;(new BuilderState&lt;&gt;(JCheckBoxMenuItem.class, UI.CheckBoxMenuItem::new));</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with the provided text
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text ) {
<span class="nc" id="L2164">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2165">        return checkBoxMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text ) {
<span class="nc" id="L2184">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2185">        return checkBoxMenuItem().withText(text);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with the provided text
     *  displayed on the menu button and the provided icon displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;, UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;, UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @param icon The icon which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text, Icon icon ) {
<span class="nc" id="L2203">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2204">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2205">        return checkBoxMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} with some custom text and a boolean property,
     *  dynamically determining whether the menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(&quot;Delete&quot;, isSelected).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(&quot;Edit&quot;, isSelected).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the boolean property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getIsSelectedProperty()}).
     *
     * @param text The text which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( String text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2229">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L2230">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2231">        return checkBoxMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided icon
     *  displayed on the menu button. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;), UI.icon(&quot;delete.png&quot;)).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;), UI.icon(&quot;edit.png&quot;)).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @param icon The icon which should be displayed on the wrapped {@link JCheckBoxMenuItem}.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text, Icon icon ) {
<span class="nc" id="L2252">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2253">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L2254">        return checkBoxMenuItem().withText(text).withIcon(icon);</span>
    }

    /**
     *  A factory method to create a {@link JCheckBoxMenuItem} bound to the provided text
     *  property, whose value will be displayed on the menu button dynamically and the provided boolean property,
     *  dynamically determining whether the menu item is selected or not. &lt;br&gt;
     *  Here an example demonstrating the usage of this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // inside your view model class:
     *    Var&lt;Boolean&gt; isSelected = Var.of(false);
     *    // inside your view class:
     *    UI.popupMenu()
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Delete&quot;), isSelected).onClick( it -&gt; {..} ))
     *    .add(UI.checkBoxMenuItem(Val.of(&quot;Edit&quot;), isSelected).onClick( it -&gt; {..} ))
     * }&lt;/pre&gt;
     * Note that in a real application you would take the text property from a model object through
     * a plain old getter method (e.g. {@code myViewModel.getTextProperty()}).
     *
     * @param text The text property which should be displayed on the wrapped {@link JCheckBoxMenuItem} dynamically.
     * @param isSelected The boolean property which will be bound to the menu item to dynamically
     *                   determines whether the menu item is selected or not.
     * @return A builder instance for the provided {@link JCheckBoxMenuItem}, which enables fluent method chaining.
     */
    public static UIForCheckBoxMenuItem&lt;JCheckBoxMenuItem&gt; checkBoxMenuItem( Val&lt;String&gt; text, Var&lt;Boolean&gt; isSelected ) {
<span class="nc" id="L2279">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L2280">        NullUtil.nullArgCheck(isSelected, &quot;isSelected&quot;, Var.class);</span>
<span class="nc" id="L2281">        return checkBoxMenuItem().withText(text).isSelectedIf(isSelected);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToolBar} instance.
     *  Using method chaining you can populate the {@link JToolBar} by like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.of(myToolBar)
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @param component The {@link JToolBar} instance to be wrapped.
     * @param &lt;T&gt; The type of the {@link JToolBar} instance to be wrapped.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;T extends JToolBar&gt; UIForToolBar&lt;T&gt; of( T component ) {
<span class="nc" id="L2302">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToolBar.class);</span>
<span class="nc" id="L2303">        return new UIForToolBar&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToolBar} instance.
     *  Use method chaining to add buttons or other components to a {@link JToolBar} by
     *  passing them to {@link UIForToolBar} builder like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.toolBar()
     *    .add(UI.button(&quot;X&quot;))
     *    .add(UI.button(&quot;Y&quot;))
     *    .add(UI.button(&quot;Z&quot;))
     *    .addSeparator()
     *    .add(UI.button(&quot;A&quot;))
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar() {
<span class="fc" id="L2323">        return new UIForToolBar&lt;&gt;(new BuilderState&lt;&gt;(JToolBar.class, UI.ToolBar::new));</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link UI.Align} enum defines the orientation of the {@link JToolBar}.
     *
     * @param align The {@link UI.Align} enum which defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( UI.Align align ) {
<span class="nc" id="L2335">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="nc" id="L2336">        return toolBar().withOrientation(align);</span>
    }

    /**
     *  A factory method for creating a {@link JToolBar} instance where
     *  the provided {@link Val} property dynamically defines
     *  the orientation of the {@link JToolBar}
     *
     * @param align The {@link Val} property which dynamically defines the orientation of the {@link JToolBar}.
     * @return A builder instance for the provided {@link JToolBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForToolBar&lt;JToolBar&gt; toolBar( Val&lt;UI.Align&gt; align ) {
<span class="nc" id="L2349">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="nc" id="L2350">        return toolBar().withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JScrollPane} component.
     *
     * @param component The {@link JScrollPane} component which should be represented by the returned builder.
     * @param &lt;P&gt; The type parameter defining the concrete scroll pane type.
     * @return A {@link UIForScrollPane} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPane&gt; UIForScrollPane&lt;P&gt; of( P component ) {
<span class="nc" id="L2362">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="nc" id="L2363">        return new UIForScrollPane&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPane())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPane()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPane}, which enables fluent method chaining.
     */
    public static UIForScrollPane&lt;JScrollPane&gt; scrollPane() {
<span class="fc" id="L2379">        return new UIForScrollPane&lt;&gt;(new BuilderState(UI.ScrollPane.class, UI.ScrollPane::new));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JScrollPanels} component.
     *
     * @param component The {@link JScrollPanels} component which should be represented by the returned builder.
     * @param &lt;P&gt; The type parameter defining the concrete scroll panels type.
     * @return A {@link UIForScrollPanels} builder representing the provided component.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JScrollPanels&gt; UIForScrollPanels&lt;P&gt; of( P component ) {
<span class="nc" id="L2391">        NullUtil.nullArgCheck(component, &quot;component&quot;, JScrollPane.class);</span>
<span class="nc" id="L2392">        return new UIForScrollPanels&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels()
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels() {
<span class="fc" id="L2410">        return new UIForScrollPanels&lt;&gt;(new BuilderState&lt;&gt;(JScrollPanels.class, ()-&gt;JScrollPanels.of(UI.Align.VERTICAL, new Dimension(100,100))));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL)
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(UI.Align align) {
<span class="nc" id="L2429">        return new UIForScrollPanels&lt;&gt;(new BuilderState&lt;&gt;(JScrollPanels.class, ()-&gt;JScrollPanels.of(align, null)));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JScrollPanels} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JScrollPanels())}. &lt;br&gt;
     *  Here is an example of a simple scroll panel with a text area inside:
     *  &lt;pre&gt;{@code
     *      UI.scrollPanels(Align.HORIZONTAL, new Dimension(100,100))
     *      .withScrollBarPolicy(UI.Scroll.NEVER)
     *      .add(UI.textArea(&quot;I am a text area with this text inside.&quot;))
     *      .add(UI.label(&quot;I am a label!&quot;))
     *      .add(UI.button(&quot;I am a button! Click me!&quot;))
     *  }&lt;/pre&gt;
     *
     * @param align The alignment of the scroll panels.
     * @param size The size of the scroll panels.
     * @return A builder instance for a new {@link JScrollPanels}, which enables fluent method chaining.
     */
    public static UIForScrollPanels&lt;JScrollPanels&gt; scrollPanels(UI.Align align, Dimension size) {
<span class="nc" id="L2449">        return new UIForScrollPanels&lt;&gt;(new BuilderState&lt;&gt;(JScrollPanels.class, ()-&gt;JScrollPanels.of(align, size)));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSplitPane} instance.
     *
     * @param component The {@link JSplitPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JSplitPane} instance.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JSplitPane&gt; UIForSplitPane&lt;P&gt; of( P component ) {
<span class="nc" id="L2461">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSplitPane.class);</span>
<span class="nc" id="L2462">        return new UIForSplitPane&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment enum determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      UI.splitPane(UI.Align.HORIZONTAL) // The split bar will be horizontal
     *      .withDividerAt(50)
     *      .add(UI.panel().add(...)) // top
     *      .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( UI.Align align ) {
<span class="fc" id="L2482">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L2483">        return new UIForSplitPane&lt;&gt;(new BuilderState&lt;&gt;(JSplitPane.class, ()-&gt;new UI.SplitPane(align)))</span>
<span class="fc" id="L2484">                .withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSplitPane} instance
     *  based on the provided alignment property determining how
     *  the split itself should be aligned. &lt;br&gt;
     *  You can create a simple split pane based UI like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    UI.splitPane(viewModel.getAlignment())
     *    .withDividerAt(50)
     *    .add(UI.panel().add(...)) // top
     *    .add(UI.scrollPane().add(...)) // bottom
     *  }&lt;/pre&gt;
     *  &lt;br&gt;
     *  The split pane will be updated whenever the provided property changes.
     *  &lt;br&gt;
     *  &lt;b&gt;Note:&lt;/b&gt; The provided property must not be {@code null}!
     *  Otherwise, an {@link IllegalArgumentException} will be thrown.
     *  &lt;br&gt;
     * @param align The alignment determining if the {@link JSplitPane} split bar is aligned vertically or horizontally.
     * @return A builder instance for the provided {@link JSplitPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     */
    public static UIForSplitPane&lt;JSplitPane&gt; splitPane( Val&lt;UI.Align&gt; align ) {
<span class="fc" id="L2509">        NullUtil.nullArgCheck(align, &quot;align&quot;, Val.class);</span>
<span class="fc" id="L2510">        NullUtil.nullPropertyCheck(align, &quot;align&quot;, &quot;Null is not a valid alignment.&quot;);</span>
<span class="fc" id="L2511">        return new UIForSplitPane&lt;&gt;(new BuilderState&lt;&gt;(JSplitPane.class, ()-&gt;new UI.SplitPane(align.get())))</span>
<span class="fc" id="L2512">                .withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JEditorPane} instance.
     *
     * @param component The {@link JEditorPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JEditorPane} instance.
     * @return A builder instance for the provided {@link JEditorPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JEditorPane&gt; UIForEditorPane&lt;P&gt; of( P component ) {
<span class="nc" id="L2524">        NullUtil.nullArgCheck(component, &quot;component&quot;, JEditorPane.class);</span>
<span class="nc" id="L2525">        return new UIForEditorPane&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JEditorPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JEditorPane())}.
     *
     * @return A builder instance for a new {@link JEditorPane}, which enables fluent method chaining.
     */
    public static UIForEditorPane&lt;JEditorPane&gt; editorPane() {
<span class="fc" id="L2535">        return new UIForEditorPane&lt;&gt;(new BuilderState&lt;&gt;(JEditorPane.class, UI.EditorPane::new));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextPane} instance.
     *
     * @param component The {@link JTextPane} instance to create a builder for.
     * @param &lt;P&gt; The type of the {@link JTextPane} instance.
     * @return A builder instance for the provided {@link JTextPane}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JTextPane&gt; UIForTextPane&lt;P&gt; of( P component ) {
<span class="nc" id="L2547">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextPane.class);</span>
<span class="nc" id="L2548">        return new UIForTextPane&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextPane} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextPane())}.
     *
     * @return A builder instance for a new {@link JTextPane}, which enables fluent method chaining.
     */
    public static UIForTextPane&lt;JTextPane&gt; textPane() {
<span class="nc" id="L2558">        return new UIForTextPane&lt;&gt;(new BuilderState&lt;&gt;(UI.TextPane.class, ()-&gt;new UI.TextPane()));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSlider} instance.
     *
     * @param component The {@link JSlider} instance to create a builder for.
     * @param &lt;S&gt; The type of the {@link JSlider} instance.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;S extends JSlider&gt; UIForSlider&lt;S&gt; of( S component ) {
<span class="fc" id="L2570">        NullUtil.nullArgCheck(component, &quot;component&quot;, JSlider.class);</span>
<span class="fc" id="L2571">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type determining if
     *  the slider will be aligned vertically or horizontally.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( UI.Align align ) {
<span class="fc" id="L2586">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L2587">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="fc" id="L2588">                .withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on the provided alignment property which dynamically
     *  determines if the property is aligned vertically or horizontally.
     *
     * @param align The alignment property determining if the {@link JSlider} aligns vertically or horizontally.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     * @throws IllegalArgumentException if the {@code align} property is {@code null}.
     *
     * @see JSlider#setOrientation
     */
    public static UIForSlider&lt;JSlider&gt; slider( Val&lt;UI.Align&gt; align ) {
<span class="nc" id="L2603">        NullUtil.nullArgCheck( align, &quot;align&quot;, Val.class );</span>
<span class="nc" id="L2604">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="nc" id="L2605">                .withOrientation(align);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSlider} instance
     *  based on tbe provided alignment type, min slider value and max slider value.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     */
    public static UIForSlider&lt;JSlider&gt; slider(UI.Align align, int min, int max ) {
<span class="fc" id="L2624">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L2625">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="fc" id="L2626">                .withOrientation(align)</span>
<span class="fc" id="L2627">                .withMin(min)</span>
<span class="fc" id="L2628">                .withMax(max)</span>
<span class="fc" id="L2629">                .withValue((min + max) / 2);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and initial values.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value  the initial value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider(UI.Align align, int min, int max, int value ) {
<span class="fc" id="L2650">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L2651">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="fc" id="L2652">                .withOrientation(align)</span>
<span class="fc" id="L2653">                .withMin(min)</span>
<span class="fc" id="L2654">                .withMax(max)</span>
<span class="fc" id="L2655">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value. &lt;br&gt;
     * The slider will be updated whenever the provided property changes.
     * But note that the property is of the read only {@link Val} type,
     * which means that when the user moves the slider, the property will not be updated.
     * &lt;br&gt;
     * If you want bidirectional binding, use {@link #slider(UI.Align, int, int, Var)}
     * instead of this method.
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider(UI.Align align, int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L2682">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="nc" id="L2683">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="nc" id="L2684">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="nc" id="L2685">                .withOrientation(align)</span>
<span class="nc" id="L2686">                .withMin(min)</span>
<span class="nc" id="L2687">                .withMax(max)</span>
<span class="nc" id="L2688">                .withValue(value);</span>
    }

    /**
     * Creates a slider with the specified alignment and the
     * specified minimum, maximum, and dynamic value property.
     * The property will be updated whenever the user
     * moves the slider and the slider will be updated whenever
     * the property changes in your code (see {@link Var#set(Object)}).
     *
     * @param align The alignment determining if the {@link JSlider} aligns vertically or horizontally.
     * @param min The minimum possible value of the slider.
     * @param max The maximum possible value of the slider.
     * @param value The property holding the value of the slider
     * @return A builder instance for the provided {@link JSlider}, which enables fluent method chaining.
     *
     * @throws IllegalArgumentException if {@code align} is {@code null}.
     *
     * @see JSlider#setOrientation
     * @see JSlider#setMinimum
     * @see JSlider#setMaximum
     * @see JSlider#setValue
     */
    public static UIForSlider&lt;JSlider&gt; slider(UI.Align align, int min, int max, Var&lt;Integer&gt; value ) {
<span class="fc" id="L2712">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L2713">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the slider should not be null!&quot;);</span>
<span class="fc" id="L2714">        return new UIForSlider&lt;&gt;(new BuilderState&lt;&gt;(JSlider.class, UI.Slider::new))</span>
<span class="fc" id="L2715">                .withOrientation(align)</span>
<span class="fc" id="L2716">                .withMin(min)</span>
<span class="fc" id="L2717">                .withMax(max)</span>
<span class="fc" id="L2718">                .withValue(value);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JComboBox} instance.&lt;br&gt;
     *  This is useful when you want to write declarative UI with a custom {@link JComboBox} type.
     *  Also see {@link #comboBox()} for a more convenient way to create a new {@link JComboBox} instance.
     *
     * @param component The {@link JComboBox} instance to create a builder for.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @param &lt;C&gt; The type of the {@link JComboBox} instance.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     */
    public static &lt;E, C extends JComboBox&lt;E&gt;&gt; UIForCombo&lt;E,C&gt; of( C component ) {
<span class="fc" id="L2732">        NullUtil.nullArgCheck(component, &quot;component&quot;, JComboBox.class);</span>
<span class="fc" id="L2733">        return new UIForCombo&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a UI builder for a the {@link JComboBox} component type.
     *  This is similar to {@code UI.of(new JComboBox())}.
     *
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for a new {@link JComboBox}, which enables fluent method chaining.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox() {
<span class="fc" id="L2744">        return new UIForCombo&lt;&gt;(new BuilderState&lt;&gt;(JComboBox.class, UI.ComboBox::new));</span>
    }

    /**
     *  Use this to declare a UI builder for the {@link JComboBox} component type
     *  with the provided array of elements as selectable items. &lt;br&gt;
     *  Note that the user may modify the items in the provided array
     *  (if the combo box is editable), if you do not want that,
     *  consider using {@link UI#comboBoxWithUnmodifiable(Object[])}
     *  or {@link UI#comboBoxWithUnmodifiable(java.util.List)}.
     *
     * @param items The array of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( E... items ) {
<span class="fc" id="L2762">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class);</span>
<span class="fc" id="L2763">        return ((UIForCombo)comboBox()).withModel(new ArrayBasedComboModel&lt;&gt;(items));</span>
    }

    /**
     *  Use this create a UI declaration for the {@link JComboBox} component type
     *  with the provided array of elements as selectable items
     *  and a lambda function converting each item into a
     *  user-friendly {@link String} representation. &lt;br&gt;
     *  Note that the user may modify the items in the provided array
     *  (if the combo box is editable), if you do not want that,
     *  consider using {@link UI#comboBoxWithUnmodifiable(Object[])}
     *  or {@link UI#comboBoxWithUnmodifiable(java.util.List)}.
     *
     * @param items The array of elements to be selectable in the {@link JComboBox}.
     * @param renderer A lambda function which is used for mapping each entry to a
     *                 user-friendly {@link String} representation.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( E[] items, Function&lt;E,String&gt; renderer ) {
<span class="nc" id="L2784">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class);</span>
<span class="nc" id="L2785">        return comboBox(items)</span>
<span class="nc" id="L2786">                .withTextRenderer(cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to declare a UI builder for the {@link JComboBox} type
     *  with the provided array of elements as selectable items which
     *  may not be modified by the user.
     *
     * @param items The unmodifiable array of elements to be selectable in the {@link JList}.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( E... items ) {
<span class="fc" id="L2801">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class); // Unmodifiable</span>
<span class="fc" id="L2802">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(java.util.Arrays.asList(items));</span>
<span class="fc" id="L2803">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Use this to declare a UI builder for the {@link JComboBox} type
     *  with the provided array of elements as selectable items which
     *  may not be modified by the user.
     *  Use this create a UI declaration for the {@link JComboBox} component type
     *  with the provided array of elements as selectable &lt;b&gt;but unmodifiable&lt;/b&gt; items
     *  and a lambda function converting each item into a
     *  user-friendly {@link String} representation. &lt;br&gt;
     *
     * @param items The unmodifiable array of elements to be selectable in the drop down list of the combo box.
     * @param &lt;E&gt; The type of the elements in the {@link JComboBox}.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( E[] items, Function&lt;E,String&gt; renderer ) {
<span class="nc" id="L2821">        NullUtil.nullArgCheck(items, &quot;items&quot;, Object[].class); // Unmodifiable</span>
<span class="nc" id="L2822">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(java.util.Arrays.asList(items));</span>
<span class="nc" id="L2823">        return comboBox(unmodifiableList)</span>
<span class="nc" id="L2824">                .withTextRenderer(cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  where the provided enum based property dynamically models the selected item
     *  as well as all possible options (all the enum states).
     *  The property will be updated whenever the user
     *  selects a new item in the {@link JComboBox} and the {@link JComboBox}
     *  will be updated whenever the property changes in your code (see {@link Var#set(Object)}).
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.comboBox(vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      The text displayed on the combo box is based on the {@link Object#toString()}
     *      method of the enum instances. If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     * @param selectedItem A property modelling the selected item in the combo box.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem ) {
<span class="fc" id="L2858">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
        // We get an array of possible enum states from the enum class
<span class="fc" id="L2860">        return comboBox(selectedItem.type().getEnumConstants()).withSelectedItem(selectedItem);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JComboBox} instance
     *  where the provided enum based property dynamically models the selected item
     *  as well as all possible options (all the enum states).
     *  The property will be updated whenever the user
     *  selects a new item in the {@link JComboBox} and the {@link JComboBox}
     *  will be updated whenever the property changes in your code (see {@link Var#set(Object)}).
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.comboBox(vm.selection(), e -&gt; switch (e) {
     *          case SMALL -&gt; &quot;Small&quot;;
     *          case MEDIUM -&gt; &quot;Medium&quot;;
     *          case LARGE -&gt; &quot;Large&quot;;
     *      })
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that the second argument is a function that maps each enum state to the text
     * which is actually displayed in the combo box to the user.
     *
     * @param selectedItem A property modelling the selected item in the combo box.
     * @param renderer A lambda function which is used for mapping each entry to a
     *                 user friendly {@link String} representation.
     * @return A builder instance for the new {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem, Function&lt;E, String&gt; renderer ) {
<span class="fc" id="L2897">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
        // We get an array of possible enum states from the enum class
<span class="fc" id="L2899">        return comboBox(selectedItem.type().getEnumConstants())</span>
<span class="fc" id="L2900">                .withSelectedItem(selectedItem)</span>
<span class="pc" id="L2901">                .withTextRenderer(cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;));</span>
    }

    /**
     *  Use this to declare a builder for a new {@link JComboBox} instance
     *  with the provided list of elements as selectable items.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( java.util.List&lt;E&gt; items ) {
<span class="fc" id="L2914">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L2915">        return ((UIForCombo)comboBox()).withItems(items);</span>
    }

    /**
     *   Use this to declare a builder for a new {@link JComboBox} instance
     *  with the provided list of elements as selectable items and a
     *  custom renderer function to display the items in the combo box
     *  as text.
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      List&lt;String&gt; items = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;);
     *      // In your view:
     *      UI.comboBox(items, fruit -&gt; fruit.toUpperCase())
     *  }&lt;/pre&gt;
     *  In this example, the combo box will display the items as &quot;APPLE&quot;, &quot;BANANA&quot;, &quot;CHERRY&quot;.
     *  The provided function is called for each item in the list to determine the text
     *  that should be displayed in the combo box.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A builder instance for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
     public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( java.util.List&lt;E&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="fc" id="L2941">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L2942">        Objects.requireNonNull(renderer, &quot;renderer&quot;);</span>
<span class="fc" id="L2943">        return comboBox(items)</span>
<span class="fc" id="L2944">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided {@link UI.List} of elements as selectable items which
     *  may not be modified by the user. &lt;br&gt;
     *  So even if the combo box is editable, the user will not be able to
     *  modify the items in the list (the selected item inside the
     *  text field can still be modified though).
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @return A UI builder for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( java.util.List&lt;E&gt; items ) {
<span class="nc" id="L2960">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="nc" id="L2961">        java.util.List&lt;E&gt; unmodifiableList = Collections.unmodifiableList(items);</span>
<span class="nc" id="L2962">        return comboBox(unmodifiableList);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided list of items,
     *  which may not be modified by the user. &lt;br&gt;
     *  An additional renderer function is provided to customize how the items
     *  are displayed as texts in the combo box.&lt;br&gt;
     *  Here's an example of how the method may be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      List&lt;String&gt; items = List.of(&quot;John&quot;, &quot;Jane&quot;, &quot;Jack&quot;);
     *      // In your view:
     *      UI.comboBoxWithUnmodifiable(items, name -&gt; name.toLowerCase())
     *  }&lt;/pre&gt;
     *  In this example, the combo box will display the items as &quot;john&quot;, &quot;jane&quot;, &quot;jack&quot;.
     *  The provided function is called for each item in the list to determine the text
     *  that should be displayed in the combo box.
     *
     * @param items The list of elements to be selectable in the {@link JComboBox}.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A builder instance for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBoxWithUnmodifiable( java.util.List&lt;E&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="nc" id="L2987">        Objects.requireNonNull(renderer, &quot;renderer&quot;);</span>
<span class="nc" id="L2988">        return comboBoxWithUnmodifiable(items)</span>
<span class="nc" id="L2989">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, java.util.List&lt;E&gt; items ) {
<span class="fc" id="L3005">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L3006">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3007">        return ((UIForCombo)comboBox()).withItems(selection, items);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided selection property
     *  and the list of items as well as a custom renderer function to display the items
     *  as text in the combo box. &lt;br&gt;
     *  Here's an example of how the method can be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      List&lt;String&gt; days = List.of(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;);
     *      Var&lt;String&gt; selectedDay = Var.of(&quot;Monday&quot;);
     *      // In your view:
     *      UI.comboBox(selectedDay, days, day -&gt; &quot;Day: &quot; + day)
     *      // The combo box will display the items as &quot;Day: Monday&quot;, &quot;Day: Tuesday&quot;, &quot;Day: Wednesday&quot;
     *  }&lt;/pre&gt;
     *  In this example, the provided function is called for each item in the list to determine the text
     *  that should be displayed in the combo box.
     *
     * @param selection The property holding the current selection, which will be updated whenever the user selects a new item.
     * @param items The list of selectable items.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A builder instance for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox(
        Var&lt;E&gt; selection, java.util.List&lt;E&gt; items, Function&lt;E, String&gt; renderer
    ) {
<span class="fc" id="L3035">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L3036">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3037">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="fc" id="L3038">        return comboBox(selection, items)</span>
<span class="fc" id="L3039">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }


    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and mutable) items.
     *
     * @param items The {@link Vars} properties of elements to be selectable in the {@link JComboBox}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A declarative builder for the provided {@link JComboBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vars&lt;E&gt; items ) {
<span class="fc" id="L3053">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3054">        return ((UIForCombo)comboBox()).withItems(items);</span>
    }

    /**
     *  Creates a declarative UI builder for the {@link JComboBox} component type
     *  where the provided property list dynamically models the selectable items
     *  in the combo box and a renderer function determines how the items are displayed
     *  as text in the combo box dropdown list. &lt;br&gt;
     *  The following example demonstrates how this method may be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // In your view model:
     *    enum Coffee { ESPRESSO, LATTE, CAPPUCCINO }
     *    Vars&lt;Coffee&gt; items = Vars.of(Coffee.ESPRESSO,
     *                                 Coffee.LATTE,
     *                                 Coffee.CAPPUCCINO);
     *    // In your view:
     *    UI.comboBox(items, coffee -&gt; switch (coffee) {
     *      case ESPRESSO -&gt; &quot;Espresso&quot;;
     *      case LATTE -&gt; &quot;Latte&quot;;
     *      case CAPPUCCINO -&gt; &quot;Cappuccino&quot;;
     *    })
     *    .onSelection( it -&gt; ... )
     *  }&lt;/pre&gt;
     *
     * @param items The property holding the list of selectable items.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vars&lt;E&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="fc" id="L3084">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3085">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="fc" id="L3086">        return comboBox(items)</span>
<span class="fc" id="L3087">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a builder for a new  {@link JComboBox} instance
     *  with the provided properties list object as selectable (and immutable) items which
     *  may not be modified by the user.
     *
     * @param items The {@link sprouts.Vals} properties of elements to be selectable in the {@link JComboBox}.
     * @return A builder instance for the provided {@link JComboBox}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vals&lt;E&gt; items ) {
<span class="nc" id="L3100">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3101">        return ((UIForCombo)comboBox()).withItems(items);</span>
    }

    /**
     *  Creates a declarative UI builder for the {@link JComboBox} component type
     *  where the provided property list dynamically models the selectable items
     *  in the combo box and a renderer function determines how the items are displayed
     *  as text in the combo box dropdown list. &lt;br&gt;
     *  The following example demonstrates how this method may be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *    // In your view model:
     *    enum Coffee { ESPRESSO, LATTE, CAPPUCCINO }
     *    Vals&lt;Coffee&gt; items = Vals.of(Coffee.ESPRESSO,
     *                                 Coffee.LATTE,
     *                                 Coffee.CAPPUCCINO);
     *    // In your view:
     *    UI.comboBox(items, coffee -&gt; switch (coffee) {
     *      case ESPRESSO -&gt; &quot;Espresso&quot;;
     *      case LATTE -&gt; &quot;Latte&quot;;
     *      case CAPPUCCINO -&gt; &quot;Cappuccino&quot;;
     *    })
     *    .onSelection( it -&gt; ... )
     *  }&lt;/pre&gt;
     *  Note that the provided list may not be modified by the user
     *  due to the use of the {@link Vals} property type, which is an immutable
     *  view of the list of items.
     *
     * @param items The property holding the list of selectable items.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Vals&lt;E&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="nc" id="L3134">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3135">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="nc" id="L3136">        return comboBox(items)</span>
<span class="nc" id="L3137">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a list of items as a dynamically sized model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided list may be mutated by the combo box UI component
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vars&lt;E&gt; items ) {
<span class="fc" id="L3153">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3154">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3155">        return ((UIForCombo)comboBox()).withItems(selection, items);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided selection property,
     *  a property list of selectable items as well as a custom renderer
     *  function to display the items as the desired text in the combo box. &lt;br&gt;
     *  Here's an example of how the method can be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Sentiment { POSITIVE, NEUTRAL, NEGATIVE }
     *      Var&lt;Sentiment&gt; selected = Var.of(Sentiment.NEUTRAL);
     *      Vars&lt;Sentiment&gt; sentiments = Vars.of(Sentiment.POSITIVE,
     *                                           Sentiment.NEUTRAL,
     *                                           Sentiment.NEGATIVE);
     *      // In your view:
     *      UI.comboBox(selected, sentiments, s -&gt; switch (s) {
     *          case POSITIVE -&gt; &quot;Positive&quot;;
     *          case NEUTRAL -&gt; &quot;Neutral&quot;;
     *          case NEGATIVE -&gt; &quot;Negative&quot;;
     *      })
     *  }&lt;/pre&gt;
     *  In the example above, the provided function is called for each item in the list
     *  to determine the text that should be displayed in the combo box dropdown list.
     *
     * @param selection The property holding the current selection, which will be updated whenever the user selects a new item.
     * @param items A property list of selectable items.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox(
        Var&lt;E&gt; selection, Vars&lt;E&gt; items, Function&lt;E, String&gt; renderer
    ) {
<span class="fc" id="L3189">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vars.class);</span>
<span class="fc" id="L3190">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L3191">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="fc" id="L3192">        return comboBox(selection, items)</span>
<span class="fc" id="L3193">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and a property list of items as a dynamically sized model for the
     *  selectable items which may not be modified by the user.
     *  Use {@link #comboBox(Var, Vars)} if you want the user to be able to modify the items.
     *
     * @param selection The property holding the current selection.
     * @param items The list of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vals&lt;E&gt; items ) {
<span class="nc" id="L3208">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3209">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L3210">        return ((UIForCombo)comboBox()).withItems(selection, items);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided selection property,
     *  a property list of selectable items as well as a custom renderer
     *  function to display the items as the desired text in the combo box. &lt;br&gt;
     *  Here's an example of how the method can be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum BloodType { A, B, AB, O }
     *      Var&lt;Sentiment&gt; selected = Var.of(BloodType.A);
     *      Vals&lt;Sentiment&gt; types = Vals.of(BloodType.A,
     *                                      BloodType.B,
     *                                      BloodType.AB,
     *                                      BloodType.O);
     *      // In your view:
     *      UI.comboBox(selected, types, t -&gt; switch (t) {
     *          case A -&gt; &quot;Type A&quot;;
     *          case B -&gt; &quot;Type B&quot;;
     *          case AB -&gt; &quot;Type AB&quot;;
     *          case O -&gt; &quot;Type O&quot;;
     *      })
     *  }&lt;/pre&gt;
     *  In the example above, the provided function is called for each item in the list
     *  to determine the text that should be displayed in the combo box dropdown list.
     *  Note that we are using the {@link Vals} property type to ensure the list of items
     *  is immutable and cannot be modified by the user.
     *  If you want the user to be able to modify the items, use {@link #comboBox(Var, Vars, Function)}.
     *
     * @param selection The property holding the current selection, which will be updated whenever the user selects a new item.
     * @param items A property list of selectable items which may not be modified by the user.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selection, Vals&lt;E&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="nc" id="L3247">        NullUtil.nullArgCheck(items, &quot;items&quot;, Vals.class);</span>
<span class="nc" id="L3248">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="nc" id="L3249">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="nc" id="L3250">        return comboBox(selection, items)</span>
<span class="nc" id="L3251">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array of items as a fixed-size model for the
     *  selectable items.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The array of selectable items.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, E... items ) {
<span class="fc" id="L3267">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L3268">        return ((UIForCombo)comboBox()).withItems(var, items);</span>
    }

    /**
     *  Creates a combo box UI declaration with a {@link Var} property as the model
     *  for the current selection and an array of items as a fixed-size model for the
     *  selectable items, as well as a lambda function which maps each combo box item
     *  to a user-friendly {@link String} representation.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component.
     *
     * @param var The property holding the current selection.
     * @param items The array of selectable items.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     *                 It is intended to make the type of entry more human readable and thereby user-friendly.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox(
        Var&lt;E&gt; var, E[] items, Function&lt;E, String&gt; renderer
    ) {
<span class="nc" id="L3289">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="nc" id="L3290">        return comboBox(var, items)</span>
<span class="nc" id="L3291">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param var The property holding the current selection.
     * @param items The property holding an array of selectable items which can be mutated by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, Var&lt;E[]&gt; items ) {
<span class="fc" id="L3307">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L3308">        return ((UIForCombo)comboBox()).withItems(var, items);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided selection property,
     *  a property of an array of selectable items and a custom renderer
     *  function to display the items as the desired text in the combo box. &lt;br&gt;
     *  Here's an example of how the method can be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Cost { CHEAP, MODERATE, EXPENSIVE }
     *      Var&lt;Cost&gt; selected = Var.of(Cost.CHEAP);
     *      Var&lt;Cost[]&gt; costs = Var.of(Cost.values());
     *      // In your view:
     *      UI.comboBox(selected, costs, c -&gt; switch (c) {
     *          case CHEAP -&gt; &quot;Cheap&quot;;
     *          case MODERATE -&gt; &quot;Moderate&quot;;
     *          case EXPENSIVE -&gt; &quot;Expensive&quot;;
     *      })
     *  }&lt;/pre&gt;
     *  In the example above, the provided function is called for each item in the list
     *  to determine the text that should be displayed in the combo box dropdown list.
     *  Note that changing the contents of the array in the property may not properly
     *  update the selectable options in the combo box. Instead, ensure that the
     *  {@link Var#set(Object)}, or {@link Var#fireChange(Channel)} method is used
     *  to update the available options in the combo box.
     *
     * @param var The property holding the current selection, which will be updated whenever the user selects a new item.
     * @param items A property array of selectable items which can be mutated by the user.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; var, Var&lt;E[]&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="fc" id="L3342">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="fc" id="L3343">        NullUtil.nullArgCheck(var, &quot;var&quot;, Var.class);</span>
<span class="fc" id="L3344">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="fc" id="L3345">        return comboBox(var, items)</span>
<span class="fc" id="L3346">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Creates a combo box UI builder node with a {@link Var} property as the model
     *  for the current selection and an array property of items as a selectable items model
     *  of variable length.
     *  &lt;p&gt;
     *  Note that the provided array may be mutated by the combo box UI component
     *
     * @param selectedItem The property holding the current selection.
     * @param items The property holding an array of selectable items which may not be modified by the user.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem, Val&lt;E[]&gt; items ) {
<span class="nc" id="L3362">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="nc" id="L3363">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
<span class="nc" id="L3364">        return ((UIForCombo)comboBox()).withItems(selectedItem, items);</span>
    }

    /**
     *  Creates a declarative combo box UI based on the provided selection property,
     *  a property of an array of selectable items and a custom renderer
     *  function to display the items as the desired text in the combo box. &lt;br&gt;
     *  Here's an example of how the method can be used: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Vehicle { TRAIN, BIKE, BUS }
     *      Var&lt;Vehicle&gt; selected = Var.of(Vehicle.BIKE);
     *      Val&lt;Vehicle[]&gt; vehicles = Val.of(Vehicle.values());
     *      // In your view:
     *      UI.comboBox(selected, vehicles, v -&gt; switch (v) {
     *          case TRAIN -&gt; &quot;Train&quot;;
     *          case BIKE -&gt; &quot;Bike&quot;;
     *          case BUS -&gt; &quot;Bus&quot;;
     *      })
     *  }&lt;/pre&gt;
     *  In this example the provided function is called for each item in the list
     *  to determine the text that should be displayed in the combo box dropdown list.
     *  Note that changing the contents of the array in the property may not properly
     *  update the selectable options in the combo box. Instead, ensure that the
     *  {@link Var#set(Object)}, or {@link Var#fireChange(Channel)} method is used
     *  to update the available options in the combo box.
     *
     * @param selectedItem The property holding the current selection, which will be updated whenever the user selects a new item.
     * @param items A property array of selectable items which may not be modified by the user.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     * @return A declarative builder for the {@link JComboBox} type, to allow for fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( Var&lt;E&gt; selectedItem, Val&lt;E[]&gt; items, Function&lt;E, String&gt; renderer ) {
<span class="nc" id="L3398">        NullUtil.nullArgCheck(items, &quot;items&quot;, UI.List.class);</span>
<span class="nc" id="L3399">        NullUtil.nullArgCheck(selectedItem, &quot;selectedItem&quot;, Var.class);</span>
<span class="nc" id="L3400">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, Function.class);</span>
<span class="nc" id="L3401">        return comboBox(selectedItem, items)</span>
<span class="nc" id="L3402">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Created a combo box UI builder node with the provided {@link ComboBoxModel}.
     *
     * @param model The model to be used by the combo box.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( ComboBoxModel&lt;E&gt; model ) {
<span class="nc" id="L3413">        NullUtil.nullArgCheck(model, &quot;model&quot;, ComboBoxModel.class);</span>
<span class="nc" id="L3414">        return (UIForCombo)comboBox().peek( c -&gt; ((JComboBox)c).setModel(model) );</span>
    }

    /**
     *  Created a combo box UI builder node with the provided {@link ComboBoxModel}
     *  and a lambda function mapping each model entry to a user-friendly
     *  human-readable {@link String} representation.
     *
     * @param model The model to be used by the combo box.
     * @param renderer A function that maps each item to the text that should be displayed in the combo box.
     *                 It is intended to make the type of entry more human-readable and thereby user-friendly.
     * @return A builder instance for the provided {@link JList}, which enables fluent method chaining.
     * @param &lt;E&gt; The type of the elements in the combo box.
     */
    public static &lt;E&gt; UIForCombo&lt;E,JComboBox&lt;E&gt;&gt; comboBox( ComboBoxModel&lt;E&gt; model, Function&lt;E, String&gt; renderer ) {
<span class="nc" id="L3429">        NullUtil.nullArgCheck(model, &quot;model&quot;, ComboBoxModel.class);</span>
<span class="nc" id="L3430">        return comboBox(model)</span>
<span class="nc" id="L3431">                .withTextRenderer( cell -&gt; cell.value().map(renderer).orElse(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JSpinner} instance.
     *
     * @param spinner The {@link JSpinner} instance to create a builder for.
     *                The provided {@link JSpinner} instance must not be {@code null}.
     * @param &lt;S&gt; The type parameter of the concrete {@link JSpinner} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code spinner} is {@code null}.
     */
    public static &lt;S extends JSpinner&gt; UIForSpinner&lt;S&gt; of( S spinner ) {
<span class="fc" id="L3444">        NullUtil.nullArgCheck(spinner, &quot;spinner&quot;, JSpinner.class);</span>
<span class="fc" id="L3445">        return new UIForSpinner&lt;&gt;(new BuilderState&lt;&gt;(spinner));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JSpinner} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JSpinner())}.
     *
     * @return A builder instance for a new {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;JSpinner&gt; spinner() {
<span class="fc" id="L3455">        return new UIForSpinner&lt;&gt;(new BuilderState&lt;&gt;(UI.Spinner.class, ()-&gt;new UI.Spinner()));</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@link SpinnerModel} as the model.
     *
     * @param model The {@link SpinnerModel} to be used by the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( SpinnerModel model ) {
<span class="nc" id="L3466">        NullUtil.nullArgCheck(model, &quot;model&quot;, SpinnerModel.class);</span>
<span class="nc" id="L3467">        return new UIForSpinner&lt;&gt;(new BuilderState&lt;JSpinner&gt;(UI.Spinner.class, UI.Spinner::new))</span>
<span class="nc" id="L3468">                .peek( s -&gt; s.setModel(model) );</span>
    }

    /**
     *  Use this factory method to create a {@link JSpinner} bound to a property of any type.
     *  The property will be updated when the user modifies its value.
     *
     * @param value A property of any type which should be bound to this spinner.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( Var&lt;?&gt; value ) {
<span class="fc" id="L3479">        NullUtil.nullArgCheck(value, &quot;value&quot;, Var.class);</span>
<span class="fc" id="L3480">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;The state of the spinner should not be null!&quot;);</span>
<span class="fc" id="L3481">        return spinner().withValue(value);</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max}, default {@code value} and {@code step} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @param step The step size of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max, int step ) {
<span class="nc" id="L3495">        return new UIForSpinner&lt;&gt;(new BuilderState&lt;JSpinner&gt;(UI.Spinner.class, UI.Spinner::new))</span>
<span class="nc" id="L3496">                .peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, step)) );</span>
    }

    /**
     * Use this to create a builder for the provided {@link JSpinner} instance
     * with the provided {@code min}, {@code max} and default {@code value} as the model.
     *
     * @param value The default value of the {@link JSpinner}.
     * @param min The minimum possible value of the {@link JSpinner}.
     * @param max The maximum possible value of the {@link JSpinner}.
     * @return A builder instance for the provided {@link JSpinner}, which enables fluent method chaining.
     */
    public static UIForSpinner&lt;javax.swing.JSpinner&gt; spinner( int value, int min, int max ) {
<span class="fc" id="L3509">        return new UIForSpinner&lt;&gt;(new BuilderState&lt;JSpinner&gt;(UI.Spinner.class, UI.Spinner::new))</span>
<span class="fc" id="L3510">                .peek( s -&gt; s.setModel(new SpinnerNumberModel(value, min, max, 1)) );</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JLabel} instance.
     *
     * @param label The {@link JLabel} instance to be used by the builder.
     * @param &lt;L&gt; The type parameter of the concrete {@link JLabel} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JLabel}, which enables fluent method chaining.
     */
    public static &lt;L extends JLabel&gt; UIForLabel&lt;L&gt; of( L label ) {
<span class="fc" id="L3521">        NullUtil.nullArgCheck(label, &quot;component&quot;, JLabel.class);</span>
<span class="fc" id="L3522">        return new UIForLabel&lt;&gt;(new BuilderState&lt;&gt;(label));</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(text)}.
     *
     * @param text The text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text ) {
<span class="fc" id="L3533">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3534">        return _label().withText(text);</span>
    }

    private static UIForLabel&lt;JLabel&gt; _label() {
<span class="fc" id="L3538">        return new UIForLabel&lt;&gt;(new BuilderState&lt;&gt;(UI.Label.class, UI.Label::new));</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(text, alignment))}.
     *
     * @param text The text which should be displayed on the label.
     * @param alignment The horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text, UI.HorizontalAlignment alignment ) {
<span class="fc" id="L3550">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3551">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class);</span>
<span class="fc" id="L3552">        return _label().withText(text).withHorizontalAlignment( alignment );</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *
     * @param text The text which should be displayed on the label.
     * @param alignment The vertical and horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( String text, UI.Alignment alignment ) {
<span class="nc" id="L3563">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="nc" id="L3564">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, UI.Alignment.class);</span>
<span class="nc" id="L3565">        return _label().withText(text).withAlignment( alignment );</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(Val&lt;String&gt; text)}.
     *
     * @param text The text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Val&lt;String&gt; text ) {
<span class="fc" id="L3576">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3577">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3578">        return _label()</span>
<span class="pc bpc" id="L3579" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L3580">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for the {@link JLabel} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(Val&lt;String&gt; text, alignment)}.
     *
     * @param text The text property which should be bound to the label.
     * @param alignment The horizontal alignment of the text.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Val&lt;String&gt; text, UI.HorizontalAlignment alignment ) {
<span class="nc" id="L3592">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3593">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3594">        NullUtil.nullArgCheck(alignment, &quot;alignment&quot;, UI.HorizontalAlignment.class);</span>
<span class="nc" id="L3595">        return _label()</span>
<span class="nc bnc" id="L3596" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3597">                .withText(text)</span>
<span class="nc" id="L3598">                .withHorizontalAlignment( alignment );</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( Icon icon ) {
<span class="nc" id="L3608">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L3609">        return _label().withIcon(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *  The icon is specified by a {@link IconDeclaration} which
     *  is essentially just a path to an icon resource.
     *  If the icon cannot be found, the label will be empty.
     *  Note that loaded icons are cached, so if you load the same icon multiple times,
     *  the same icon instance will be used (see {@link SwingTree#getIconCache()}).
     *
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( IconDeclaration icon ) {
<span class="nc" id="L3624">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3625">        return icon.find().map( UI::label ).orElseGet( () -&gt; label(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon dynamically.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property which should dynamically provide a desired icon for the {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; labelWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L3651">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L3652">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;Null icons are not allowed!&quot;);</span>
<span class="nc" id="L3653">        return _label().withIcon(icon);</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *
     * @param width The width of the icon when displayed on the label.
     * @param height The height of the icon when displayed on the label.
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( int width, int height, ImageIcon icon ) {
<span class="fc" id="L3665">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, ImageIcon.class);</span>
<span class="fc" id="L3666">        float scale = UI.scale();</span>

<span class="fc" id="L3668">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L3669" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L3670">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L3672">        width  = (int) (width * scale);</span>
<span class="fc" id="L3673">        height = (int) (height * scale);</span>

<span class="fc" id="L3675">        Image scaled = icon.getImage().getScaledInstance(width, height, scaleHint);</span>
<span class="fc" id="L3676">        return _label()</span>
<span class="fc" id="L3677">                .withIcon(new ImageIcon(scaled));</span>
    }

    /**
     *  Use this to create a UI builder for a text-less label containing and displaying an icon.
     *  The icon is specified by a {@link IconDeclaration} which
     *  is essentially just a path to an icon resource.
     *  If the icon cannot be found, the label will be empty.
     *  Note that loaded icons are cached, so if you load the same icon multiple times,
     *  the same icon instance will be used (see {@link SwingTree#getIconCache()}).
     *
     * @param width The width of the icon when displayed on the label.
     * @param height The height of the icon when displayed on the label.
     * @param icon The icon which should be placed into a {@link JLabel}.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; label( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L3694">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3695">        return icon.find().map( i -&gt; label(width, height, i) ).orElseGet( () -&gt; label(&quot;&quot;) );</span>
    }

    /**
     *  Use this to create a UI builder for a {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(String text).makeBold()}.
     *  @param text The text which should be displayed on the label.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( String text ) {
<span class="fc" id="L3705">        return _label().withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a UI builder for a bound {@link JLabel} with bold font.
     *  This is in essence a convenience method for {@code UI.label(Val&lt;String&gt; text).makeBold()}.
     *  @param text The text property which should be displayed on the label dynamically.
     *  @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; boldLabel( Val&lt;String&gt; text ) {
<span class="fc" id="L3715">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3716">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L3717">        return _label().withText(text).makeBold();</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text which should be displayed on the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( String text ) {
<span class="fc" id="L3728">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3729">        return _label().withText(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;);</span>
    }

    /**
     *  Use this to create a builder for a {@link JLabel} displaying HTML.
     *  This is in essence a convenience method for {@code UI.of(new JLabel(&quot;&lt;html&gt;&quot; + text + &quot;&lt;/html&gt;&quot;))}.
     *
     * @param text The html text property which should be bound to the label.
     * @return A builder instance for the label, which enables fluent method chaining.
     */
    public static UIForLabel&lt;JLabel&gt; html( Val&lt;String&gt; text ) {
<span class="nc" id="L3740">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3741">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3742">        return _label()</span>
<span class="nc bnc" id="L3743" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3744">                .withText(text.view( it -&gt; &quot;&lt;html&gt;&quot; + it + &quot;&lt;/html&gt;&quot;));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link swingtree.components.JIcon} instance.
     *
     * @param icon The {@link swingtree.components.JIcon} instance to be used by the builder.
     * @param &lt;I&gt; The type of the {@link swingtree.components.JIcon} instance.
     * @return A builder instance for the provided {@link swingtree.components.JIcon}, which enables fluent method chaining.
     */
    public static &lt;I extends JIcon&gt; UIForIcon&lt;I&gt; of(I icon ) {
<span class="nc" id="L3755">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, JIcon.class);</span>
<span class="nc" id="L3756">        return new UIForIcon&lt;&gt;(new BuilderState&lt;&gt;(icon));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the provided
     *  icon displayed on it.
     *
     * @param icon The icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( Icon icon ) {
<span class="fc" id="L3768">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L3769">        return new UIForIcon&lt;&gt;(new BuilderState&lt;&gt;(JIcon.class, ()-&gt;new JIcon(icon)));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the
     *  path provided by the supplied {@link IconDeclaration} displayed on it.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param icon The icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( IconDeclaration icon ) {
<span class="fc" id="L3782">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="fc" id="L3783">        return new UIForIcon&lt;&gt;(new BuilderState&lt;&gt;(JIcon.class, ()-&gt;new JIcon(icon)));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the
     *  provided icon scaled to the provided width and height.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param icon The icon which should be placed into a {@link JIcon} for display.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, Icon icon ) {
<span class="fc" id="L3797">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L3798">        float scale = UI.scale();</span>

<span class="fc" id="L3800">        int scaleHint = Image.SCALE_SMOOTH;</span>
<span class="pc bpc" id="L3801" title="1 of 2 branches missed.">        if ( scale &gt; 1.5f )</span>
<span class="nc" id="L3802">            scaleHint = Image.SCALE_FAST;</span>

<span class="fc" id="L3804">        width  = (int) (width * scale);</span>
<span class="fc" id="L3805">        height = (int) (height * scale);</span>

<span class="pc bpc" id="L3807" title="1 of 2 branches missed.">        if ( icon instanceof SvgIcon) {</span>
<span class="nc" id="L3808">            SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="nc" id="L3809">            svgIcon = svgIcon.withIconSize(width, height);</span>
<span class="nc" id="L3810">            return UI.icon(svgIcon);</span>
        } else {
<span class="fc" id="L3812">            Image scaled = ((ImageIcon) icon).getImage().getScaledInstance(width, height, scaleHint);</span>
<span class="fc" id="L3813">            return UI.icon(new ImageIcon(scaled));</span>
        }
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the
     *  path defined by the supplied {@link IconDeclaration} displayed on it and scaled to the
     *  provided width and height.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param icon The icon which should be placed into a {@link JIcon} for display.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L3830">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L3831">        return icon.find().map( i -&gt; icon(width, height, i) ).orElseGet( () -&gt; icon(&quot;&quot;) );</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the provided
     *  path displayed on it and scaled to the provided width and height.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param width The width of the icon when displayed on the {@link JIcon}.
     * @param height The height of the icon when displayed on the {@link JIcon}.
     * @param iconPath The path to the icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon path is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( int width, int height, String iconPath ) {
<span class="fc" id="L3846">        NullUtil.nullArgCheck(iconPath, &quot;iconPath&quot;, String.class);</span>
<span class="fc" id="L3847">        return icon(width, height, UI.findIcon(iconPath).orElse(new ImageIcon()));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JIcon} instance with the icon found at the provided
     *  path displayed on it.
     *  Note that the icon will be cached by the {@link JIcon} instance, so that it will not be reloaded.
     *
     * @param iconPath The path to the icon which should be displayed on the {@link JIcon}.
     * @return A builder instance for the icon, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided icon path is null.
     */
    public static UIForIcon&lt;JIcon&gt; icon( String iconPath ) {
<span class="fc" id="L3860">        NullUtil.nullArgCheck(iconPath, &quot;iconPath&quot;, String.class);</span>
<span class="fc" id="L3861">        return new UIForIcon&lt;&gt;(new BuilderState&lt;&gt;(JIcon.class, ()-&gt;new JIcon(iconPath)));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text ) {
<span class="fc" id="L3873">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3874">        return new UIForCheckBox&lt;&gt;(new BuilderState&lt;JCheckBox&gt;(UI.CheckBox.class, UI.CheckBox::new))</span>
<span class="fc" id="L3875">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance where the provided
     *  text property dynamically displays its value on the checkbox.
     *
     * @param text The text property which should be bound to the checkbox.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text ) {
<span class="fc" id="L3887">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3888">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3889">        return new UIForCheckBox&lt;&gt;(new BuilderState&lt;JCheckBox&gt;(UI.CheckBox.class, UI.CheckBox::new))</span>
<span class="nc bnc" id="L3890" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3891">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  where the provided text property dynamically displays its value on the checkbox
     *  and the provided selection property dynamically determines whether the checkbox
     *  is selected or not.
     *
     * @param text The text property which should be bound to the checkbox.
     *             This is the text which is displayed on the checkbox.
     * @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     * @return A builder instance for the checkbox, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( Val&lt;String&gt; text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L3907">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3908">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="nc" id="L3909">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3910">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="nc" id="L3911">        return new UIForCheckBox&lt;&gt;(new BuilderState&lt;JCheckBox&gt;(UI.CheckBox.class, UI.CheckBox::new))</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L3913" title="All 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="nc" id="L3914">                .withText(text)</span>
<span class="nc" id="L3915">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JCheckBox} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the checkbox is selected or not.
     *  @param text The text which should be displayed on the checkbox.
     *  @param isChecked The selection property which should be bound to the checkbox and determines whether it is selected or not.
     *  @return A builder instance for the checkbox, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForCheckBox&lt;JCheckBox&gt; checkBox( String text, Var&lt;Boolean&gt; isChecked ) {
<span class="fc" id="L3928">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3929">        NullUtil.nullArgCheck(isChecked, &quot;isChecked&quot;, Var.class);</span>
<span class="fc" id="L3930">        NullUtil.nullPropertyCheck(isChecked, &quot;isChecked&quot;, &quot;The selection state of a check box may not be modelled using null!&quot;);</span>
<span class="fc" id="L3931">        return new UIForCheckBox&lt;&gt;(new BuilderState&lt;JCheckBox&gt;(UI.CheckBox.class, UI.CheckBox::new))</span>
<span class="pc bpc" id="L3932" title="1 of 2 branches missed.">                .applyIf(!isChecked.hasNoID(), it -&gt; it.id(isChecked.id()))</span>
<span class="fc" id="L3933">                .withText(text)</span>
<span class="fc" id="L3934">                .isSelectedIf(isChecked);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JCheckBox} instance.
     *
     * @param component The {@link JCheckBox} instance to be used by the builder.
     * @param &lt;B&gt; The type parameter of the concrete {@link JCheckBox} subclass to be used by the builder.
     * @return A builder instance for the provided {@link JCheckBox}, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided checkbox is null.
     */
    public static &lt;B extends JCheckBox&gt; UIForCheckBox&lt;B&gt; of( B component ) {
<span class="nc" id="L3946">        NullUtil.nullArgCheck(component, &quot;component&quot;, JCheckBox.class);</span>
<span class="nc" id="L3947">        return new UIForCheckBox&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance with the provided
     *  text displayed on it.
     *
     * @param text The text which should be displayed on the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text ) {
<span class="fc" id="L3959">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L3960">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="fc" id="L3961">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance where the provided
     *  text property dynamically displays its value on the radio button.
     *
     * @param text The text property which should be bound to the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text ) {
<span class="fc" id="L3972">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L3973">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3974">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="nc bnc" id="L3975" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L3976">                .withText(text);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  where the provided text property dynamically displays its value on the radio button
     *  and the provided selection property dynamically determines whether the radio button
     *  is selected or not.
     *
     * @param text The text property which should be bound to the radio button.
     *             This is the text which is displayed on the radio button.
     * @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text property is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L3992">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L3993">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L3994">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L3995">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L3996">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="nc bnc" id="L3997" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc bnc" id="L3998" title="All 2 branches missed.">                .applyIf(!selected.hasNoID(), it -&gt; it.id(selected.id()))</span>
<span class="nc" id="L3999">                .withText(text)</span>
<span class="nc" id="L4000">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  with the provided text displayed on it and the provided selection property
     *  dynamically determining whether the radio button is selected or not.
     *  @param text The text which should be displayed on the radio button.
     *  @param selected The selection property which should be bound to the radio button and determines whether it is selected or not.
     *  @return A builder instance for the radio button, which enables fluent method chaining.
     *  @throws IllegalArgumentException If the provided text is null.
     */
    public static UIForRadioButton&lt;JRadioButton&gt; radioButton( String text, Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L4013">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4014">        NullUtil.nullArgCheck(text, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L4015">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4016">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="nc" id="L4017">                .withText(text)</span>
<span class="nc" id="L4018">                .isSelectedIf(selected);</span>
    }

    /**
     *  Creates a builder node wrapping a new {@link JRadioButton} instance
     *  dynamically bound to an enum based {@link sprouts.Var}
     *  instance which will be used to dynamically model the selection state of the
     *  wrapped {@link JToggleButton} type by checking
     *  weather the property matches the provided enum or not.
     *  &lt;br&gt;
     *  Here's an example of how to use this method: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Size { SMALL, MEDIUM, LARGE }
     *      private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *
     *      public Var&lt;Size&gt; selection() { return selection; }
     *
     *      // In your view:
     *      UI.panel()
     *      .add(UI.radioButton(Size.SMALL,  vm.selection())
     *      .add(UI.radioButton(Size.MEDIUM, vm.selection())
     *      .add(UI.radioButton(Size.LARGE,  vm.selection())
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Tip:&lt;/b&gt;&lt;i&gt;
     *      For the text displayed on the radio buttons, the enums will be converted
     *      to strings using {@link Object#toString()} method.
     *      If you want to customize how they are displayed
     *      (So that 'Size.LARGE' is displayed as 'Large' instead of 'LARGE')
     *      simply override the {@link Object#toString()} method in your enum. &lt;/i&gt;
     *
     *
     * @param state The reference {@link Enum} which this {@link JToggleButton} should represent.
     * @param selection The {@link sprouts.Var} instance which will be used
     *                  to dynamically model the selection state of the wrapped {@link JToggleButton} type.
     * @param &lt;E&gt; The type of the enum which this {@link JToggleButton} should represent.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; UIForRadioButton&lt;JRadioButton&gt; radioButton( E state, Var&lt;E&gt; selection ) {
<span class="fc" id="L4059">        NullUtil.nullArgCheck(state, &quot;state&quot;, Enum.class);</span>
<span class="fc" id="L4060">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L4061">        NullUtil.nullPropertyCheck(selection, &quot;selection&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="fc" id="L4062">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="pc bpc" id="L4063" title="1 of 2 branches missed.">                .applyIf(!selection.hasNoID(), it -&gt; it.id(selection.id()))</span>
<span class="fc" id="L4064">                .withText( state.toString() )</span>
<span class="fc" id="L4065">                .isSelectedIf( state, selection );</span>
    }

    /**
     *  Creates a declarative UI builder for the {@link JRadioButton} component type which
     *  is dynamically bound to the equality of the provided state and the provided selection property.
     *  This means that the radio button will be selected if the provided state is
     *  equal to the value of the provided selection property and deselected otherwise.
     *  &lt;br&gt;
     *  A typical use case for this is to use an enum based property to model the selection state of the radio button
     *  like so:
     *  &lt;pre&gt;{@code
     *    // In your view model:
     *    enum Size { SMALL, MEDIUM, LARGE }
     *    private Var&lt;Size&gt; selection = Var.of(Size.SMALL);
     *    public Var&lt;Size&gt; selection() { return selection; }
     *    // In your view:
     *    UI.panel()
     *    .add(UI.radioButton(&quot;Small&quot;, Size.SMALL, vm.selection())
     *    .add(UI.radioButton(&quot;Medium&quot;, Size.MEDIUM, vm.selection())
     *    .add(UI.radioButton(&quot;Large&quot;, Size.LARGE, vm.selection())
     *  }&lt;/pre&gt;
     *
     * @param label The text which should be displayed on the radio button.
     * @param state The reference object which this radio button should represent.
     * @param selection The property which will be used to model the selection state of the radio button.
     * @return A builder instance for the radio button, which enables fluent method chaining.
     * @param &lt;T&gt; The type of the state object which this radio button should represent.
     */
    public static &lt;T&gt; UIForRadioButton&lt;JRadioButton&gt; radioButton( String label, T state, Var&lt;T&gt; selection ) {
<span class="fc" id="L4095">        NullUtil.nullArgCheck(state, &quot;state&quot;, Object.class);</span>
<span class="fc" id="L4096">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L4097">        NullUtil.nullPropertyCheck(selection, &quot;selection&quot;, &quot;The selection state of a radio button may not be modelled using null!&quot;);</span>
<span class="fc" id="L4098">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;JRadioButton&gt;(UI.RadioButton.class, UI.RadioButton::new))</span>
<span class="pc bpc" id="L4099" title="1 of 2 branches missed.">                .applyIf(!selection.hasNoID(), it -&gt; it.id(selection.id()))</span>
<span class="fc" id="L4100">                .withText( label )</span>
<span class="fc" id="L4101">                .isSelectedIf( state, selection );</span>
    }


    /**
     *  Use this to create a builder for the provided {@link JRadioButton} instance.
     *
     * @param component The {@link JRadioButton} instance which should be wrapped by the builder.
     * @param &lt;R&gt; The type of the {@link JRadioButton} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JRadioButton}, which enables fluent method chaining.
     */
    public static &lt;R extends JRadioButton&gt; UIForRadioButton&lt;R&gt; of( R component ) {
<span class="nc" id="L4113">        NullUtil.nullArgCheck(component, &quot;component&quot;, JRadioButton.class);</span>
<span class="nc" id="L4114">        return new UIForRadioButton&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a {@link JToggleButton} instance.
     *
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton() {
<span class="fc" id="L4123">        return new UIForToggleButton&lt;&gt;(new BuilderState&lt;JToggleButton&gt;(UI.ToggleButton.class, UI.ToggleButton::new));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it.
     *
     * @param text The text which should be displayed on the toggle button.
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text ) {
<span class="fc" id="L4134">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4135">        return toggleButton().withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button.
     *  &lt;p&gt;
     *  Note that the provided text property may not be null,
     *  and it is also not permitted to contain null values,
     *  instead use an empty string instead of null.
     *
     * @param text The text property which should be bound to the toggle button.
     * @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text ) {
<span class="nc" id="L4150">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4151">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4152">        return toggleButton()</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4154">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param  isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L4164">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="nc" id="L4165">        return toggleButton()</span>
<span class="nc bnc" id="L4166" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4167">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  with the provided text displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *  @param text The text which should be displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( String text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4179">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4180">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;);</span>
<span class="fc" id="L4181">        return toggleButton()</span>
<span class="fc" id="L4182">                .withText(text)</span>
<span class="fc" id="L4183">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance
     *  where the provided text property dynamically displays its value on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  @param text The text property which should be bound to the toggle button.
     *             This is the text which is displayed on the toggle button.
     *  @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     *  @return A builder instance for a new {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Val&lt;String&gt; text, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4196">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L4197">        NullUtil.nullArgCheck(isToggled, &quot;isToggled&quot;, Var.class);</span>
<span class="fc" id="L4198">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="pc" id="L4199">        return toggleButton()</span>
<span class="pc bpc" id="L4200" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="pc bpc" id="L4201" title="1 of 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4202">                .withText(text)</span>
<span class="nc" id="L4203">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon ) {
<span class="fc" id="L4214">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L4215">        return toggleButton().withIcon(icon);</span>
    }

    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( ImageIcon icon, UI.FitComponent fit ) {
<span class="nc" id="L4219">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4220">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, UI.FitComponent.class);</span>
<span class="nc" id="L4221">        return toggleButton().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for the {@link JToggleButton} UI component
     *  with an icon displayed on it scaled according to the provided width and height.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The icon to be displayed on top of the button.
     * @return A builder instance for a {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( int width, int height, ImageIcon icon ) {
<span class="fc" id="L4234">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L4235">        return toggleButton().withIcon(width, height, icon);</span>
    }

    /**
     *  Use this to create a builder for the {@link JToggleButton} UI component
     *  with an icon displayed on it scaled according to the provided width and height.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The {@link IconDeclaration} whose icon ought to be displayed on top of the button.
     * @return A builder instance for a {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( int width, int height, IconDeclaration icon ) {
<span class="nc" id="L4248">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4249">        return toggleButton().withIcon(width, height, icon);</span>
    }

    /**
     *  Creates a declarative toggle button builder for a {@link JToggleButton}
     *  displaying the provided icon
     *  scaled to fit the desired size and {@link UI.FitComponent} policy.
     *
     * @param width The width the icon should be scaled to.
     * @param height The height the icon should be scaled to.
     * @param icon The {@link IconDeclaration} whose icon ought to be displayed on top of the button.
     * @param fit The {@link UI.FitComponent} which determines how the icon should be fitted into the button.
     * @return A builder instance for a {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( int width, int height, IconDeclaration icon, UI.FitComponent fit ) {
<span class="nc" id="L4264">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4265">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, UI.FitComponent.class);</span>
<span class="nc" id="L4266">        return toggleButton().withIcon(width, height, icon, fit);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the icon found at the path provided by the supplied {@link IconDeclaration} displayed on top of it.
     *  Note that the icon will be cached by the {@link JToggleButton} instance, so that it will not be reloaded.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( IconDeclaration icon ) {
<span class="nc" id="L4278">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="nc" id="L4279">        return toggleButton().withIcon(icon);</span>
    }

    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( IconDeclaration icon, UI.FitComponent fit ) {
<span class="fc" id="L4283">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, IconDeclaration.class);</span>
<span class="fc" id="L4284">        NullUtil.nullArgCheck(fit, &quot;fit&quot;, UI.FitComponent.class);</span>
<span class="fc" id="L4285">        return toggleButton().withIcon(icon, fit);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance with
     *  the provided {@link Icon} displayed on it and the provided boolean property
     *  dynamically determining whether the toggle button is selected or not.
     *
     * @param icon The icon which should be displayed on the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButton( Icon icon, Var&lt;Boolean&gt; isToggled ) {
<span class="nc" id="L4298">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Icon.class);</span>
<span class="nc" id="L4299">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4300">        return toggleButton(icon)</span>
<span class="nc bnc" id="L4301" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4302">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link IconDeclaration} based property dynamically
     *  displays the targeted image on the toggle button.
     *  &lt;p&gt;
     *  Note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="nc" id="L4331">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L4332">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4333">        return new UIForToggleButton&lt;&gt;(new BuilderState&lt;&gt;(UI.ToggleButton.class, ()-&gt;new JToggleButton()))</span>
<span class="nc bnc" id="L4334" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc" id="L4335">                .withIcon(icon);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JToggleButton} instance where
     *  the provided {@link IconDeclaration} property dynamically displays its targeted icon on the toggle button
     *  and the provided boolean property dynamically determines whether the toggle button is selected or not.
     *  &lt;p&gt;
     *  But note that you may not use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful in case of unit tests for you view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The icon property which should be bound to the toggle button.
     * @param isToggled The boolean property which should be bound to the toggle button and determines whether it is selected or not.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static UIForToggleButton&lt;JToggleButton&gt; toggleButtonWithIcon( Val&lt;IconDeclaration&gt; icon, Var&lt;Boolean&gt; isToggled ) {
<span class="fc" id="L4364">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="nc" id="L4365">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;, &quot;The icon of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4366">        NullUtil.nullPropertyCheck(isToggled, &quot;isToggled&quot;, &quot;The selection state of a toggle button may not be modelled using null!&quot;);</span>
<span class="nc" id="L4367">        return new UIForToggleButton&lt;&gt;(new BuilderState&lt;&gt;(UI.ToggleButton.class, ()-&gt;new JToggleButton()))</span>
<span class="nc bnc" id="L4368" title="All 2 branches missed.">                .applyIf(!icon.hasNoID(), it -&gt; it.id(icon.id()))</span>
<span class="nc bnc" id="L4369" title="All 2 branches missed.">                .applyIf(!isToggled.hasNoID(), it -&gt; it.id(isToggled.id()))</span>
<span class="nc" id="L4370">                .withIcon(icon)</span>
<span class="nc" id="L4371">                .isSelectedIf(isToggled);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JToggleButton} instance.
     *
     * @param component The {@link JToggleButton} instance which should be wrapped by the builder.
     * @param &lt;B&gt; The type of the {@link JToggleButton} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JToggleButton}, which enables fluent method chaining.
     */
    public static &lt;B extends JToggleButton&gt; UIForToggleButton&lt;B&gt; of( B component ) {
<span class="fc" id="L4382">        NullUtil.nullArgCheck(component, &quot;component&quot;, JToggleButton.class);</span>
<span class="fc" id="L4383">        return new UIForToggleButton&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextField} instance.
     *
     * @param component The {@link JTextField} instance which should be wrapped by the builder.
     * @param &lt;F&gt; The type of the {@link JTextField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException If the provided text field is null.
     */
    public static &lt;F extends JTextField&gt; UIForTextField&lt;F&gt; of( F component ) {
<span class="fc" id="L4395">        NullUtil.nullArgCheck(component, &quot;component&quot;, JTextComponent.class);</span>
<span class="fc" id="L4396">        return new UIForTextField&lt;&gt;(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( String text ) {
<span class="fc" id="L4407">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4408">        return textField().withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Val&lt;String&gt; text ) {
<span class="nc" id="L4421">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4422">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4423">        return textField()</span>
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4425">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided text property dynamically displaying its value on the text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( Var&lt;String&gt; text ) {
<span class="fc" id="L4437">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L4438">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L4439">        return textField()</span>
<span class="pc bpc" id="L4440" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L4441">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JTextField())}.
     *
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField() {
<span class="fc" id="L4451">        return new UIForTextField&lt;&gt;(new BuilderState&lt;JTextField&gt;(UI.TextField.class, UI.TextField::new));</span>
    }

    /**
     *  A convenience method for creating a builder for a {@link JTextField} with
     *  the specified {@link UI.HorizontalAlignment} constant as the text orientation.
     *  You may also use {@link UIForTextField#withTextOrientation(UI.HorizontalAlignment)}
     *  to define the text orientation:
     *  &lt;pre&gt;{@code
     *    UI.textField(&quot;may text&quot;)
     *    .withTextOrientation(
     *        UI.HorizontalAlignment.RIGHT
     *    );
     *  }&lt;/pre&gt;
     *
     * @param direction The text orientation type which should be used.
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField( UI.HorizontalAlignment direction ) {
<span class="nc" id="L4470">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, UI.HorizontalAlignment.class);</span>
<span class="nc" id="L4471">        return textField().withTextOrientation(direction);</span>
    }

    /**
     *  A convenience method for creating a builder for a {@link JTextField}
     *  with the specified text and text orientation.
     *  You may also use {@link UIForTextField#withText(String)}
     *  and {@link UIForTextField#withTextOrientation(UI.HorizontalAlignment)}
     *  to define the text and text orientation:
     *  &lt;pre&gt;{@code
     *    UI.textField()
     *    .withTextOrientation(
     *        UI.HorizontalAlignment.LEFT
     *    )
     *    .withText(text);
     *  }&lt;/pre&gt;
     *
     * @param orientation Defines the orientation of the text inside the text field.&lt;br&gt;
     *                    This may be one of the following constants:
     *                    &lt;ul&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#LEFT}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#CENTER}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#RIGHT}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#LEADING}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#TRAILING}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.HorizontalAlignment#UNDEFINED} (No-Op)&lt;/li&gt;
     *                    &lt;/ul&gt;
     * @param text The new text to be set for the wrapped text component type.
     * @return A builder instance for a new {@link JTextField}, which enables fluent method chaining.
     */
    public static UIForTextField&lt;JTextField&gt; textField(UI.HorizontalAlignment orientation, String text ) {
<span class="fc" id="L4502">        NullUtil.nullArgCheck(orientation, &quot;orientation&quot;, UI.HorizontalAlignment.class);</span>
<span class="fc" id="L4503">        return textField().withTextOrientation(orientation).withText(text);</span>
    }

    /**
     *  Creates a UI builder for a text field where the text is aligned according
     *  to the provided {@link UI.HorizontalAlignment} constant, and the text
     *  of the text field is bound to a string property.
     *  Whenever the user modifies the text inside the text field, the value of the
     *  property will be updated accordingly. Conversely, when the state of the property
     *  is modified inside your view model through the {@link Var#set(Object)} method,
     *  the text field will be updated accordingly.
     *  &lt;p&gt;
     *  You may also use {@link UIForTextField#withTextOrientation(UI.HorizontalAlignment)}
     *  and {@link UIForTextField#withText(Var)} to define the text orientation and text property
     *  of the text field:
     *  &lt;pre&gt;{@code
     *  UI.textField()
     *  .withTextOrientation(
     *    UI.HorizontalAlignment.RIGHT
     *  )
     *  .withText(textProperty);
     *  }&lt;/pre&gt;
     *
     * @param textOrientation The orientation of the text inside the text field.
     * @param text A string property which is used to model the text of this text field.
     * @return A text field UI builder for declarative UI
     *        design based on method chaining and nesting of SwingTree builder types.
     */
    public static UIForTextField&lt;JTextField&gt; textField(UI.HorizontalAlignment textOrientation, Var&lt;String&gt; text ) {
<span class="fc" id="L4532">        NullUtil.nullArgCheck(textOrientation, &quot;textOrientation&quot;, UI.HorizontalAlignment.class);</span>
<span class="fc" id="L4533">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L4534">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4535">        return textField()</span>
<span class="nc bnc" id="L4536" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4537">                .withTextOrientation(textOrientation)</span>
<span class="nc" id="L4538">                .withText(text);</span>
    }

    /**
     *  Creates a UI builder for a text field where the text is aligned according
     *  to the provided {@link UI.HorizontalAlignment} constant, and the text
     *  of the text field is uni-directionally bound to a string property.
     *  Whenever the state of the property is modified inside your view model through the
     *  {@link Var#set(Object)} method, the text field will be updated accordingly. &lt;br&gt;
     *  But note that &lt;b&gt;when the user modifies the text inside the text field, the value of the
     *  property will not be updated&lt;/b&gt;.
     *  &lt;p&gt;
     *  You may also use {@link UIForTextField#withTextOrientation(UI.HorizontalAlignment)}
     *  and {@link UIForTextField#withText(Val)} to define the text orientation and text property
     *  of the text field:
     *  &lt;pre&gt;{@code
     *  UI.textField()
     *  .withTextOrientation(
     *    UI.HorizontalAlignment.RIGHT
     *  )
     *  .withText(readOnlyTextProperty);
     *  }&lt;/pre&gt;
     *
     *  @param orientation The orientation of the text inside the text field.
     *                     This is the direction in which the text is aligned.&lt;br&gt;
     *                     It may be one of the following constants:
     *                     &lt;ul&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#LEFT}&lt;/li&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#CENTER}&lt;/li&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#RIGHT}&lt;/li&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#LEADING}&lt;/li&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#TRAILING}&lt;/li&gt;
     *                       &lt;li&gt;{@link UI.HorizontalAlignment#UNDEFINED} (No-Op)&lt;/li&gt;
     *                     &lt;/ul&gt;
     *  @param text A string property which is used to model the text of this text field
     *              uni-directionally (read-only).
     *  @return A text field UI builder for declarative UI design based on method chaining
     *        and nesting of SwingTree builder types.
     */
    public static UIForTextField&lt;JTextField&gt; textField(UI.HorizontalAlignment orientation, Val&lt;String&gt; text ) {
<span class="nc" id="L4578">        NullUtil.nullArgCheck(orientation, &quot;orientation&quot;, UI.HorizontalAlignment.class);</span>
<span class="nc" id="L4579">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4580">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4581">        return textField()</span>
<span class="nc bnc" id="L4582" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4583">                .withTextOrientation(orientation)</span>
<span class="nc" id="L4584">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field.
     *  The property is a {@link Var}, meaning that it can be modified by the user.
     *  &lt;p&gt;
     *  The number property will only receive values if the text field contains a valid number.
     *  &lt;p&gt;
     *  Also note that the provided property is not allowed to contain {@code null} values,
     *  as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number ) {
<span class="fc" id="L4602">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="fc" id="L4603">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="fc" id="L4604">        return textField()</span>
<span class="pc bpc" id="L4605" title="1 of 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="fc" id="L4606">                .withNumber(number);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field
     *  and a function which will be used to format the number as a string.
     *  &lt;p&gt;
     *  The number property will only receive values if the text in the text field can be parsed as a number,
     *  in which case the provided formatter function will be used to convert the number to a string.
     *  &lt;p&gt;
     *  Note that the provided property is not allowed to contain {@code null} values,
     *  as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param formatter The function which will be used to format the number as a string.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number, Function&lt;N,String&gt; formatter ) {
<span class="nc" id="L4626">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="nc" id="L4627">        NullUtil.nullArgCheck(formatter, &quot;formatter&quot;, Function.class);</span>
<span class="nc" id="L4628">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="nc" id="L4629">        return textField()</span>
<span class="nc bnc" id="L4630" title="All 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="nc" id="L4631">                .withNumber(number, formatter);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field
     *  and a boolean property which will be set to {@code true} if the text field contains a valid number,
     *  and {@code false} otherwise.
     *  &lt;p&gt;
     *  The number property will only receive values if the text in the text field can be parsed as a number,
     *  in which case the provided {@link Var} will be set to {@code true}, otherwise it will be set to {@code false}.
     *  &lt;p&gt;
     *  Note that the two provided properties are not permitted to
     *  contain {@code null} values, as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param isValid A {@link Var} which will be set to {@code true} if the text field contains a valid number,
     *                and {@code false} otherwise.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code number} is {@code null}.
     * @throws IllegalArgumentException if {@code isValid} is {@code null}.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number, Var&lt;Boolean&gt; isValid ) {
<span class="fc" id="L4655">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="fc" id="L4656">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="fc" id="L4657">        NullUtil.nullArgCheck(isValid, &quot;isValid&quot;, Var.class);</span>
<span class="fc" id="L4658">        NullUtil.nullPropertyCheck(isValid, &quot;isValid&quot;, &quot;Please use false instead of null!&quot;);</span>
<span class="fc" id="L4659">        return textField()</span>
<span class="pc bpc" id="L4660" title="1 of 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="fc" id="L4661">                .withNumber(number, isValid);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextField} instance with
     *  the provided number property dynamically displaying its value on the text field
     *  and a boolean property which will be set to {@code true} if the text field contains a valid number,
     *  and {@code false} otherwise.
     *  &lt;p&gt;
     *  The number property will only receive values if the text in the text field can be parsed as a number,
     *  in which case the provided {@link Var} will be set to {@code true}, otherwise it will be set to {@code false}.
     *  &lt;p&gt;
     *  Note that the two provided properties are not permitted to
     *  contain {@code null} values, as this would lead to a {@link NullPointerException} being thrown.
     *
     * @param number The number property which should be bound to the text field.
     * @param isValid A {@link Var} which will be set to {@code true} if the text field contains a valid number,
     *                and {@code false} otherwise.
     * @param formatter The function which will be used to format the number as a string.
     * @param &lt;N&gt; The type of the number property which should be bound to the text field.
     * @return A builder instance for the provided {@link JTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code number} is {@code null}.
     * @throws IllegalArgumentException if {@code isValid} is {@code null}.
     */
    public static &lt;N extends Number&gt; UIForTextField&lt;JTextField&gt; numericTextField( Var&lt;N&gt; number, Var&lt;Boolean&gt; isValid, Function&lt;N,String&gt; formatter ) {
<span class="nc" id="L4686">        NullUtil.nullArgCheck(number, &quot;number&quot;, Var.class);</span>
<span class="nc" id="L4687">        NullUtil.nullPropertyCheck(number, &quot;number&quot;, &quot;Please use 0 instead of null!&quot;);</span>
<span class="nc" id="L4688">        NullUtil.nullArgCheck(isValid, &quot;isValid&quot;, Var.class);</span>
<span class="nc" id="L4689">        NullUtil.nullPropertyCheck(isValid, &quot;isValid&quot;, &quot;Please use false instead of null!&quot;);</span>
<span class="nc" id="L4690">        NullUtil.nullArgCheck(formatter, &quot;formatter&quot;, Function.class);</span>
<span class="nc" id="L4691">        return textField()</span>
<span class="nc bnc" id="L4692" title="All 2 branches missed.">                .applyIf( !number.hasNoID(), it -&gt; it.id(number.id()) )</span>
<span class="nc" id="L4693">                .withNumber(number, isValid, formatter);</span>
    }


    /**
     *  Use this to create a builder for the provided {@link JFormattedTextField} instance.
     *
     * @param component The {@link JFormattedTextField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static UIForFormattedTextField of( JFormattedTextField component ) {
<span class="nc" id="L4705">        NullUtil.nullArgCheck(component, &quot;component&quot;, JFormattedTextField.class);</span>
<span class="nc" id="L4706">        return new UIForFormattedTextField(new BuilderState&lt;&gt;(component));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text displayed on it.
     *
     * @param text The text which should be displayed on the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( String text ) {
<span class="fc" id="L4717">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4718">        return new UIForFormattedTextField(new BuilderState&lt;&gt;(JFormattedTextField.class, ()-&gt;{</span>
<span class="fc" id="L4719">            JFormattedTextField tf = new UI.FormattedTextField();</span>
<span class="fc" id="L4720">            tf.setText(text);</span>
<span class="fc" id="L4721">            return tf;</span>
        }));
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the text field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text field.
     *
     * @param text The text property which should be bound to the text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Val&lt;String&gt; text ) {
<span class="nc" id="L4735">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4736">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4737">        return new UIForFormattedTextField(new BuilderState&lt;&gt;(JFormattedTextField.class, ()-&gt;new UI.FormattedTextField()))</span>
<span class="nc bnc" id="L4738" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4739">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} instance with
     *  the provided text property dynamically displaying its value in the formatted text field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the formatted text field.
     * @return A builder instance for the provided {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField( Var&lt;String&gt; text ) {
<span class="nc" id="L4751">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="nc" id="L4752">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4753">        return new UIForFormattedTextField(new BuilderState&lt;&gt;(JFormattedTextField.class, ()-&gt;new UI.FormattedTextField()))</span>
<span class="nc bnc" id="L4754" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4755">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JFormattedTextField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JFormattedTextField())}.
     *
     * @return A builder instance for a new {@link JFormattedTextField}, which enables fluent method chaining.
     */
    public static UIForFormattedTextField formattedTextField() {
<span class="fc" id="L4765">        return new UIForFormattedTextField(new BuilderState&lt;&gt;(JFormattedTextField.class, ()-&gt;new UI.FormattedTextField()));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JPasswordField} instance.
     *
     * @param passwordField The {@link JPasswordField} instance which should be wrapped by the builder.
     * @param &lt;F&gt; The type of the {@link JPasswordField} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;F extends JPasswordField&gt; UIForPasswordField&lt;F&gt; of( F passwordField ) {
<span class="fc" id="L4777">        NullUtil.nullArgCheck(passwordField, &quot;passwordField&quot;, JPasswordField.class);</span>
<span class="fc" id="L4778">        return new UIForPasswordField&lt;&gt;(new BuilderState&lt;&gt;(passwordField));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text as the initial password.
     *
     * @param text The initial password which should be displayed on the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( String text ) {
<span class="fc" id="L4789">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L4790">        return new UIForPasswordField&lt;&gt;(new BuilderState&lt;JPasswordField&gt;(UI.PasswordField.class, UI.PasswordField::new))</span>
<span class="fc" id="L4791">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the password field.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Val&lt;String&gt; text ) {
<span class="nc" id="L4804">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L4805">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L4806">        return new UIForPasswordField&lt;&gt;(new BuilderState&lt;&gt;(JPasswordField.class, UI.PasswordField::new))</span>
<span class="nc bnc" id="L4807" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L4808">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} instance with
     *  the provided text property dynamically displaying its value in the password field.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the password field.
     * @return A builder instance for the provided {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField( Var&lt;String&gt; text ) {
<span class="fc" id="L4820">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="fc" id="L4821">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L4822">        return passwordField()</span>
<span class="pc bpc" id="L4823" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L4824">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JPasswordField} UI component.
     *  This is in essence a convenience method for {@code UI.of(new JPasswordField())}.
     *
     * @return A builder instance for a new {@link JPasswordField}, which enables fluent method chaining.
     */
    public static UIForPasswordField&lt;JPasswordField&gt; passwordField() {
<span class="fc" id="L4834">        return new UIForPasswordField&lt;&gt;(new BuilderState&lt;&gt;(JPasswordField.class, ()-&gt;new UI.PasswordField()));</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JProgressBar} instance.
     *
     * @param progressBar The {@link JProgressBar} instance which should be wrapped by the builder.
     * @param &lt;P&gt; The type of the {@link JProgressBar} instance which should be wrapped by the builder.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     * @throws IllegalArgumentException if {@code component} is {@code null}.
     */
    public static &lt;P extends JProgressBar&gt; UIForProgressBar&lt;P&gt; of( P progressBar ) {
<span class="fc" id="L4846">        NullUtil.nullArgCheck(progressBar, &quot;progressBar&quot;, JProgressBar.class);</span>
<span class="fc" id="L4847">        return new UIForProgressBar&lt;&gt;(new BuilderState&lt;&gt;(progressBar));</span>
    }

    /**
     *  A factory method for creating a progress bar builder with a default {@link JProgressBar} implementation.
     *
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar() {
<span class="fc" id="L4856">        return new UIForProgressBar&lt;&gt;(new BuilderState&lt;&gt;(UI.ProgressBar.class, ()-&gt;new UI.ProgressBar()));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum and maximum values.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max ) {
<span class="nc" id="L4868">        return progressBar().withMin(min).withMax(max);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum, maximum and current value.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max, int value ) {
<span class="nc" id="L4881">        return progressBar().withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided minimum, maximum and current value property dynamically bound to the progress bar.
     *
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value property of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar( int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L4894">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;Null is not a valid value for the value property of a progress bar.&quot;);</span>
<span class="nc" id="L4895">        return progressBar().withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum and maximum values.
     *  The alignment is a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(UI.Align align, int min, int max ) {
<span class="fc" id="L4910">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L4911">        return progressBar().withOrientation(align).withMin(min).withMax(max);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum, maximum and current value.
     *  The alignment is a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(UI.Align align, int min, int max, int value ) {
<span class="fc" id="L4927">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L4928">        return progressBar().withOrientation(align).withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with
     *  the provided alignment, minimum, maximum and current value property dynamically bound to the progress bar.
     *  The alignment is a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param min The minimum value of the progress bar.
     * @param max The maximum value of the progress bar.
     * @param value The current value property of the progress bar.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(UI.Align align, int min, int max, Val&lt;Integer&gt; value ) {
<span class="nc" id="L4944">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="nc" id="L4945">        NullUtil.nullArgCheck(value, &quot;value&quot;, Val.class);</span>
<span class="nc" id="L4946">        NullUtil.nullPropertyCheck(value, &quot;value&quot;, &quot;Null is not a valid value for the value property of a progress bar.&quot;);</span>
<span class="nc" id="L4947">        return progressBar().withOrientation(align).withMin(min).withMax(max).withValue(value);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment and double based progress property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment is a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(UI.Align align, Val&lt;Double&gt; progress ) {
<span class="fc" id="L4962">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="fc" id="L4963">        NullUtil.nullArgCheck(progress, &quot;progress&quot;, Val.class);</span>
<span class="fc" id="L4964">        NullUtil.nullPropertyCheck(progress, &quot;progress&quot;, &quot;Null is not a valid value for the progress property of a progress bar.&quot;);</span>
<span class="fc" id="L4965">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment and double based progress property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment is a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(UI.Align align, double progress ) {
<span class="nc" id="L4980">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="nc" id="L4981">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JProgressBar} instance with a default minimum and maximum value
     *  of 0 and 100 and the provided alignment property and double based progress
     *  property (a property wrapping a double value between 0 and 1)
     *  dynamically bound to the progress bar.
     *  The alignment property wraps a {@link UI.Align} value, which may be either {@link UI.Align#HORIZONTAL}
     *  or {@link UI.Align#VERTICAL}.
     *  When any of the two properties change in your view model, the progress bar will be updated accordingly.
     *
     * @param align The alignment of the progress bar.
     * @param progress The current progress property of the progress bar, a property wrapping a double value between 0 and 1.
     * @return A builder instance for the provided {@link JProgressBar}, which enables fluent method chaining.
     */
    public static UIForProgressBar&lt;JProgressBar&gt; progressBar(Val&lt;UI.Align&gt; align, Val&lt;Double&gt; progress ) {
<span class="nc" id="L4998">        NullUtil.nullArgCheck(align, &quot;align&quot;, UI.Align.class);</span>
<span class="nc" id="L4999">        NullUtil.nullArgCheck(progress, &quot;progress&quot;, Val.class);</span>
<span class="nc" id="L5000">        NullUtil.nullPropertyCheck(progress, &quot;progress&quot;, &quot;Null is not a valid value for the progress property of a progress bar.&quot;);</span>
<span class="nc" id="L5001">        return progressBar().withOrientation(align).withMin(0).withMax(100).withProgress(progress);</span>
    }

    /**
     *  Use this to create a builder for the provided {@link JTextArea} instance.
     *
     * @param area The {@link JTextArea} which should be wrapped by the builder.
     * @param &lt;A&gt; The type of the {@link JTextArea} for which the builder should be created.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static &lt;A extends JTextArea&gt; UIForTextArea&lt;A&gt; of( A area ) {
<span class="fc" id="L5012">        NullUtil.nullArgCheck(area, &quot;area&quot;, JTextArea.class);</span>
<span class="fc" id="L5013">        return new UIForTextArea&lt;&gt;(new BuilderState&lt;&gt;(area));</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text as the initial text.
     *
     * @param text The initial text which should be displayed on the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( String text ) {
<span class="fc" id="L5024">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class);</span>
<span class="fc" id="L5025">        return new UIForTextArea&lt;&gt;(new BuilderState&lt;JTextArea&gt;(UI.TextArea.class, UI.TextArea::new))</span>
<span class="fc" id="L5026">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property is a {@link Val}, meaning that it is read-only and may not be changed
     *  by the text area.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Val&lt;String&gt; text ) {
<span class="nc" id="L5039">        NullUtil.nullArgCheck(text, &quot;text&quot;, Val.class);</span>
<span class="nc" id="L5040">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="nc" id="L5041">        return new UIForTextArea&lt;&gt;(new BuilderState&lt;JTextArea&gt;(UI.TextArea.class, UI.TextArea::new))</span>
<span class="nc bnc" id="L5042" title="All 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="nc" id="L5043">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a new {@link JTextArea} instance with
     *  the provided text property dynamically displaying its value in the text area.
     *  The property may also be modified by the user.
     *
     * @param text The text property which should be bound to the text area.
     * @return A builder instance for the provided {@link JTextArea}, which enables fluent method chaining.
     */
    public static UIForTextArea&lt;JTextArea&gt; textArea( Var&lt;String&gt; text ) {
<span class="fc" id="L5055">        NullUtil.nullArgCheck(text, &quot;text&quot;, Var.class);</span>
<span class="fc" id="L5056">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L5057">        return new UIForTextArea&lt;&gt;(new BuilderState&lt;JTextArea&gt;(UI.TextArea.class, UI.TextArea::new))</span>
<span class="pc bpc" id="L5058" title="1 of 2 branches missed.">                .applyIf(!text.hasNoID(), it -&gt; it.id(text.id()))</span>
<span class="fc" id="L5059">                .withText(text);</span>
    }

    /**
     *  Use this to create a builder for a concrete {@link JList} component
     *  type instance. This method allows you to easily integrate custom
     *  {@link JList} implementations into the SwingTree framework.
     *
     * @param list The {@link JList} which should be wrapped by the builder.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for the provided {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; of( JList&lt;E&gt; list ) {
<span class="fc" id="L5072">        NullUtil.nullArgCheck(list, &quot;list&quot;, JList.class);</span>
<span class="fc" id="L5073">        return new UIForList&lt;&gt;(new BuilderState&lt;&gt;(list));</span>
    }

    /**
     *  Allows for the creation of a declarative UI for the {@link JList} component type.
     *
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list() {
<span class="fc" id="L5083">        return new UIForList&lt;&gt;(new BuilderState&lt;&gt;(UI.List.class, UI.List::new));</span>
    }

    /**
     *  Allows for the creation of a declarative UI for a new {@link JList} instance
     *  with a custom list model.
     *
     * @param model The model which should be used for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList}.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( ListModel&lt;E&gt; model ) {
<span class="nc" id="L5095">        NullUtil.nullArgCheck(model, &quot;model&quot;, ListModel.class);</span>
<span class="nc" id="L5096">        return new UIForList&lt;&gt;(new BuilderState&lt;&gt;(UI.List.class, ()-&gt;{</span>
<span class="nc" id="L5097">            JList&lt;E&gt; list = new UI.List&lt;&gt;();</span>
<span class="nc" id="L5098">            list.setModel(model);</span>
<span class="nc" id="L5099">            return list;</span>
        }));
    }

    /**
     *  Creates a new {@link JList} instance builder
     *  with the provided array as data model.
     *  This is functionally equivalent to {@link #listOf(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( E... elements ) {
<span class="fc" id="L5114">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Object[].class);</span>
<span class="fc" id="L5115">        return new UIForList&lt;&gt;(new BuilderState&lt;JList&lt;E&gt;&gt;(UI.List.class, ()-&gt;new UI.List&lt;E&gt;()))</span>
<span class="fc" id="L5116">                .withEntries( elements );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with the provided
     *  observable property list (a {@link Vals} object) as data model.
     *  When the property list changes, the {@link JList} will be updated accordingly.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided {@link Vals} as data model.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Vals&lt;E&gt; elements ) {
<span class="fc" id="L5129">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="fc" id="L5130">        return new UIForList&lt;&gt;(new BuilderState&lt;JList&lt;E&gt;&gt;(UI.List.class, ()-&gt;new UI.List&lt;E&gt;()))</span>
<span class="fc" id="L5131">                .withEntries( elements );</span>
    }

    /**
     *  A functionally identical alias method for {@link #list(Vals)}, which allows for
     *  the creation of a new {@link JList} instance with the provided
     *  observable property list (a {@link Vals} object) as data model.
     *  When the property list changes, the {@link JList} will be updated accordingly.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided {@link Vals} as data model.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( Vals&lt;E&gt; elements ) {
<span class="nc" id="L5145">        return list( elements );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with 2 observable
     *  collections as data model, a {@link Var} property for the selection and a {@link Vals}
     *  property list for the elements.
     *  When any of the properties change, the {@link JList} will be updated accordingly,
     *  and conversely, when the {@link JList} selection changes, the properties will be updated accordingly.
     *
     * @param selection The {@link Var} property which should be bound to the selection of the {@link JList}.
     * @param elements The {@link Vals} property which should be bound to the displayed elements of the {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided arguments as data model.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Var&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="fc" id="L5161">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Var.class);</span>
<span class="fc" id="L5162">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="fc" id="L5163">        return list( elements ).withSelection( selection );</span>
    }

    /**
     *  Allows for the creation of a new {@link JList} instance with 2 observable
     *  collections as data model, a {@link Val} property for the selection and a {@link Vals}
     *  property list for the elements.
     *  When any of the properties change, the {@link JList} will be updated accordingly,
     *  however, due to the usage of a read only {@link Val} property for the selection,
     *  the {@link JList} selection will not be updated when the property changes.
     *  If you want a bidirectional binding, use {@link #list(Var, Vals)} instead.
     *
     * @param selection The {@link Val} property which should be bound to the selection of the {@link JList}.
     * @param elements The {@link Vals} property which should be bound to the displayed elements of the {@link JList}.
     * @return A builder instance for a new {@link JList} with the provided {@link Val} and {@link Vals} as data models.
     * @param &lt;E&gt; The type of the elements in the list.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( Val&lt;E&gt; selection, Vals&lt;E&gt; elements ) {
<span class="nc" id="L5181">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Val.class);</span>
<span class="nc" id="L5182">        NullUtil.nullArgCheck(elements, &quot;elements&quot;, Vals.class);</span>
<span class="nc" id="L5183">        return new UIForList&lt;&gt;(new BuilderState&lt;JList&lt;E&gt;&gt;(UI.List.class, ()-&gt;new UI.List&lt;E&gt;()))</span>
<span class="nc" id="L5184">                .withEntries( elements ).withSelection( selection );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided array
     *  as data model.
     *  This is functionally equivalent to {@link #list(Object...)}.
     *
     * @param elements The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided array as data model.
     */
    @SafeVarargs
<span class="fc" id="L5197">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( E... elements ) { return list( elements ); }</span>

    /**
     *  Creates a new {@link JList} instance with the provided {@link UI.List}
     *  as data model.
     *  This is functionally equivalent to {@link #listOf(java.util.List)}.
     *
     * @param entries The list of entries used for populating a new {@link JList} component.
     * @param &lt;E&gt; The type parameter defining the concrete type of the list entries.
     * @return A builder instance for a new {@link JList} with the provided {@link UI.List} as data model.
     */
    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; list( java.util.List&lt;E&gt; entries ) {
<span class="fc" id="L5209">        return new UIForList&lt;&gt;(new BuilderState&lt;JList&lt;E&gt;&gt;(UI.List.class, ()-&gt;new UI.List&lt;E&gt;()))</span>
<span class="fc" id="L5210">                .withEntries( entries );</span>
    }

    /**
     *  Creates a new {@link JList} instance with the provided {@link UI.List}
     *  as data model.
     *  This is functionally equivalent to {@link #list(java.util.List)}.
     *
     * @param entries The elements which should be used as model data for the new {@link JList}.
     * @param &lt;E&gt; The type of the elements in the list.
     * @return A builder instance for a new {@link JList} with the provided {@link UI.List} as data model.
     */
<span class="fc" id="L5222">    public static &lt;E&gt; UIForList&lt;E, JList&lt;E&gt;&gt; listOf( java.util.List&lt;E&gt; entries ) { return list( entries ); }</span>

    /**
     *  Allows you to wrap the provided {@link JTable} type in a declarative UI builder.
     *  This is useful when you want to use a custom {@link JTable} implementation
     *  in the SwingTree framework.
     *
     * @param table The table which should be wrapped by the builder.
     * @param &lt;T&gt; The {@link JTable} type.
     * @return A builder instance for a new {@link JTable}.
     */
    public static &lt;T extends JTable&gt; UIForTable&lt;T&gt; of( T table ) {
<span class="nc" id="L5234">        NullUtil.nullArgCheck(table, &quot;table&quot;, JTable.class);</span>
<span class="nc" id="L5235">        return new UIForTable&lt;&gt;(new BuilderState&lt;&gt;(table));</span>
    }

    /**
     *  Creates a declarative UI builder for the {@link JTable} component type.
     *
     * @return A fluent builder instance for a new {@link JTable}.
     */
    public static UIForTable&lt;JTable&gt; table() {
<span class="fc" id="L5244">        return new UIForTable&lt;&gt;(new BuilderState&lt;&gt;(UI.Table.class, ()-&gt;new UI.Table()));</span>
    }

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a list of lists of entries.  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link java.util.List} which gets modified), the table model will not be updated automatically!
     *      Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( UI.ListData dataFormat, TableListDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L5262">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, UI.ListData.class);</span>
<span class="fc" id="L5263">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableListDataSource.class);</span>
<span class="fc" id="L5264">        return table().withModel(dataFormat, dataSource);</span>
    }

    /**
     *  Use this to create a new {@link JTable} with a table model whose data can be represented based
     *  on a map of column names to lists of table entries (basically a column major matrix).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *  &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *  is a {@link Map} which gets modified), the table model will not be updated automatically!
     *  Use {@link UIForTable#updateTableOn(sprouts.Event)} to bind an update {@link Event} to the table model.&lt;/b&gt;
     *
     * @param dataFormat An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public static &lt;E&gt; UIForTable&lt;JTable&gt; table( UI.MapData dataFormat, TableMapDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L5282">        NullUtil.nullArgCheck(dataFormat, &quot;dataFormat&quot;, UI.ListData.class);</span>
<span class="fc" id="L5283">        NullUtil.nullArgCheck(dataSource, &quot;dataSource&quot;, TableMapDataSource.class);</span>
<span class="fc" id="L5284">        return table().withModel(dataFormat, dataSource);</span>
    }

    /**
     *  Creates a new {@link JTable} instance builder with the provided table model
     *  configuration as a basis for creating the table model in a declarative fashion. &lt;br&gt;
     *  It is expected to be used like so:
     *  &lt;pre&gt;{@code
     *  UI.table( m -&gt; m
     *    .colCount( () -&gt; data[0].size() )
     *    .rowCount( () -&gt; data.size() )
     *    .getsEntryAt((col, row) -&gt; data[col][row] )
     * )
     * }&lt;/pre&gt;
     * The purpose of this pattern is to remove the necessity of implementing the {@link javax.swing.table.TableModel}
     * interface manually, which is a rather tedious task.
     * Instead, you can use ths fluent API provided by the {@link BasicTableModel.Builder} to create
     * a general purpose table model for your table.
     *
     * @param tableModelBuildable A lambda function which takes in model builder
     *                            and then returns a fully configured model builder
     *                            used as a basis for the table model.
     * @return This builder instance, to allow for further method chaining.
     */
    public static UIForTable&lt;JTable&gt; table(
        Configurator&lt;BasicTableModel.Builder&lt;Object&gt;&gt; tableModelBuildable
    ) {
<span class="fc" id="L5311">        Objects.requireNonNull(tableModelBuildable);</span>
<span class="fc" id="L5312">        BasicTableModel.Builder&lt;Object&gt; builder = new BasicTableModel.Builder&lt;&gt;(Object.class);</span>
        BasicTableModel.Builder&lt;Object&gt; modifiedBuilder;
        try {
<span class="fc" id="L5315">            modifiedBuilder = tableModelBuildable.configure(builder);</span>
<span class="nc" id="L5316">        } catch (Exception e) {</span>
<span class="nc" id="L5317">            log.error(&quot;Failed to configure table model!&quot;, e);</span>
<span class="nc" id="L5318">            return table();</span>
<span class="fc" id="L5319">        }</span>
<span class="fc" id="L5320">        return table().withModel(modifiedBuilder);</span>
    }

    /**
     *  Creates a new {@link JTable} instance builder with the provided table model
     *  configuration as a basis for creating the table model in a declarative fashion. &lt;br&gt;
     *  It is expected to be used like so:
     *  &lt;pre&gt;{@code
     *  UI.table(Double.class, m -&gt; m
     *    .colCount( () -&gt; data[0].size() )
     *    .rowCount( () -&gt; data.size() )
     *    .getsEntryAt((col, row) -&gt; data[col][row] )
     * )
     * }&lt;/pre&gt;
     * This API removes the necessity to implement the {@link javax.swing.table.TableModel}
     * interface manually, which is a rather tedious task.
     * Instead, you can configure a model step by step through a {@link Configurator} function
     * receiving the fluent builder API provided by the {@link BasicTableModel.Builder}.
     *
     * @param tableModelBuildable A lambda function which takes in model builder
     *                            and then returns a fully configured model builder
     *                            used as a basis for the table model.
     * @return This builder instance, to allow for further method chaining.
     */
    public static &lt;T&gt; UIForTable&lt;JTable&gt; table(
        Class&lt;T&gt; itemType,
        Configurator&lt;BasicTableModel.Builder&lt;T&gt;&gt; tableModelBuildable
    ) {
<span class="nc" id="L5348">        Objects.requireNonNull(tableModelBuildable);</span>
<span class="nc" id="L5349">        BasicTableModel.Builder&lt;T&gt; builder = new BasicTableModel.Builder&lt;&gt;(itemType);</span>
        BasicTableModel.Builder&lt;T&gt; modifiedBuilder;
        try {
<span class="nc" id="L5352">            modifiedBuilder = tableModelBuildable.configure(builder);</span>
<span class="nc" id="L5353">        } catch (Exception e) {</span>
<span class="nc" id="L5354">            log.error(&quot;Failed to configure table model!&quot;, e);</span>
<span class="nc" id="L5355">            return table();</span>
<span class="nc" id="L5356">        }</span>
<span class="nc" id="L5357">        return table().withModel(modifiedBuilder.build());</span>
    }

    /**
     *  Allows you to wrap a custom {@link JTableHeader} type in a
     *  declarative SwingTree UI builder.
     *
     * @param header The table header which should be wrapped by the builder.
     * @return A builder instance for a new {@link JTableHeader}.
     * @param &lt;H&gt; The type of the {@link JTableHeader} for which the builder should be created.
     */
    public static &lt;H extends UI.TableHeader&gt; UIForTableHeader&lt;H&gt; of( H header ) {
<span class="nc" id="L5369">        NullUtil.nullArgCheck(header, &quot;header&quot;, UI.TableHeader.class);</span>
<span class="nc" id="L5370">        return new UIForTableHeader&lt;&gt;(new BuilderState&lt;&gt;(header));</span>
    }

    /**
     *  Allows you to create a declarative builder for the {@link JTableHeader} UI component.
     * @return A builder instance for a new {@link JTableHeader}.
     */
    public static UIForTableHeader&lt;UI.TableHeader&gt; tableHeader() {
<span class="nc" id="L5378">        return new UIForTableHeader&lt;&gt;(new BuilderState&lt;&gt;(UI.TableHeader.class, ()-&gt;new UI.TableHeader()));</span>
    }

    /**
     *  This returns an instance of a SwingTree builder for a {@link JFrame} type.
     * @param frame The new frame instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     * @param &lt;F&gt; The concrete type of this new frame.
     */
    public static &lt;F extends JFrame&gt; UIForJFrame&lt;F&gt; of( F frame ) {
<span class="fc" id="L5388">        Objects.requireNonNull(frame);</span>
<span class="fc" id="L5389">        return new UIForJFrame&lt;&gt;(new BuilderState&lt;&gt;(frame));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JFrame()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame() {
<span class="fc" id="L5399">        return new UIForJFrame&lt;&gt;(new BuilderState&lt;&gt;(JFrame.class, ()-&gt;new JFrame()));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JFrame} with the supplied title. &lt;br&gt;
     * @param title The title for the new frame.
     * @return A basic UI builder instance wrapping a {@link JFrame}.
     */
    public static UIForJFrame&lt;JFrame&gt; frame( String title ) {
<span class="fc" id="L5408">        return new UIForJFrame&lt;&gt;(new BuilderState&lt;&gt;(JFrame.class, ()-&gt;new JFrame()))</span>
<span class="fc" id="L5409">                .withTitle(title);</span>
    }

    /**
     *  This returns an instance of a SwingTree builder for a {@link JDialog} type.
     * @param dialog The new dialog instance which ought to be part of the Swing UI.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     * @param &lt;D&gt; The concrete type of this new dialog.
     */
    public static &lt;D extends JDialog&gt; UIForJDialog&lt;D&gt; of( D dialog ) {
<span class="fc" id="L5419">        return new UIForJDialog&lt;&gt;(new BuilderState&lt;&gt;(dialog));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog}. &lt;br&gt;
     *  This is in essence a convenience method for {@code UI.of(new JDialog()) )}.
     *
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog() {
<span class="fc" id="L5429">        return new UIForJDialog&lt;&gt;(new BuilderState&lt;&gt;(JDialog.class, ()-&gt;new JDialog()));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner ) {
<span class="nc" id="L5438">        return new UIForJDialog&lt;&gt;(new BuilderState&lt;&gt;(JDialog.class, ()-&gt;new JDialog(owner)));</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied title. &lt;br&gt;
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( String title ) {
<span class="nc" id="L5447">        return new UIForJDialog&lt;&gt;(new BuilderState&lt;&gt;(JDialog.class, ()-&gt;new JDialog())).withTitle(title);</span>
    }

    /**
     *  Use this to create a builder for the supplied {@link JDialog} with the supplied owner and title. &lt;br&gt;
     * @param owner The owner for the new dialog.
     * @param title The title for the new dialog.
     * @return A basic UI builder instance wrapping a {@link JDialog}.
     */
    public static UIForJDialog&lt;JDialog&gt; dialog( Window owner, String title ) {
<span class="nc" id="L5457">        return new UIForJDialog&lt;&gt;(new BuilderState&lt;&gt;(JDialog.class, ()-&gt;new JDialog(owner)))</span>
<span class="nc" id="L5458">                .withTitle(title);</span>
    }


    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( 100, TimeUnit.MILLISECONDS )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setValue( it.progress() );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *  @param unit The time unit of the duration.
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( long duration, TimeUnit unit ) {
<span class="fc" id="L5482">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="fc" id="L5483">        return Animator.animateFor( LifeTime.of(duration, unit) );</span>
    }

    /**
     *  Exposes a builder API for creating and scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( 0.1, TimeUnit.MINUTES )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *  @param unit The time unit of the duration.
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( double duration, TimeUnit unit ) {
<span class="fc" id="L5506">        return Animator.animateFor( LifeTime.of(duration, unit) );</span>
    }

    /**
     *  Exposes a builder API for creating and scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime, Stride)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( 0.1, TimeUnit.MINUTES, Stride.REGRESSIVE )
     *       .until( it -&gt; it.progress() &lt; 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *  @param unit The time unit of the duration.
     *  @param stride The stride of the animation, which determines whether the animation
     *                progresses going forward or backwards.
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor(double duration, TimeUnit unit, Stride stride) {
<span class="fc" id="L5531">        return Animator.animateFor( LifeTime.of(duration, unit), stride );</span>
    }

    /**
     *  Exposes an API for scheduling periodic animation updates.
     *  This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *    UI.animateFor( LifeTime.of(0.1, TimeUnit.MINUTES) )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *          // ...
     *          someComponent.repaint();
     *       });
     *  }&lt;/pre&gt;
     *  @param duration The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     *
     *  @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( LifeTime duration ) {
<span class="nc" id="L5554">        return Animator.animateFor( duration );</span>
    }

    /**
     * Exposes an API for scheduling periodic animation updates
     * for a specific component whose {@link java.awt.Component#repaint()}
     * method should be called after every animation update.
     * This is a convenience method for {@link Animator#animateFor(LifeTime)}. &lt;br&gt;
     * A typical usage would be:
     * &lt;pre&gt;{@code
     *    UI.animateFor( UI.lifeTime(0.1, TimeUnit.MINUTES), someComponent )
     *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *       .go( it -&gt; {
     *          // do something
     *          someComponent.setBackground( new Color( 0, 0, 0, (int)(it.progress()*255) ) );
     *       });
     *  }&lt;/pre&gt;
     *
     * @param duration  The duration of the animation.
     *                  This is the time it takes for the animation to reach 100% progress.
     * @param component The component which should be repainted after every animation update.
     * @return An {@link Animator} instance which allows you to configure the animation.
     */
    public static Animator animateFor( LifeTime duration, java.awt.Component component ) {
<span class="nc" id="L5578">        return Animator.animateFor( duration, component );</span>
    }

    /**
     *  A factory method for creating a {@link LifeTime} instance
     *  with the given duration and time unit.
     *  This is a convenience method for {@link LifeTime#of(long, TimeUnit)}.
     *  The {@link LifeTime} instance is an immutable value type
     *  which is used for scheduling animations, usually through
     *  {@link Animator#animateFor(LifeTime)} or the convenience methods
     *  {@link UI#animateFor(long, TimeUnit)}, {@link UI#animateFor(double, TimeUnit)},
     *  {@link UI#animateFor(LifeTime)} or {@link UI#animateFor(LifeTime, java.awt.Component)}.
     *  A typical usage would be:
     *  &lt;pre&gt;{@code
     *      UI.animateFor( UI.lifeTime(0.1, TimeUnit.MINUTES) )
     *      .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
     *      .go( it -&gt; {
     *          // do something
     *      });
     *  }&lt;/pre&gt;
     *
     * @param duration The duration of the animation.
     * @param unit The time unit of the duration.
     * @return A {@link LifeTime} instance.
     */
<span class="nc" id="L5603">    public static LifeTime lifeTime( long duration, TimeUnit unit ) { return LifeTime.of(duration, unit); }</span>

    /**
     *  Shows an info dialog with the given message.
     * @param message The message to show in the dialog.
     */
<span class="fc" id="L5609">    public static void info( String message ) { info(&quot;Info&quot;, message); }</span>

    /**
     * Shows an info dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The message to show in the dialog.
     */
    public static void info( String title, String message ) {
<span class="fc" id="L5618">        message(message)</span>
<span class="fc" id="L5619">                .titled(title)</span>
<span class="fc" id="L5620">                .showAsInfo();</span>
<span class="fc" id="L5621">    }</span>

    /**
     *  Shows a warning dialog with the given message.
     * @param message The warning message to show in the dialog.
     */
<span class="fc" id="L5627">    public static void warn( String message ) { warn(&quot;Warning&quot;, message); }</span>

    /**
     * Shows a warning dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The warning message to show in the dialog.
     */
    public static void warn( String title, String message ) {
<span class="fc" id="L5636">        message(message)</span>
<span class="fc" id="L5637">                .titled(title)</span>
<span class="fc" id="L5638">                .showAsWarning();</span>
<span class="fc" id="L5639">    }</span>

    /**
     *  Shows an error dialog with the given message.
     * @param message The error message to show in the dialog.
     */
<span class="fc" id="L5645">    public static void error( String message ) { error(&quot;Error&quot;, message); }</span>

    /**
     * Shows an error dialog with the given message and dialog title.
     *
     * @param title   The title of the dialog.
     * @param message The error message to show in the dialog.
     */
    public static void error( String title, String message ) {
<span class="fc" id="L5654">        message(message)</span>
<span class="fc" id="L5655">                .titled(title)</span>
<span class="fc" id="L5656">                .showAsError();</span>
<span class="fc" id="L5657">    }</span>

    /**
     *  Exposes the {@link MessageDialog} API, an immutable builder config
     *  for creating a message dialog with a given message text.
     *  Call methods like {@link MessageDialog#showAsInfo()}, {@link MessageDialog#showAsWarning()}
     *  or {@link MessageDialog#showAsError()} to show the dialog in the desired style.
     *
     * @param text The text to show in the dialog.
     * @return A builder for creating an error dialog.
     */
<span class="fc" id="L5668">    public static MessageDialog message( String text ) { return MessageDialog.saying(text); }</span>

    /**
     *  Shows a conformation dialog with the given message and
     *  returns the user's answer in the form of a {@link ConfirmAnswer}
     *  enum constant.
     *
     * @param message the message to show
     * @return {@code Answer.YES} if the user clicked &quot;Yes&quot;, {@code Answer.NO} if the user clicked &quot;No&quot;, {@code Answer.CANCEL} otherwise.
     */
<span class="nc" id="L5678">    public static ConfirmAnswer confirm( String message ) { return confirm(&quot;Confirm&quot;, message); }</span>

    /**
     * Shows a conformation dialog with the given title and message and
     * returns the user's answer in the form of a {@link ConfirmAnswer}
     * enum constant.
     *
     * @param title   the title of the dialog
     * @param message the message to show
     * @return {@code Answer.YES} if the user clicked &quot;Yes&quot;, {@code Answer.NO} if the user clicked &quot;No&quot;, {@code Answer.CANCEL} otherwise.
     */
    public static ConfirmAnswer confirm( String title, String message ) {
<span class="fc" id="L5690">        return ConfirmDialog.asking(message)</span>
<span class="fc" id="L5691">                .titled(title)</span>
<span class="fc" id="L5692">                .showAsQuestion();</span>
    }

    /**
     *  Exposes the {@link ConfirmDialog} API, an immutable builder config type
     *  for creating a confirmation dialog designed to ask a question.
     *  The supplied string will be used as the question to ask the user
     *  when the dialog is shown using the {@link ConfirmDialog#showAsQuestion()} method.
     *
     * @param toBeConfirmed The question to ask the user.
     * @return A builder for creating a confirmation dialog designed to ask a question.
     */
    public static ConfirmDialog confirmation( String toBeConfirmed ) {
<span class="fc" id="L5705">        return ConfirmDialog.asking(toBeConfirmed);</span>
    }

    /**
     *  Shows a dialog where the user can select a value from a list of options
     *  based on the enum type implicitly defined by the given enum based property.
     *  The selected value will be stored in said property after the user has
     *  selected a value and also returned as an {@link Optional}.
     *  If no value is selected, the returned {@link Optional} will be empty
     *  and the property will not be changed.
     *
     * @param question The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The enum type.
     * @return The selected enum value wrapped in an {@link Optional} or an empty optional if the user cancelled the dialog.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; Optional&lt;E&gt; ask( String question, Var&lt;E&gt; selected ) {
<span class="fc" id="L5722">        return ask(&quot;Select&quot;, question, selected );</span>
    }

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The enum type.
     * @return The selected enum value wrapped in an {@link Optional} or an empty optional if the user cancelled the dialog.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; Optional&lt;E&gt; ask( String title, String message, Var&lt;E&gt; selected ) {
<span class="fc" id="L5738">        Objects.requireNonNull( message  );</span>
<span class="fc" id="L5739">        Objects.requireNonNull( title    );</span>
<span class="fc" id="L5740">        Objects.requireNonNull( selected );</span>
<span class="fc" id="L5741">        return OptionsDialog.offering(message, selected)</span>
<span class="fc" id="L5742">                .titled(title)</span>
<span class="fc" id="L5743">                .showAsQuestion();</span>
    }

    /**
     * Shows a dialog where the user can select a value from a list of options
     * based on the enum type implicitly defined by the given enum based property.
     * The selected value will be stored in said property after the user has
     * selected a value.
     *
     * @param title    The title of the dialog.
     * @param message  The message to show in the dialog.
     * @param icon     The icon to show in the dialog.
     * @param selected The enum based property to store the selected value in.
     * @param &lt;E&gt; The type parameter defining the concrete enum type.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; void ask( String title, String message, Icon icon, Var&lt;E&gt; selected ) {
<span class="fc" id="L5759">        Objects.requireNonNull( message  );</span>
<span class="fc" id="L5760">        Objects.requireNonNull( title    );</span>
<span class="fc" id="L5761">        Objects.requireNonNull( selected );</span>
<span class="fc" id="L5762">        OptionsDialog.offering(message, selected)</span>
<span class="fc" id="L5763">                .titled(title)</span>
<span class="fc" id="L5764">                .icon(icon)</span>
<span class="fc" id="L5765">                .showAsQuestion();</span>
<span class="fc" id="L5766">    }</span>

    /**
     *  Exposes the {@link OptionsDialog} API for creating a question dialog
     *  that allows the user to select a value from an array of provided enum values.
     *
     * @param offer The message to show in the dialog.
     * @param options The array of enum values to show in the dialog.
     * @param &lt;E&gt; The enum type.
     * @return A builder for creating a question dialog with a set of selectable enum values
     *         based on the provided array of enum values.
     */
    @SafeVarargs
    public static &lt;E extends Enum&lt;E&gt;&gt; OptionsDialog&lt;E&gt; choice( String offer, E... options ) {
<span class="fc" id="L5780">        return OptionsDialog.offering(offer, options);</span>
    }

    /**
     *  Exposes the {@link OptionsDialog} API for creating a question dialog
     *  that allows the user to select and set a value from the provided enum based property.
     *
     * @param offer The message to show in the dialog.
     * @param selectable The enum based property to store the selected value in.
     * @param &lt;E&gt; The enum type.
     * @return A builder for creating a question dialog with a set of selectable enum values
     *         based on the provided array of enum values.
     */
    public static &lt;E extends Enum&lt;E&gt;&gt; OptionsDialog&lt;E&gt; choice( String offer, Var&lt;E&gt; selectable ) {
<span class="fc" id="L5794">        return OptionsDialog.offering(offer, selectable);</span>
    }

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen.&lt;br&gt;
     *  &lt;b&gt;Warning: This method should only be invoked from the Event Dispatch Thread (EDT).
     *  You may encounter unexpected behavior if you call this method from another thread.&lt;br&gt;
     *  Use {@link #show(Function)} instead to ensure that the UI is created on the EDT.&lt;/b&gt;
     *
     * @param component The component to show in the window.
     */
    public static void show( java.awt.Component component ) {
<span class="nc" id="L5807">        Objects.requireNonNull( component );</span>
<span class="nc" id="L5808">        new TestWindow( &quot;&quot;, f -&gt; component );</span>
<span class="nc" id="L5809">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen.&lt;br&gt;
     *  &lt;b&gt;Warning: This method should only be invoked from the Event Dispatch Thread (EDT).
     *  You may encounter unexpected behavior if you call this method from another thread.&lt;br&gt;
     *  Use {@link #show(String, Function)} instead to ensure that the UI is created on the EDT.&lt;/b&gt;
     *
     * @param title The title of the window.
     * @param component The component to show in the window.
     */
    public static void show( String title, java.awt.Component component ) {
<span class="nc" id="L5822">        Objects.requireNonNull( component );</span>
<span class="nc" id="L5823">        new TestWindow( title, f -&gt; component );</span>
<span class="nc" id="L5824">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen. &lt;br&gt;
     *  &lt;b&gt;Warning: This method should only be invoked from the Event Dispatch Thread (EDT).
     *  You may encounter unexpected behavior if you call this method from another thread.&lt;br&gt;
     *  Use {@link #show(Function)} instead to ensure that the UI is created on the EDT.&lt;/b&gt;
     *
     * @param ui The SwingTree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L5837">        new TestWindow( &quot;&quot;, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L5838">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen. &lt;br&gt;
     *  &lt;b&gt;Warning: This method should only be invoked from the Event Dispatch Thread (EDT).
     *  You may encounter unexpected behavior if you call this method from another thread.&lt;br&gt;
     *  Use {@link #show(String, Function)} instead to ensure that the UI is created on the EDT.&lt;/b&gt;
     *  
     * @param title The title of the window.
     * @param ui The SwingTree UI to show in the window.
     * @param &lt;C&gt; The type of the component to show in the window.
     */
    public static &lt;C extends JComponent&gt; void show( String title, UIForAnySwing&lt;?, C&gt; ui ) {
<span class="nc" id="L5852">        new TestWindow( title, f -&gt; ui.getComponent() );</span>
<span class="nc" id="L5853">    }</span>

    /**
     *  Use this to quickly launch a UI component in a {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( Function&lt;JFrame, java.awt.Component&gt; uiSupplier ) {
<span class="nc" id="L5864">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L5865">        new TestWindow( &quot;&quot;, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L5866">    }</span>

    /**
     *  Use this to quickly launch a UI component in a titled {@link JFrame} window
     *  at the center of the screen using a function receiving the {@link JFrame}
     *  and returning the component to be shown.
     *
     * @param title The title of the window.
     * @param uiSupplier The component supplier which receives the current {@link JFrame}
     *                   and returns the component to be shown.
     */
    public static void show( String title, Function&lt;JFrame, java.awt.Component&gt; uiSupplier ) {
<span class="nc" id="L5878">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L5879">        new TestWindow( title, frame -&gt; uiSupplier.apply(frame) );</span>
<span class="nc" id="L5880">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing(EventProcessor eventProcessor, Function&lt;JFrame, java.awt.Component&gt; uiSupplier ) {
<span class="nc" id="L5890">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L5891">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L5892">        show(frame -&gt; use(eventProcessor, () -&gt; {</span>
            try {
<span class="nc" id="L5894">                return uiSupplier.apply(frame);</span>
<span class="nc" id="L5895">            } catch (Exception e) {</span>
<span class="nc" id="L5896">                log.error(&quot;Error trying to create a UI component for a new JFrame.&quot;, e);</span>
<span class="nc" id="L5897">                return panel(&quot;fill&quot;)</span>
<span class="nc" id="L5898">                        .add(&quot;grow&quot;, label(&quot;Error: &quot; + e.getMessage()) )</span>
<span class="nc" id="L5899">                        .get(JPanel.class);</span>
            }
        }));
<span class="nc" id="L5902">    }</span>

    /**
     *  Use this to quickly launch a UI component with a custom event processor
     *  in a titled {@link JFrame} window at the center of the screen.
     *
     * @param eventProcessor the event processor to use for the UI built inside the {@link Supplier} lambda.
     * @param title The title of the window.
     * @param uiSupplier The component supplier which builds the UI and supplies the component to be shown.
     */
    public static void showUsing(
            EventProcessor eventProcessor,
            String title,
            Function&lt;JFrame, java.awt.Component&gt; uiSupplier
    ) {
<span class="nc" id="L5917">        Objects.requireNonNull( eventProcessor );</span>
<span class="nc" id="L5918">        Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L5919">        show(title, frame -&gt; use(eventProcessor, () -&gt; uiSupplier.apply(frame)));</span>
<span class="nc" id="L5920">    }</span>


    /**
     *  Sets a {@link StyleSheet} which will be applied to all SwingTree UIs defined in the subsequent lambda scope.
     *  This method allows to switch between different style sheets.
     *  &lt;p&gt;
     * 	You can switch to a style sheet like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(new MyCustomStyeSheet(), ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param styleSheet The style sheet to be used for all subsequent UI building operations.
     * @param scope A lambda scope in which the style sheet is active for all subsequent UI building operations.
     * @param &lt;T&gt; The type of the result of the given scope.
     * @return the result of the given scope, usually a {@link JComponent} or SwingTree UI.
     */
    public static &lt;T&gt; T use( StyleSheet styleSheet, Supplier&lt;T&gt; scope ) {
<span class="fc bfc" id="L5947" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L5948">            return UI.runAndGet( ()-&gt; use(styleSheet, scope) );</span>

<span class="fc" id="L5950">        SwingTree swingTreeContext = SwingTree.get();</span>
<span class="fc" id="L5951">        StyleSheet oldStyleSheet = swingTreeContext.getStyleSheet();</span>
<span class="fc" id="L5952">        swingTreeContext.setStyleSheet(styleSheet);</span>
        try {
<span class="fc" id="L5954">            T result = scope.get();</span>
<span class="pc bpc" id="L5955" title="1 of 2 branches missed.">            if ( result instanceof JComponent )</span>
<span class="nc" id="L5956">                ComponentExtension.from((JComponent) result).gatherApplyAndInstallStyle(true);</span>
<span class="pc bpc" id="L5957" title="1 of 2 branches missed.">            if ( result instanceof UIForAnySwing )</span>
<span class="fc" id="L5958">                ComponentExtension.from(((UIForAnySwing&lt;?,?&gt;) result).getComponent()).gatherApplyAndInstallStyle(true);</span>

<span class="fc" id="L5960">            return result;</span>
        } finally {
<span class="fc" id="L5962">            swingTreeContext.setStyleSheet(oldStyleSheet);</span>
        }
    }

    /**
     *  Sets the {@link EventProcessor} to be used for all subsequent UI building operations.
     *  This method allows to switch between different event processing strategies.
     *  In particular, the {@link EventProcessor#DECOUPLED} is recommended to be used for
     *  proper decoupling of the UI thread from the application logic.
     *  &lt;p&gt;
     * 	You can switch to the decoupled event processor like so: &lt;br&gt;
     * 	&lt;pre&gt;{@code
     * 	use(EventProcessor.DECOUPLED, ()-&gt;
     *      UI.panel(&quot;fill&quot;)
     *      .add( &quot;shrink&quot;, UI.label( &quot;Username:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.textField(&quot;User1234..42&quot;) )
     *      .add( label( &quot;Password:&quot; ) )
     *      .add( &quot;grow, pushx&quot;, UI.passwordField(&quot;child-birthday&quot;) )
     *      .add( &quot;span&quot;,
     *          UI.button(&quot;Login!&quot;).onClick( it -&gt; {...} )
     *      )
     *  );
     *  }&lt;/pre&gt;
     *
     * @param processor The event processor to be used for all subsequent UI building operations
     * @param scope The scope of the event processor to be used for all subsequent UI building operations.
     *              The value returned by the given scope is returned by this method.
     * @return The value returned by the given scope.
     * @param &lt;T&gt; The type of the value returned by the given scope.
     */
    public static &lt;T&gt; T use( EventProcessor processor, Supplier&lt;T&gt; scope )
    {
<span class="fc bfc" id="L5994" title="All 2 branches covered.">        if ( !UI.thisIsUIThread() )</span>
<span class="fc" id="L5995">            return UI.runAndGet(()-&gt; use(processor, scope));</span>

<span class="fc" id="L5997">        SwingTree swingTreeContext = SwingTree.get();</span>
<span class="fc" id="L5998">        EventProcessor oldProcessor = swingTreeContext.getEventProcessor();</span>
<span class="fc" id="L5999">        swingTreeContext.setEventProcessor(processor);</span>
        try {
<span class="fc" id="L6001">            return scope.get();</span>
        } finally {
<span class="fc" id="L6003">            swingTreeContext.setEventProcessor(oldProcessor);</span>
        }
    }

    /**
     *  Use this to quickly create and inspect a test window for a UI component.
     */
    private static class TestWindow
    {
        private final JFrame frame;
        private final java.awt.@Nullable Component component;

<span class="nc" id="L6015">        private TestWindow( String title, Function&lt;JFrame, java.awt.Component&gt; uiSupplier ) {</span>
<span class="nc" id="L6016">            Objects.requireNonNull( title );</span>
<span class="nc" id="L6017">            Objects.requireNonNull( uiSupplier );</span>
<span class="nc" id="L6018">            this.frame = new JFrame();</span>
<span class="nc bnc" id="L6019" title="All 2 branches missed.">            if ( !title.isEmpty() ) this.frame.setTitle(title);</span>
<span class="nc" id="L6020">            frame.setLocationRelativeTo(null); // Initial centering!</span>
<span class="nc" id="L6021">            java.awt.Component c = null;</span>
<span class="nc bnc" id="L6022" title="All 2 branches missed.">            if ( !UI.thisIsUIThread() ) {</span>
                try {
<span class="nc" id="L6024">                    c = UI.runAndGet(() -&gt; uiSupplier.apply(frame));</span>
<span class="nc" id="L6025">                } catch (Exception e) {</span>
<span class="nc" id="L6026">                    log.error(&quot;Error trying to create a UI component for a new JFrame.&quot;, e);</span>
<span class="nc" id="L6027">                }</span>
            }
            else
<span class="nc" id="L6030">                c = uiSupplier.apply(frame);</span>

<span class="nc" id="L6032">            this.component = c;</span>
<span class="nc" id="L6033">            frame.add(component);</span>
<span class="nc" id="L6034">            frame.pack(); // Otherwise some components resize strangely or are not shown at all...</span>
            // Make sure that the window is centered on the screen again but with the component:
<span class="nc" id="L6036">            frame.setLocationRelativeTo(null);</span>
            // We set the size to fit the component:
<span class="nc" id="L6038">            _determineSize();</span>
<span class="nc" id="L6039">            frame.setVisible(true);</span>
<span class="nc" id="L6040">        }</span>
        private void _determineSize() {
<span class="nc" id="L6042">            Dimension size = frame.getSize();</span>
<span class="nc bnc" id="L6043" title="All 2 branches missed.">            if ( component != null ) {</span>
<span class="nc bnc" id="L6044" title="All 2 branches missed.">                if ( size == null ) // The frame has no size! It is best to set the size to the preferred size of the component:</span>
<span class="nc" id="L6045">                    size = component.getPreferredSize();</span>

<span class="nc bnc" id="L6047" title="All 2 branches missed.">                if ( size == null ) // The component has no preferred size! It is best to set the size to the minimum size of the component:</span>
<span class="nc" id="L6048">                    size = component.getMinimumSize();</span>

<span class="nc bnc" id="L6050" title="All 2 branches missed.">                if ( size == null ) // The component has no minimum size! Let's just look up the size of the component:</span>
<span class="nc" id="L6051">                    size = component.getSize();</span>
            }
<span class="nc" id="L6053">            frame.setSize(size);</span>
<span class="nc" id="L6054">        }</span>
    }


    /**
     * Loads an {@link ImageIcon} from the resource folder, the classpath, a local file
     * or from cache if it has already been loaded.
     * If no icon could be found, an empty optional is returned.
     * &lt;br&gt;&lt;br&gt;
     * Note that this method will also return {@link SvgIcon} instances, if the icon is an SVG image.
     * &lt;br&gt;&lt;br&gt;
     * Also, checkout {@link SwingTree#getIconCache()} to see where the icons are cached.
     *
     * @param path The path to the icon. It can be a classpath resource or a file path.
     * @return An optional containing the icon if it could be found, an empty optional otherwise.
     * @throws NullPointerException if {@code path} is {@code null}.
     */
    public static Optional&lt;ImageIcon&gt; findIcon(String path ) {
<span class="fc" id="L6072">        return findIcon(IconDeclaration.of(path));</span>
    }

    /**
     * Loads an {@link ImageIcon} from the resource folder, the classpath, a local file
     * or from cache if it has already been loaded.
     * If no icon could be found, an empty optional is returned.
     * &lt;br&gt;&lt;br&gt;
     * Note that this method will also return {@link SvgIcon} instances, if the icon is an SVG image.
     * &lt;br&gt;&lt;br&gt;
     * Also, checkout {@link SwingTree#getIconCache()} to see where the icons are cached.
     *
     * @param declaration The icon declaration, a value object defining the path to the icon.
     * @return An optional containing the icon if it could be found, an empty optional otherwise.
     * @throws NullPointerException if {@code declaration} is {@code null}.
     */
    public static Optional&lt;ImageIcon&gt; findIcon( IconDeclaration declaration ) {
<span class="fc" id="L6089">        Objects.requireNonNull(declaration, &quot;declaration&quot;);</span>
<span class="fc" id="L6090">        Map&lt;IconDeclaration, ImageIcon&gt; cache = SwingTree.get().getIconCache();</span>
<span class="fc" id="L6091">        ImageIcon icon = cache.get(declaration);</span>
<span class="fc bfc" id="L6092" title="All 2 branches covered.">        if ( icon == null ) {</span>
<span class="fc" id="L6093">            icon = _tryLoadIcon(declaration);</span>
<span class="fc bfc" id="L6094" title="All 2 branches covered.">            if ( icon != null )</span>
<span class="fc" id="L6095">                cache.put(declaration, icon);</span>
        }
<span class="fc" id="L6097">        return Optional.ofNullable(icon);</span>
    }

    /**
     * Loads an {@link SvgIcon} from the resource folder, the classpath, a local file
     * or from cache if it has already been loaded.
     * If no icon could be found, an empty optional is returned.
     * &lt;br&gt;&lt;br&gt;
     * Also, checkout {@link SwingTree#getIconCache()} to see where the icons are cached.
     *
     * @param path The path to the icon. It can be a classpath resource or a file path.
     * @return An optional containing the {@link SvgIcon} if it could be found, an empty optional otherwise.
     * @throws NullPointerException if {@code path} is {@code null}.
     */
    public static Optional&lt;SvgIcon&gt; findSvgIcon( String path ) {
<span class="nc" id="L6112">        Objects.requireNonNull(path, &quot;path&quot;);</span>
<span class="nc" id="L6113">        return findSvgIcon(IconDeclaration.of(path));</span>
    }

    /**
     * Loads an {@link SvgIcon} from the resource folder, the classpath, a local file
     * or from cache if it has already been loaded.
     * If no icon could be found, an empty optional is returned.
     * &lt;br&gt;&lt;br&gt;
     * Also, checkout {@link SwingTree#getIconCache()} to see where the icons are cached.
     *
     * @param declaration The icon declaration, a value object defining the path to the icon.
     * @return An optional containing the {@link SvgIcon} if it could be found, an empty optional otherwise.
     * @throws NullPointerException if {@code declaration} is {@code null}.
     */
    public static Optional&lt;SvgIcon&gt; findSvgIcon( IconDeclaration declaration ) {
<span class="fc" id="L6128">        Objects.requireNonNull(declaration, &quot;declaration&quot;);</span>
<span class="pc bpc" id="L6129" title="1 of 2 branches missed.">        if ( !declaration.path().endsWith(&quot;.svg&quot;) )</span>
<span class="nc" id="L6130">            return Optional.empty();</span>

<span class="fc" id="L6132">        Map&lt;IconDeclaration, ImageIcon&gt; cache = SwingTree.get().getIconCache();</span>
<span class="fc" id="L6133">        ImageIcon icon = cache.get(declaration);</span>
<span class="pc bpc" id="L6134" title="1 of 2 branches missed.">        if ( icon == null ) {</span>
<span class="fc" id="L6135">            icon = _tryLoadIcon(declaration);</span>
<span class="fc bfc" id="L6136" title="All 2 branches covered.">            if ( icon != null )</span>
<span class="fc" id="L6137">                cache.put(declaration, icon);</span>
        }
<span class="fc bfc" id="L6139" title="All 2 branches covered.">        if ( !(icon instanceof SvgIcon) )</span>
<span class="fc" id="L6140">            return Optional.empty();</span>
        else
<span class="fc" id="L6142">            return Optional.of(icon).map(SvgIcon.class::cast);</span>
    }

    /**
     * Loads an icon from the classpath or from a file.
     * @param declaration The icon declaration, a value object defining the path to the icon.
     *          The path can be a classpath resource or a file path.
     * @return The icon.
     * @throws NullPointerException if {@code path} is {@code null}.
     */
    private static @Nullable ImageIcon _tryLoadIcon(IconDeclaration declaration )
    {
<span class="fc" id="L6154">        ImageIcon icon = null;</span>
        try {
<span class="fc" id="L6156">            icon = _loadIcon(declaration);</span>
<span class="nc" id="L6157">        } catch (Exception e) {</span>
<span class="nc" id="L6158">            log.error(&quot;Failed to load icon from declaration: &quot; + declaration, e);</span>
<span class="fc" id="L6159">        }</span>
<span class="fc" id="L6160">        return icon;</span>
    }

    /**
     * Loads an icon from the classpath or from a file.
     * @param declaration The icon declaration, a value object defining the path to the icon.
     *          The path can be a classpath resource or a file path.
     * @return The icon.
     * @throws NullPointerException if {@code path} is {@code null}.
     */
    private static @Nullable ImageIcon _loadIcon( IconDeclaration declaration )
    {
<span class="fc" id="L6172">        Objects.requireNonNull(declaration, &quot;declaration&quot;);</span>
<span class="fc" id="L6173">        String path = declaration.path();</span>
<span class="fc" id="L6174">        Objects.requireNonNull(path, &quot;path&quot;);</span>
<span class="fc" id="L6175">        path = path.trim();</span>
<span class="fc bfc" id="L6176" title="All 2 branches covered.">        if ( path.isEmpty() )</span>
<span class="fc" id="L6177">            return null;</span>
        // First we make the path platform independent:
<span class="fc" id="L6179">        path = path.replace('\\', '/');</span>
        // Then we try to load the icon url from the classpath:
<span class="fc" id="L6181">        URL url = UI.class.getResource(path);</span>
        // We check if the url is null:
<span class="fc bfc" id="L6183" title="All 2 branches covered.">        if ( url == null ) {</span>
            // It is, let's do some troubleshooting:
<span class="fc bfc" id="L6185" title="All 2 branches covered.">            if ( !path.startsWith(&quot;/&quot;) )</span>
<span class="fc" id="L6186">                url = UI.class.getResource(&quot;/&quot; + path);</span>

<span class="fc bfc" id="L6188" title="All 2 branches covered.">            if ( url == null ) // Still null? Let's try to load it as a file:</span>
                try {
<span class="fc" id="L6190">                    url = new File(path).toURI().toURL();</span>
<span class="nc" id="L6191">                } catch (MalformedURLException e) {</span>
<span class="nc" id="L6192">                    throw new RuntimeException(e);</span>
<span class="fc" id="L6193">                }</span>
        }
<span class="fc" id="L6195">        Optional&lt;Integer&gt; width  = declaration.size().width().map(Number::intValue);</span>
<span class="fc" id="L6196">        Optional&lt;Integer&gt; height = declaration.size().height().map(Number::intValue);</span>
<span class="fc bfc" id="L6197" title="All 2 branches covered.">        if ( path.endsWith(&quot;.svg&quot;) ) {</span>
<span class="fc" id="L6198">            SVGDocument tempSVGDocument = null;</span>
            try {
<span class="fc" id="L6200">                SVGLoader loader = new SVGLoader();</span>
<span class="fc" id="L6201">                tempSVGDocument = Objects.requireNonNull(loader.load(url));</span>
<span class="fc" id="L6202">            } catch (Exception e) {</span>
<span class="fc" id="L6203">                log.error(&quot;Failed to load SVG document from URL: &quot; + url, e);</span>
<span class="fc" id="L6204">                return null;</span>
<span class="fc" id="L6205">            }</span>
<span class="fc" id="L6206">            SvgIcon icon = new SvgIcon(tempSVGDocument).withIconSize(declaration.size());</span>
<span class="pc bpc" id="L6207" title="3 of 4 branches missed.">            if ( width.isPresent() &amp;&amp; height.isPresent() )</span>
<span class="nc" id="L6208">                return icon.withIconSize(width.get(), height.get());</span>
<span class="pc bpc" id="L6209" title="1 of 2 branches missed.">            if ( width.isPresent() )</span>
<span class="nc" id="L6210">                return icon.withIconSizeFromWidth(width.get());</span>
<span class="pc bpc" id="L6211" title="1 of 2 branches missed.">            if ( height.isPresent() )</span>
<span class="nc" id="L6212">                return icon.withIconSizeFromHeight(height.get());</span>
<span class="fc" id="L6213">            return icon;</span>
        } else {
        /*
            Not that we explicitly use the &quot;createImage&quot; method of the toolkit here.
            This is because otherwise the image might get cached inside the toolkit,
            which is in the way of our own caching mechanism.
            (The internal caching of the toolkit is somewhat limited and we have no control over it,
            which is why we use our own cache.)
        */
<span class="fc" id="L6222">            ImageIcon icon = new ImageIcon(Toolkit.getDefaultToolkit().createImage(url), url.toExternalForm());</span>
<span class="fc" id="L6223">            double ratio = (double) icon.getIconWidth() / (double) icon.getIconHeight();</span>
<span class="pc bpc" id="L6224" title="1 of 4 branches missed.">            if ( width.isPresent() &amp;&amp; height.isPresent() )</span>
<span class="fc" id="L6225">                return new ImageIcon(icon.getImage().getScaledInstance(width.get(), height.get(), Image.SCALE_SMOOTH));</span>
<span class="pc bpc" id="L6226" title="1 of 2 branches missed.">            if ( width.isPresent() )</span>
<span class="nc" id="L6227">                return new ImageIcon(icon.getImage().getScaledInstance(width.get(), (int) (width.get() / ratio), Image.SCALE_SMOOTH));</span>
<span class="pc bpc" id="L6228" title="1 of 2 branches missed.">            if ( height.isPresent() )</span>
<span class="nc" id="L6229">                return new ImageIcon(icon.getImage().getScaledInstance((int) (height.get() * ratio), height.get(), Image.SCALE_SMOOTH));</span>
<span class="fc" id="L6230">            return icon;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>