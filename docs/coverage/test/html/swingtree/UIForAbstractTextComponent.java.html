<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAbstractTextComponent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAbstractTextComponent.java</span></div><h1>UIForAbstractTextComponent.java</h1><pre class="source lang-java linenums">package swingtree;


import sprouts.Action;
import sprouts.Val;
import sprouts.Var;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Objects;
import java.util.function.Consumer;

/**
 *  A swing tree builder node for {@link JTextComponent} instances.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 */
public abstract class UIForAbstractTextComponent&lt;I, C extends JTextComponent&gt; extends UIForAbstractSwing&lt;I, C&gt;
{
<span class="fc" id="L25">    private final java.util.List&lt;Action&lt;RemoveDelegate&gt;&gt;   removes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L26">    private final java.util.List&lt;Action&lt;InsertDelegate&gt;&gt;   inserts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L27">    private final java.util.List&lt;Action&lt;ReplaceDelegate&gt;&gt;  replaces = new ArrayList&lt;&gt;();</span>

    /**
     *  A custom document filter which is simply a lambda-rization wrapper which ought to make
     *  the implementation of custom callbacks more convenient, because the user does not have to implement
     *  all the methods provided by the {@link DocumentFilter}, but can simply pass a lambda for either one
     *  of them.
     */
<span class="fc" id="L35">    private final DocumentFilter filter = new DocumentFilter()</span>
<span class="fc" id="L36">    {</span>
<span class="fc" id="L37">        private final C _component = getComponent();</span>

        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void remove(FilterBypass fb, int offset, int length) throws BadLocationException {
<span class="fc" id="L43">            removes.forEach(action -&gt; action.accept( new RemoveDelegate(_component, fb, offset, length) ) );</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">            if ( removes.isEmpty() ) fb.remove(offset, length);</span>
<span class="fc" id="L45">        }</span>
        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
<span class="fc" id="L50">            inserts.forEach(action -&gt; action.accept( new InsertDelegate(_component, fb, offset, string.length(), string, attr) ) );</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">            if ( inserts.isEmpty() ) fb.insertString(offset, string, attr);</span>
<span class="fc" id="L52">        }</span>
        /**
         * See documentation in {@link DocumentFilter}!
         */
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
<span class="fc" id="L57">            replaces.forEach(action -&gt; action.accept(new ReplaceDelegate(_component, fb, offset, length, text, attrs)) );</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">            if ( replaces.isEmpty() ) fb.replace(offset, length, text, attrs);</span>
<span class="fc" id="L59">        }</span>
    };

<span class="fc" id="L62">    protected UIForAbstractTextComponent(C component) { super(component); }</span>

    /**
     * Sets the text of the wrapped &lt;code&gt;{@link TextComponent}&lt;/code&gt;
     * to the specified text. If the text is &lt;code&gt;null&lt;/code&gt;
     * or empty, has the effect of simply deleting the old text.
     * When text has been inserted, the resulting caret location
     * is determined by the implementation of the caret class.
     *
     * &lt;p&gt;
     * Note that text is not a bound property, so no {@link java.beans.PropertyChangeEvent}
     * is fired when it changes. To listen for changes to the text,
     * register action lambdas through {@link #onTextChange(Consumer)} or
     * use {@link DocumentListener} directly.
     * &lt;/p&gt;
     *
     * @param text The new text to be set for the wrapped text component type.
     * @return This very builder to allow for method chaining.
     */
    public final I withText( String text ) {
<span class="fc" id="L82">        NullUtil.nullArgCheck(text, &quot;text&quot;, String.class, &quot;Please use an empty string instead of null!&quot;);</span>
<span class="fc" id="L83">        getComponent().setText(text);</span>
<span class="fc" id="L84">        return _this();</span>
    }

    /**
     * Binds the text of the wrapped &lt;code&gt;{@link TextComponent}&lt;/code&gt; to
     * the specified {@link Val} property instance so that the text of the wrapped
     * text component is dynamically updated whenever the value of the property changes.
     * &lt;p&gt;
     *     Note that the text of the wrapped text component is only updated if the new value
     *     is different from the old value. This is to avoid infinite feedback loops.
     * &lt;br&gt;
     * @param val The property instance to bind the text of the wrapped text component to.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if the specified property is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if the specified property allows &lt;code&gt;null&lt;/code&gt; values.
     */
    public final I withText( Val&lt;String&gt; val ) {
<span class="nc" id="L101">        NullUtil.nullArgCheck(val, &quot;val&quot;, Val.class);</span>
<span class="nc" id="L102">        _onShow(val, v -&gt; getComponent().setText(v) );</span>
<span class="nc" id="L103">        return withText( val.orElseThrow() );</span>
    }

    /**
     *  Binds the text of the wrapped &lt;code&gt;{@link TextComponent}&lt;/code&gt; to
     *  the specified {@link Val} property instance so that the text of the wrapped
     *  text component is dynamically updated whenever the value of the property changes.
     *  &lt;p&gt;
     *  This method is the same as {@link #withText(Val)} except that the {@link Var}
     *  property is used instead of the {@link Val} property which allows for the
     *  text of the wrapped text component to be changed by the user.
     *
     * @param text The property instance to bind the text of the wrapped text component to.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if the specified property is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if the specified property allows &lt;code&gt;null&lt;/code&gt; values.
     */
    public final I withText( Var&lt;String&gt; text ) {
<span class="fc" id="L121">        NullUtil.nullPropertyCheck(text, &quot;text&quot;, &quot;Use an empty string instead of null!&quot;);</span>
<span class="fc" id="L122">        _onShow( text, newText -&gt; {</span>
<span class="fc" id="L123">            C c = getComponent();</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if ( !Objects.equals(c.getText(), newText) ) // avoid infinite recursion or some other Swing weirdness</span>
<span class="fc" id="L125">                c.setText(newText);</span>
<span class="fc" id="L126">        });</span>
<span class="fc" id="L127">        _onKeyTyped( (KeyEvent e) -&gt; {</span>
<span class="nc" id="L128">            C component = getComponent();</span>
<span class="nc" id="L129">            String oldText = component.getText();</span>
            // We need to add the now typed character to the old text, because the key typed event
            // is fired before the text is actually inserted into the text component.
            // The newly typed character needs to go at where the selection/caret.
            // So what we do first is get the non-selected text parts, then we insert the new character...
<span class="nc" id="L134">            int selectionStart = component.getSelectionStart();</span>
<span class="nc" id="L135">            int selectionEnd   = component.getSelectionEnd();</span>
<span class="nc" id="L136">            String part1 = oldText.substring(0, selectionStart);</span>
<span class="nc" id="L137">            String part2 = oldText.substring(selectionEnd);</span>
            String newText;
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if ( e.getKeyChar() == '\b' ) // backspace</span>
<span class="nc" id="L140">                newText = part1 + part2; // The user has deleted a character(s), they will already be gone, we just need to set the text.</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            else if ( e.getKeyChar() == '\u007f' ) // delete</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                newText = part1 + ( part2.length() &lt; 2 ? part2 : part2.substring(1) );</span>
            else
<span class="nc" id="L144">                newText = part1 + e.getKeyChar() + part2; // The user has typed a character, we need to add it to the text.</span>

            // So and now we can simply inform the property right? Not so fast, we need to do that later!
<span class="nc" id="L147">            UI.runLater(() -&gt; {</span>
<span class="nc" id="L148">                _doApp(newText, text::act);</span>
                /*
                    Yes, it looks really strange that we apply the text to the property in the next EDT cycle,
                    but this is important to prevent a tricky bug!
                    To understand the bug you need to know 2 things:
                    1. Calling 'act' on a prop triggers user defined 'onAct' callbacks, usually inside the view model.
                    2. When this code her is executed the text component is actually not yet updated with the new text!
                       It is in a sort of intermediate state, where the text component has already received the key typed event,
                       but the text has not yet been inserted into deleted from the text component.
                       The modification will only apply to the text component after this method has returned.

                    So if a user decides to rebroadcast the text property in the view model by calling the
                    'set' method on the text property or 'fireSet' in one of their 'onAct' callbacks,
                    then the text component will receive that new text and then apply the key typed event to it
                    which is already outdated, because the text property has already been updated with the new text,
                    the component however has not yet been updated with the new text.

                    To prevent this madness we simply call the 'act' method of the text property in the next EDT cycle!
                */
<span class="nc" id="L167">            });</span>
<span class="nc" id="L168">        });</span>
<span class="fc" id="L169">        return withText( text.orElseThrow() );</span>
    }

    /**
     *  Use this to set the font of the wrapped {@link JTextComponent}.
     * @param font The font of the text which should be displayed on the text component.
     * @return This builder instance, to allow for method chaining.
     * @throws IllegalArgumentException if {@code font} is {@code null}.
     */
    public final I withFont( Font font ) {
<span class="nc" id="L179">        NullUtil.nullArgCheck(font, &quot;font&quot;, Font.class);</span>
<span class="nc" id="L180">        this.getComponent().setFont( font );</span>
<span class="nc" id="L181">        return _this();</span>
    }

    /**
     *  Use this to dynamically set the font of the wrapped {@link JTextComponent}
     *  through the provided view model property.
     *  When the font wrapped by the provided property changes,
     *  then so does the font of this text component.
     *
     * @param font The font property of the text which should be displayed on the text component.
     * @return This builder instance, to allow for method chaining.
     * @throws IllegalArgumentException if {@code font} is {@code null}.
     * @throws IllegalArgumentException if {@code font} is a property which can wrap {@code null}.
     */
    public final I withFont( Val&lt;Font&gt; font ) {
<span class="nc" id="L196">        NullUtil.nullArgCheck(font, &quot;font&quot;, Val.class);</span>
<span class="nc" id="L197">        NullUtil.nullPropertyCheck(font, &quot;font&quot;, &quot;Use the default font of this component instead of null!&quot;);</span>
<span class="nc" id="L198">        _onShow( font, v -&gt; withFont(v) );</span>
<span class="nc" id="L199">        return withFont( font.orElseThrow() );</span>
    }

    /**
     * The provided {@link UI.HorizontalDirection} translates to {@link ComponentOrientation}
     * instances which are used to align the elements or text within the wrapped {@link JTextComponent}.
     * {@link LayoutManager} and {@link Component}
     * subclasses will use this property to
     * determine how to lay out and draw components.
     * &lt;p&gt;
     * Note: This method indirectly changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param direction The text orientation type which should be used.
     * @return This very builder to allow for method chaining.
     */
    public final I withTextOrientation( UI.HorizontalDirection direction ) {
<span class="fc" id="L216">        NullUtil.nullArgCheck(direction, &quot;direction&quot;, UI.HorizontalDirection.class);</span>
<span class="fc" id="L217">        getComponent().setComponentOrientation(direction.forTextOrientation());</span>
<span class="fc" id="L218">        return _this();</span>
    }

    /**
     * The provided {@link UI.HorizontalDirection} property translates to {@link ComponentOrientation}
     * instances which are used to align the elements or text within the wrapped {@link JTextComponent}.
     * {@link LayoutManager} and {@link Component}
     * subclasses will use this property to
     * determine how to lay out and draw components.
     * &lt;p&gt;
     * Note: This method indirectly changes layout-related information, and therefore,
     * invalidates the component hierarchy.
     *
     * @param direction The text orientation type which should be used.
     * @return This very builder to allow for method chaining.
     */
    public final I withHorizontalTextOrientation( Val&lt;UI.HorizontalDirection&gt; direction ) {
<span class="nc" id="L235">        NullUtil.nullArgCheck( direction, &quot;direction&quot;, Val.class );</span>
<span class="nc" id="L236">        NullUtil.nullPropertyCheck(direction, &quot;direction&quot;, &quot;Null is not a valid value for the text orientation!&quot;);</span>
<span class="nc" id="L237">        _onShow( direction, v -&gt; {</span>
<span class="nc" id="L238">            withTextOrientation(v);</span>
<span class="nc" id="L239">            getComponent().validate();</span>
<span class="nc" id="L240">        });</span>
<span class="nc" id="L241">        return withTextOrientation(direction.orElseThrow());</span>
    }

    /**
     *  Use this to modify the components' modifiability.
     *
     * @param isEditable The flag determining if the underlying {@link JTextComponent} should be editable or not.
     * @return This very builder to allow for method chaining.
     */
    public final I isEditableIf( boolean isEditable ) {
<span class="fc" id="L251">        getComponent().setEditable(isEditable);</span>
<span class="fc" id="L252">        return _this();</span>
    }


    /**
     *  Use this to register any change in the contents of the text component including both
     *  the displayed text and its attributes.
     *
     * @param action An action which will be executed when the text or its attributes in the underlying {@link JTextComponent} changes.
     * @return This very builder to allow for method chaining.
     */
    public final I onContentChange( Consumer&lt;SimpleDelegate&lt;JTextComponent, DocumentEvent&gt;&gt; action ) {
<span class="fc" id="L264">        C component = getComponent();</span>
<span class="fc" id="L265">        component.getDocument().addDocumentListener(new DocumentListener() {</span>
            @Override public void insertUpdate(DocumentEvent e)  {
<span class="pc" id="L267">                _doApp(()-&gt;action.accept(new SimpleDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));}</span>
            @Override public void removeUpdate(DocumentEvent e)  {
<span class="pc" id="L269">                _doApp(()-&gt;action.accept(new SimpleDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));}</span>
            @Override public void changedUpdate(DocumentEvent e) {
<span class="nc" id="L271">                _doApp(()-&gt;action.accept(new SimpleDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));}</span>
        });
<span class="fc" id="L273">        return _this();</span>
    }

    /**
     *  Use this to register if the text in this text component changes.
     *  This does not include style attributes like font size.
     *
     * @param action An action which will be executed when the text string in the underlying {@link JTextComponent} changes.
     * @return This very builder to allow for method chaining.
     */
    public final I onTextChange( Consumer&lt;SimpleDelegate&lt;JTextComponent, DocumentEvent&gt;&gt; action ) {
<span class="fc" id="L284">        NullUtil.nullArgCheck(action, &quot;action&quot;, Consumer.class);</span>
<span class="fc" id="L285">        C component = getComponent();</span>
<span class="fc" id="L286">        component.getDocument().addDocumentListener(new DocumentListener() {</span>
            @Override public void insertUpdate(DocumentEvent e) {
<span class="pc" id="L288">                _doApp(()-&gt;action.accept(new SimpleDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));}</span>
            @Override public void removeUpdate(DocumentEvent e) {
<span class="pc" id="L290">                _doApp(()-&gt;action.accept(new SimpleDelegate&lt;&gt;(component, e, ()-&gt;getSiblinghood())));}</span>
<span class="nc" id="L291">            @Override public void changedUpdate(DocumentEvent e) {}</span>
        });
<span class="fc" id="L293">        return _this();</span>
    }

    /**
     * @param action An action which will be executed in case the underlying
     *               component supports text filtering (The underlying document is an {@link AbstractDocument}).
     */
    private void _ifFilterable( Runnable action ) {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if ( getComponent().getDocument() instanceof AbstractDocument ) {</span>
<span class="fc" id="L302">            action.run();</span>
<span class="fc" id="L303">            AbstractDocument doc = (AbstractDocument)getComponent().getDocument();</span>
<span class="fc" id="L304">            doc.setDocumentFilter(filter);</span>
        }
<span class="fc" id="L306">    }</span>

    /**
     * @param action A {@link Action} lambda which will be called when parts (or all) of the text in
     *               the underlying text component gets removed.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextRemove( Action&lt;RemoveDelegate&gt; action ) {
<span class="fc" id="L315">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L316">        _ifFilterable( () -&gt; this.removes.add(action) );</span>
<span class="fc" id="L317">        return _this();</span>
    }

    /**
     * @param action A {@link Action} lambda which will be called when new text gets inserted
     *               into the underlying text component.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextInsert( Action&lt;InsertDelegate&gt; action ) {
<span class="fc" id="L327">        _ifFilterable( () -&gt; this.inserts.add(action) );</span>
<span class="fc" id="L328">        return _this();</span>
    }

    /**
     * @param action A {@link Action} lambda which will be called when the text in
     *               the underlying text component gets replaced.
     *
     * @return This very builder to allow for method chaining.
     */
    public final I onTextReplace( Action&lt;ReplaceDelegate&gt; action ) {
<span class="fc" id="L338">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L339">        _ifFilterable( () -&gt; this.replaces.add(action) );</span>
<span class="fc" id="L340">        return _this();</span>
    }


    public static abstract class AbstractDelegate
    {
        private final JTextComponent textComponent;
        private final DocumentFilter.FilterBypass filterBypass;
        private final int offset;
        private final int length;

<span class="fc" id="L351">        protected AbstractDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length) {</span>
<span class="fc" id="L352">            this.textComponent = textComponent;</span>
<span class="fc" id="L353">            this.filterBypass = filterBypass;</span>
<span class="fc" id="L354">            this.offset = offset;</span>
<span class="fc" id="L355">            this.length = length;</span>
<span class="fc" id="L356">        }</span>

        public JTextComponent getComponent() {
            // We make sure that only the Swing thread can access the component:
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            if ( UI.thisIsUIThread() ) return textComponent;</span>
            else
<span class="nc" id="L362">                throw new IllegalStateException(</span>
                        &quot;Text component can only be accessed by the Swing thread.&quot;
                    );
        }
<span class="nc" id="L366">        public DocumentFilter.FilterBypass getFilterBypass() { return filterBypass; }</span>
<span class="fc" id="L367">        public int getOffset() { return offset; }</span>
<span class="fc" id="L368">        public int getLength() { return length; }</span>

    }

    public static final class RemoveDelegate extends AbstractDelegate
    {
        private RemoveDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length) {
<span class="fc" id="L375">            super(textComponent, filterBypass, offset, length);</span>
<span class="fc" id="L376">        }</span>

        public String getTextToBeRemoved() {
            try {
<span class="fc" id="L380">                return getComponent().getDocument().getText(getOffset(), getLength());</span>
<span class="nc" id="L381">            } catch (BadLocationException e) {</span>
<span class="nc" id="L382">                throw new IllegalStateException(&quot;Could not get text to be removed!&quot;, e);</span>
            }
        }
    }

    public static final class InsertDelegate extends AbstractDelegate
    {
        private final String text;
        private final AttributeSet attributeSet;

        private InsertDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) {
<span class="fc" id="L393">            super(textComponent, filterBypass, offset, length);</span>
<span class="fc" id="L394">            this.text = text;</span>
<span class="fc" id="L395">            this.attributeSet = attributeSet;</span>
<span class="fc" id="L396">        }</span>
<span class="fc" id="L397">        public String getTextToBeInserted() { return text; }</span>
<span class="nc" id="L398">        public AttributeSet attributeSet() { return attributeSet; }</span>
    }

    public static final class ReplaceDelegate extends AbstractDelegate
    {
        private final String text;
        private final AttributeSet attributeSet;

        private ReplaceDelegate(JTextComponent textComponent, DocumentFilter.FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) {
<span class="fc" id="L407">            super(textComponent, filterBypass, offset, length);</span>
<span class="fc" id="L408">            this.text = text;</span>
<span class="fc" id="L409">            this.attributeSet = attributeSet;</span>
<span class="fc" id="L410">        }</span>
<span class="nc" id="L411">        public String getText() { return text; }</span>
        public String getReplacementText() {
            try {
<span class="fc" id="L414">                return getComponent().getDocument().getText(getOffset(), getLength());</span>
<span class="nc" id="L415">            } catch (BadLocationException e) {</span>
<span class="nc" id="L416">                throw new IllegalStateException(&quot;Could not get text to be removed!&quot;, e);</span>
            }
        }
<span class="nc" id="L419">        public AttributeSet getAttributeSet() { return attributeSet; }</span>
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>