<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForTable.java</span></div><h1>UIForTable.java</h1><pre class="source lang-java linenums">package swingtree;

import sprouts.Event;
import swingtree.api.Buildable;
import swingtree.api.model.BasicTableModel;
import swingtree.api.model.TableListDataSource;
import swingtree.api.model.TableMapDataSource;

import javax.swing.*;
import javax.swing.table.*;
import java.util.*;

/**
 *  A SwingTree builder node designed for configuring {@link JTable} instances allowing
 *  for a fluent API to build tables in a declarative way.
 */
public final class UIForTable&lt;T extends JTable&gt; extends UIForAnySwing&lt;UIForTable&lt;T&gt;, T&gt;
{
    private final BuilderState&lt;T&gt; _state;

    /**
     * Extensions of the {@link  UIForAnySwing} always wrap
     * a single component for which they are responsible.
     *
     * @param state The {@link BuilderState} modelling how the component is built.
     */
<span class="fc" id="L27">    UIForTable( BuilderState&lt;T&gt; state ) {</span>
<span class="fc" id="L28">        Objects.requireNonNull(state);</span>
<span class="fc" id="L29">        _state = state;</span>
<span class="fc" id="L30">    }</span>

    @Override
    protected BuilderState&lt;T&gt; _state() {
<span class="fc" id="L34">        return _state;</span>
    }
    
    @Override
    protected UIForTable&lt;T&gt; _with( BuilderState&lt;T&gt; newState ) {
<span class="fc" id="L39">        return new UIForTable&lt;&gt;(newState);</span>
    }

    /**
     *  Use this to set the table header.
     *
     * @param header The table header to be set.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withHeader( UIForTableHeader&lt;?&gt; header ) {
<span class="nc" id="L49">        NullUtil.nullArgCheck(header, &quot;header&quot;, UIForTableHeader.class);</span>
<span class="nc" id="L50">        return withHeader(header.getComponent());</span>
    }

    /**
     *  Use this to set the table header.
     *
     * @param header The table header to be set.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withHeader( JTableHeader header ) {
<span class="nc" id="L60">        NullUtil.nullArgCheck(header, &quot;header&quot;, JTableHeader.class);</span>
<span class="nc" id="L61">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L62">                    thisComponent.setTableHeader(header);</span>
<span class="nc" id="L63">                })</span>
<span class="nc" id="L64">                ._this();</span>
    }

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts the builder API for a cell renderer.
     *
     * @param columnName The name of the column for which the cell renderer will be built.
     * @param renderBuilder The builder API for a cell renderer.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn( String columnName, Render.Builder&lt;JTable, ?&gt; renderBuilder ) {
<span class="fc" id="L76">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, Render.Builder.class);</span>
<span class="fc" id="L77">        return withRendererForColumn(columnName, renderBuilder.getForTable());</span>
    }

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts the builder API for a cell renderer.
     *
     * @param columnIndex The index of the column for which the cell renderer will be built.
     * @param renderBuilder The builder API for a cell renderer.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn( int columnIndex, Render.Builder&lt;JTable, ?&gt; renderBuilder ) {
<span class="fc" id="L89">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, Render.Builder.class);</span>
<span class="fc" id="L90">        return withRendererForColumn(columnIndex, renderBuilder.getForTable());</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column.
     * @param columnName The name of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     * @return This builder node, to allow for builder-style method chaining.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn( String columnName, TableCellRenderer renderer ) {
<span class="fc" id="L100">        NullUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="fc" id="L101">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L102">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L103">                    thisComponent.getColumn(columnName).setCellRenderer(renderer);</span>
<span class="fc" id="L104">                })</span>
<span class="fc" id="L105">                ._this();</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column.
     * @param columnIndex The index of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withRendererForColumn( int columnIndex, TableCellRenderer renderer ) {
<span class="fc" id="L115">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L116">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L117">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellRenderer(renderer);</span>
<span class="fc" id="L118">                })</span>
<span class="fc" id="L119">                ._this();</span>
    }

    /**
     * Use this to register a table cell renderer for all columns of this table.
     * @param renderer The cell renderer to be registered.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withRenderer( TableCellRenderer renderer ) {
<span class="fc" id="L128">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L129">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L130">                    thisComponent.setDefaultRenderer(Object.class, renderer);</span>
<span class="fc" id="L131">                })</span>
<span class="fc" id="L132">                ._this();</span>
    }

    /**
     * Use this to register a table cell renderer for all columns of this table.
     * @param renderBuilder The builder API for a cell renderer.
     * @return  This builder node.
     */
    public final UIForTable&lt;T&gt; withRenderer( Render.Builder&lt;JTable, ?&gt; renderBuilder ) {
<span class="fc" id="L141">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, Render.Builder.class);</span>
<span class="fc" id="L142">        return withRenderer(renderBuilder.getForTable());</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * @param columnName The name of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     * @return This builder instance, to allow for method chaining.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn( String columnName, TableCellEditor editor ) {
<span class="nc" id="L152">        NullUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="nc" id="L153">        NullUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L154">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L155">                    thisComponent.getColumn(columnName).setCellEditor(editor);</span>
<span class="nc" id="L156">                })</span>
<span class="nc" id="L157">                ._this();</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * @param columnIndex The index of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     * @return This builder node, to allow for builder-style method chaining.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn( int columnIndex, TableCellEditor editor ) {
<span class="nc" id="L167">        NullUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L168">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L169">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellEditor(editor);</span>
<span class="nc" id="L170">                })</span>
<span class="nc" id="L171">                ._this();</span>
    }

    /**
     *  Use this to set a table model.
     *  The provided argument is a builder object whose build method will be called
     *  for you instead of having to call the build method on the builder object yourself.
     * @param dataModelBuilder The builder object which will be used to build and then set the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel( Buildable&lt;BasicTableModel&gt; dataModelBuilder ) {
<span class="fc" id="L182">        return this.withModel(dataModelBuilder.build());</span>
    }

    /**
     * Use this to set a table model.
     * @param model The model for the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel( BasicTableModel model ) {
<span class="fc" id="L191">        NullUtil.nullArgCheck(model, &quot;model&quot;, BasicTableModel.class);</span>
<span class="fc" id="L192">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L193">                    thisComponent.setModel(model);</span>
<span class="fc" id="L194">                })</span>
<span class="fc" id="L195">                ._this();</span>
    }

    /**
     *  Use this instead of {@link JTable#setModel(TableModel)} if your table data can be represented through
     *  either a row major {@link List} of {@link List}s of entry {@link Object}s (a list of rows)      &lt;br&gt;
     *  or a columns major {@link List} of {@link List}s of entry {@link Object}s (a list of columns).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link List} and the list is modified), the table model will not be updated automatically!
     *      Use {@link #updateTableOn(sprouts.Event)} to bind an update {@link sprouts.Event} to the table model.&lt;/b&gt;
     *
     * @param mode An enum which configures the layout as well as modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableListDataSource} returning a list matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; withModel( UI.ListData mode, TableListDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L214">        boolean isRowMajor = mode.isRowMajor();</span>
<span class="fc" id="L215">        boolean isEditable = mode.isEditable();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if ( isRowMajor )</span>
<span class="fc" id="L217">            return _with( thisComponent -&gt;</span>
<span class="fc" id="L218">                    thisComponent.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L219">                    {</span>
<span class="fc" id="L220">                        @Override public int getRowCount() { return getData().size(); }</span>
                        @Override public int getColumnCount() {
<span class="fc" id="L222">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                            return ( data.isEmpty() ? 0 : data.get(0).size() );</span>
                        }
                        @Override public Object getValueAt(int rowIndex, int columnIndex) {
<span class="fc" id="L226">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                            if (isNotWithinBounds(rowIndex, columnIndex)) return null;</span>
<span class="fc" id="L228">                            return data.get(rowIndex).get(columnIndex);</span>
                        }
                        @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L231">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">                            if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L233">                            data.get(rowIndex).set(columnIndex, (E)aValue);</span>
<span class="nc" id="L234">                        }</span>
                    })
                )
<span class="fc" id="L237">                ._this();</span>
        else // isColumnMajor
<span class="fc" id="L239">            return _with( thisComponent -&gt;</span>
<span class="fc" id="L240">                    thisComponent.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L241">                    {</span>
                        @Override public int getRowCount() {
<span class="fc" id="L243">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                            return (data.isEmpty() ? 0 : data.get(0).size());</span>
                        }
<span class="fc" id="L246">                        @Override public int getColumnCount() { return getData().size(); }</span>
                        @Override public Object getValueAt( int rowIndex, int columnIndex ) {
<span class="fc" id="L248">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                            if ( isNotWithinBounds(rowIndex, columnIndex) ) return null;</span>
<span class="fc" id="L250">                            return data.get(columnIndex).get(rowIndex);</span>
                        }
                        @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L253">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">                            if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L255">                            data.get(columnIndex).set(rowIndex, (E)aValue);</span>
<span class="nc" id="L256">                        }</span>
                    })
                )
<span class="fc" id="L259">                ._this();</span>
    }

    /**
     *  Use this instead of {@link JTable#setModel(TableModel)} if your table data can be represented based
     *  on a map of column names to lists of table entries (basically a column major matrix).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link Map} which gets modified), the table model will not be updated automatically!
     *      Use {@link #updateTableOn(sprouts.Event)} to bind an update {@link sprouts.Event} to the table model.&lt;/b&gt;
     *
     * @param mode An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; withModel( UI.MapData mode, TableMapDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L277">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L278">                    thisComponent.setModel(new MapBasedColumnMajorTableModel&lt;&gt;(mode.isEditable(), dataSource));</span>
<span class="fc" id="L279">                })</span>
<span class="fc" id="L280">                ._this();</span>
    }

    /**
     *  Use this to bind an {@link sprouts.Event} to the {@link TableModel} of this table
     *  which will trigger the {@link AbstractTableModel#fireTableDataChanged()} method.
     *  This is useful if you want to update the table when the data source changes.
     *
     * @param event The event to be bound.
     * @return This builder node, for chaining.
     */
    public final UIForTable&lt;T&gt; updateTableOn( Event event ) {
<span class="fc" id="L292">        NullUtil.nullArgCheck(event, &quot;event&quot;, Event.class);</span>
<span class="fc" id="L293">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L294">                    event.subscribe(()-&gt;</span>
<span class="fc" id="L295">                        _doUI(()-&gt;{</span>
<span class="fc" id="L296">                            TableModel model = thisComponent.getModel();</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                            if ( model instanceof AbstractTableModel ) {</span>
                                // We want the table model update to be as thorough as possible, so we
                                // will fire a table structure changed event, followed by a table data
                                // changed event.
<span class="fc" id="L301">                                ((AbstractTableModel)model).fireTableStructureChanged();</span>
<span class="fc" id="L302">                                ((AbstractTableModel)model).fireTableDataChanged();</span>
                            }
                            else
<span class="nc" id="L305">                                throw new IllegalStateException(&quot;The table model is not an AbstractTableModel instance.&quot;);</span>
<span class="fc" id="L306">                        })</span>
                    );
<span class="fc" id="L308">                })</span>
<span class="fc" id="L309">                ._this();</span>
    }


    private static abstract class ListBasedTableModel&lt;E&gt; extends AbstractTableModel
    {
        private final TableListDataSource&lt;E&gt; dataSource;
        private final boolean isEditable;

<span class="fc" id="L318">        ListBasedTableModel(boolean isEditable, TableListDataSource&lt;E&gt; dataSource) {</span>
<span class="fc" id="L319">            this.isEditable = isEditable;</span>
<span class="fc" id="L320">            this.dataSource = dataSource;</span>
<span class="fc" id="L321">        }</span>

<span class="nc" id="L323">        @Override public boolean isCellEditable( int rowIndex, int columnIndex ) { return this.isEditable; }</span>

        protected List&lt;List&lt;E&gt;&gt; getData() {
<span class="fc" id="L326">            List&lt;List&lt;E&gt;&gt; data = dataSource.get();</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if ( data == null ) return new ArrayList&lt;&gt;(); // We really don't want null pointer in UIs.</span>
<span class="fc" id="L328">            return data;</span>
        }
        protected boolean isNotWithinBounds(int rowIndex, int colIndex) {
<span class="pc bpc" id="L331" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= getRowCount()     ) return true;</span>
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">            if ( colIndex &lt; 0 || colIndex &gt;= getColumnCount()  ) return true;</span>
<span class="fc" id="L333">            return false;</span>
        }
    }


    private abstract static class MapBasedTableModel&lt;E&gt; extends AbstractTableModel
    {
        private final TableMapDataSource&lt;E&gt; dataSource;
        private final boolean isEditable;

<span class="fc" id="L343">        MapBasedTableModel(boolean isEditable, TableMapDataSource&lt;E&gt; dataSource) {</span>
<span class="fc" id="L344">            this.isEditable = isEditable;</span>
<span class="fc" id="L345">            this.dataSource = dataSource;</span>
<span class="fc" id="L346">        }</span>

        protected Map&lt;String, List&lt;E&gt;&gt; getData() {
<span class="fc" id="L349">            Map&lt;String, List&lt;E&gt;&gt; data = dataSource.get();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if ( data == null ) return Collections.emptyMap(); // We really don't want null pointer in UIs.</span>
<span class="fc" id="L351">            return data;</span>
        }

        @Override
        public String getColumnName(int column) {
<span class="fc" id="L356">            List&lt;String&gt; columnNames = new ArrayList&lt;&gt;(getData().keySet());</span>
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">            if ( column &lt; 0 || column &gt;= columnNames.size() ) return null;</span>
<span class="fc" id="L358">            return columnNames.get(column);</span>
        }

<span class="nc" id="L361">        @Override public boolean isCellEditable( int rowIndex, int columnIndex ) { return this.isEditable; }</span>


        protected boolean isNotWithinBounds(int rowIndex, int colIndex) {
<span class="pc bpc" id="L365" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= getRowCount()     ) return true;</span>
<span class="pc bpc" id="L366" title="2 of 4 branches missed.">            if ( colIndex &lt; 0 || colIndex &gt;= getColumnCount()  ) return true;</span>
<span class="fc" id="L367">            return false;</span>
        }

    }

    private static class MapBasedColumnMajorTableModel&lt;E&gt; extends MapBasedTableModel&lt;E&gt;
    {
        MapBasedColumnMajorTableModel(boolean isEditable, TableMapDataSource&lt;E&gt; dataSource) {
<span class="fc" id="L375">            super(isEditable, dataSource);</span>
<span class="fc" id="L376">        }</span>

        @Override
        public int getRowCount() {
<span class="fc" id="L380">            Map&lt;String, List&lt;E&gt;&gt; data = getData();</span>
<span class="fc" id="L381">            return data.values()</span>
<span class="fc" id="L382">                        .stream()</span>
<span class="fc" id="L383">                        .filter(Objects::nonNull) // Again, we don't want null pointer exceptions in UIs.</span>
<span class="fc" id="L384">                        .mapToInt(List::size)</span>
<span class="fc" id="L385">                        .max()</span>
<span class="fc" id="L386">                        .orElse(0);</span>
        }

        @Override
<span class="fc" id="L390">        public int getColumnCount() { return getData().size(); }</span>

        @Override
        public Object getValueAt( int rowIndex, int columnIndex ) {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if ( isNotWithinBounds(rowIndex, columnIndex) ) return null;</span>
<span class="fc" id="L395">            List&lt;E&gt; column = getData().values().stream().skip(columnIndex).findFirst().orElse(null);</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if ( column == null ) return null;</span>
<span class="pc bpc" id="L397" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= column.size() ) return null;</span>
<span class="fc" id="L398">            return column.get(rowIndex);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>