<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForTable.java</span></div><h1>UIForTable.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.Event;
import sprouts.Observable;
import sprouts.Observer;
import swingtree.api.Buildable;
import swingtree.api.Configurator;
import swingtree.api.model.BasicTableModel;
import swingtree.api.model.TableListDataSource;
import swingtree.api.model.TableMapDataSource;

import javax.swing.*;
import javax.swing.table.*;
import java.awt.Component;
import java.util.*;
import java.util.function.Function;

/**
 *  A SwingTree declarative builder designed for configuring {@link JTable} instances allowing
 *  for a fluent API to build tables in a declarative way.
 */
public final class UIForTable&lt;T extends JTable&gt; extends UIForAnySwing&lt;UIForTable&lt;T&gt;, T&gt;
{
<span class="fc" id="L26">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(UIForTable.class);</span>

    private final BuilderState&lt;T&gt; _state;


    /**
     * Extensions of the {@link  UIForAnySwing} always wrap
     * a single component for which they are responsible.
     *
     * @param state The {@link BuilderState} modelling how the component is built.
     */
<span class="fc" id="L37">    UIForTable( BuilderState&lt;T&gt; state ) {</span>
<span class="fc" id="L38">        Objects.requireNonNull(state);</span>
<span class="fc" id="L39">        _state = state;</span>
<span class="fc" id="L40">    }</span>

    @Override
    protected BuilderState&lt;T&gt; _state() {
<span class="fc" id="L44">        return _state;</span>
    }
    
    @Override
    protected UIForTable&lt;T&gt; _newBuilderWithState(BuilderState&lt;T&gt; newState ) {
<span class="fc" id="L49">        return new UIForTable&lt;&gt;(newState);</span>
    }

    /**
     *  Use this to set the table header.
     *
     * @param header The table header to be set.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withHeader( UIForTableHeader&lt;?&gt; header ) {
<span class="nc" id="L59">        NullUtil.nullArgCheck(header, &quot;header&quot;, UIForTableHeader.class);</span>
<span class="nc" id="L60">        return withHeader(header.getComponent());</span>
    }

    /**
     *  Use this to set the table header.
     *
     * @param header The table header to be set.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withHeader( JTableHeader header ) {
<span class="nc" id="L70">        NullUtil.nullArgCheck(header, &quot;header&quot;, JTableHeader.class);</span>
<span class="nc" id="L71">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L72">                    thisComponent.setTableHeader(header);</span>
<span class="nc" id="L73">                })</span>
<span class="nc" id="L74">                ._this();</span>
    }

    private static &lt;T extends JTable&gt; CellBuilder&lt;T, Object&gt; _renderTable() {
<span class="fc" id="L78">        return (CellBuilder) CellBuilder.forTable(Object.class);</span>
    }

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts a lambda function which exposes the builder API for a cell renderer.
     *  Here is an example of how to use this method:
     * &lt;pre&gt;{@code
     *     UI.table(myModel)
     *     .withCellsForColumn(&quot;column1&quot;, it -&gt; it
     *         .when(String.class)
     *         .asText( cell -&gt; &quot;[&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;]&quot; ) )
     *     )
     *     .withCellsForColumn(&quot;column2&quot;, it -&gt; it
     *         .when(Float.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;f)&quot; ) )
     *         .when(Double.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;d)&quot; ) )
     *     );
     * }&lt;/pre&gt;
     * The above example would render the first column of the table as a string surrounded by square brackets,
     * and the second column as a float or double value surrounded by parentheses.
     * Note that the API allows you to specify how specific types of table entry values
     * should be rendered. This is done by calling the {@link CellBuilder#when(Class)} method
     * before calling the {@link RenderAs#asText(Function)} method.
     * &lt;br&gt;
     * &lt;b&gt;
     *     Due to this method being inherently based on the expectation of type ambiguity it is
     *     a rather verbose way of defining how your cells should look and behave. The simpler and
     *     preferred way of defining cell views is through the {@link #withCell(Configurator)},
     *     {@link #withCellForColumn(String, Configurator)} and {@link #withCellForColumn(int, Configurator)}
     *     methods.
     * &lt;/b&gt;
     *
     * @param columnName The name of the column for which the cell renderer will be built.
     * @param renderBuilder A lambda function which exposes a fluent builder API for a cell renderer
     *                      and returns the builder API for a cell renderer.
     *                      Call the appropriate methods on the builder API to configure the cell renderer.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withCellsForColumn(
        String columnName,
        Configurator&lt;CellBuilder&lt;T, Object&gt;&gt; renderBuilder
    ) {
<span class="fc" id="L122">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, CellBuilder.class);</span>
<span class="fc" id="L123">        CellBuilder&lt;T, Object&gt; builder = _renderTable();</span>
        try {
<span class="fc" id="L125">            builder = renderBuilder.configure(builder);</span>
<span class="nc" id="L126">        } catch (Exception e) {</span>
<span class="nc" id="L127">            log.error(&quot;Error while building table renderer.&quot;, e);</span>
<span class="nc" id="L128">            return this;</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">        return _withCellRendererForColumn(columnName, builder.getForTable());</span>
    }

    /**
     *  Use this to build a basic table cell renderer for a particular column.
     *  The second argument passed to this method is a lambda function
     *  which accepts a {@link CellConf} representing the cell to be rendered.
     *  You may then return an updated cell with a desired view component
     *  through methods like {@link CellConf#view(Component)} or {@link CellConf#updateView(Configurator)}.
     *  Here an example of how this method may be used:
     * &lt;pre&gt;{@code
     *     UI.table(UI.ListData.ROW_MAJOR_EDITABLE, ()-&gt;List.of(List.of(1, 2, 3), List.of(7, 8, 9)) )
     *     .withCellForColumn(0, cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              .orGet(JLabel::new) // initialize a new JLabel if not already present
     *              .updateIf(JLabel.class, l -&gt; {
     *                  l.setText(cell.valueAsString().orElse(&quot;&quot;));
     *                  l.setBackground(cell.isSelected() ? Color.YELLOW : Color.WHITE);
     *                  return l;
     *              })
     *              //...
     *          )
     *     )
     *     .withCellForColumn(1, cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              //...
     *          )
     *     );
     * }&lt;/pre&gt;
     * Also see {@link #withCellForColumn(int, Configurator)} method to build a cell renderer for a column by index,
     * and {@link #withCell(Configurator)} method to build a cell renderer for all columns of the table.
     * &lt;br&gt;
     * This API also supports the configuration of cell editors as the supplied lambda will also be
     * called by an underlying {@link TableCellEditor} implementation when the cell is in editing mode.
     * The cell will indicate that it needs an editor component by having the {@link CellConf#isEditing()}
     * set to true. You can then decide to return a different view component for the cell editor
     * by checking this property. The next time the lambda is invoked with the {@link CellConf#isEditing()}
     * flag is set to true, then the cell will still contain the same editor component as previously specified.
     * In case of the flag being false, the cell will contain the view component
     * that was provided the last time the cell was not in editing mode.
     *
     *
     * @param columnName The name of the column for which the cell renderer will be built.
     * @param cellConfigurator A lambda function which configures the cell view.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withCellForColumn(
        String columnName,
        Configurator&lt;CellConf&lt;T, Object&gt;&gt; cellConfigurator
    ) {
<span class="nc" id="L180">        Objects.requireNonNull(cellConfigurator);</span>
<span class="nc" id="L181">        Objects.requireNonNull(columnName);</span>
<span class="nc" id="L182">        return withCellsForColumn(columnName, it -&gt; it.when((Class)Object.class).as(cellConfigurator));</span>
    }

    /**
     *  Use this to build a table cell renderer for a particular column.
     *  The second argument accepts a lambda function which exposes the builder API for a cell renderer.
     *  Here an example of how this method may be used:
     * &lt;pre&gt;{@code
     *     UI.table(myModel)
     *     .withCellForColumn(0, it -&gt; it
     *         .when(String.class)
     *         .asText( cell -&gt; &quot;[&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;]&quot; ) )
     *     )
     *     .withCellForColumn(1, it -&gt; it
     *         .when(Float.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;f)&quot; ) )
     *         .when(Double.class)
     *         .asText( cell -&gt; &quot;(&quot; + cell.valueAsString().orElse(&quot;&quot;) + &quot;d)&quot; ) )
     *     );
     * }&lt;/pre&gt;
     * The above example would render the first column of the table as a string surrounded by square brackets,
     * and the second column as a float or double value surrounded by parentheses.
     * Note that the API allows you to specify how specific types of table entry values
     * should be rendered. This is done by calling the {@link CellBuilder#when(Class)} method
     * before calling the {@link RenderAs#asText(Function)} method. &lt;br&gt;
     * &lt;br&gt;
     * &lt;b&gt;
     *      Due to this method being inherently based on the expectation of type ambiguity it is
     *      a rather verbose way of defining how your cells should look and behave. The simpler and
     *      preferred way of defining cell views is through the {@link #withCell(Configurator)},
     *      {@link #withCellForColumn(String, Configurator)} and {@link #withCellForColumn(int, Configurator)}
     *      methods.
     * &lt;/b&gt;
     *
     *
     * @param columnIndex The index of the column for which the cell renderer will be built.
     * @param renderBuilder A lambda function which exposes a fluent builder API for a cell renderer
     *                      and returns the builder API for a cell renderer.
     *                      Call the appropriate methods on the builder API to configure the cell renderer.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withCellsForColumn(
        int columnIndex,
        Configurator&lt;CellBuilder&lt;T, Object&gt;&gt; renderBuilder
    ) {
<span class="fc" id="L227">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, CellBuilder.class);</span>
<span class="fc" id="L228">        CellBuilder&lt;T, Object&gt; builder = _renderTable();</span>
        try {
<span class="fc" id="L230">            builder = renderBuilder.configure(builder);</span>
<span class="nc" id="L231">        } catch (Exception e) {</span>
<span class="nc" id="L232">            log.error(&quot;Error while building table renderer.&quot;, e);</span>
<span class="nc" id="L233">            return this;</span>
<span class="fc" id="L234">        }</span>
<span class="fc" id="L235">        return _withCellRendererForColumn(columnIndex, builder.getForTable());</span>
    }

    /**
     *  Use this to build a basic table cell view for a particular column.
     *  The second argument passed to this method is a lambda function
     *  which accepts a {@link CellConf} representing the cell to be rendered and possibly even edited.
     *  You may then return an updated cell with a desired view component
     *  through methods like {@link CellConf#view(Component)} or {@link CellConf#updateView(Configurator)}.
     *  Here an example of how this method may be used:
     * &lt;pre&gt;{@code
     *     UI.table(UI.ListData.ROW_MAJOR_EDITABLE, ()-&gt;List.of(List.of(1, 2, 3), List.of(7, 8, 9)) )
     *     .withCellForColumn(0, cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              .orGet(JLabel::new) // initialize a new JLabel if not already present
     *              .updateIf(JLabel.class, l -&gt; {
     *                  l.setText(cell.valueAsString().orElse(&quot;&quot;));
     *                  l.setBackground(cell.isSelected() ? Color.YELLOW : Color.WHITE);
     *                  return l;
     *              })
     *              //...
     *          )
     *     )
     *     .withCellForColumn(1, cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              //...
     *          )
     *     );
     * }&lt;/pre&gt;
     * Also see {@link #withCellForColumn(String, Configurator)} method to build a cell renderer for a column by name,
     * and {@link #withCell(Configurator)} method to build a cell renderer for all columns of the table.
     * &lt;br&gt;
     * This API also supports the configuration of cell editors as the supplied lambda will also be
     * called by an underlying {@link TableCellEditor} implementation when the cell is in editing mode.
     * The cell will indicate that it needs an editor component by having the {@link CellConf#isEditing()}
     * set to true. You can then decide to return a different view component for the cell editor
     * by checking this property. The next time the lambda is invoked with the {@link CellConf#isEditing()}
     * flag is set to true, then the cell will still contain the same editor component as previously specified.
     * In case of the flag being false, the cell will contain the view component
     * that was provided the last time the cell was not in editing mode.
     *
     * @param columnIndex The index of the column for which the cell renderer will be built.
     * @param cellConfigurator A lambda function which configures the cell view.
     *                         The lambda is invoked in two main situations: when the cell is in editing mode
     *                         and when the cell is not in editing mode (only rendering).
     *                         You may decide what to store in the cell based on its state.
     * @return This instance of the builder, to allow for declarative method chaining.
     */
    public final UIForTable&lt;T&gt; withCellForColumn(
        int columnIndex,
        Configurator&lt;CellConf&lt;T, Object&gt;&gt; cellConfigurator
    ) {
<span class="nc" id="L287">        Objects.requireNonNull(cellConfigurator);</span>
<span class="nc" id="L288">        return withCellsForColumn(columnIndex, it -&gt; it.when((Class)Object.class).as(cellConfigurator));</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column.
     * A {@link TableCellRenderer} is a supplier of {@link java.awt.Component} instances which are used to render
     * the cells of a table.
     * &lt;b&gt;Note that in SwingTree, the preferred way of defining a cell renderer for a particular column is through the
     * {@link #withCellForColumn(String, Configurator)} method, which allows for a more fluent and declarative
     * way of defining cell renderers as well as editors.&lt;/b&gt;
     *
     * @param columnName The name of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     * @return This builder node, to allow for builder-style method chaining.
     */
    public final UIForTable&lt;T&gt; withCellRendererForColumn( String columnName, TableCellRenderer renderer ) {
<span class="nc" id="L304">        NullUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="nc" id="L305">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="nc" id="L306">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L307">                    thisComponent.getColumn(columnName).setCellRenderer(renderer);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                    if ( renderer instanceof TableCellEditor )</span>
<span class="nc" id="L309">                        thisComponent.getColumn(columnName).setCellEditor((TableCellEditor)renderer);</span>
<span class="nc" id="L310">                })</span>
<span class="nc" id="L311">                ._this();</span>
    }

    private final UIForTable&lt;T&gt; _withCellRendererForColumn( String columnName, CellBuilder&lt;?,?&gt;.SimpleTableCellRenderer renderer ) {
<span class="fc" id="L315">        NullUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="fc" id="L316">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L317">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L318">                    thisComponent.getColumn(columnName).setCellRenderer(renderer);</span>
<span class="fc" id="L319">                    thisComponent.getColumn(columnName).setCellEditor(renderer);</span>
<span class="fc" id="L320">                })</span>
<span class="fc" id="L321">                ._this();</span>
    }

    /**
     * Use this to register a table cell renderer for a particular column. &lt;br&gt;
     * A {@link TableCellRenderer} is a supplier of {@link java.awt.Component} instances which are used to render
     * the cells of a table.
     * &lt;b&gt;Note that in SwingTree, the preferred way of defining a cell renderer for a particular column is through the
     * {@link #withCellForColumn(int, Configurator)} method, which allows for a more fluent and declarative
     * way of defining cell renderers. It also supports both cell rendering and editing.&lt;/b&gt;
     *
     * @param columnIndex The index of the column for which the cell renderer will be registered.
     * @param renderer The cell renderer to be registered.
     * @return This builder instance, to allow for method chaining.
     */
    public final UIForTable&lt;T&gt; withCellRendererForColumn( int columnIndex, TableCellRenderer renderer ) {
<span class="nc" id="L337">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="nc" id="L338">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L339">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellRenderer(renderer);</span>
<span class="nc" id="L340">                })</span>
<span class="nc" id="L341">                ._this();</span>
    }

    private final UIForTable&lt;T&gt; _withCellRendererForColumn( int columnIndex, CellBuilder.SimpleTableCellRenderer renderer ) {
<span class="fc" id="L345">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L346">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L347">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellRenderer(renderer);</span>
<span class="fc" id="L348">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellEditor(renderer);</span>
<span class="fc" id="L349">                })</span>
<span class="fc" id="L350">                ._this();</span>
    }

    /**
     *  Use this to register a {@link TableCellRenderer} for all columns of this table.&lt;br&gt;
     *  A {@link TableCellRenderer} is a supplier of {@link java.awt.Component} instances which are used to render
     *  the cells of a table.&lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;Note that in SwingTree, the preferred way of defining a cell renderer is through the
     *  {@link #withCell(Configurator)} method, which allows for a more fluent and declarative
     *  way of defining cell renderers and also supports both cell rendering and editing.&lt;/b&gt;
     *
     * @param renderer A provider of {@link java.awt.Component} instances which are used to render the cells of a table.
     * @return This builder instance, to allow for method chaining.
     */
    public final UIForTable&lt;T&gt; withCellRenderer( TableCellRenderer renderer ) {
<span class="nc" id="L365">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="nc" id="L366">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L367">                    thisComponent.setDefaultRenderer(Object.class, renderer);</span>
<span class="nc" id="L368">                })</span>
<span class="nc" id="L369">                ._this();</span>
    }

    private final UIForTable&lt;T&gt; _withCellRenderer( CellBuilder.SimpleTableCellRenderer renderer ) {
<span class="fc" id="L373">        NullUtil.nullArgCheck(renderer, &quot;renderer&quot;, TableCellRenderer.class);</span>
<span class="fc" id="L374">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L375">                    thisComponent.setDefaultRenderer(Object.class, renderer);</span>
<span class="fc" id="L376">                    thisComponent.setDefaultEditor(Object.class, renderer);</span>
<span class="fc" id="L377">                })</span>
<span class="fc" id="L378">                ._this();</span>
    }

    /**
     *  Use this to define a table cell renderer for all columns of this table
     *  using the fluent builder API exposed to the provided lambda function.&lt;br&gt;
     *  Here is an example of how this method is used:
     *  &lt;pre&gt;{@code
     *    UI.table()
     *    .withCells( it -&gt; it
     *        .when(SomeDataType.class)
     *        .asText( cell -&gt; cell.value().get().toString() )
     *    )
     *    // ...
     *  }&lt;/pre&gt;
     *  You may want to know that a similar API is also available for the {@link javax.swing.JList}
     *  and {@link javax.swing.JComboBox} components, see {@link UIForList#withCells(Configurator)},
     *  {@link UIForCombo#withCells(Configurator)} for more information.
     *  &lt;p&gt;
     *  &lt;b&gt;
     *      Also see {@link #withCell(Configurator)} method, which constitutes the preferred way
     *      to build a list cell renderer as it is simpler, more concise and less error-prone.
     *  &lt;/b&gt;
     *
     * @param renderBuilder A lambda function which exposes the builder API for a cell renderer
     *                      and returns the builder API for a cell renderer.
     *                      Call the appropriate methods on the builder API to configure the cell renderer.
     * @return This builder node.
     */
    public final UIForTable&lt;T&gt; withCells(
        Configurator&lt;CellBuilder&lt;T, Object&gt;&gt; renderBuilder
    ) {
<span class="fc" id="L410">        NullUtil.nullArgCheck(renderBuilder, &quot;renderBuilder&quot;, CellBuilder.class);</span>
<span class="fc" id="L411">        CellBuilder&lt;T, Object&gt; builder = _renderTable();</span>
        try {
<span class="fc" id="L413">            builder = renderBuilder.configure(builder);</span>
<span class="nc" id="L414">        } catch (Exception e) {</span>
<span class="nc" id="L415">            log.error(&quot;Error while building table renderer.&quot;, e);</span>
<span class="nc" id="L416">            return this;</span>
<span class="fc" id="L417">        }</span>
<span class="fc" id="L418">        Objects.requireNonNull(builder);</span>
<span class="fc" id="L419">        return _withCellRenderer(builder.getForTable());</span>
    }

    /**
     *  Allows for the configuration of a cell view for the items of the {@link JTable} instance.
     *  The {@link Configurator} lambda function passed to this method receives a {@link CellConf}
     *  exposing a wide range of properties describing the state of the cell, like
     *  its current item, its index, its selection state, etc.
     *  You may update return an updated cell with a desired view component
     *  through methods like {@link CellConf#view(Component)} or {@link CellConf#updateView(Configurator)}.
     *  &lt;p&gt;
     *  Here code snippet demonstrating how this method may be used
     *  as part of a UI declaration:
     *  &lt;pre&gt;{@code
     *      UI.table(UI.MapData.EDITABLE,()-&gt;{
     *          Map&lt;String, List&lt;String&gt;&gt; data = new LinkedHashMap&lt;&gt;();
     *          data.put(&quot;A&quot;, List.of(&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;));
     *          data.put(&quot;B&quot;, List.of(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;));
     *          data.put(&quot;C&quot;, List.of(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;));
     *          return data;
     *      })
     *      .withCell( cell -&gt; cell
     *          .updateView( comp -&gt; comp
     *              .orGet(JLabel::new) // initialize a new JLabel if not already present
     *              .updateIf(JLabel.class, tf -&gt; {
     *                  tf.setText(cell.valueAsString().orElse(&quot;&quot;));
     *                  tf.setBackground(cell.isSelected() ? Color.YELLOW : Color.WHITE);
     *                  return tf;
     *              })
     *          )
     *      )
     *  }&lt;/pre&gt;
     *  In this example, a new {@link JTable} is created from a map of column names to lists of strings.
     *  The {@link Configurator} lambda function passed to this method configures the cell view
     *  by setting the text of a {@link JLabel} to the value of the cell, and setting the background
     *  color of the label to yellow if the cell is selected, and white otherwise.
     *  &lt;br&gt;
     *  This API also supports the configuration of cell editors as the supplied lambda will also be
     *  called by an underlying {@link TableCellEditor} implementation when the cell is in editing mode.
     *  The cell will indicate that it needs an editor component by having the {@link CellConf#isEditing()}
     *  set to true. You can then decide to return a different view component for the cell editor
     *  by checking this property. The next time the lambda is invoked with the {@link CellConf#isEditing()}
     *  flag is set to true, then the cell will still contain the same editor component as previously specified.
     *  In case of the flag being false, the cell will contain the view component
     *  that was provided the last time the cell was not in editing mode.
     *
     *
     * @param cellConfigurator The {@link Configurator} lambda function that configures the cell view.
     * @return This instance of the builder node to allow for fluent method chaining.
     * @param &lt;V&gt; The type of the value that is being rendered in this combo box.
     */
    public final &lt;V&gt; UIForTable&lt;T&gt; withCell(
            Configurator&lt;CellConf&lt;T, V&gt;&gt; cellConfigurator
    ) {
<span class="fc" id="L473">        return withCells( it -&gt; it.when((Class)Object.class).as(cellConfigurator) );</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * &lt;b&gt;Note that in SwingTree, the preferred way of defining a cell editor for a particular column is through the
     * {@link #withCellForColumn(String, Configurator)} method, which allows for a more fluent and declarative
     * way of defining cell editors.&lt;/b&gt;
     *
     * @param columnName The name of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     * @return This builder instance, to allow for method chaining.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn( String columnName, TableCellEditor editor ) {
<span class="nc" id="L487">        NullUtil.nullArgCheck(columnName, &quot;columnName&quot;, String.class);</span>
<span class="nc" id="L488">        NullUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L489">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L490">                    thisComponent.getColumn(columnName).setCellEditor(editor);</span>
<span class="nc" id="L491">                })</span>
<span class="nc" id="L492">                ._this();</span>
    }

    /**
     * Use this to register a table cell editor for a particular column.
     * &lt;b&gt;Note that in SwingTree, the preferred way of defining a cell editor for a particular column is through the
     * {@link #withCellForColumn(int, Configurator)} method, which allows for a more fluent and declarative
     * way of defining cell editors.&lt;/b&gt;
     * @param columnIndex The index of the column for which the cell editor will be registered.
     * @param editor The cell editor to be registered.
     * @return This builder node, to allow for builder-style method chaining.
     */
    public final UIForTable&lt;T&gt; withCellEditorForColumn( int columnIndex, TableCellEditor editor ) {
<span class="nc" id="L505">        NullUtil.nullArgCheck(editor, &quot;editor&quot;, TableCellEditor.class);</span>
<span class="nc" id="L506">        return _with( thisComponent -&gt; {</span>
<span class="nc" id="L507">                    thisComponent.getColumnModel().getColumn(columnIndex).setCellEditor(editor);</span>
<span class="nc" id="L508">                })</span>
<span class="nc" id="L509">                ._this();</span>
    }

    /**
     *  Use this to set a table model.
     *  The provided argument is a builder object whose build method will be called
     *  for you instead of having to call the build method on the builder object yourself.
     *  &lt;b&gt;
     *      The preferred way of setting a table model is through the {@link #withModel(Configurator)}
     *      which exposes a fluent builder API for binding the table model to a data source
     *      without any boilerplate code.
     *  &lt;/b&gt;
     * @param dataModelBuilder The builder object which will be used to build and then set the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel( Buildable&lt;BasicTableModel&gt; dataModelBuilder ) {
<span class="fc" id="L525">        Objects.requireNonNull(dataModelBuilder);</span>
        try {
<span class="fc" id="L527">            return this.withModel(dataModelBuilder.build());</span>
<span class="nc" id="L528">        } catch (Exception e) {</span>
<span class="nc" id="L529">            log.error(&quot;Error while building a table model.&quot;, e);</span>
<span class="nc" id="L530">            return this;</span>
        }
    }

    /**
     *  Exposes a fluent builder API for a table model. &lt;br&gt;
     *  Here an example demonstrating how this API
     *  is typically used as part of a UI declaration:
     *  &lt;pre&gt;{@code
     *  UI.table().withModel( m -&gt; m
     *      .colName( col -&gt; new String[]{&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;}[col] )
     *      .colCount( () -&gt; 3 )
     *      .rowCount( () -&gt; data.size() )
     *      .getsEntryAt( (r, c) -&gt; data[r][c] )
     *      .updateOn(update)
     *  )
     *  }&lt;/pre&gt;
     *  The builder API is exposed to the lambda function passed to this method.
     *  The actually {@link TableModel} is built internally and then set on the table.
     *
     * @param dataModelBuilder A lambda function which receives a builder API for a table model
     * @return This builder instance, to allow for further method chaining.
     */
    public final UIForTable&lt;T&gt; withModel(
        Configurator&lt;BasicTableModel.Builder&lt;Object&gt;&gt; dataModelBuilder
    ) {
<span class="fc" id="L556">        Objects.requireNonNull(dataModelBuilder);</span>
<span class="fc" id="L557">        BasicTableModel.Builder&lt;Object&gt; builder = new BasicTableModel.Builder&lt;&gt;(Object.class);</span>
        try {
<span class="fc" id="L559">            builder = dataModelBuilder.configure(builder);</span>
<span class="nc" id="L560">        } catch (Exception e) {</span>
<span class="nc" id="L561">            log.error(&quot;Error while building table model.&quot;, e);</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        return this.withModel(builder.build());</span>
    }

    /**
     *  Exposes a fluent builder API for a table model holding a specific type of entry. &lt;br&gt;
     *  Here an example demonstrating how this API
     *  is typically used as part of a UI declaration:
     *  &lt;pre&gt;{@code
     *  UI.table().withModel(Double.class, m -&gt; m
     *      .colName( col -&gt; new String[]{&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;}[col] )
     *      .colCount( () -&gt; 3 )
     *      .rowCount( () -&gt; data.size() )
     *      .getsEntryAt( (r, c) -&gt; data[r][c] )
     *      .updateOn(update)
     *  )
     *  }&lt;/pre&gt;
     *  In this example, the table model is built for a {@link Double} based data source.
     *  So here the data array is a two-dimensional array of {@link Double}s. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that the builder API is exposed to the lambda function passed to this method.
     *  The actual {@link TableModel} is built internally and then installed on the table component.
     *  &lt;p&gt;
     *  You can also use the {@link UI#table(Configurator)} factory method to directly create a table
     *  with a custom table model. &lt;br&gt;
     *
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     * @param itemType The type of the table entry {@link Object}s.
     * @param dataModelBuilder A lambda function which receives a builder API for a table model
     * @return This builder instance, to allow for further method chaining.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; withModel(
        Class&lt;E&gt; itemType,
        Configurator&lt;BasicTableModel.Builder&lt;E&gt;&gt; dataModelBuilder
    ) {
<span class="nc" id="L597">        Objects.requireNonNull(itemType);</span>
<span class="nc" id="L598">        Objects.requireNonNull(dataModelBuilder);</span>
<span class="nc" id="L599">        BasicTableModel.Builder&lt;E&gt; builder = new BasicTableModel.Builder&lt;&gt;(itemType);</span>
        try {
<span class="nc" id="L601">            builder = dataModelBuilder.configure(builder);</span>
<span class="nc" id="L602">        } catch (Exception e) {</span>
<span class="nc" id="L603">            log.error(&quot;Error while building table model.&quot;, e);</span>
<span class="nc" id="L604">        }</span>
<span class="nc" id="L605">        return this.withModel(builder.build());</span>
    }
    /**
     * Use this to set a basic table model for this table.
     * @param model The model for the table model.
     * @return This builder object.
     */
    public final UIForTable&lt;T&gt; withModel( BasicTableModel model ) {
<span class="fc" id="L613">        NullUtil.nullArgCheck(model, &quot;model&quot;, BasicTableModel.class);</span>
<span class="fc" id="L614">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L615">                    thisComponent.setModel(model);</span>
<span class="fc" id="L616">                })</span>
<span class="fc" id="L617">                ._this();</span>
    }

    /**
     *  Use this instead of {@link JTable#setModel(TableModel)} if your table data can be represented by
     *  either a row major {@link List} of {@link List}s of entry {@link Object}s (a list of rows)      &lt;br&gt;
     *  or a columns major {@link List} of {@link List}s of entry {@link Object}s (a list of columns).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link List} and the list is modified), the table model will not be updated automatically!
     *      Use {@link #updateTableOn(sprouts.Event)} to bind an update {@link sprouts.Event} to the table model.&lt;/b&gt;
     *
     * @param mode An enum which configures the layout as well as modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableListDataSource} returning a list matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; withModel( UI.ListData mode, TableListDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L636">        boolean isRowMajor = mode.isRowMajor();</span>
<span class="fc" id="L637">        boolean isEditable = mode.isEditable();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if ( isRowMajor )</span>
<span class="fc" id="L639">            return _with( thisComponent -&gt;</span>
<span class="fc" id="L640">                    thisComponent.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L641">                    {</span>
<span class="fc" id="L642">                        @Override public int getRowCount() { return getData().size(); }</span>
                        @Override public int getColumnCount() {
<span class="fc" id="L644">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                            return ( data.isEmpty() ? 0 : data.get(0).size() );</span>
                        }
                        @Override public @Nullable Object getValueAt(int rowIndex, int columnIndex) {
<span class="fc" id="L648">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                            if (isNotWithinBounds(rowIndex, columnIndex)) return null;</span>
<span class="fc" id="L650">                            return data.get(rowIndex).get(columnIndex);</span>
                        }
                        @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L653">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L654" title="All 4 branches missed.">                            if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L655">                            data.get(rowIndex).set(columnIndex, (E)aValue);</span>
<span class="nc" id="L656">                        }</span>
                    })
                )
<span class="fc" id="L659">                ._this();</span>
        else // isColumnMajor
<span class="fc" id="L661">            return _with( thisComponent -&gt;</span>
<span class="fc" id="L662">                    thisComponent.setModel(new ListBasedTableModel&lt;E&gt;(isEditable, dataSource)</span>
<span class="fc" id="L663">                    {</span>
                        @Override public int getRowCount() {
<span class="fc" id="L665">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">                            return (data.isEmpty() ? 0 : data.get(0).size());</span>
                        }
<span class="fc" id="L668">                        @Override public int getColumnCount() { return getData().size(); }</span>
                        @Override public @Nullable Object getValueAt( int rowIndex, int columnIndex ) {
<span class="fc" id="L670">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                            if ( isNotWithinBounds(rowIndex, columnIndex) ) return null;</span>
<span class="fc" id="L672">                            return data.get(columnIndex).get(rowIndex);</span>
                        }
                        @Override public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
<span class="nc" id="L675">                            List&lt;List&lt;E&gt;&gt; data = getData();</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">                            if ( !isEditable || isNotWithinBounds(rowIndex, columnIndex) ) return;</span>
<span class="nc" id="L677">                            data.get(columnIndex).set(rowIndex, (E)aValue);</span>
<span class="nc" id="L678">                        }</span>
                    })
                )
<span class="fc" id="L681">                ._this();</span>
    }

    /**
     *  Use this instead of {@link JTable#setModel(TableModel)} if your table data can be represented based
     *  on a map of column names to lists of table entries (basically a column major matrix).  &lt;br&gt;
     *  This method will automatically create a {@link AbstractTableModel} instance for you.
     *  &lt;p&gt;
     *      &lt;b&gt;Please note that when the data of the provided data source changes (i.e. when the data source
     *      is a {@link Map} which gets modified), the table model will not be updated automatically!
     *      Use {@link #updateTableOn(sprouts.Event)} to bind an update {@link sprouts.Event} to the table model.&lt;/b&gt;
     *
     * @param mode An enum which configures the modifiability of the table in a readable fashion.
     * @param dataSource The {@link TableMapDataSource} returning a column major map based matrix which will be used to populate the table.
     * @return This builder node.
     * @param &lt;E&gt; The type of the table entry {@link Object}s.
     */
    public final &lt;E&gt; UIForTable&lt;T&gt; withModel( UI.MapData mode, TableMapDataSource&lt;E&gt; dataSource ) {
<span class="fc" id="L699">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L700">                    thisComponent.setModel(new MapBasedColumnMajorTableModel&lt;&gt;(mode.isEditable(), dataSource));</span>
<span class="fc" id="L701">                })</span>
<span class="fc" id="L702">                ._this();</span>
    }

    /**
     *  Use this to bind an {@link sprouts.Event} to the {@link TableModel} of this table
     *  which will trigger the {@link AbstractTableModel#fireTableDataChanged()} method.
     *  This is useful if you want to update the table when the data source changes.
     *
     * @param event The event to be bound.
     * @return This builder node, for chaining.
     */
    public final UIForTable&lt;T&gt; updateTableOn( Event event ) {
<span class="fc" id="L714">        NullUtil.nullArgCheck(event, &quot;event&quot;, Event.class);</span>
<span class="fc" id="L715">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L716">                    Observable.cast(event).subscribe(Observer.ofWeak(thisComponent, innerComponent-&gt;</span>
<span class="fc" id="L717">                        _runInUI(()-&gt;{</span>
<span class="fc" id="L718">                            TableModel model = innerComponent.getModel();</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">                            if ( model instanceof AbstractTableModel ) {</span>
                                // We want the table model update to be as thorough as possible, so we
                                // will fire a table structure changed event, followed by a table data
                                // changed event.
<span class="fc" id="L723">                                ((AbstractTableModel)model).fireTableStructureChanged();</span>
<span class="fc" id="L724">                                ((AbstractTableModel)model).fireTableDataChanged();</span>
                            }
                            else
<span class="nc" id="L727">                                throw new IllegalStateException(&quot;The table model is not an AbstractTableModel instance.&quot;);</span>
<span class="fc" id="L728">                        })</span>
                    ));
<span class="fc" id="L730">                })</span>
<span class="fc" id="L731">                ._this();</span>
    }


    private static abstract class ListBasedTableModel&lt;E&gt; extends AbstractTableModel
    {
        private final TableListDataSource&lt;E&gt; dataSource;
        private final boolean isEditable;

<span class="fc" id="L740">        ListBasedTableModel(boolean isEditable, TableListDataSource&lt;E&gt; dataSource) {</span>
<span class="fc" id="L741">            this.isEditable = isEditable;</span>
<span class="fc" id="L742">            this.dataSource = dataSource;</span>
<span class="fc" id="L743">        }</span>

<span class="nc" id="L745">        @Override public boolean isCellEditable( int rowIndex, int columnIndex ) { return this.isEditable; }</span>

        protected List&lt;List&lt;E&gt;&gt; getData() {
<span class="fc" id="L748">            List&lt;List&lt;E&gt;&gt; data = dataSource.get();</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            if ( data == null ) return new ArrayList&lt;&gt;(); // We really don't want null pointer in UIs.</span>
<span class="fc" id="L750">            return data;</span>
        }
        protected boolean isNotWithinBounds(int rowIndex, int colIndex) {
<span class="pc bpc" id="L753" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= getRowCount()     ) return true;</span>
<span class="pc bpc" id="L754" title="2 of 4 branches missed.">            if ( colIndex &lt; 0 || colIndex &gt;= getColumnCount()  ) return true;</span>
<span class="fc" id="L755">            return false;</span>
        }
    }


    private abstract static class MapBasedTableModel&lt;E&gt; extends AbstractTableModel
    {
        private final TableMapDataSource&lt;E&gt; dataSource;
        private final boolean isEditable;

<span class="fc" id="L765">        MapBasedTableModel(boolean isEditable, TableMapDataSource&lt;E&gt; dataSource) {</span>
<span class="fc" id="L766">            this.isEditable = isEditable;</span>
<span class="fc" id="L767">            this.dataSource = dataSource;</span>
<span class="fc" id="L768">        }</span>

        protected Map&lt;String, List&lt;E&gt;&gt; getData() {
<span class="fc" id="L771">            Map&lt;String, List&lt;E&gt;&gt; data = dataSource.get();</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">            if ( data == null ) return Collections.emptyMap(); // We really don't want null pointer in UIs.</span>
<span class="fc" id="L773">            return data;</span>
        }

        @Override
        public @Nullable String getColumnName(int column) {
<span class="fc" id="L778">            List&lt;String&gt; columnNames = new ArrayList&lt;&gt;(getData().keySet());</span>
<span class="pc bpc" id="L779" title="2 of 4 branches missed.">            if ( column &lt; 0 || column &gt;= columnNames.size() ) return null;</span>
<span class="fc" id="L780">            return columnNames.get(column);</span>
        }

<span class="nc" id="L783">        @Override public boolean isCellEditable( int rowIndex, int columnIndex ) { return this.isEditable; }</span>


        protected boolean isNotWithinBounds(int rowIndex, int colIndex) {
<span class="pc bpc" id="L787" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= getRowCount()     ) return true;</span>
<span class="pc bpc" id="L788" title="2 of 4 branches missed.">            if ( colIndex &lt; 0 || colIndex &gt;= getColumnCount()  ) return true;</span>
<span class="fc" id="L789">            return false;</span>
        }

    }

    private static class MapBasedColumnMajorTableModel&lt;E&gt; extends MapBasedTableModel&lt;E&gt;
    {
        MapBasedColumnMajorTableModel(boolean isEditable, TableMapDataSource&lt;E&gt; dataSource) {
<span class="fc" id="L797">            super(isEditable, dataSource);</span>
<span class="fc" id="L798">        }</span>

        @Override
        public int getRowCount() {
<span class="fc" id="L802">            Map&lt;String, List&lt;E&gt;&gt; data = getData();</span>
<span class="fc" id="L803">            return data.values()</span>
<span class="fc" id="L804">                        .stream()</span>
<span class="fc" id="L805">                        .filter(Objects::nonNull) // Again, we don't want null pointer exceptions in UIs.</span>
<span class="fc" id="L806">                        .mapToInt(List::size)</span>
<span class="fc" id="L807">                        .max()</span>
<span class="fc" id="L808">                        .orElse(0);</span>
        }

        @Override
<span class="fc" id="L812">        public int getColumnCount() { return getData().size(); }</span>

        @Override
        public @Nullable Object getValueAt( int rowIndex, int columnIndex ) {
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">            if ( isNotWithinBounds(rowIndex, columnIndex) )</span>
<span class="nc" id="L817">                return null;</span>
<span class="fc" id="L818">            List&lt;E&gt; column = getData().values().stream().skip(columnIndex).findFirst().orElse(null);</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">            if ( column == null )</span>
<span class="nc" id="L820">                return null;</span>
<span class="pc bpc" id="L821" title="2 of 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= column.size() )</span>
<span class="nc" id="L822">                return null;</span>
<span class="fc" id="L823">            return column.get(rowIndex);</span>
        }

        @Override
        public void setValueAt( Object aValue, int rowIndex, int columnIndex ) {
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if ( isNotWithinBounds(rowIndex, columnIndex) )</span>
<span class="nc" id="L829">                return;</span>
<span class="nc" id="L830">            List&lt;E&gt; column = getData().values().stream().skip(columnIndex).findFirst().orElse(null);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if ( column == null )</span>
<span class="nc" id="L832">                return;</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">            if ( rowIndex &lt; 0 || rowIndex &gt;= column.size() )</span>
<span class="nc" id="L834">                return;</span>
            try {
<span class="nc" id="L836">                column.set(rowIndex, (E) aValue);</span>
<span class="nc" id="L837">            } catch (Exception e) {</span>
<span class="nc" id="L838">                log.warn(&quot;Failed to set value in hash table based table model.&quot;, e);</span>
<span class="nc" id="L839">            }</span>
<span class="nc" id="L840">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>