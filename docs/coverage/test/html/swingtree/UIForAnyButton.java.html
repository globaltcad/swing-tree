<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIForAnyButton.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree</a> &gt; <span class="el_source">UIForAnyButton.java</span></div><h1>UIForAnyButton.java</h1><pre class="source lang-java linenums">package swingtree;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sprouts.Action;
import sprouts.From;
import sprouts.Val;
import sprouts.Var;
import swingtree.api.IconDeclaration;
import swingtree.layout.Size;
import swingtree.style.ScalableImageIcon;
import swingtree.style.SvgIcon;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 *  The following is a more specialized type of builder node based on the {@link UIForAnySwing} builder type,
 *  and provides additional features associated with the more specialized
 *  {@link AbstractButton}&quot; Swing component type.
 *  One of such features is the {@link #onClick(Action)} method allowing for a more readable way of adding
 *  {@link ActionListener} instances to button types...
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/swing-tree/&quot;&gt;living swing-tree documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *  &lt;br&gt;&lt;br&gt;
 *
 * @param &lt;B&gt; The type parameter for the component wrapped by an instance of this class.
 * @param &lt;I&gt; The type parameter for the instance type of this concrete class itself.
 */
<span class="fc" id="L42">public abstract class UIForAnyButton&lt;I, B extends AbstractButton&gt; extends UIForAnySwing&lt;I, B&gt;</span>
{
<span class="fc" id="L44">    private static final Logger log = LoggerFactory.getLogger(UIForAnyButton.class);</span>

    /**
     * Defines the single line of text the wrapped button type will display.
     * If the value of text is null or empty string, nothing is displayed.
     *
     * @param text The new text to be set for the wrapped button type.
     * @return This very builder to allow for method chaining.
     */
    public final I withText( String text ) {
<span class="fc" id="L54">        return _with( thisComponent -&gt; thisComponent.setText(text) )._this();</span>
    }

    /**
     *  Binds the provided {@link Val} property to the wrapped button type
     *  and sets the text of the button to the value of the property.
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to manually
     * send the property value to this view component.&lt;/i&gt;
     * @param text The view model property which should be bound to this UI.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code text} is {@code null}.
     */
    public final I withText( Val&lt;String&gt; text ) {
<span class="fc" id="L67">        NullUtil.nullArgCheck(text, &quot;val&quot;, Val.class);</span>
<span class="fc" id="L68">        NullUtil.nullPropertyCheck(text, &quot;text&quot;);</span>
<span class="fc" id="L69">        return _withOnShow( text, AbstractButton::setText )</span>
<span class="fc" id="L70">               ._with( c -&gt; c.setText(text.orElseThrowUnchecked()) )</span>
<span class="fc" id="L71">               ._this();</span>
    }

    /**
     *  Use this to set the icon for the wrapped button type.
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  Please also see {@link #withIcon(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting icons on buttons!&lt;/b&gt;
     *
     *
     * @param icon The {@link Icon} which should be displayed on the button.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code icon} is {@code null}.
     */
    public I withIcon( Icon icon ) {
<span class="fc" id="L95">        NullUtil.nullArgCheck(icon,&quot;icon&quot;,Icon.class);</span>
<span class="fc" id="L96">        return _with( c -&gt; c.setIcon(_ensureIconIsScalable(icon)) )._this();</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type.
     *  The icon is determined based on the provided {@link IconDeclaration}
     *  instance which is conceptually merely a resource path to the icon.
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Click me!&quot;)
     *     .peek( button -&gt; icon.find().ifPresent(button::setIcon) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *
     * @param icon The desired icon to be displayed on top of the button.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( IconDeclaration icon ) {
<span class="fc" id="L118">        NullUtil.nullArgCheck(icon,&quot;icon&quot;, IconDeclaration.class);</span>
<span class="fc" id="L119">        return _with( c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setIcon) )._this();</span>
    }

    /**
     *  Use this to dynamically set the icon property for the wrapped button type.
     *  When the {@link IconDeclaration} wrapped by the provided property changes,
     *  then so does the icon displayed on this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed on the button.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code icon} is {@code null}.
     */
    public I withIcon( Val&lt;IconDeclaration&gt; icon ) {
<span class="fc" id="L161">        NullUtil.nullArgCheck(icon, &quot;icon&quot;, Val.class);</span>
<span class="fc" id="L162">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L163">        return _withOnShow( icon, UIForAnyButton::_setIconFromDeclaration)</span>
<span class="fc" id="L164">               ._with( c -&gt; _setIconFromDeclaration(c, icon.orElseThrowUnchecked()) )</span>
<span class="fc" id="L165">               ._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type.&lt;br&gt;
     *  Also see {@link #withIcon(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and displayed on the button.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( int width, int height, Icon icon ) {
<span class="fc" id="L182">        NullUtil.nullArgCheck(icon,&quot;icon&quot;,Icon.class);</span>
<span class="fc" id="L183">        icon = _fitTo( width, height, icon );</span>
<span class="fc" id="L184">        return withIcon(icon);</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales it to the provided width and height
     *  before displaying it on the wrapped button type.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and displayed on the button.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( int width, int height, IconDeclaration icon ) {
<span class="fc" id="L205">        NullUtil.nullArgCheck(icon,&quot;icon&quot;,IconDeclaration.class);</span>
<span class="fc" id="L206">        return icon.find()</span>
<span class="fc" id="L207">                   .map( i -&gt; withIcon(width, height, i) )</span>
<span class="fc" id="L208">                   .orElseGet( this::_this );</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link IconDeclaration}, whose referenced icon will be scaled and displayed on the button.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( int width, int height, IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L230">        NullUtil.nullArgCheck(icon,&quot;icon&quot;,IconDeclaration.class);</span>
<span class="fc" id="L231">        return icon.find()</span>
<span class="fc" id="L232">                .map( i -&gt; withIcon(_fitTo(width, height, i), fitComponent) )</span>
<span class="fc" id="L233">                .orElseGet( this::_this );</span>
    }

    /**
     *  Sets the {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is also used as the &quot;pressed&quot; and &quot;disabled&quot; icon if
     *  there is no explicitly set pressed icon.&lt;br&gt;
     *  Please also see {@link #withIcon(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link Icon} which should be displayed on the button.
     *             Ideally, this should be an {@link SvgIcon} to ensure that {@link swingtree.UI.FitComponent}
     *             can be applied properly.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should
     *                     be scaled to fit the component.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( Icon icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L252">        NullUtil.nullArgCheck(icon,&quot;icon&quot;, Icon.class);</span>
<span class="fc" id="L253">        NullUtil.nullArgCheck(fitComponent,&quot;fitComponent&quot;, UI.FitComponent.class);</span>
<span class="fc" id="L254">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L255">                          _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setIcon);</span>
<span class="fc" id="L256">                   })</span>
<span class="fc" id="L257">                   ._this();</span>
    }

    /**
     *  Sets the {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is also used as the &quot;pressed&quot; and &quot;disabled&quot; icon if
     *  no other icon type is explicitly set.
     *  This method will try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The {@link IconDeclaration} which should be displayed on the button.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     */
    public I withIcon( IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L277">        NullUtil.nullArgCheck(icon,&quot;icon&quot;, IconDeclaration.class);</span>
<span class="fc" id="L278">        NullUtil.nullArgCheck(fitComponent,&quot;fitComponent&quot;, UI.FitComponent.class);</span>
<span class="fc" id="L279">        return icon.find()</span>
<span class="fc" id="L280">                   .map( i -&gt; withIcon(i, fitComponent) )</span>
<span class="fc" id="L281">                   .orElseGet( this::_this );</span>
    }

    // - On Press Icon:

    /**
     *  Use this to set the &quot;pressed&quot; icon for the wrapped button type.
     *  This is in essence a convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setPressedIcon(...) );
     *  }&lt;/pre&gt;
     *  Please also see {@link #withIconOnPress(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting icons on buttons!&lt;/b&gt;
     *
     *
     * @param icon The {@link Icon} which should be displayed when the button is pressed.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnPress( Icon icon ) {
<span class="fc" id="L302">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L303">        return _with( c -&gt; c.setPressedIcon(_ensureIconIsScalable(icon)) )._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the user presses the button type.&lt;br&gt;
     *  Also see {@link #withIconOnPress(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is being pressed.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnPress( int width, int height, Icon icon ) {
<span class="fc" id="L321">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L322">        icon = _fitTo( width, height, icon );</span>
<span class="fc" id="L323">        return withIconOnPress(icon);</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type when pressed.
     *  This method will try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and
     *             then displayed when the button is being pressed.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnPress( int width, int height, IconDeclaration icon ) {
<span class="fc" id="L346">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L347">        return icon.find()</span>
<span class="fc" id="L348">                .map( i -&gt; withIconOnPress(width, height, i) )</span>
<span class="fc" id="L349">                .orElseGet( this::_this );</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type
     *  when pressed by the user.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is being pressed.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnPress( int width, int height, IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L367">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L368">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L369">        return icon.find()</span>
<span class="fc" id="L370">                .map( i -&gt; withIconOnPress(_fitTo(width, height, i), fitComponent) )</span>
<span class="fc" id="L371">                .orElseGet( this::_this );</span>
    }

    /**
     *  Sets the pressed {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the user presses the button type.&lt;br&gt;
     *  Please also see {@link #withIconOnPress(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting pressed icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is being pressed.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnPress( Icon icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L387">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L388">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L389">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L390">                        _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setPressedIcon);</span>
<span class="fc" id="L391">                    })</span>
<span class="fc" id="L392">                    ._this();</span>

    }

    /**
     *  Sets the pressed {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed temporarily when the user presses and holds the button.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is being pressed.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnPress( IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L407">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L408">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L409">        return icon.find()</span>
<span class="fc" id="L410">                .map( i -&gt; withIconOnPress(i, fitComponent) )</span>
<span class="fc" id="L411">                .orElseGet( this::_this );</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed temporarily when the user presses the button.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is being pressed.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnPress( IconDeclaration icon ) {
<span class="fc" id="L425">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L426">        return _with( c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setPressedIcon) )._this();</span>
    }

    /**
     *  Use this to dynamically set the &quot;pressed icon&quot; property for the wrapped button type,
     *  which is displayed when the user presses and holds the button.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the pressed icon of this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setPressedIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the pressed icon on the component, this method
     *  will also try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is being pressed.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnPress( Val&lt;IconDeclaration&gt; icon ) {
<span class="fc" id="L472">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L473">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L474">        return _withOnShow( icon, UIForAnyButton::_setIconOnPressFromDeclaration)</span>
<span class="fc" id="L475">                ._with( c -&gt; _setIconOnPressFromDeclaration(c, icon.orElseThrowUnchecked()) )</span>
<span class="fc" id="L476">                ._this();</span>
    }

    // - On Hover Icon:

    /**
     *  Use this to set the &quot;hovered&quot; icon for the wrapped button type,
     *  which translates to {@link AbstractButton#setRolloverIcon(Icon)} of the
     *  underlying button component, but with additional UI scalability guarantees.
     *  In most cases this is a convenience method to avoid peeking into this
     *  builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setRolloverIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the hover/rollover icon on the component,
     *  it will also try to convert it to an icon variant which scales according to
     *  the {@link UI#scale()} factor.
     *  Please also see {@link #withIconOnHover(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting icons on buttons!&lt;/b&gt;
     *
     *
     * @param icon The {@link Icon} which should be displayed when the cursor hovers over the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnHover( Icon icon ) {
<span class="fc" id="L503">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L504">        return _with( c -&gt; c.setRolloverIcon(_ensureIconIsScalable(icon)) )._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the user hovers their cursor over
     *  the button type.&lt;br&gt;
     *  Also see {@link #withIconOnHover(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting hover icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is being hovered over.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHover( int width, int height, Icon icon ) {
<span class="fc" id="L523">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L524">        icon = _fitTo( width, height, icon );</span>
<span class="fc" id="L525">        return withIconOnHover(icon);</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type whenever the user hovers their cursor over the button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Click me!&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.withSize(width,height)
     *                 .find()
     *                 .ifPresent(button::setRolloverIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  In case of the referenced icon being an SVG file, the icon will be loaded as
     *  a fully scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which whose icon should be scaled and
     *             then displayed when the button is being hovered over.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHover( int width, int height, IconDeclaration icon ) {
<span class="fc" id="L558">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L559">        return icon.find()</span>
<span class="fc" id="L560">                .map( i -&gt; withIconOnHover(width, height, i) )</span>
<span class="fc" id="L561">                .orElseGet( this::_this );</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales the corresponding icon it
     *  to the desired width and height after which it uses the {@link swingtree.UI.FitComponent}
     *  layout policy enum constant to display it on the wrapped button type
     *  whenever the user hovers their cursor over the button...&lt;br&gt;
     *  Note that the {@code width} and {@code height} properties only serve as reference values
     *  as the {@link swingtree.UI.FitComponent} is used to resize the icon to fit the component.
     *  &lt;p&gt;
     *  In case of the referenced icon being an SVG file, the icon will be loaded as
     *  a fully scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is being hovered over.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHover( int width, int height, IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L588">        Objects.requireNonNull(icon); </span>
<span class="fc" id="L589">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L590">        return icon.find()</span>
<span class="fc" id="L591">                .map( i -&gt; withIconOnHover(_fitTo(width, height, i), fitComponent) )</span>
<span class="fc" id="L592">                .orElseGet( this::_this );</span>
    }

    /**
     *  Sets the hover {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the user hovers their cursor over the button type.&lt;br&gt;
     *  Please also see {@link #withIconOnHover(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting hover icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is being hovered over.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHover( Icon icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L608">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L609">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L610">        return _with( thisComponent -&gt; {</span>
<span class="fc" id="L611">                    _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setRolloverIcon);</span>
<span class="fc" id="L612">                })</span>
<span class="fc" id="L613">                ._this();</span>

    }

    /**
     *  Sets the hover {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed temporarily when the user hovers their mouse cursor
     *  over the button area.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is being hovered over.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHover( IconDeclaration icon, UI.FitComponent fitComponent ) {
<span class="fc" id="L629">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L630">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L631">        return icon.find()</span>
<span class="fc" id="L632">                .map( i -&gt; withIconOnHover(i, fitComponent) )</span>
<span class="fc" id="L633">                .orElseGet( this::_this );</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed temporarily whenever the user
     *  has their cursor hovering over the button area.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is being hovered over.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHover( IconDeclaration icon ) {
<span class="fc" id="L648">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L649">        return _with( c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setRolloverIcon) )._this();</span>
    }

    /**
     *  Use this to dynamically set the &quot;hovered icon&quot; property for the wrapped button type,
     *  which is displayed when the user hovers their cursor over the button area.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the &quot;hover icon&quot; of this button. Or more specifically,
     *  the {@link AbstractButton#getRolloverIcon()} property of the underlying component.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setRolloverIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the rollover icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should always use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is being hovered over.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnHover( Val&lt;IconDeclaration&gt; icon ) {
<span class="fc" id="L693">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L694">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L695">        return _withOnShow( icon, UIForAnyButton::_setIconOnHoverFromDeclaration)</span>
<span class="fc" id="L696">                ._with( c -&gt; _setIconOnHoverFromDeclaration(c, icon.orElseThrowUnchecked()) )</span>
<span class="fc" id="L697">                ._this();</span>
    }

    // Icon on Hover and Selected
    
    /**
     *  Use this to set the &quot;rollover and selected&quot; icon for the wrapped button type.
     *  This is in essence a convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setRolloverSelectedIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the rollover and selected icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  Please also see {@link #withIconOnHoverAndSelected(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting rollover and selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link Icon} which should be displayed when the button is both rolled over and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnHoverAndSelected(Icon icon) {
<span class="fc" id="L721">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L722">        return _with(c -&gt; c.setRolloverSelectedIcon(_ensureIconIsScalable(icon)))._this();</span>
    }
    
    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the button is both rolled over and selected.&lt;br&gt;
     *  Also see {@link #withIconOnHoverAndSelected(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting rollover and selected icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is both rolled over and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHoverAndSelected(int width, int height, Icon icon) {
<span class="fc" id="L740">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L741">        icon = _fitTo(width, height, icon);</span>
<span class="fc" id="L742">        return withIconOnHoverAndSelected(icon);</span>
    }
    
    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type when both rolled over and selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and
     *             then displayed when the button is both rolled over and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHoverAndSelected(int width, int height, IconDeclaration icon) {
<span class="fc" id="L765">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L766">        return icon.find()</span>
<span class="fc" id="L767">                .map(i -&gt; withIconOnHoverAndSelected(width, height, i))</span>
<span class="fc" id="L768">                .orElseGet(this::_this);</span>
    }
    
    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type
     *  when both rolled over and selected by the user.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is both rolled over and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHoverAndSelected(int width, int height, IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L792">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L793">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L794">        return icon.find()</span>
<span class="fc" id="L795">                .map(i -&gt; withIconOnHoverAndSelected(_fitTo(width, height, i), fitComponent))</span>
<span class="fc" id="L796">                .orElseGet(this::_this);</span>
    }
    
    /**
     *  Sets the rollover and selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is both rolled over and selected.&lt;br&gt;
     *  Please also see {@link #withIconOnHoverAndSelected(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting rollover and selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is both rolled over and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHoverAndSelected(Icon icon, UI.FitComponent fitComponent) {
<span class="fc" id="L812">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L813">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L814">        return _with(thisComponent -&gt; {</span>
<span class="fc" id="L815">            _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setRolloverSelectedIcon);</span>
<span class="fc" id="L816">        })</span>
<span class="fc" id="L817">                ._this();</span>
    }
    
    /**
     *  Sets the rollover and selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is both rolled over and selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is both rolled over and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnHoverAndSelected(IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L837">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L838">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L839">        return icon.find()</span>
<span class="fc" id="L840">                .map(i -&gt; withIconOnHoverAndSelected(i, fitComponent))</span>
<span class="fc" id="L841">                .orElseGet(this::_this);</span>
    }
    
    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed when the button is both rolled over and selected.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is both rolled over and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnHoverAndSelected(IconDeclaration icon) {
<span class="fc" id="L861">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L862">        return _with(c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setRolloverSelectedIcon))._this();</span>
    }
    
    /**
     *  Use this to dynamically set the &quot;rollover and selected icon&quot; property for the wrapped button type,
     *  which is displayed when the button is both rolled over and selected.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the rollover and selected icon of this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setRolloverSelectedIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the rollover and selected icon on the component, this method
     *  will also try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is both rolled over and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnHoverAndSelected(Val&lt;IconDeclaration&gt; icon) {
<span class="fc" id="L908">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L909">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L910">        return _withOnShow(icon, UIForAnyButton::_setIconOnHoverAndSelectedFromDeclaration)</span>
<span class="fc" id="L911">                ._with(c -&gt; _setIconOnHoverAndSelectedFromDeclaration(c, icon.orElseThrowUnchecked()))</span>
<span class="fc" id="L912">                ._this();</span>
    }

    // Icon on Selected:

    /**
     *  Use this to set the &quot;selected&quot; icon for the wrapped button type.
     *  This is in essence a convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setSelectedIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the selected icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  Please also see {@link #withIconOnSelected(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link Icon} which should be displayed when the button is selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnSelected(Icon icon) {
<span class="fc" id="L936">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L937">        return _with(c -&gt; c.setSelectedIcon(_ensureIconIsScalable(icon)))._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the button is selected.&lt;br&gt;
     *  Also see {@link #withIconOnSelected(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting selected icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnSelected(int width, int height, Icon icon) {
<span class="fc" id="L955">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L956">        icon = _fitTo(width, height, icon);</span>
<span class="fc" id="L957">        return withIconOnSelected(icon);</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type when selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and
     *             then displayed when the button is selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnSelected(int width, int height, IconDeclaration icon) {
<span class="fc" id="L980">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L981">        return icon.find()</span>
<span class="fc" id="L982">                .map(i -&gt; withIconOnSelected(width, height, i))</span>
<span class="fc" id="L983">                .orElseGet(this::_this);</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type
     *  when selected by the user.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnSelected(int width, int height, IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1007">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1008">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1009">        return icon.find()</span>
<span class="fc" id="L1010">                .map(i -&gt; withIconOnSelected(_fitTo(width, height, i), fitComponent))</span>
<span class="fc" id="L1011">                .orElseGet(this::_this);</span>
    }

    /**
     *  Sets the selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is selected.&lt;br&gt;
     *  Please also see {@link #withIconOnSelected(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnSelected(Icon icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1027">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1028">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1029">        return _with(thisComponent -&gt; {</span>
<span class="fc" id="L1030">            _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setSelectedIcon);</span>
<span class="fc" id="L1031">        })</span>
<span class="fc" id="L1032">                ._this();</span>
    }

    /**
     *  Sets the selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnSelected(IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1052">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1053">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1054">        return icon.find()</span>
<span class="fc" id="L1055">                .map(i -&gt; withIconOnSelected(i, fitComponent))</span>
<span class="fc" id="L1056">                .orElseGet(this::_this);</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed when the button is selected.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnSelected(IconDeclaration icon) {
<span class="fc" id="L1076">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1077">        return _with(c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setSelectedIcon))._this();</span>
    }

    /**
     *  Use this to dynamically set the &quot;selected icon&quot; property for the wrapped button type,
     *  which is displayed when the button is selected.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the selected icon of this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setSelectedIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the selected icon on the component, this method
     *  will also try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnSelected(Val&lt;IconDeclaration&gt; icon) {
<span class="fc" id="L1123">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1124">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L1125">        return _withOnShow(icon, UIForAnyButton::_setIconOnSelectedFromDeclaration)</span>
<span class="fc" id="L1126">                ._with(c -&gt; _setIconOnSelectedFromDeclaration(c, icon.orElseThrowUnchecked()))</span>
<span class="fc" id="L1127">                ._this();</span>
    }

    // Icon on Disabled:

        /**
     *  Use this to set the &quot;disabled&quot; icon for the wrapped button type.
     *  This is in essence a convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setDisabledIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the disabled icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  Please also see {@link #withIconOnDisabled(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting disabled icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link Icon} which should be displayed when the button is disabled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnDisabled(Icon icon) {
<span class="fc" id="L1151">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1152">        return _with(c -&gt; c.setDisabledIcon(_ensureIconIsScalable(icon)))._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the button is disabled.&lt;br&gt;
     *  Also see {@link #withIconOnDisabled(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting disabled icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is disabled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabled(int width, int height, Icon icon) {
<span class="fc" id="L1170">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1171">        icon = _fitTo(width, height, icon);</span>
<span class="fc" id="L1172">        return withIconOnDisabled(icon);</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type when disabled.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and
     *             then displayed when the button is disabled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabled(int width, int height, IconDeclaration icon) {
<span class="fc" id="L1195">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1196">        return icon.find()</span>
<span class="fc" id="L1197">                .map(i -&gt; withIconOnDisabled(width, height, i))</span>
<span class="fc" id="L1198">                .orElseGet(this::_this);</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type
     *  when disabled by the user.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is disabled.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabled(int width, int height, IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1222">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1223">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1224">        return icon.find()</span>
<span class="fc" id="L1225">                .map(i -&gt; withIconOnDisabled(_fitTo(width, height, i), fitComponent))</span>
<span class="fc" id="L1226">                .orElseGet(this::_this);</span>
    }

    /**
     *  Sets the disabled {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is disabled.&lt;br&gt;
     *  Please also see {@link #withIconOnDisabled(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting disabled icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is disabled.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabled(Icon icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1242">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1243">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1244">        return _with(thisComponent -&gt; {</span>
<span class="fc" id="L1245">                    _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setDisabledIcon);</span>
<span class="fc" id="L1246">                })</span>
<span class="fc" id="L1247">                ._this();</span>
    }

    /**
     *  Sets the disabled {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is disabled.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is disabled.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabled(IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1267">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1268">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1269">        return icon.find()</span>
<span class="fc" id="L1270">                .map(i -&gt; withIconOnDisabled(i, fitComponent))</span>
<span class="fc" id="L1271">                .orElseGet(this::_this);</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed when the button is disabled.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is disabled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabled(IconDeclaration icon) {
<span class="fc" id="L1291">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1292">        return _with(c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setDisabledIcon))._this();</span>
    }

    /**
     *  Use this to dynamically set the &quot;disabled icon&quot; property for the wrapped button type,
     *  which is displayed when the button is disabled.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the disabled icon of this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setDisabledIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the disabled icon on the component, this method
     *  will also try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is disabled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnDisabled(Val&lt;IconDeclaration&gt; icon) {
<span class="fc" id="L1338">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1339">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L1340">        return _withOnShow(icon, UIForAnyButton::_setIconOnDisabledFromDeclaration)</span>
<span class="fc" id="L1341">                ._with(c -&gt; _setIconOnDisabledFromDeclaration(c, icon.orElseThrowUnchecked()))</span>
<span class="fc" id="L1342">                ._this();</span>
    }

    // Icon on disabled AND selected

    /**
     *  Use this to set the &quot;disabled and selected&quot; icon for the wrapped button type.
     *  This is in essence a convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; button.setDisabledSelectedIcon(...) );
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the disabled and selected icon on the component, this method
     *  will also try to convert the icon to an icon variant which scales according to
     *  the current {@link UI#scale()} factor (see {@link ScalableImageIcon}) so
     *  that the icon is upscaled proportionally in high-dpi environments.
     *  Please also see {@link #withIconOnDisabledAndSelected(IconDeclaration)}, which is
     *  &lt;b&gt;the recommended way of setting disabled and selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link Icon} which should be displayed when the button is both disabled and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnDisabledAndSelected(Icon icon) {
<span class="fc" id="L1366">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1367">        return _with(c -&gt; c.setDisabledSelectedIcon(_ensureIconIsScalable(icon)))._this();</span>
    }

    /**
     *  Takes the provided {@link Icon} and scales it to the provided width and height
     *  before displaying it on the wrapped button type when the button is both disabled and selected.&lt;br&gt;
     *  Also see {@link #withIconOnDisabledAndSelected(int, int, IconDeclaration)}, which is
     *  &lt;b&gt;the preferred way of setting disabled and selected icons on buttons!&lt;/b&gt;
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is both disabled and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabledAndSelected(int width, int height, Icon icon) {
<span class="fc" id="L1385">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1386">        icon = _fitTo(width, height, icon);</span>
<span class="fc" id="L1387">        return withIconOnDisabledAndSelected(icon);</span>
    }

    /**
     *  Takes the supplied {@link IconDeclaration} and scales it to the desired width and height
     *  before displaying it on the wrapped button type when both disabled and selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()}.
     * @param icon The {@link IconDeclaration} which should be scaled and
     *             then displayed when the button is both disabled and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabledAndSelected(int width, int height, IconDeclaration icon) {
<span class="fc" id="L1410">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1411">        return icon.find()</span>
<span class="fc" id="L1412">                .map(i -&gt; withIconOnDisabledAndSelected(width, height, i))</span>
<span class="fc" id="L1413">                .orElseGet(this::_this);</span>
    }

    /**
     *  Takes the provided {@link IconDeclaration} and scales the corresponding icon it
     *  to the provided width and height before displaying it on the wrapped button type
     *  when both disabled and selected by the user.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param width The desired width of the icon in &quot;developer pixels&quot;,
     *              the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param height The desired height of the icon in &quot;developer pixels&quot;,
     *               the actual width may be influenced by {@link UI#scale()} and {@link UI.FitComponent}.
     * @param icon The {@link Icon} which should be scaled and then displayed when the button is both disabled and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled relative to the button.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabledAndSelected(int width, int height, IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1437">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1438">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1439">        return icon.find()</span>
<span class="fc" id="L1440">                .map(i -&gt; withIconOnDisabledAndSelected(_fitTo(width, height, i), fitComponent))</span>
<span class="fc" id="L1441">                .orElseGet(this::_this);</span>
    }

    /**
     *  Sets the disabled and selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is both disabled and selected.&lt;br&gt;
     *  Please also see {@link #withIconOnDisabledAndSelected(IconDeclaration, UI.FitComponent)}, which is
     *  &lt;b&gt;the recommended way of setting disabled and selected icons on buttons!&lt;/b&gt;
     *
     * @param icon The {@link SvgIcon} which should be displayed when the button is both disabled and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabledAndSelected(Icon icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1457">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1458">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1459">        return _with(thisComponent -&gt; {</span>
<span class="fc" id="L1460">                    _installAutomaticIconApplier(thisComponent, icon, fitComponent, AbstractButton::setDisabledSelectedIcon);</span>
<span class="fc" id="L1461">                })</span>
<span class="fc" id="L1462">                ._this();</span>
    }

    /**
     *  Sets the disabled and selected {@link Icon} property of the wrapped button type and scales it
     *  according to the provided {@link UI.FitComponent} policy.
     *  This icon is only displayed when the button is both disabled and selected.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The {@link IconDeclaration} which should be displayed when the button is both disabled and selected.
     * @param fitComponent The {@link UI.FitComponent} which determines how the icon should be scaled.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if any of the supplied arguments are {@code null}!
     */
    public I withIconOnDisabledAndSelected(IconDeclaration icon, UI.FitComponent fitComponent) {
<span class="fc" id="L1482">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1483">        Objects.requireNonNull(fitComponent);</span>
<span class="fc" id="L1484">        return icon.find()</span>
<span class="fc" id="L1485">                .map(i -&gt; withIconOnDisabledAndSelected(i, fitComponent))</span>
<span class="fc" id="L1486">                .orElseGet(this::_this);</span>
    }

    /**
     *  Use this to specify the icon for the wrapped button type,
     *  which ought to be displayed when the button is both disabled and selected.
     *  The icon is resolved based on the supplied {@link IconDeclaration}
     *  instance which serves as a resource path to the icon actual.&lt;br&gt;
     *  This method will try to load and install the icon as a scalable {@link ImageIcon},
     *  which means that in case of the referenced icon being an SVG file, the icon will be
     *  loaded as a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *
     * @param icon The desired icon to be displayed on top of the button for when it is both disabled and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}!
     */
    public I withIconOnDisabledAndSelected(IconDeclaration icon) {
<span class="fc" id="L1506">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1507">        return _with(c -&gt; icon.find().map(UIForAnyButton::_ensureIconIsScalable).ifPresent(c::setDisabledSelectedIcon))._this();</span>
    }

    /**
     *  Use this to dynamically set the &quot;disabled and selected icon&quot; property for the wrapped button type,
     *  which is displayed when the button is both disabled and selected.
     *  When the icon wrapped by the supplied {@link Val} property changes,
     *  then so does the disabled and selected icon of this button.&lt;br&gt;
     *  &lt;p&gt;
     *  For most scenarios, this is a convenience method equivalent to
     *  peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Something&quot;)
     *     .peek( button -&gt; iconProperty.onChange(From.ALL,
     *          icon -&gt; icon.find().ifPresent(button::setDisabledSelectedIcon)
     *     ));
     *  }&lt;/pre&gt;
     *  But in addition to simply setting the disabled and selected icon on the component, this method
     *  will also try to load and install the icon as a scalable {@link ImageIcon}, which means that
     *  in case of the referenced icon being an SVG file, the icon will be loaded as
     *  a smoothly scalable {@link SvgIcon}, if it is a png or jpeg file however,
     *  then this method will represent it as a {@link ScalableImageIcon}, which
     *  dynamically scales the underlying image according to the {@link UI#scale()}
     *  so that it has a proportionally correct size in high-dpi environments.
     *  &lt;p&gt;
     *  But note that here you cannot use the {@link Icon} or {@link ImageIcon} classes directly,
     *  instead &lt;b&gt;you must use implementations of the {@link IconDeclaration} interface&lt;/b&gt;,
     *  which merely models the resource location of the icon, but does not load
     *  the whole icon itself.
     *  &lt;p&gt;
     *  The reason for this distinction is the fact that traditional Swing icons
     *  are heavy objects whose loading may or may not succeed, and so they are
     *  not suitable for direct use in a property as part of your view model.
     *  Instead, you should use the {@link IconDeclaration} interface, which is a
     *  lightweight value object that merely models the resource location of the icon
     *  even if it is not yet loaded or even does not exist at all.
     *  &lt;p&gt;
     *  This is especially useful when writing unit tests for your view model,
     *  where the icon may not be available at all, but you still want to test
     *  the behaviour of your view model.
     *
     * @param icon The {@link Icon} property which should be displayed when the button is both disabled and selected.
     * @return This very builder to allow for method chaining.
     * @throws NullPointerException if {@code icon} is {@code null}.
     */
    public I withIconOnDisabledAndSelected(Val&lt;IconDeclaration&gt; icon) {
<span class="fc" id="L1553">        Objects.requireNonNull(icon);</span>
<span class="fc" id="L1554">        NullUtil.nullPropertyCheck(icon, &quot;icon&quot;);</span>
<span class="fc" id="L1555">        return _withOnShow(icon, UIForAnyButton::_setIconOnDisabledAndSelectedFromDeclaration)</span>
<span class="fc" id="L1556">                ._with(c -&gt; _setIconOnDisabledAndSelectedFromDeclaration(c, icon.orElseThrowUnchecked()))</span>
<span class="fc" id="L1557">                ._this();</span>
    }



    private static void _installAutomaticIconApplier(
        AbstractButton thisComponent,
        Icon icon,
        UI.FitComponent fitComponent,
        BiConsumer&lt;AbstractButton, Icon&gt; iconApplier
    ) {
<span class="fc bfc" id="L1568" title="All 2 branches covered.">        if ( icon instanceof SvgIcon) {</span>
<span class="fc" id="L1569">            SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="fc" id="L1570">            iconApplier.accept(thisComponent, svgIcon.withFitComponent(fitComponent));</span>
<span class="fc" id="L1571">            return; // An SvgIcon already scales dynamically!</span>
        }
<span class="fc" id="L1573">        Runnable dynamicSizer = _createDynamicIconApplier(thisComponent, icon, fitComponent, iconApplier);</span>
<span class="fc" id="L1574">        dynamicSizer.run(); // Initial sizing</span>
<span class="fc" id="L1575">        UI.runLater(dynamicSizer); // Run later to ensure correct sizing after layout</span>
        // TODO: make ScalableImageIcon use FitComponent to automatically resize itself
<span class="fc" id="L1577">    }</span>

    private static Runnable _createDynamicIconApplier(
        AbstractButton thisComponent,
        Icon icon,
        UI.FitComponent fitComponent,
        BiConsumer&lt;AbstractButton, Icon&gt; iconApplier
    ) {
<span class="fc" id="L1585">        AtomicReference&lt;Size&gt; lastSize = new AtomicReference&lt;&gt;(Size.of(-1,-1));</span>
<span class="fc" id="L1586">        return ()-&gt;{</span>
<span class="fc" id="L1587">            Size size = _determineIconSize(thisComponent, icon, fitComponent);</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">            if ( !Objects.equals(size,lastSize.get()) ) {</span>
<span class="fc" id="L1589">                lastSize.set(size);</span>
<span class="fc" id="L1590">                int width = size.width().map(Number::intValue).orElse(-1);</span>
<span class="fc" id="L1591">                int height = size.height().map(Number::intValue).orElse(-1);</span>
<span class="pc bpc" id="L1592" title="1 of 4 branches missed.">                if ( width &gt; 0 &amp;&amp; height &gt; 0 )</span>
<span class="fc" id="L1593">                    iconApplier.accept(thisComponent, _fitTo( size, icon ));</span>
            }
<span class="fc" id="L1595">        };</span>
    }

    private static Size _determineIconSize(JComponent thisComponent, Icon icon, UI.FitComponent fitComponent) {
        float width ;
        float height;
<span class="fc" id="L1601">        Insets insets = thisComponent.getInsets();</span>
<span class="fc" id="L1602">        float fittedWidth = Math.max(thisComponent.getWidth(),  thisComponent.getMinimumSize().width);</span>
<span class="fc" id="L1603">        float fittedHeight = Math.max(thisComponent.getHeight(), thisComponent.getMinimumSize().height);</span>
<span class="fc" id="L1604">        fittedWidth  = Math.max(0, UI.unscale((float) fittedWidth - insets.left - insets.right)); // We unscale because the icon will be scaled internally</span>
<span class="fc" id="L1605">        fittedHeight = Math.max(0, UI.unscale((float) fittedHeight - insets.top  - insets.bottom));</span>
<span class="fc" id="L1606">        int iconWidth  = icon.getIconWidth();</span>
<span class="fc" id="L1607">        int iconHeight = icon.getIconHeight();</span>
        // We need to determine and return a base size to be scaled later on...
        // But some icon types already do the scaling internally, so we need to check for that:
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        if ( icon instanceof ScalableImageIcon ) {</span>
<span class="fc" id="L1611">            ScalableImageIcon scalableIcon = (ScalableImageIcon) icon;</span>
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">            if ( scalableIcon.getBaseWidth() &gt; 0 )</span>
<span class="fc" id="L1613">                iconWidth = scalableIcon.getBaseWidth();</span>
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">            if ( scalableIcon.getBaseHeight() &gt; 0 )</span>
<span class="fc" id="L1615">                iconHeight = scalableIcon.getBaseHeight();</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">        } else if ( icon instanceof SvgIcon ) {</span>
<span class="nc" id="L1617">            SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            if ( svgIcon.getBaseWidth() &gt; 0 )</span>
<span class="nc" id="L1619">                iconWidth = svgIcon.getBaseWidth();</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">            if ( svgIcon.getBaseHeight() &gt; 0 )</span>
<span class="nc" id="L1621">                iconHeight = svgIcon.getBaseHeight();</span>
        }
<span class="fc bfc" id="L1623" title="All 2 branches covered.">        if ( fitComponent == UI.FitComponent.NO ) {</span>
<span class="fc" id="L1624">            width  = iconWidth;</span>
<span class="fc" id="L1625">            height = iconHeight;</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">        } else if ( fitComponent == UI.FitComponent.WIDTH_AND_HEIGHT) {</span>
<span class="fc" id="L1627">            width  = fittedWidth;</span>
<span class="fc" id="L1628">            height = fittedHeight;</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">        } else if ( fitComponent == UI.FitComponent.WIDTH ) {</span>
<span class="fc" id="L1630">            width  = fittedWidth;</span>
<span class="fc" id="L1631">            height = iconHeight;</span>
<span class="fc bfc" id="L1632" title="All 2 branches covered.">        } else if ( fitComponent == UI.FitComponent.HEIGHT ) {</span>
<span class="fc" id="L1633">            width = iconWidth;</span>
<span class="fc" id="L1634">            height = fittedHeight;</span>
<span class="fc bfc" id="L1635" title="All 2 branches covered.">        } else if ( fitComponent == UI.FitComponent.MAX_DIM ) {</span>
<span class="fc" id="L1636">            width  = Math.max(fittedWidth, fittedHeight);</span>
<span class="fc" id="L1637">            height = Math.max(fittedWidth, fittedHeight);</span>
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">        } else if ( fitComponent == UI.FitComponent.MIN_DIM ) {</span>
<span class="fc" id="L1639">            width  = Math.min(fittedWidth, fittedHeight);</span>
<span class="fc" id="L1640">            height = Math.min(fittedWidth, fittedHeight);</span>
        } else {
<span class="nc" id="L1642">            log.error(&quot;Unknown 'UI.FitComponent' value: '{}'. Using 'NO' instead.&quot;, fitComponent);</span>
<span class="nc" id="L1643">            width  = icon.getIconWidth();</span>
<span class="nc" id="L1644">            height = icon.getIconHeight();</span>
        }
<span class="fc" id="L1646">        return Size.of(width, height);</span>
    }

    private static Icon _fitTo(int width, int height, Icon icon) {
<span class="fc" id="L1650">        return _fitTo(Size.of(width, height), icon);</span>
    }

    private static Icon _fitTo(Size size, Icon icon) {
<span class="fc" id="L1654">        float width = size.width().orElse(0f);</span>
<span class="fc" id="L1655">        float height = size.height().orElse(0f);</span>
<span class="fc bfc" id="L1656" title="All 2 branches covered.">        if ( icon instanceof SvgIcon ) {</span>
<span class="fc" id="L1657">            SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="fc" id="L1658">            svgIcon = svgIcon.withIconWidth((int) width);</span>
<span class="fc" id="L1659">            return svgIcon.withIconHeight((int) height);</span>
        }
<span class="fc bfc" id="L1661" title="All 2 branches covered.">        else if ( icon instanceof ScalableImageIcon ) {</span>
<span class="fc" id="L1662">            return ((ScalableImageIcon)icon).withSize(Size.of(width, height));</span>
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">        } else if ( icon instanceof ImageIcon ) {</span>
<span class="fc" id="L1664">            return ScalableImageIcon.of(Size.of(width, height), (ImageIcon) icon);</span>
        }
<span class="nc" id="L1666">        return icon;</span>
    }

    private static Icon _ensureIconIsScalable(Icon icon) {
<span class="fc bfc" id="L1670" title="All 2 branches covered.">        if ( icon instanceof ScalableImageIcon ) {</span>
<span class="fc" id="L1671">            return icon; // Already scalable</span>
        }
<span class="fc bfc" id="L1673" title="All 2 branches covered.">        if ( icon instanceof SvgIcon ) {</span>
<span class="fc" id="L1674">            return icon; // Already scalable</span>
        }
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">        if ( icon instanceof ImageIcon ) {</span>
<span class="fc" id="L1677">            return ScalableImageIcon.of(Size.of(icon.getIconWidth(), icon.getIconHeight()), (ImageIcon) icon);</span>
        }
<span class="nc" id="L1679">        return icon; // Not yet supported</span>
    }

    private static void _setIconFromDeclaration( AbstractButton button, IconDeclaration icon ) {
<span class="fc" id="L1683">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setIcon);</span>
<span class="fc" id="L1684">    }</span>

    private static void _setIconOnPressFromDeclaration( AbstractButton button, IconDeclaration icon ) {
<span class="fc" id="L1687">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setPressedIcon);</span>
<span class="fc" id="L1688">    }</span>

    private static void _setIconOnHoverFromDeclaration( AbstractButton button, IconDeclaration icon ) {
<span class="fc" id="L1691">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setRolloverIcon);</span>
<span class="fc" id="L1692">    }</span>

    private static void _setIconOnHoverAndSelectedFromDeclaration(AbstractButton button, IconDeclaration icon) {
<span class="fc" id="L1695">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setRolloverSelectedIcon);</span>
<span class="fc" id="L1696">    }</span>

    private static void _setIconOnSelectedFromDeclaration(AbstractButton button, IconDeclaration icon) {
<span class="fc" id="L1699">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setSelectedIcon);</span>
<span class="fc" id="L1700">    }</span>

    private static void _setIconOnDisabledFromDeclaration(AbstractButton button, IconDeclaration icon) {
<span class="fc" id="L1703">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setDisabledIcon);</span>
<span class="fc" id="L1704">    }</span>

    private static void _setIconOnDisabledAndSelectedFromDeclaration(AbstractButton button, IconDeclaration icon) {
<span class="fc" id="L1707">        _setAnyIconFromDeclaration(button, icon, AbstractButton::setDisabledSelectedIcon);</span>
<span class="fc" id="L1708">    }</span>


    private static void _setAnyIconFromDeclaration(
        AbstractButton button,
        IconDeclaration icon,
        BiConsumer&lt;AbstractButton, @Nullable Icon&gt; iconSetter
    ) {
<span class="fc" id="L1716">        Optional&lt;ImageIcon&gt; optIcon = icon.find();</span>
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">        if ( optIcon.isPresent() )</span>
<span class="fc" id="L1718">            iconSetter.accept(button, optIcon.get());</span>
        else {
<span class="nc" id="L1720">            log.warn(</span>
                    &quot;Failed to load from 'IconDeclaration' instance '{}', &quot; +
                            &quot;with path '{}' and size '{}', and set it as the icon of 'AbstractButton' '{}'.&quot;,
<span class="nc" id="L1723">                    icon, icon.path(), icon.size(), button,</span>
                    new Throwable(&quot;Stack trace for debugging purposes.&quot;)
            );
<span class="nc" id="L1726">            iconSetter.accept(button, null);</span>
        }
<span class="fc" id="L1728">    }</span>

    /**
     *  Use this to set the size of the font of the wrapped button type.
     * @param size The size of the font which should be displayed on the button.
     * @return This very builder to allow for method chaining.
     */
    public I withFontSize( int size ) {
<span class="fc" id="L1736">        return _with( button -&gt; {</span>
<span class="fc" id="L1737">                   Font old = button.getFont();</span>
<span class="fc" id="L1738">                   button.setFont(old.deriveFont(UI.scale((float)size)));</span>
<span class="fc" id="L1739">               })</span>
<span class="fc" id="L1740">               ._this();</span>
    }

    /**
     *  Use this to dynamically set the size of the font of the wrapped button type
     *  through the provided view model property.
     *  When the integer wrapped by the provided property changes,
     *  then so does the font size of the text displayed on this button.
     *
     * @param size The size property of the font which should be displayed on the button.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code size} is {@code null}.
     */
    public I withFontSize( Val&lt;Integer&gt; size ) {
<span class="nc" id="L1754">        NullUtil.nullArgCheck(size, &quot;val&quot;, Val.class);</span>
<span class="nc" id="L1755">        NullUtil.nullPropertyCheck(size, &quot;size&quot;, &quot;Null is not a sensible value for a font size.&quot;);</span>
<span class="nc" id="L1756">        return _withOnShow( size, (c,v)-&gt;{</span>
<span class="nc" id="L1757">                    c.setFont(c.getFont().deriveFont(UI.scale((float)v)));</span>
<span class="nc" id="L1758">                })</span>
<span class="nc" id="L1759">                ._with( c -&gt; {</span>
<span class="nc" id="L1760">                    c.setFont(c.getFont().deriveFont(UI.scale((float)size.orElseThrowUnchecked())));</span>
<span class="nc" id="L1761">                })</span>
<span class="nc" id="L1762">                ._this();</span>
    }

    /**
     *  Use this to set the font of the wrapped button type.
     * @param font The font of the text which should be displayed on the button.
     * @return This builder instance, to allow for method chaining.
     * @throws IllegalArgumentException if {@code font} is {@code null}.
     */
    public final I withFont( Font font ) {
<span class="nc" id="L1772">        NullUtil.nullArgCheck(font, &quot;font&quot;, Font.class);</span>
<span class="nc" id="L1773">        return _with( button -&gt; {</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">                        if ( _isUndefinedFont(font) )</span>
<span class="nc" id="L1775">                            button.setFont(null);</span>
                        else
<span class="nc" id="L1777">                            button.setFont(font);</span>
<span class="nc" id="L1778">                    })._this();</span>
    }

    /**
     *  Use this to dynamically set the font of the wrapped button type
     *  through the provided view model property.
     *  When the font wrapped by the provided property changes,
     *  then so does the font of the text displayed on this button.
     *
     * @param font The font property of the text which should be displayed on the button type.
     * @return This builder instance, to allow for method chaining.
     * @throws IllegalArgumentException if {@code font} is {@code null}.
     * @throws IllegalArgumentException if {@code font} is a property which can wrap {@code null}.
     */
    public final I withFont( Val&lt;Font&gt; font ) {
<span class="nc" id="L1793">        NullUtil.nullArgCheck(font, &quot;font&quot;, Val.class);</span>
<span class="nc" id="L1794">        NullUtil.nullPropertyCheck(font, &quot;font&quot;, &quot;Use the default font of this component instead of null!&quot;);</span>
<span class="nc" id="L1795">        return _withOnShow( font, (c,v) -&gt; {</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                    if ( _isUndefinedFont(v) )</span>
<span class="nc" id="L1797">                        c.setFont(null);</span>
                    else
<span class="nc" id="L1799">                        c.setFont(v);</span>
<span class="nc" id="L1800">                })</span>
<span class="nc" id="L1801">               ._with( thisComponent -&gt; {</span>
<span class="nc" id="L1802">                   Font newFont = font.orElseThrowUnchecked();</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">                   if ( _isUndefinedFont(newFont) )</span>
<span class="nc" id="L1804">                       thisComponent.setFont( null );</span>
                   else
<span class="nc" id="L1806">                       thisComponent.setFont( newFont );</span>
<span class="nc" id="L1807">               } )</span>
<span class="nc" id="L1808">               ._this();</span>
    }

    /**
     *  Use this to set the selection state of the wrapped button type.
     *
     * @param isSelected The selection state of the wrapped button type, which translates to {@link AbstractButton#setSelected(boolean)}.
     * @return This builder instance, to allow for method chaining.
     */
    public final I isSelectedIf( boolean isSelected ) {
<span class="fc" id="L1818">        return _with( button -&gt; _setSelectedSilently(button, isSelected) )._this();</span>
    }

    void _setSelectedSilently( B thisButton, boolean isSelected ) {
        /*
            This is used to change the selection state of the button without triggering
            any action listeners. We need this because we want to construct the
            GUI and the state of its properties without side effects.
         */
<span class="fc" id="L1827">        ItemListener[] listeners = thisButton.getItemListeners();</span>
<span class="fc bfc" id="L1828" title="All 2 branches covered.">        for ( ItemListener l : listeners )</span>
<span class="fc" id="L1829">            thisButton.removeItemListener(l);</span>

<span class="fc" id="L1831">        thisButton.setSelected(isSelected);</span>

<span class="fc bfc" id="L1833" title="All 2 branches covered.">        for ( ItemListener l : listeners )</span>
<span class="fc" id="L1834">            thisButton.addItemListener(l);</span>

<span class="fc" id="L1836">    }</span>

    /**
     *  Use this to bind to a {@link sprouts.Var}
     *  instance which will be used to dynamically model the selection state of the
     *  wrapped {@link AbstractButton} type.
     *
     * @param selected The {@link sprouts.Var} instance which will be used to model the selection state of the wrapped button type.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public final I isSelectedIf( Val&lt;Boolean&gt; selected ) {
<span class="nc" id="L1848">        NullUtil.nullArgCheck(selected, &quot;selected&quot;, Val.class);</span>
<span class="nc" id="L1849">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;Null can not be used to model the selection state of a button type.&quot;);</span>
<span class="nc" id="L1850">        return _withOnShow(selected, this::_setSelectedSilently)</span>
<span class="nc" id="L1851">               ._with( button -&gt; _setSelectedSilently(button, selected.get()) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Var}
     *  instance which will be used to dynamically model the inverse selection state of the
     *  wrapped {@link AbstractButton} type.
     *
     * @param selected The {@link sprouts.Var} instance which will be used to
     *                 model the inverse selection state of the wrapped button type.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public final I isSelectedIfNot( Val&lt;Boolean&gt; selected ) {
<span class="nc" id="L1865">        NullUtil.nullArgCheck(selected, &quot;selected&quot;, Val.class);</span>
<span class="nc" id="L1866">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;Null can not be used to model the selection state of a button type.&quot;);</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        return _withOnShow( selected, (c, v) -&gt; _setSelectedSilently(c, !v) )</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">               ._with( button -&gt; _setSelectedSilently(button, !selected.is(true)) )._this();</span>
    }

    /**
     *  Use this to bind to a {@link sprouts.Var}
     *  instance which will be used to dynamically model the selection state of the
     *  wrapped {@link AbstractButton} type.
     *
     * @param selected The {@link sprouts.Var} instance which will be used to model the selection state of the wrapped button type.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public final I isSelectedIf( Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L1881">        NullUtil.nullArgCheck(selected, &quot;selected&quot;, Var.class);</span>
<span class="fc" id="L1882">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;Null can not be used to model the selection state of a button type.&quot;);</span>
<span class="fc" id="L1883">        return _withOnShow( selected, this::_setSelectedSilently )</span>
<span class="fc" id="L1884">                ._with( button -&gt; {</span>
<span class="fc" id="L1885">                    _onClick(button,</span>
<span class="fc" id="L1886">                        e -&gt; _runInApp(button.isSelected(), newItem -&gt; selected.set(From.VIEW, newItem) )</span>
                    );
<span class="fc" id="L1888">                    _onChange(button,</span>
<span class="fc" id="L1889">                        v -&gt; _runInApp(button.isSelected(), newItem -&gt; selected.set(From.VIEW, newItem) )</span>
                    );
<span class="fc" id="L1891">                })</span>
<span class="fc" id="L1892">                ._with( button -&gt; _setSelectedSilently(button, selected.get()) )</span>
<span class="fc" id="L1893">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a {@link sprouts.Var}
     *  instance which will be used to dynamically model the inverse selection state of the
     *  wrapped {@link AbstractButton} type.
     *
     * @param selected The {@link sprouts.Var} instance which will be used to
     *                 model the inverse selection state of the wrapped button type.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public final I isSelectedIfNot( Var&lt;Boolean&gt; selected ) {
<span class="fc" id="L1907">        NullUtil.nullArgCheck(selected, &quot;selected&quot;, Var.class);</span>
<span class="nc" id="L1908">        NullUtil.nullPropertyCheck(selected, &quot;selected&quot;, &quot;Null can not be used to model the selection state of a button type.&quot;);</span>
<span class="nc" id="L1909">        return _withOnShow( selected, (c, v) -&gt; {</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">                    _setSelectedSilently(c, !v);</span>
<span class="nc" id="L1911">                })</span>
<span class="nc" id="L1912">                ._with( button -&gt; {</span>
<span class="nc" id="L1913">                    _onClick(button,</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">                        e -&gt; _runInApp(!button.isSelected(), newItem -&gt; selected.set(From.VIEW, newItem) )</span>
                    );
<span class="nc" id="L1916">                    _onChange(button,</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">                        v -&gt; _runInApp(!button.isSelected(), newItem -&gt; selected.set(From.VIEW, newItem) )</span>
                    );
<span class="nc" id="L1919">                })</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">                ._with( button -&gt; _setSelectedSilently(button, !selected.is(true)) )</span>
<span class="nc" id="L1921">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind the selection flag of the button to a {@link Val}
     *  property which will determine the selection state of the button based on the
     *  equality of the property value and the provided reference value.
     *  So if the first {@code state} argument is equal to the value of the {@code selection} property,
     *  the button will be selected, otherwise it will be deselected.&lt;br&gt;
     *  A typical use case is to bind a button to an enum property, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Step { ONE, TWO, THREE }
     *      Var&lt;Step&gt; step = Var.of(Step.ONE);
     *
     *      // In your view:
     *      UI.radioButton(&quot;Two&quot;).isSelectedIf(Step.TWO, vm.getStep());
     *  }&lt;/pre&gt;
     *  As you can see, the radio button will be selected if the enum property is equal to the supplied enum value
     *  and deselected otherwise. &lt;br&gt;
     *  &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param state The reference value which the button type should represent when selected.
     * @param selection The {@link sprouts.Val} instance which will be used
     *                  to dynamically model the selection state of the wrapped button type
     *                  based on the equality of the {@code state} argument and the value of the property.
     * @param &lt;T&gt; The type of the property value.
     * @return The current builder type, to allow for further method chaining.
     * @throws IllegalArgumentException if {@code selected} is {@code null}.
     */
    public final &lt;T&gt; I isSelectedIf( T state, Val&lt;T&gt; selection ) {
<span class="fc" id="L1953">        NullUtil.nullArgCheck(state, &quot;state&quot;, Object.class);</span>
<span class="fc" id="L1954">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Val.class);</span>
<span class="fc" id="L1955">        return _withOnShow( selection, (c,v) -&gt; _setSelectedSilently(c, state.equals(v)) )</span>
<span class="fc" id="L1956">                ._with( button -&gt;</span>
<span class="fc" id="L1957">                     _setSelectedSilently(button, state.equals(selection.orElseThrowUnchecked()))</span>
                )
<span class="fc" id="L1959">                ._this();</span>
    }

    /**
     *  This is the inverse of {@link #isSelectedIf(Object, Val)}.
     *  Use this to make the wrapped UI component dynamically deselected or selected,
     *  based on the equality between the supplied value and the property value. &lt;br&gt;
     *  &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;&lt;br&gt;
     *  A typical use case is to bind to an enum property, like so: &lt;br&gt;
     *  &lt;pre&gt;{@code
     *      // In your view model:
     *      enum Step { ONE, TWO, THREE }
     *      Var&lt;Step&gt; step = Var.of(Step.ONE);
     *
     *      // In your view:
     *      UI.radioButton(&quot;Not Two&quot;)
     *      .isSelectedIfNot(Step.TWO, vm.getStep());
     *  }&lt;/pre&gt;
     *  As you can see, the radio button will be selected if the enum property is equal to the supplied enum value
     *  and deselected otherwise. &lt;br&gt;
     *
     * @param state The value which, if equal to the supplied property value, makes the UI component deselected.
     * @param selection The enum property which, if equal to the supplied value, makes the UI component deselected.
     * @param &lt;T&gt; The type of the value.
     * @return This very instance, which enables builder-style method chaining.
     */
    public final &lt;T&gt; I isSelectedIfNot( T state, Val&lt;T&gt; selection ) {
<span class="fc" id="L1986">        NullUtil.nullArgCheck(state, &quot;state&quot;, Object.class);</span>
<span class="fc" id="L1987">        NullUtil.nullArgCheck(selection, &quot;selection&quot;, Val.class);</span>
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">        return _withOnShow( selection, (c, v) -&gt; _setSelectedSilently(c, !state.equals(v)) )</span>
<span class="fc" id="L1989">                ._with( button -&gt;</span>
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">                     _setSelectedSilently(button, !state.equals(selection.orElseThrowUnchecked()))</span>
                )
<span class="fc" id="L1992">                ._this();</span>
    }

    /**
     *  Use this to dynamically bind to a {@link sprouts.Var}
     *  instance which will be used to dynamically model the pressed state of the
     *  wrapped {@link AbstractButton} type.
     *
     * @param var The {@link sprouts.Var} instance which will be used to model the pressed state of the wrapped button type.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code var} is {@code null}.
     */
    public final I isPressedIf( Var&lt;Boolean&gt; var ) {
<span class="fc" id="L2005">        NullUtil.nullArgCheck(var, &quot;var&quot;, Var.class);</span>
<span class="fc" id="L2006">        return _withOnShow( var, (c,v) -&gt; {</span>
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">                    if ( v != c.getModel().isPressed() )</span>
<span class="nc" id="L2008">                        c.getModel().setPressed(v);</span>
<span class="fc" id="L2009">                })</span>
<span class="fc" id="L2010">                ._with( button -&gt; {</span>
<span class="fc" id="L2011">                    _onModelChange(button, e -&gt;</span>
<span class="fc" id="L2012">                        _runInApp(button.getModel().isPressed(), pressed-&gt;{</span>
<span class="fc" id="L2013">                            var.set(From.VIEW, pressed);</span>
<span class="fc" id="L2014">                        })</span>
                    );
<span class="fc" id="L2016">                })</span>
                // on change is not needed because the pressed state is only changed by the user.
<span class="fc" id="L2018">                ._with( button -&gt;</span>
<span class="fc" id="L2019">                    button.setSelected(var.orElseThrowUnchecked())</span>
                )
<span class="fc" id="L2021">                ._this();</span>
    }

    protected final void _onModelChange( B button, Consumer&lt;ChangeEvent&gt; action ) {
        /*
            When an item event is fired Swing will go through all the listeners
            from the most recently added to the first added. This means that if we simply add
            a listener through the &quot;addItemListener&quot; method, we will be the last to be notified.
            This is problematic because the first listeners we register are usually
            the ones that are responsible for updating properties.
            This means that when the item listener events of the user
            are fired, the properties will not be updated yet.
            To solve this problem, we do the revers by making sure that our listener is added
            at the first position in the list of listeners inside the button.
        */
<span class="fc" id="L2036">        ItemListener[] listeners = button.getItemListeners();</span>
<span class="pc bpc" id="L2037" title="1 of 2 branches missed.">        for (ItemListener listener : listeners)</span>
<span class="nc" id="L2038">            button.removeItemListener(listener);</span>

<span class="fc" id="L2040">        button.addChangeListener(action::accept);</span>

<span class="pc bpc" id="L2042" title="1 of 2 branches missed.">        for ( int i = listeners.length - 1; i &gt;= 0; i-- ) // reverse order because swing does not give us the listeners in the order they were added!</span>
<span class="nc" id="L2043">            button.addItemListener(listeners[i]);</span>
        /*
            The reasoning behind why Swing calls item listeners from last to first is
            the assumption that the last listener added is more interested in the event
            than the first listener added.
            This however is an unintuitive assumption, meaning a user would expect
            the first listener added to be the most interested in the event
            simply because it was added first.
            This is especially true in the context of declarative UI design.
         */
<span class="fc" id="L2053">    }</span>


    /**
     *  Sets the {@link AbstractButton#setBorderPainted(boolean)} flag of the wrapped button type.
     *  If the flag is set to true, the border of the button will be painted.
     *  The default value for the borderPainted property is true.
     *  Some look and feels might not support the borderPainted property,
     *  in which case they ignore this.
     *
     * @param borderPainted Whether the border of the button should be painted.
     * @return This very instance, which enables builder-style method chaining.
     */
    public I isBorderPaintedIf( boolean borderPainted ) {
<span class="fc" id="L2067">        return _with( button -&gt; button.setBorderPainted(borderPainted) )._this();</span>
    }

    /**
     *  Binds the provided {@link Val} property to the {@link AbstractButton#setBorderPainted(boolean)} method.,
     *  which means that whenever the value of the property changes, the border of the button will be painted or not.
     *  The default value for the borderPainted property is true.
     *  Some look and feels might not support the borderPainted property, in which case they ignore this.
     *
     * @param val Whether the border of the button should be painted.
     * @return This very instance, which enables builder-style method chaining.
     */
    public I isBorderPaintedIf( Val&lt;Boolean&gt; val ) {
<span class="nc" id="L2080">        NullUtil.nullArgCheck(val, &quot;val&quot;, Val.class);</span>
<span class="nc" id="L2081">        NullUtil.nullPropertyCheck(val, &quot;val&quot;, &quot;Null is not a valid value for the border painted property.&quot;);</span>
<span class="nc" id="L2082">        return _withOnShow( val, AbstractButton::setBorderPainted )</span>
<span class="nc" id="L2083">               ._with( button -&gt; button.setBorderPainted(val.orElseThrowUnchecked()) )</span>
<span class="nc" id="L2084">               ._this();</span>
    }

    /**
     *  Effectively removes the native style of this button.
     *  Without an icon or text, one will not be able to recognize the button.
     *  Use this for buttons with a custom icon or clickable text!
     *
     * @return This very instance, which enables builder-style method chaining.
     */
    public final I makePlain() {
<span class="fc" id="L2095">        return peek( it -&gt; {</span>
<span class="fc" id="L2096">                    it.setBorderPainted(false);</span>
<span class="fc" id="L2097">                    it.setContentAreaFilled(false);</span>
<span class="fc" id="L2098">                    it.setOpaque(false);</span>
<span class="fc" id="L2099">                    it.setFocusPainted(false);</span>
<span class="fc" id="L2100">                    it.setMargin(new Insets(0,0,0,0));</span>
<span class="fc" id="L2101">                    _setBackground(it, UI.Color.TRANSPARENT);</span>
<span class="fc" id="L2102">                });</span>
    }

    /**
     *  This method adds the provided
     *  {@link ItemListener} instance to the wrapped button component.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param action The change action lambda which will be passed to the button component.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code action} is {@code null}.
     */
    public final I onChange( Action&lt;ComponentDelegate&lt;B, ItemEvent&gt;&gt; action ) {
<span class="fc" id="L2115">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L2116">        return _with( button -&gt; {</span>
<span class="fc" id="L2117">                    _onChange(button, e -&gt;</span>
<span class="fc" id="L2118">                        _runInApp(()-&gt;{</span>
                            try {
<span class="fc" id="L2120">                                action.accept(new ComponentDelegate&lt;&gt;(button, e));</span>
<span class="nc" id="L2121">                            } catch ( Exception ex ) {</span>
<span class="nc" id="L2122">                                log.error(&quot;Failed to execute action on button change event.&quot;, ex);</span>
<span class="fc" id="L2123">                            }</span>
<span class="fc" id="L2124">                        })</span>
                    );
<span class="fc" id="L2126">                })</span>
<span class="fc" id="L2127">                ._this();</span>
    }

    protected final void _onChange( B button, Consumer&lt;ItemEvent&gt; action ) {
        /*
            When an item event is fired Swing will go through all the listeners
            from the most recently added to the first added. This means that if we simply add
            a listener through the &quot;addItemListener&quot; method, we will be the last to be notified.
            This is problematic because the first listeners we register are usually
            the ones that are responsible for updating properties.
            This means that when the item listener events of the user
            are fired, the properties will not be updated yet.
            To solve this problem, we do the revers by making sure that our listener is added
            at the first position in the list of listeners inside the button.
        */
<span class="fc" id="L2142">        ItemListener[] listeners = button.getItemListeners();</span>
<span class="fc bfc" id="L2143" title="All 2 branches covered.">        for (ItemListener listener : listeners)</span>
<span class="fc" id="L2144">            button.removeItemListener(listener);</span>

<span class="fc" id="L2146">        button.addItemListener(action::accept);</span>

<span class="fc bfc" id="L2148" title="All 2 branches covered.">        for ( int i = listeners.length - 1; i &gt;= 0; i-- ) // reverse order because swing does not give us the listeners in the order they were added!</span>
<span class="fc" id="L2149">            button.addItemListener(listeners[i]);</span>
        /*
            The reasoning behind why Swing calls item listeners from last to first is
            the assumption that the last listener added is more interested in the event
            than the first listener added.
            This however is an unintuitive assumption, meaning a user would expect
            the first listener added to be the most interested in the event
            simply because it was added first.
            This is especially true in the context of declarative UI design.
         */
<span class="fc" id="L2159">    }</span>

    /**
     *  This method enables a more readable way of adding
     *  {@link ActionListener} instances to button types.
     *  Additionally, to the other &quot;onClick&quot; method this method enables the involvement of the
     *  {@link JComponent} itself into the action supplied to it.
     *  This is very useful for changing the state of the JComponent when the action is being triggered.
     *  &lt;br&gt;&lt;br&gt;
     *
     * @param action an {@link Action} instance which will receive an {@link ComponentDelegate} containing important context information.
     * @return This very instance, which enables builder-style method chaining.
     * @throws IllegalArgumentException if {@code action} is {@code null}.
     */
    public I onClick( Action&lt;ComponentDelegate&lt;B, ActionEvent&gt;&gt; action ) {
<span class="fc" id="L2174">        NullUtil.nullArgCheck(action, &quot;action&quot;, Action.class);</span>
<span class="fc" id="L2175">        return _with( button -&gt; {</span>
<span class="fc" id="L2176">                    _onClick(button, e -&gt;</span>
<span class="fc" id="L2177">                        _runInApp(() -&gt; {</span>
                            try {
<span class="fc" id="L2179">                                action.accept(new ComponentDelegate&lt;&gt;(button, e));</span>
<span class="nc" id="L2180">                            } catch ( Exception ex ) {</span>
<span class="nc" id="L2181">                                log.error(&quot;Failed to execute action on button click event.&quot;, ex);</span>
<span class="fc" id="L2182">                            }</span>
<span class="fc" id="L2183">                        })</span>
                    );
<span class="fc" id="L2185">                })</span>
<span class="fc" id="L2186">                ._this();</span>
    }

    protected final void _onClick( B button, Consumer&lt;ActionEvent&gt; action ) {
        /*
            When an action event is fired, Swing will go through all the listeners
            from the most recently added to the first added. This means that if we simply add
            a listener through the &quot;addActionListener&quot; method, we will be the last to be notified.
            This is problematic because it is built on the assumption that the last listener
            added is more interested in the event than the first listener added.
            This however is an unintuitive assumption, meaning a user would expect
            the first listener added to be the most interested in the event
            simply because it was added first.
            This is especially true in the context of declarative UI design.
        */
<span class="fc" id="L2201">        ActionListener[] listeners = button.getActionListeners();</span>
<span class="fc bfc" id="L2202" title="All 2 branches covered.">        for (ActionListener listener : listeners)</span>
<span class="fc" id="L2203">            button.removeActionListener(listener);</span>

<span class="fc" id="L2205">        button.addActionListener(action::accept);</span>

<span class="fc bfc" id="L2207" title="All 2 branches covered.">        for ( int i = listeners.length - 1; i &gt;= 0; i-- ) // reverse order because swing does not give us the listeners in the order they were added!</span>
<span class="fc" id="L2208">            button.addActionListener(listeners[i]);</span>
<span class="fc" id="L2209">    }</span>

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *         .peek( button -&gt; button.setHorizontalAlignment(...) );
     *  }&lt;/pre&gt;
     * This sets the horizontal alignment of the icon and text.
     *
     * @param horizontalAlign The horizontal alignment which should be applied to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code horizontalAlign} is {@code null}.
     */
    public final I withHorizontalAlignment( UI.HorizontalAlignment horizontalAlign ) {
<span class="nc" id="L2224">        NullUtil.nullArgCheck(horizontalAlign, &quot;horizontalAlign&quot;, UI.HorizontalAlignment.class);</span>
<span class="nc" id="L2225">        return _with( c -&gt;</span>
<span class="nc" id="L2226">                    horizontalAlign.forSwing().ifPresent(c::setHorizontalAlignment)</span>
                )
<span class="nc" id="L2228">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *     .peek( button -&gt; {
     *          property.onSetItem(v-&gt;button.setHorizontalAlignment(v.forSwing()));
     *          button.setHorizontalAlignment(property.get().forSwing());
     *     });
     *  }&lt;/pre&gt;
     * This sets the horizontal alignment of the icon and text
     * and also binds the provided property to the underlying component. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param horizontalAlign The horizontal alignment property which should be bound to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code horizontalAlign} is {@code null}.
     */
    public final I withHorizontalAlignment( Val&lt;UI.HorizontalAlignment&gt; horizontalAlign ) {
<span class="nc" id="L2249">        NullUtil.nullArgCheck(horizontalAlign, &quot;horizontalAlign&quot;, Val.class);</span>
<span class="nc" id="L2250">        NullUtil.nullPropertyCheck(horizontalAlign, &quot;horizontalAlign&quot;);</span>
<span class="nc" id="L2251">        return _withOnShow( horizontalAlign, (c, align) -&gt; {</span>
<span class="nc" id="L2252">                    align.forSwing().ifPresent(c::setHorizontalAlignment);</span>
<span class="nc" id="L2253">                })</span>
<span class="nc" id="L2254">                ._with( c -&gt;</span>
<span class="nc" id="L2255">                    horizontalAlign.orElseThrowUnchecked().forSwing().ifPresent(c::setHorizontalAlignment)</span>
                )
<span class="nc" id="L2257">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *         .peek( button -&gt; button.setVerticalAlignment(...) );
     *  }&lt;/pre&gt;
     * This sets the vertical alignment of the icon and text.
     *
     * @param verticalAlign The vertical alignment which should be applied to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code verticalAlign} is {@code null}.
     */
    public final I withVerticalAlignment( UI.VerticalAlignment verticalAlign ) {
<span class="nc" id="L2273">        NullUtil.nullArgCheck(verticalAlign, &quot;verticalAlign&quot;, UI.VerticalAlignment.class);</span>
<span class="nc" id="L2274">        return _with( c -&gt;</span>
<span class="nc" id="L2275">                    verticalAlign.forSwing().ifPresent(c::setVerticalAlignment)</span>
                )
<span class="nc" id="L2277">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *     .peek( button -&gt; {
     *          property.onSetItem(v-&gt;button.setVerticalAlignment(v.forSwing()));
     *          button.setVerticalAlignment(property.get().forSwing());
     *     });
     *  }&lt;/pre&gt;
     * This sets the vertical alignment of the icon and text
     * and also binds the provided property to the underlying component. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param verticalAlign The vertical alignment property which should be bound to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code verticalAlign} is {@code null}.
     */
    public final I withVerticalAlignment( Val&lt;UI.VerticalAlignment&gt; verticalAlign ) {
<span class="nc" id="L2298">        NullUtil.nullArgCheck(verticalAlign, &quot;verticalAlign&quot;, Val.class);</span>
<span class="nc" id="L2299">        NullUtil.nullPropertyCheck(verticalAlign, &quot;verticalAlign&quot;);</span>
<span class="nc" id="L2300">        return _withOnShow( verticalAlign, (c, align) -&gt; {</span>
<span class="nc" id="L2301">                    align.forSwing().ifPresent(c::setVerticalAlignment);</span>
<span class="nc" id="L2302">                })</span>
<span class="nc" id="L2303">                ._with( c -&gt;</span>
<span class="nc" id="L2304">                    verticalAlign.orElseThrowUnchecked().forSwing().ifPresent(c::setVerticalAlignment)</span>
                )
<span class="nc" id="L2306">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *         .peek( button -&gt; button.setHorizontalTextPosition(...) );
     *  }&lt;/pre&gt;
     * This sets the horizontal position of the text relative to the icon.
     *
     * @param horizontalAlign The horizontal text alignment relative to the icon which should be applied to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code horizontalAlign} is {@code null}.
     */
    public final I withHorizontalTextAlignment( UI.HorizontalAlignment horizontalAlign ) {
<span class="nc" id="L2322">        NullUtil.nullArgCheck(horizontalAlign, &quot;horizontalAlign&quot;, UI.HorizontalAlignment.class);</span>
<span class="nc" id="L2323">        return _with( c -&gt;</span>
<span class="nc" id="L2324">                    horizontalAlign.forSwing().ifPresent(c::setHorizontalTextPosition)</span>
                )
<span class="nc" id="L2326">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *     .peek( button -&gt; {
     *          property.onSetItem(v-&gt;button.setHorizontalTextPosition(v.forSwing()));
     *          button.setHorizontalTextPosition(property.get().forSwing());
     *     });
     *  }&lt;/pre&gt;
     * This sets the horizontal position of the text relative to the icon
     * and also binds the provided property to the underlying component. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param horizontalAlign The horizontal text alignment property relative to the icon which should be bound to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code horizontalAlign} is {@code null}.
     */
    public final I withHorizontalTextAlignment( Val&lt;UI.HorizontalAlignment&gt; horizontalAlign ) {
<span class="nc" id="L2347">        NullUtil.nullArgCheck(horizontalAlign, &quot;horizontalAlign&quot;, Val.class);</span>
<span class="nc" id="L2348">        return _withOnShow( horizontalAlign, (c, align) -&gt; {</span>
<span class="nc" id="L2349">                    align.forSwing().ifPresent(c::setHorizontalTextPosition);</span>
<span class="nc" id="L2350">                })</span>
<span class="nc" id="L2351">                ._with( c -&gt;</span>
<span class="nc" id="L2352">                    horizontalAlign.orElseThrowUnchecked().forSwing().ifPresent(c::setHorizontalTextPosition)</span>
                )
<span class="nc" id="L2354">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *         .peek( button -&gt; button.setVerticalTextPosition(...) );
     *  }&lt;/pre&gt;
     * This sets the vertical position of the text relative to the icon.
     *
     * @param verticalAlign The vertical text alignment relative to the icon which should be applied to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code verticalAlign} is {@code null}.
     */
    public final I withVerticalTextAlignment( UI.VerticalAlignment verticalAlign ) {
<span class="nc" id="L2370">        NullUtil.nullArgCheck(verticalAlign, &quot;verticalAlign&quot;, UI.VerticalAlignment.class);</span>
<span class="nc" id="L2371">        return _with( c -&gt;</span>
<span class="nc" id="L2372">                    verticalAlign.forSwing().ifPresent(c::setVerticalTextPosition)</span>
                )
<span class="nc" id="L2374">                ._this();</span>
    }

    /**
     *  A convenience method to avoid peeking into this builder like so:
     *  &lt;pre&gt;{@code
     *     UI.button(&quot;Clickable!&quot;)
     *     .peek( button -&gt; {
     *          property.onSetItem(v-&gt;button.setVerticalTextPosition(v.forSwing()));
     *          button.setVerticalTextPosition(property.get().forSwing());
     *     });
     *  }&lt;/pre&gt;
     * This sets the vertical position of the text relative to the icon
     * and also binds the provided property to the underlying component. &lt;br&gt;
     * &lt;i&gt;Hint: Use {@code myProperty.fire(From.VIEW_MODEL)} in your view model to send the property value to this view component.&lt;/i&gt;
     *
     * @param verticalAlign The vertical text alignment property relative to the icon which should be bound to the underlying component.
     * @return This very builder to allow for method chaining.
     * @throws IllegalArgumentException if {@code verticalAlign} is {@code null}.
     */
    public final I withVerticalTextAlignment( Val&lt;UI.VerticalAlignment&gt; verticalAlign ) {
<span class="nc" id="L2395">        NullUtil.nullArgCheck(verticalAlign, &quot;verticalAlign&quot;, Val.class);</span>
<span class="nc" id="L2396">        return _withOnShow( verticalAlign, (c, align) -&gt; {</span>
<span class="nc" id="L2397">                    align.forSwing().ifPresent(c::setVerticalTextPosition);</span>
<span class="nc" id="L2398">                })</span>
<span class="nc" id="L2399">                ._with( c -&gt;</span>
<span class="nc" id="L2400">                    verticalAlign.orElseThrowUnchecked().forSwing().ifPresent(c::setVerticalTextPosition)</span>
                )
<span class="nc" id="L2402">                ._this();</span>
    }

    /**
     *  Use this to attach this button type to a button group.
     *
     * @param group The button group to which this button should be attached.
     * @return This very builder to allow for method chaining.
     */
    public final I withButtonGroup( ButtonGroup group ) {
<span class="fc" id="L2412">        NullUtil.nullArgCheck(group, &quot;group&quot;, ButtonGroup.class);</span>
<span class="fc" id="L2413">        return _with(group::add)._this();</span>
    }

    /**
     *  Use this to set the margin of the wrapped button type.
     *
     * @param insets The margin of the button.
     * @return This very builder to allow for method chaining.
     */
    public final I withMargin( Insets insets ) {
<span class="nc" id="L2423">        NullUtil.nullArgCheck(insets, &quot;insets&quot;, Insets.class);</span>
<span class="nc" id="L2424">        return _with( thisComponent -&gt;</span>
<span class="nc" id="L2425">                    thisComponent.setMargin(insets)</span>
                )
<span class="nc" id="L2427">                ._this();</span>
    }

    /**
     *  Use this to set the margin of the wrapped button type.
     *
     * @param top The top margin of the button.
     * @param left The left margin of the button.
     * @param bottom The bottom margin of the button.
     * @param right The right margin of the button.
     * @return This very builder to allow for method chaining.
     */
    public final I withMargin( int top, int left, int bottom, int right ) {
<span class="nc" id="L2440">        return withMargin( new Insets(top, left, bottom, right) );</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>