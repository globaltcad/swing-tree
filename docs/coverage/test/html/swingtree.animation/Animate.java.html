<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Animate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.animation</a> &gt; <span class="el_source">Animate.java</span></div><h1>Animate.java</h1><pre class="source lang-java linenums">package swingtree.animation;

import swingtree.ComponentDelegate;

import java.awt.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

/**
 *  An API for creating an {@link Animation} and defining how it should be executed.
 *  Instances of this class are intended to be created and used either by the
 *  {@link swingtree.UI} API or the user event delegation API (see {@link ComponentDelegate}). &lt;br&gt;
 *  The UI API can be used like so:
 *  &lt;pre&gt;{@code
 *    UI.schedule( 100, TimeUnit.MILLISECONDS ) // returns an Animate instance
 *       .until( it -&gt; it.progress() &gt;= 0.75 &amp;&amp; someOtherCondition() )
 *       .go( state -&gt; {
 *          // do something
 *          someComponent.setValue( it.progress() );
 *          // ...
 *          someComponent.repaint();
 *       });
 *   }&lt;/pre&gt;
 *   The user event delegation API can be used like this:
 *   &lt;pre&gt;{@code
 *       panel()
 *       .onMouseClick( it -&gt; {
 *           it.animate( 100, TimeUnit.MILLISECONDS )
 *           .goOnce( state -&gt; {
 *               int width = (int) (100 * state.progress());
 *               it.getComponent().setSize( width, 100 );
 *           });
 *       })
 *   }&lt;/pre&gt;
 */
public class Animate
{
    private final Component _component;
    private final LifeTime _lifeTime;
    private final StopCondition _condition;

    /**
     * Creates an {@link Animate} instance which allows you to define the stop condition
     * for an animation as well as an {@link Animation} that will be executed
     * when passed to the {@link #go(Animation)} or {@link #goOnce(Animation)} methods.
     *
     * @param lifeTime The schedule that defines when the animation should be executed and for how long.
     * @return An {@link Animate} instance that can be used to define how the animation should be executed.
     */
    public static Animate on( LifeTime lifeTime) {
<span class="fc" id="L51">        return new Animate( null, lifeTime, state -&gt; true );</span>
    }

    /**
     * Creates an {@link Animate} instance which allows you to define the stop condition
     * for an animation as well as an {@link Animation} that will be executed
     * when passed to the {@link #go(Animation)} or {@link #goOnce(Animation)} methods.
     *
     * @param component The component that should be repainted after each animation step.
     * @param lifeTime The schedule that defines when the animation should be executed and for how long.
     * @return An {@link Animate} instance that can be used to define how the animation should be executed.
     */
    public static Animate on( Component component, LifeTime lifeTime) {
<span class="fc" id="L64">        return new Animate( component, lifeTime, state -&gt; true );</span>
    }

<span class="fc" id="L67">    private Animate(Component component, LifeTime lifeTime, StopCondition animation ) {</span>
<span class="fc" id="L68">        _component = component;</span>
<span class="fc" id="L69">        _lifeTime = lifeTime;</span>
<span class="fc" id="L70">        _condition = animation;</span>
<span class="fc" id="L71">    }</span>

    /**
     *  Creates a new {@link Animate} instance that will be executed after the given delay.
     *
     * @param delay The delay after which the animation should be executed.
     * @param unit The time unit of the delay.
     * @return A new {@link Animate} instance that will be executed after the given delay.
     */
    public Animate startingIn( long delay, TimeUnit unit ) {
<span class="nc" id="L81">        long offset = unit.toMillis( delay );</span>
<span class="nc" id="L82">        LifeTime lifeTime = LifeTime.of(</span>
                offset,                                         TimeUnit.MILLISECONDS,
<span class="nc" id="L84">                _lifeTime.getDurationIn(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS</span>
        );

<span class="nc" id="L87">        return new Animate( _component, lifeTime, _condition );</span>
    }

    /**
     *  Runs the given animation once
     *  based on the stop condition {@code state -&gt; state.currentIteration() == 0}
     *
     * @param animation The animation that should be executed.
     */
    public void goOnce( Animation animation ) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        this.asLongAs( state -&gt; state.currentIteration() == 0 ).go( animation );</span>
<span class="fc" id="L98">    }</span>

    /**
     *  Runs the given animation twice
     *  based on the stop condition {@code state -&gt; state.currentIteration() &lt; 2}
     *
     * @param animation The animation that should be executed.
     */
    public void goTwice( Animation animation ) {
<span class="nc bnc" id="L107" title="All 2 branches missed.">        this.asLongAs( state -&gt; state.currentIteration() &lt; 2 ).go( animation );</span>
<span class="nc" id="L108">    }</span>

    /**
     *  Use this to define a stop condition for the animation.
     *
     * @param shouldStop The stop condition for the animation, i.e. the animation will be executed
     *                   until this condition is true.
     * @return A new {@link Animate} instance that will be executed until the given stop condition is true.
     */
    public Animate until( Predicate&lt;AnimationState&gt; shouldStop ) {
<span class="nc" id="L118">        return this.asLongAs( shouldStop.negate() );</span>
    }

    /**
     *  Use this to define a running condition for the animation.
     *
     * @param shouldRun The running condition for the animation, i.e. the animation will be executed
     *                  as long as this condition is true.
     * @return A new {@link Animate} instance that will be executed as long as the given running condition is true.
     */
    public Animate asLongAs( Predicate&lt;AnimationState&gt; shouldRun ) {
<span class="fc" id="L129">        return new Animate( _component, _lifeTime, state -&gt; {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if ( shouldRun.test(state) )</span>
<span class="fc" id="L131">                return _condition.check(state);</span>
<span class="fc" id="L132">            return false;</span>
        });
    }

    /**
     *  Runs the given animation based on the stop condition defined by {@link #until(Predicate)} or {@link #asLongAs(Predicate)}.
     *  If no stop condition was defined, the animation will be executed forever.
     *
     * @param animation The animation that should be executed.
     */
    public void go( Animation animation ) {
<span class="fc" id="L143">        AnimationRunner.add( new ComponentAnimator( _component, _lifeTime, _condition, animation ) );</span>
<span class="fc" id="L144">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>