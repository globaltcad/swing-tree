<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JScrollPanels.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.components</a> &gt; <span class="el_source">JScrollPanels.java</span></div><h1>JScrollPanels.java</h1><pre class="source lang-java linenums">package swingtree.components;

import net.miginfocom.swing.MigLayout;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.From;
import swingtree.SwingTree;
import swingtree.UI;
import swingtree.UIForAnySwing;
import swingtree.api.mvvm.EntryViewModel;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.layout.AddConstraint;
import swingtree.layout.ResponsiveGridFlowLayout;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 *  The {@link JScrollPanels} class is a container for a list of scrollable UI components
 *  representing view models or simple data models which are dynamically turned into
 *  views by a {@link ViewSupplier}.
 *  This class exists to compensate for the deficits of the {@link JList} and {@link JTable} components,
 *  whose entries are not able to receive user events like for example mouse events, button clicks etc...
 *  &lt;br&gt;
 *  A {@link JScrollPanels} instance can arrange its entries in a vertical or horizontal manner
 *  based on the {@link UI.Align} parameter.
 *  &lt;br&gt;&lt;br&gt;
 *  Instances of this store view model implementations in a view model property list
 *  so that they can dynamically be turned into views by a {@link ViewSupplier} lambda
 *  when the list changes its state. &lt;br&gt;
 *  Here a simple example demonstrating the usage of the {@link JScrollPanels} class
 *  through the Swing-Tree API:
 *  &lt;pre&gt;{@code
 *    UI.scrollPanels()
 *    .addAll(viewModel.entries(), entry -&gt;
 *        UI.panel().add(UI.button(&quot;Click me! :)&quot;))
 *    )
 *  }&lt;/pre&gt;
 *  ...where {@code entries()} is a method returning a {@link sprouts.Vars} instance
 *  which contains a list of your sub-view models.
 *  The second parameter of the {@link swingtree.UIForScrollPanels#addAll(sprouts.Vals, ViewSupplier)} method is a lambda
 *  which takes a single view model from the list of view models and turns it into a view.
 */
public class JScrollPanels extends UI.ScrollPane
{
<span class="fc" id="L57">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(JScrollPanels.class);</span>

    /**
     * Constructs a new {@link JScrollPanels} instance with the provided alignment and size.
     * @param align The alignment of the entries inside this {@link JScrollPanels} instance.
     *              The alignment can be either {@link UI.Align#HORIZONTAL} or {@link UI.Align#VERTICAL}.
     * @param size The size of the entries in this {@link JScrollPanels} instance.
     * @return A new {@link JScrollPanels} instance.
     */
    public static JScrollPanels of(
        UI.Align align, @Nullable Dimension size
    ) {
<span class="fc" id="L69">        Objects.requireNonNull(align);</span>
<span class="pc" id="L70">        return _construct(align, size, Collections.emptyList(), null, m -&gt; UI.panel());</span>
    }

    private static JScrollPanels _construct(
        UI.Align align,
        @Nullable Dimension shape,
        List&lt;EntryViewModel&gt; models,
        @Nullable AddConstraint constraints,
        ViewSupplier&lt;EntryViewModel&gt; viewSupplier
    ) {
<span class="fc" id="L80">        UI.Align type = align;</span>
<span class="fc" id="L81">        @Nullable InternalPanel[] forwardReference = {null};</span>
<span class="fc" id="L82">        List&lt;EntryPanel&gt; entries =</span>
<span class="fc" id="L83">                IntStream.range(0,models.size())</span>
<span class="fc" id="L84">                        .mapToObj( i -&gt;</span>
<span class="nc" id="L85">                            new EntryPanel(</span>
<span class="nc" id="L86">                                    ()-&gt; _entriesIn(forwardReference[0].getComponents()),</span>
                                    i,
<span class="nc" id="L88">                                    models.get(i),</span>
                                    viewSupplier,
                                    constraints
                                )
                        )
<span class="fc" id="L93">                        .collect(Collectors.toList());</span>


<span class="fc" id="L96">        InternalPanel internalWrapperPanel = new InternalPanel(entries, shape, type);</span>
<span class="fc" id="L97">        JScrollPanels newJScrollPanels = new JScrollPanels(internalWrapperPanel);</span>
<span class="fc" id="L98">        forwardReference[0] = internalWrapperPanel;</span>

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if ( type == UI.Align.HORIZONTAL )</span>
<span class="nc" id="L101">            newJScrollPanels.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);</span>
        else
<span class="fc" id="L103">            newJScrollPanels.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);</span>

<span class="fc" id="L105">        return newJScrollPanels;</span>
    }


    private final InternalPanel _internal; // Wrapper for the actual UI components


    private JScrollPanels(InternalPanel listWrapper) {
<span class="fc" id="L113">        super(listWrapper);</span>
<span class="fc" id="L114">        _internal = listWrapper;</span>
<span class="fc" id="L115">    }</span>

    /**
     *  Allows you to get the number of entries which are currently managed by this {@link JScrollPanels}.
     *  The number of entries is the number of view models which are currently managed by this {@link JScrollPanels}.
     *
     * @return The number of entries which are currently managed by this {@link JScrollPanels}.
     */
<span class="fc" id="L123">    public int getNumberOfEntries() { return _internal.getComponents().length; }</span>

    /**
     *  Exposes the content panel that contains the actual entry components.
     * @return The container of the entry views.
     */
    public JComponent getContentPanel() {
<span class="fc" id="L130">        return _internal;</span>
    }

    /**
     *  The {@link JScrollPanels} does not store components statically in the UI tree.
     *  Instead, it is a hybrid of the traditional static approach
     *  and a renderer based approach (as in the {@link JList}).
     *  The lambda passed to this method is responsible for continuously supplying a UI
     *  which fits a certain context (which defines if the entry is selected or not among other things).
     *
     * @param entryViewModel A view model which ought to be added.
     * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
     * @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void addEntry( M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L145">        Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L146">        addEntry(null, entryViewModel, viewSupplier);</span>
<span class="fc" id="L147">    }</span>

    public &lt;M extends EntryViewModel&gt; void addEntryAt( int index, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="nc" id="L150">        Objects.requireNonNull(entryViewModel);</span>
<span class="nc" id="L151">        EntryPanel entryPanel = _createEntryPanel(null, entryViewModel, viewSupplier, index);</span>
<span class="nc" id="L152">        _internal.add(entryPanel, index);</span>
<span class="nc" id="L153">    }</span>

    /**
     *  The {@link JScrollPanels} does not store components statically in the UI tree.
     *  Instead, it is a hybrid of the traditional static approach
     *  and a renderer based approach (as in the {@link JList}).
     *  The view supplier lambda passed to this method is responsible for continuously supplying a UI
     *  which fits a certain context (which defines if the entry is selected or not among other things).
     *
     * @param constraints The constraints which ought to be applied to the entry.
     * @param entryViewModel The entry model which ought to be added.
     * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
     * @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void addEntry( @Nullable AddConstraint constraints, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L168">        Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L169">        EntryPanel entryPanel = _createEntryPanel(constraints, entryViewModel, viewSupplier, _internal.getComponents().length);</span>
<span class="fc" id="L170">        _internal.add(entryPanel);</span>
<span class="fc" id="L171">        this.validate();</span>
<span class="fc" id="L172">    }</span>

    /**
     *  Adds multiple entries at once to this {@link JScrollPanels}.
     * @param constraints The constraints which ought to be applied to the entry.
     * @param entryViewModels A list of entry models which ought to be added.
     * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
     * @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void addAllEntries( @Nullable AddConstraint constraints, Iterable&lt;M&gt; entryViewModels, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="nc" id="L182">        Objects.requireNonNull(entryViewModels);</span>
<span class="nc" id="L183">        addAllEntriesAt(_internal.getComponents().length, constraints, entryViewModels, viewSupplier);</span>
<span class="nc" id="L184">    }</span>

    /**
     *  Adds multiple entries at once to this {@link JScrollPanels} at a certain index.
     * @param index The index at which the entries ought to be added.
     * @param constraints The constraints which ought to be applied to the entry.
     * @param entryViewModels A list of entry models which ought to be added.
     * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
     * @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void addAllEntriesAt( int index, @Nullable AddConstraint constraints, Iterable&lt;M&gt; entryViewModels, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L195">        Objects.requireNonNull(entryViewModels);</span>
<span class="fc" id="L196">        List&lt;EntryPanel&gt; entryPanels = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L197">        int i = 0;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        for ( M model : entryViewModels ) {</span>
<span class="fc" id="L199">            entryPanels.add(</span>
<span class="fc" id="L200">                    _createEntryPanel(</span>
                            constraints,
                            model,
                            viewSupplier,
                            index + i
                    )
            );
<span class="fc" id="L207">            i++;</span>
<span class="fc" id="L208">        }</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for ( int j = 0; j &lt; entryPanels.size(); j++ ) {</span>
<span class="fc" id="L210">            _internal.add(entryPanels.get(j), index + j);</span>
        }
<span class="fc" id="L212">        this.validate();</span>
<span class="fc" id="L213">    }</span>

    /**
     *   Use this to set all entries at a certain index
     *   to effectively replace the old entries with the new ones.
     * @param index The index at which the entries ought to be set.
     * @param constraints The constraints which ought to be applied to the entry.
     * @param entryViewModels A list of entry models which ought to be added.
     * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
     * @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void setAllEntriesAt( int index, @Nullable AddConstraint constraints, Iterable&lt;M&gt; entryViewModels, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L225">        Objects.requireNonNull(entryViewModels);</span>
<span class="fc" id="L226">        boolean somethingChanged = false;</span>
<span class="fc" id="L227">        int i = 0;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for ( M model : entryViewModels ) {</span>
<span class="fc" id="L229">            int localIndex = index + i;</span>
<span class="fc" id="L230">            i++;</span>
<span class="fc" id="L231">            EntryPanel entry = _createEntryPanel(</span>
                                    constraints,
                                    model,
                                    viewSupplier,
                                    localIndex
                                );
            try {
<span class="fc" id="L238">                Component existing = _internal.getComponent(localIndex);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">                if ( existing instanceof EntryPanel ) {</span>
<span class="fc" id="L240">                    EntryPanel existingEntry = (EntryPanel) existing;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                    if ( existingEntry.getComponentCount() == 0 ) {</span>
<span class="nc" id="L242">                        log.error(SwingTree.get().logMarker(),</span>
                                &quot;The entry panel '{}' about to be replaced by '{}' in '{}' is missing its view.&quot;,
                                existingEntry, entry, JScrollPanels.class,
                                new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                        );
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                    } else if ( entry.getComponentCount() == 0 ) {</span>
<span class="nc" id="L248">                        log.error(SwingTree.get().logMarker(),</span>
                                &quot;The entry panel '{}' that should replace panel '{}' in '{}' is missing its view.&quot;,
                                entry, existingEntry, JScrollPanels.class,
                                new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                            );
                    } else {
<span class="fc" id="L254">                        Component existingView = existingEntry.getComponent(0);</span>
<span class="fc" id="L255">                        Component newView = entry.getComponent(0);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                        if ( existingView == newView )</span>
<span class="fc" id="L257">                            continue; // The view is already there</span>
                    }
<span class="nc" id="L259">                } else {</span>
<span class="nc" id="L260">                    log.error(SwingTree.get().logMarker(),</span>
                            &quot;Encountered illegal type of entry panel in {}.&quot;,
                            JScrollPanels.class, new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                        );
                }
<span class="nc" id="L265">                _internal.remove(localIndex);</span>
<span class="nc" id="L266">                _internal.add(entry, localIndex);</span>
<span class="nc" id="L267">                somethingChanged = true;</span>
<span class="nc" id="L268">            } catch (Exception e) {</span>
<span class="nc" id="L269">                log.error(SwingTree.get().logMarker(), &quot;Encountered an exception while trying to update the component at index '{}'.&quot;, localIndex, e);</span>
<span class="nc" id="L270">            }</span>
<span class="nc" id="L271">        }</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if ( somethingChanged ) {</span>
<span class="nc" id="L273">            this.validate();</span>
        }
<span class="fc" id="L275">    }</span>

    /**
     *  Use this to remove all entries.
     */
    public void removeAllEntries() {
<span class="fc" id="L281">        _internal.removeAll();</span>
<span class="fc" id="L282">        this.validate();</span>
<span class="fc" id="L283">    }</span>

    /**
     *  Use this to remove an entry at a certain index.
     * @param index The index of the entry which ought to be removed.
     */
    public void removeEntryAt( int index ) {
<span class="nc" id="L290">        _internal.remove(index);</span>
<span class="nc" id="L291">        this.validate();</span>
<span class="nc" id="L292">    }</span>

    /**
     *  Use this to remove a certain number of entries starting at a certain index.
     * @param index The index at which the entries ought to be removed.
     * @param count The number of entries which ought to be removed.
     */
    public void removeEntriesAt( int index, int count ) {
<span class="fc" id="L300">        IntStream.range(0, count).forEach( i -&gt; _internal.remove(index) );</span>
<span class="fc" id="L301">        this.validate();</span>
<span class="fc" id="L302">    }</span>

    /**
     *  Use this to add an entry at a certain index.
     *
     *  @param index The index at which the entry ought to be added.
     *  @param attr The constraints which ought to be applied to the entry, may be null.
     *  @param entryViewModel The entry view model which ought to be added.
     *  @param viewSupplier The supplier which is used to create the view for the given entry view model.
     *  @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void addEntryAt( int index, @Nullable AddConstraint attr, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L314">        Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L315">        EntryPanel entryPanel = _createEntryPanel(attr, entryViewModel, viewSupplier, index);</span>
<span class="fc" id="L316">        _internal.add(entryPanel, index);</span>
<span class="fc" id="L317">        this.validate();</span>
<span class="fc" id="L318">    }</span>

    /**
     *     Use this to replace an entry at a certain index. &lt;br&gt;
     *     Note: This method will replace an existing entry at the given index.
     *
     *  @param index The index at which the entry ought to be placed.
     *  @param attr The constraints which ought to be applied to the entry, may be null.
     *  @param entryViewModel The entry view model which ought to be added.
     *  @param viewSupplier The supplier which is used to create the view for the given entry view model.
     *  @param &lt;M&gt; The type of the entry view model.
     */
    public &lt;M extends EntryViewModel&gt; void setEntryAt( int index, @Nullable AddConstraint attr, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier ) {
<span class="fc" id="L331">        Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L332">        EntryPanel newEntryPanel = _createEntryPanel(attr, entryViewModel, viewSupplier, index);</span>
<span class="fc" id="L333">        Component existing = _internal.getComponent(index);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if ( existing instanceof EntryPanel ) {</span>
<span class="fc" id="L335">            EntryPanel existingEntry = (EntryPanel) existing;</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if ( existingEntry.getComponentCount() == 0 ) {</span>
<span class="nc" id="L337">                log.error(SwingTree.get().logMarker(),</span>
                        &quot;The entry panel '{}' about to be replaced by '{}' in '{}' is missing its view.&quot;,
                        existingEntry, newEntryPanel, JScrollPanels.class,
                        new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                    );
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            } else if ( newEntryPanel.getComponentCount() == 0 ) {</span>
<span class="nc" id="L343">                log.error(SwingTree.get().logMarker(),</span>
                        &quot;The entry panel '{}' that should replace panel '{}' in '{}' is missing its view.&quot;,
                        newEntryPanel, existingEntry, JScrollPanels.class,
                        new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                    );
            } else {
<span class="fc" id="L349">                Component existingView = ((EntryPanel) existing).getComponent(0);</span>
<span class="fc" id="L350">                Component newView = newEntryPanel.getComponent(0);</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                if ( existingView == newView )</span>
<span class="nc" id="L352">                    return; // The view is already there</span>
            }
<span class="fc" id="L354">        } else {</span>
<span class="nc" id="L355">            log.error(SwingTree.get().logMarker(),</span>
                    &quot;Encountered illegal type of entry panel in {}.&quot;,
                    JScrollPanels.class, new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                );
        }
        // We first remove the old entry panel and then add the new one.
        // This is necessary because the layout manager does not allow to replace
        // a component at a certain index.
<span class="fc" id="L363">        _internal.remove(index);</span>
        // We have to re-add the entry panel at the same index
        // because the layout manager will otherwise add it at the end.
<span class="fc" id="L366">        _internal.add(newEntryPanel, index);</span>
<span class="fc" id="L367">        this.validate();</span>
<span class="fc" id="L368">    }</span>

    /**
     *  Use this to find an entry component.
     *
     * @param type The component type which ought to be found.
     * @param condition A predicate which ought to return true for this method to yield the found entry panel.
     * @param &lt;T&gt; The component type which ought to be found.
     * @return The found entry panel matching the provided type class and predicate lambda.
     */
    private &lt;T extends JComponent&gt; @Nullable EntryPanel get(
            Class&lt;T&gt; type, Predicate&lt;EntryPanel&gt; condition
    ) {
<span class="nc" id="L381">        Objects.requireNonNull(type);</span>
<span class="nc" id="L382">        Objects.requireNonNull(condition);</span>
<span class="nc" id="L383">        return</span>
<span class="nc" id="L384">            Arrays.stream(_internal.getComponents())</span>
<span class="nc" id="L385">                    .filter(Objects::nonNull)</span>
<span class="nc" id="L386">                    .map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L387">                    .filter( c -&gt; type.isAssignableFrom(c.getLastState().getClass()) )</span>
<span class="nc" id="L388">                    .filter( c -&gt; condition.test(c) )</span>
<span class="nc" id="L389">                    .findFirst()</span>
<span class="nc" id="L390">                    .orElse(null);</span>
    }

    /**
     *  Use this to find an entry component.
     *
     * @param type The component type which ought to be found.
     * @param &lt;T&gt; The component type which ought to be found.
     * @return The found entry panel matching the provided type class and predicate lambda.
     */
    public &lt;T extends JComponent&gt; Optional&lt;T&gt; getSelected( Class&lt;T&gt; type ) {
<span class="nc" id="L401">        Objects.requireNonNull(type);</span>
<span class="nc" id="L402">        Objects.requireNonNull(type);</span>
<span class="nc" id="L403">        return (Optional&lt;T&gt;) Optional.ofNullable(get(type, EntryPanel::isEntrySelected)).map(e -&gt; e.getLastState() );</span>
    }

    /**
     *  Use this to iterate over all panel list entries.
     *
     * @param action The action which ought to be applied to all {@link JScrollPanels} entries.
     */
    public void forEachEntry( Consumer&lt;EntryPanel&gt; action ) {
<span class="nc" id="L412">        Objects.requireNonNull(action);</span>
<span class="nc" id="L413">        Arrays.stream(_internal.getComponents())</span>
<span class="nc" id="L414">                .map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L415">                .forEach(action);</span>
<span class="nc" id="L416">    }</span>

    /**
     *  Use this to iterate over all panel list entries of a certain type
     *  by supplying a type class and a consumer action.
     *  Neither of the two parameters may be null!
     *
     * @param type The type of the entry which ought to be iterated over.
     * @param action The action which ought to be applied to all {@link JScrollPanels} entries of the given type.
     * @param &lt;T&gt; The entry value type parameter.
     */
    public &lt;T extends JComponent&gt; void forEachEntry(Class&lt;T&gt; type, Consumer&lt;EntryPanel&gt; action) {
<span class="nc" id="L428">        Objects.requireNonNull(type);</span>
<span class="nc" id="L429">        Objects.requireNonNull(action);</span>
<span class="nc" id="L430">        Arrays.stream(_internal.getComponents())</span>
<span class="nc" id="L431">                .map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L432">                .filter( e -&gt; type.isAssignableFrom(e.getLastState().getClass()) )</span>
<span class="nc" id="L433">                .forEach(action);</span>
<span class="nc" id="L434">    }</span>

    /**
     *  Use this to set entries as selected based on a condition lambda (predicate).
     * @param type The type of the entry which ought to be selected.
     * @param condition The condition which ought to be met for the entry to be selected.
     * @param &lt;T&gt; The type of the entry which ought to be selected.
     */
    public &lt;T extends JComponent&gt; void setSelectedFor(Class&lt;T&gt; type, Predicate&lt;T&gt; condition) {
<span class="nc" id="L443">        forEachEntry( e -&gt; e.setEntrySelected(false) );</span>
<span class="nc" id="L444">        forEachEntry(type, e -&gt; {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if ( condition.test((T) e.getLastState()) ) e.setEntrySelected(true);</span>
<span class="nc" id="L446">        });</span>
<span class="nc" id="L447">    }</span>

    private &lt;M extends EntryViewModel&gt; EntryPanel _createEntryPanel(
        @Nullable AddConstraint constraints,
        M viewModel,
        ViewSupplier&lt;M&gt; viewSupplier,
        int index
    ) {
<span class="fc" id="L455">        Function&lt;Boolean, JComponent&gt; indexedViewSupplier = EntryPanel.providerFrom(index, viewModel, viewSupplier);</span>
<span class="fc" id="L456">        JComponent initialView = indexedViewSupplier.apply(false);</span>
        // Let's see if we can avoid recreating an entry:
<span class="fc" id="L458">        int numberOfExistingComponents = _internal.getComponentCount();</span>
<span class="fc bfc" id="L459" title="All 4 branches covered.">        if ( numberOfExistingComponents &gt; 0 &amp;&amp; numberOfExistingComponents &gt; index ) {</span>
<span class="fc" id="L460">            Component found = _internal.getComponent(index);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            if ( !(found instanceof EntryPanel) ) {</span>
<span class="nc" id="L462">                log.error(SwingTree.get().logMarker(),</span>
                        &quot;Encountered illegal child component '{}' in '{}'.&quot;,
                        found, JScrollPanels.class,
                        new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                    );
            } else {
<span class="fc" id="L468">                EntryPanel existingEntry = (EntryPanel) found;</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                if ( existingEntry.getComponentCount() == 0 ) {</span>
<span class="nc" id="L470">                    log.error(SwingTree.get().logMarker(),</span>
                            &quot;Existing entry panel '{}' about to be replaced by new view '{}' in '{}' is missing its view.&quot;,
                            existingEntry, initialView, JScrollPanels.class,
                            new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                        );
                } else {
<span class="fc" id="L476">                    Component existingView = existingEntry.getComponent(0);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                    if ( existingView == initialView )</span>
<span class="fc" id="L478">                        return existingEntry; // The view is already there</span>
                }
            }
        }
<span class="pc" id="L482">        Supplier&lt;List&lt;EntryPanel&gt;&gt; components = ()-&gt; _entriesIn(_internal.getComponents());</span>
<span class="fc" id="L483">        return new EntryPanel(</span>
                        components,
                        index,
                        viewModel,
                        initialView,
                        indexedViewSupplier,
                        constraints
                    );
    }

    /**
     *  This panel holds the list panels.
     *  It wraps {@link EntryPanel} instances which themselves
     *  wrap user provided {@link JPanel} implementations rendering the actual content.
     */
    private static class InternalPanel extends JBox implements Scrollable
    {
        private final int _W, _H, _horizontalGap, _verticalGap;
        private final UI.Align _type;
        private final Dimension _size;


        private InternalPanel(
            List&lt;EntryPanel&gt; entryPanels,
            @Nullable Dimension shape,
            UI.Align type
<span class="fc" id="L509">        ) {</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            shape = ( shape == null ? new Dimension(120, 100) : shape );</span>
<span class="fc" id="L511">            int n = entryPanels.size() / 2;</span>
<span class="fc" id="L512">            _W = (int) shape.getWidth(); // 120</span>
<span class="fc" id="L513">            _H = (int) shape.getHeight(); // 100</span>
<span class="fc" id="L514">            _type = type;</span>
            LayoutManager layout;
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">            if ( type == UI.Align.HORIZONTAL ) {</span>
<span class="nc" id="L517">                ResponsiveGridFlowLayout flow = new ResponsiveGridFlowLayout();</span>
<span class="nc" id="L518">                _horizontalGap = flow.horizontalGapSize();</span>
<span class="nc" id="L519">                _verticalGap = flow.verticalGapSize();</span>
<span class="nc" id="L520">                layout = flow;</span>
<span class="nc" id="L521">            } else {</span>
<span class="fc" id="L522">                BoxLayout box = new BoxLayout(this, BoxLayout.Y_AXIS);</span>
<span class="fc" id="L523">                _horizontalGap = 5;</span>
<span class="fc" id="L524">                _verticalGap = 5;</span>
<span class="fc" id="L525">                layout = box;</span>
            }
<span class="fc" id="L527">            setLayout(layout);</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            for ( EntryPanel c : entryPanels ) this.add(c);</span>

<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            if ( type == UI.Align.HORIZONTAL )</span>
<span class="nc" id="L531">                _size = new Dimension(n * _W + (n + 1) * _horizontalGap, _H + 2 * _verticalGap);</span>
            else
<span class="fc" id="L533">                _size = new Dimension(_W + 2 * _horizontalGap, n * _H + (n + 1) * _verticalGap);</span>

<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            for ( EntryPanel c : entryPanels )</span>
<span class="nc" id="L536">                c.addMouseListener(</span>
<span class="nc" id="L537">                    new MouseAdapter() {</span>
                        @Override
                        public void mouseClicked(MouseEvent e) {
<span class="nc" id="L540">                            entryPanels.forEach( entry -&gt; entry.setEntrySelected(false) );</span>
<span class="nc" id="L541">                            c.setEntrySelected(true);</span>
<span class="nc" id="L542">                        }</span>
                    }
                );

<span class="fc" id="L546">            setOpaque(false);</span>
<span class="fc" id="L547">            setBackground(Color.PINK);</span>
<span class="fc" id="L548">        }</span>

<span class="fc" id="L550">        @Override public Dimension getPreferredScrollableViewportSize() { return _size; }</span>

        @Override
        public Dimension getPreferredSize() {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if ( _type == UI.Align.VERTICAL )</span>
<span class="fc" id="L555">                return new Dimension(</span>
<span class="fc" id="L556">                            Math.max(_W, getParent().getWidth()),</span>
<span class="fc" id="L557">                            (int) super.getPreferredSize().getHeight()</span>
                        );
            else
<span class="nc" id="L560">                return new Dimension(</span>
<span class="nc" id="L561">                            (int) super.getPreferredSize().getWidth(),</span>
<span class="nc" id="L562">                            Math.max(_H, getParent().getHeight())</span>
                        );
        }

        @Override
        public int getScrollableUnitIncrement(
                Rectangle visibleRect, int orientation, int direction
        ) {
<span class="nc" id="L570">            return _incrementFrom(orientation);</span>
        }

        @Override
        public int getScrollableBlockIncrement(
                Rectangle visibleRect, int orientation, int direction
        ) {
<span class="nc" id="L577">            return _incrementFrom(orientation) / 2;</span>
        }

<span class="nc bnc" id="L580" title="All 2 branches missed.">        private int _incrementFrom(int orientation) { return orientation == JScrollBar.HORIZONTAL ? _W + _horizontalGap : _H + _verticalGap; }</span>

<span class="fc" id="L582">        @Override public boolean getScrollableTracksViewportWidth()  { return false; }</span>
<span class="fc" id="L583">        @Override public boolean getScrollableTracksViewportHeight() { return false; }</span>
    }

    /**
     *  Filters the entry panels from the provided components array.
     */
    private static List&lt;EntryPanel&gt; _entriesIn(Component[] components) {
<span class="nc" id="L590">        return Arrays.stream(components)</span>
<span class="nc" id="L591">                .filter( c -&gt; c instanceof EntryPanel )</span>
<span class="nc" id="L592">                .map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L593">                .collect(Collectors.toList());</span>
    }

    /**
     *     Instances of this are entries of this {@link JScrollPanels}.
     *     {@link EntryPanel}s themselves are wrappers for whatever content should be displayed
     *     by the UI provided by {@link ViewSupplier}s wrapped by {@link EntryPanel}s.
     *     The {@link ViewSupplier} turn whatever kind of view model the user provides into
     *     a {@link JComponent} which is then wrapped by an {@link EntryPanel}.
     */
    public static class EntryPanel extends JBox
    {
<span class="fc" id="L605">        private static final Color HIGHLIGHT = Color.GREEN;</span>
<span class="fc" id="L606">        private static final Color LOW_LIGHT = Color.WHITE;</span>
        private final Function&lt;Boolean, JComponent&gt; _provider;
        private final EntryViewModel _viewable;
        private boolean _isSelected;
        private JComponent _lastState;


        static &lt;M extends EntryViewModel&gt; Function&lt;Boolean, JComponent&gt; providerFrom(
            int position,
            M viewModel,
            ViewSupplier&lt;M&gt; viewSupplier
        ) {
<span class="fc" id="L618">            return (Boolean isSelected) -&gt; {</span>
<span class="fc" id="L619">                viewModel.position().set(From.VIEW, position);</span>
<span class="fc" id="L620">                viewModel.isSelected().set(From.VIEW, isSelected);</span>
<span class="fc" id="L621">                UIForAnySwing&lt;?,?&gt; view = null;</span>
                try {
<span class="fc" id="L623">                    view = viewSupplier.createViewFor(viewModel);</span>
<span class="nc" id="L624">                } catch (Exception e) {</span>
<span class="nc" id="L625">                    log.error(SwingTree.get().logMarker(), &quot;Failed to create view for entry &quot; + viewModel, e);</span>
<span class="fc" id="L626">                }</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">                if ( view == null )</span>
<span class="nc" id="L628">                    view = UI.box(); // We return an empty box if the view is null.</span>
<span class="fc" id="L629">                return view.get((Class) view.getType());</span>
            };
        }

        private &lt;M extends EntryViewModel&gt; EntryPanel(
            Supplier&lt;List&lt;EntryPanel&gt;&gt; components,
            int position,
            M viewModel,
            ViewSupplier&lt;M&gt; viewSupplier,
            @Nullable AddConstraint constraints
        ) {
<span class="nc" id="L640">            this(</span>
<span class="nc" id="L641">                Objects.requireNonNull(components),</span>
                position,
<span class="nc" id="L643">                Objects.requireNonNull(viewModel),</span>
<span class="nc" id="L644">                providerFrom(position, viewModel, viewSupplier),</span>
                constraints
            );
<span class="nc" id="L647">        }</span>

        private &lt;M extends EntryViewModel&gt; EntryPanel(
            Supplier&lt;List&lt;EntryPanel&gt;&gt; components,
            int position,
            M provider,
            Function&lt;Boolean, JComponent&gt; viewSupplier,
            @Nullable AddConstraint constraints
        ) {
<span class="nc" id="L656">            this(</span>
                components,
                position,
                provider,
<span class="nc" id="L660">                viewSupplier.apply(false),</span>
                viewSupplier,
                constraints
            );
<span class="nc" id="L664">        }</span>

        private &lt;M extends EntryViewModel&gt; EntryPanel(
            Supplier&lt;List&lt;EntryPanel&gt;&gt; components,
            int position,
            M provider,
            JComponent lastState,
            Function&lt;Boolean, JComponent&gt; viewSupplier,
            @Nullable AddConstraint constraints
<span class="fc" id="L673">        ) {</span>
<span class="fc" id="L674">            Objects.requireNonNull(components);</span>
<span class="fc" id="L675">            Objects.requireNonNull(provider);</span>
            // We make the entry panel fit the outer (public) scroll panel.
<span class="fc" id="L677">            this.setLayout(new MigLayout(&quot;fill, insets 0&quot;, &quot;[grow]&quot;));</span>
<span class="fc" id="L678">            _viewable = provider;</span>
<span class="fc" id="L679">            _provider = viewSupplier;</span>
<span class="fc" id="L680">            _lastState = lastState;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            if ( _lastState.getParent() != null ) {</span>
<span class="fc" id="L682">                Container parent = _lastState.getParent();</span>
<span class="fc" id="L683">                log.error(SwingTree.get().logMarker(),</span>
                            &quot;View supplier in {} class supplied a view which is already tied to another parent {}.&quot;,
<span class="fc" id="L685">                            JScrollPanels.class.getSimpleName(), parent,</span>
                            new Throwable(&quot;Stack trace for debugging purposes.&quot;)
                        );
            }
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">            this.add(_lastState, constraints != null ? constraints.toConstraintForLayoutManager() : &quot;grow&quot; );</span>

<span class="fc" id="L691">            ComponentExtension.from(this).storeBoundObservable(</span>
<span class="pc" id="L692">                    _viewable.isSelected().view().onChange(From.VIEW_MODEL, it -&gt; _selectThis(components) )</span>
                );
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">            if ( _viewable.isSelected().is(true) )</span>
<span class="nc" id="L695">                _selectThis(components);</span>
<span class="fc" id="L696">            _viewable.position().set(From.VIEW, position);</span>
<span class="fc" id="L697">        }</span>

        private void _selectThis(
                Supplier&lt;List&lt;EntryPanel&gt;&gt; components
        ) {
<span class="nc" id="L702">            SwingUtilities.invokeLater( () -&gt; {</span>
<span class="nc" id="L703">                        components.get()</span>
<span class="nc" id="L704">                                .stream()</span>
<span class="nc" id="L705">                                .forEach( entry -&gt; entry.setEntrySelected(false) );</span>
<span class="nc" id="L706">                        setEntrySelected(true);</span>
<span class="nc" id="L707">                    }</span>
            );
<span class="nc" id="L709">        }</span>

        /**
         *  The last state of this entry panel is the view which was most recently set.
         * @return The last state of this entry panel.
         */
<span class="nc" id="L715">        public JComponent getLastState() { return _lastState; }</span>

<span class="nc" id="L717">        public boolean isEntrySelected() { return _isSelected; }</span>

        public void setEntrySelected(Boolean isHighlighted) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">            if ( _isSelected != isHighlighted ) {</span>
<span class="nc" id="L721">                this.remove(_lastState);</span>
                try {
<span class="nc" id="L723">                    _lastState = _provider.apply(isHighlighted);</span>
<span class="nc" id="L724">                } catch (Exception e) {</span>
<span class="nc" id="L725">                    log.error(SwingTree.get().logMarker(), &quot;Failed to create view for entry: &quot; + this, e);</span>
<span class="nc" id="L726">                }</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                this.setBackground( isHighlighted ? HIGHLIGHT : LOW_LIGHT );</span>
<span class="nc" id="L728">                this.add(_lastState, &quot;grow&quot;);</span>
<span class="nc" id="L729">                this.validate();</span>
<span class="nc" id="L730">                _viewable.isSelected().set(From.VIEW, isHighlighted);</span>
            }
<span class="nc" id="L732">            _isSelected = isHighlighted;</span>
<span class="nc" id="L733">        }</span>

<span class="fc" id="L735">        @Override public String toString() { return &quot;EntryPanel[&quot; + _lastState + &quot;]&quot;; }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>