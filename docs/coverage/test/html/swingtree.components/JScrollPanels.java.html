<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JScrollPanels.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.components</a> &gt; <span class="el_source">JScrollPanels.java</span></div><h1>JScrollPanels.java</h1><pre class="source lang-java linenums">package swingtree.components;

import net.miginfocom.swing.MigLayout;
import org.slf4j.Logger;
import sprouts.From;
import swingtree.UI;
import swingtree.api.mvvm.EntryViewModel;
import swingtree.api.mvvm.ViewSupplier;
import swingtree.components.listener.NestedJScrollPanelScrollCorrection;
import swingtree.style.ComponentExtension;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * 	The {@link JScrollPanels} class is a container for a list of scrollable UI components
 * 	representing view models or simple data models which are dynamically turned into
 * 	views by a {@link ViewSupplier}.
 *  This class exists to compensate for the deficits of the {@link JList} and {@link JTable} components,
 *  whose entries are not able to receive user events like for example mouse events, button clicks etc...
 * 	&lt;br&gt;
 * 	A {@link JScrollPanels} instance can arrange its entries in a vertical or horizontal manner
 * 	based on the {@link UI.Align} parameter.
 * 	&lt;br&gt;&lt;br&gt;
 * 	Instances of this store view model implementations in a view model property list
 * 	so that they can dynamically be turned into views by a {@link ViewSupplier} lambda
 * 	when the list changes its state. &lt;br&gt;
 * 	Here a simple example demonstrating the usage of the {@link JScrollPanels} class
 * 	through the Swing-Tree API:
 * 	&lt;pre&gt;{@code
 *    UI.scrollPanels()
 *    .add(viewModel.entries(), entry -&gt;
 *        UI.panel().add(UI.button(&quot;Click me! :)&quot;))
 *    )
 * 	}&lt;/pre&gt;
 * 	...where {@code entries()} is a method returning a {@link sprouts.Vars} instance
 * 	which contains a list of your sub-view models.
 * 	The second parameter of the {@link swingtree.UIForScrollPanels#add(sprouts.Vals, ViewSupplier)} method is a lambda
 *  which takes a single view model from the list of view models and turns it into a view.
 */
public class JScrollPanels extends JScrollPane
{
<span class="fc" id="L53">	private static final Logger log = org.slf4j.LoggerFactory.getLogger(JScrollPanels.class);</span>

	/**
	 * 	Constructs a new {@link JScrollPanels} instance with the provided alignment and size.
	 * 	@param align The alignment of the entries inside this {@link JScrollPanels} instance.
	 * 				 The alignment can be either {@link UI.Align#HORIZONTAL} or {@link UI.Align#VERTICAL}.
	 * @param size The size of the entries in this {@link JScrollPanels} instance.
	 * @return A new {@link JScrollPanels} instance.
	 */
	public static JScrollPanels of(
		UI.Align align, Dimension size
	) {
<span class="fc" id="L65">		Objects.requireNonNull(align);</span>
<span class="pc" id="L66">		return _construct(align, size, Collections.emptyList(), null, m -&gt; UI.panel());</span>
	}

	private static JScrollPanels _construct(
		UI.Align align,
		Dimension shape,
		List&lt;EntryViewModel&gt; models,
		String constraints,
		ViewSupplier&lt;EntryViewModel&gt; viewSupplier
	) {
<span class="fc" id="L76">		UI.Align type = align;</span>
<span class="fc" id="L77">		InternalPanel[] forwardReference = {null};</span>
<span class="fc" id="L78">		List&lt;EntryPanel&gt; entries =</span>
<span class="fc" id="L79">				IntStream.range(0,models.size())</span>
<span class="fc" id="L80">						.mapToObj( i -&gt;</span>
<span class="nc" id="L81">							new EntryPanel(</span>
<span class="nc" id="L82">									()-&gt; _entriesIn(forwardReference[0].getComponents()),</span>
									i,
<span class="nc" id="L84">									models.get(i),</span>
									viewSupplier,
									constraints
								)
						)
<span class="fc" id="L89">						.collect(Collectors.toList());</span>


<span class="fc" id="L92">		InternalPanel internalWrapperPanel = new InternalPanel(entries, shape, type);</span>
<span class="fc" id="L93">		JScrollPanels newJScrollPanels = new JScrollPanels(internalWrapperPanel);</span>
<span class="fc" id="L94">		forwardReference[0] = internalWrapperPanel;</span>

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">		if ( type == UI.Align.HORIZONTAL )</span>
<span class="nc" id="L97">			newJScrollPanels.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);</span>
		else
<span class="fc" id="L99">			newJScrollPanels.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);</span>

<span class="fc" id="L101">		return newJScrollPanels;</span>
	}


	private final InternalPanel _internal; // Wrapper for the actual UI components


	private JScrollPanels(InternalPanel listWrapper) {
<span class="fc" id="L109">		super(listWrapper);</span>
<span class="fc" id="L110">		_internal = listWrapper;</span>
<span class="fc" id="L111">		this.addMouseWheelListener(new NestedJScrollPanelScrollCorrection(this));</span>
<span class="fc" id="L112">	}</span>

	/** {@inheritDoc} */
	@Override public void paint(Graphics g){
<span class="nc" id="L116">		ComponentExtension.from(this).paintBackgroundStyle( g );</span>
<span class="nc" id="L117">		super.paint(g);</span>
<span class="nc" id="L118">	}</span>

	/** {@inheritDoc} */
	@Override public void paintChildren(Graphics g){
<span class="nc" id="L122">		super.paintChildren(g);</span>
<span class="nc" id="L123">		ComponentExtension.from(this).paintForegroundStyle( (Graphics2D) g );</span>
<span class="nc" id="L124">	}</span>

	/**
	 * @return The number of entries which are currently managed by this {@link JScrollPanels}.
	 */
<span class="nc" id="L129">	public int getNumberOfEntries() { return _internal.getComponents().length; }</span>

	/**
	 * 	The {@link JScrollPanels} does not store components statically in the UI tree.
	 * 	Instead, it is a hybrid of the traditional static approach
	 * 	and a renderer based approach (as in the {@link JList}).
	 * 	The lambda passed to this method is responsible for continuously supplying a UI
	 * 	which fits a certain context (which defines if the entry is selected or not among other things).
	 *
	 * @param entryViewModel A view model which ought to be added.
	 * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
	 * @param &lt;M&gt; The type of the entry view model.
	 */
	public &lt;M extends EntryViewModel&gt; void addEntry( M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L143">		Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L144">		EntryPanel entryPanel = _createEntryPanel(null, entryViewModel, viewSupplier, _internal.getComponents().length);</span>
<span class="fc" id="L145">		_internal.add(entryPanel);</span>
<span class="fc" id="L146">	}</span>

	/**
	 * 	The {@link JScrollPanels} does not store components statically in the UI tree.
	 * 	Instead, it is a hybrid of the traditional static approach
	 * 	and a renderer based approach (as in the {@link JList}).
	 * 	The view supplier lambda passed to this method is responsible for continuously supplying a UI
	 * 	which fits a certain context (which defines if the entry is selected or not among other things).
	 *
	 * @param constraints The constraints which ought to be applied to the entry.
	 * @param entryViewModel The entry model which ought to be added.
	 * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
	 * @param &lt;M&gt; The type of the entry view model.
	 */
	public &lt;M extends EntryViewModel&gt; void addEntry( String constraints, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="nc" id="L161">		Objects.requireNonNull(entryViewModel);</span>
<span class="nc" id="L162">		EntryPanel entryPanel = _createEntryPanel(constraints, entryViewModel, viewSupplier, _internal.getComponents().length);</span>
<span class="nc" id="L163">		_internal.add(entryPanel);</span>
<span class="nc" id="L164">		this.validate();</span>
<span class="nc" id="L165">	}</span>

	/**
	 *  Adds multiple entries at once to this {@link JScrollPanels}.
	 * @param constraints The constraints which ought to be applied to the entry.
	 * @param entryViewModels A list of entry models which ought to be added.
	 * @param viewSupplier A provider lambda which ought to turn a context object into a fitting UI.
	 * @param &lt;M&gt; The type of the entry view model.
	 */
	public &lt;M extends EntryViewModel&gt; void addAllEntries( String constraints, List&lt;M&gt; entryViewModels, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L175">		Objects.requireNonNull(entryViewModels);</span>
<span class="fc" id="L176">		List&lt;EntryPanel&gt; entryPanels = IntStream.range(0, entryViewModels.size())</span>
<span class="fc" id="L177">				.mapToObj(</span>
<span class="fc" id="L178">						i -&gt; _createEntryPanel(</span>
								constraints,
<span class="fc" id="L180">								entryViewModels.get(i),</span>
								viewSupplier,
<span class="fc" id="L182">								_internal.getComponents().length + i</span>
						)
				)
<span class="fc" id="L185">				.collect(Collectors.toList());</span>

<span class="fc" id="L187">		entryPanels.forEach(_internal::add);</span>
<span class="fc" id="L188">		this.validate();</span>
<span class="fc" id="L189">	}</span>

	/**
	 * 	Use this to remove all entries.
	 */
	public void removeAllEntries() {
<span class="nc" id="L195">		_internal.removeAll();</span>
<span class="nc" id="L196">		this.validate();</span>
<span class="nc" id="L197">	}</span>

	/**
	 * 	Use this to remove an entry at a certain index.
	 * @param index The index of the entry which ought to be removed.
	 */
	public void removeEntryAt( int index ) {
<span class="fc" id="L204">		_internal.remove(index);</span>
<span class="fc" id="L205">		this.validate();</span>
<span class="fc" id="L206">	}</span>

	/**
	 * 	Use this to add an entry at a certain index.
	 *
	 *  @param index The index at which the entry ought to be added.
	 *  @param attr The constraints which ought to be applied to the entry, may be null.
	 *  @param entryViewModel The entry view model which ought to be added.
	 *  @param viewSupplier The supplier which is used to create the view for the given entry view model.
	 *  @param &lt;M&gt; The type of the entry view model.
	 */
	public &lt;M extends EntryViewModel&gt; void addEntryAt( int index, String attr, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="fc" id="L218">		Objects.requireNonNull(entryViewModel);</span>
<span class="fc" id="L219">		EntryPanel entryPanel = _createEntryPanel(attr, entryViewModel, viewSupplier, index);</span>
<span class="fc" id="L220">		_internal.add(entryPanel, index);</span>
<span class="fc" id="L221">		this.validate();</span>
<span class="fc" id="L222">	}</span>

	/**
	 * 	Use this to replace an entry at a certain index. &lt;br&gt;
	 * 	Note: This method will replace an existing entry at the given index.
	 *
	 *  @param index The index at which the entry ought to be placed.
	 *  @param attr The constraints which ought to be applied to the entry, may be null.
	 *  @param entryViewModel The entry view model which ought to be added.
	 *  @param viewSupplier The supplier which is used to create the view for the given entry view model.
	 *  @param &lt;M&gt; The type of the entry view model.
	 */
	public &lt;M extends EntryViewModel&gt; void setEntryAt( int index, String attr, M entryViewModel, ViewSupplier&lt;M&gt; viewSupplier) {
<span class="nc" id="L235">		Objects.requireNonNull(entryViewModel);</span>
<span class="nc" id="L236">		EntryPanel entryPanel = _createEntryPanel(attr, entryViewModel, viewSupplier, index);</span>
		// We first remove the old entry panel and then add the new one.
		// This is necessary because the layout manager does not allow to replace
		// a component at a certain index.
<span class="nc" id="L240">		_internal.remove(index);</span>
		// We have to re-add the entry panel at the same index
		// because the layout manager will otherwise add it at the end.
<span class="nc" id="L243">		_internal.add(entryPanel, index);</span>
<span class="nc" id="L244">		this.validate();</span>
<span class="nc" id="L245">	}</span>

	/**
	 * 	Use this to find an entry component.
	 *
	 * @param type The component type which ought to be found.
	 * @param condition A predicate which ought to return true for this method to yield the found entry panel.
	 * @param &lt;T&gt; The component type which ought to be found.
	 * @return The found entry panel matching the provided type class and predicate lambda.
	 */
	private &lt;T extends JComponent&gt; EntryPanel get(
			Class&lt;T&gt; type, Predicate&lt;EntryPanel&gt; condition
	) {
<span class="nc" id="L258">		Objects.requireNonNull(type);</span>
<span class="nc" id="L259">		Objects.requireNonNull(condition);</span>
<span class="nc" id="L260">		return</span>
<span class="nc" id="L261">			Arrays.stream(_internal.getComponents())</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">					.filter( c -&gt; c != null )</span>
<span class="nc" id="L263">					.map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L264">					.filter( c -&gt; type.isAssignableFrom(c.getLastState().getClass()) )</span>
<span class="nc" id="L265">					.filter( c -&gt; condition.test(c) )</span>
<span class="nc" id="L266">					.findFirst()</span>
<span class="nc" id="L267">					.orElse(null);</span>
	}

	/**
	 * 	Use this to find an entry component.
	 *
	 * @param type The component type which ought to be found.
	 * @param &lt;T&gt; The component type which ought to be found.
	 * @return The found entry panel matching the provided type class and predicate lambda.
	 */
	public &lt;T extends JComponent&gt; Optional&lt;T&gt; getSelected( Class&lt;T&gt; type ) {
<span class="nc" id="L278">		Objects.requireNonNull(type);</span>
<span class="nc" id="L279">		Objects.requireNonNull(type);</span>
<span class="nc" id="L280">		return (Optional&lt;T&gt;) Optional.ofNullable(get(type, EntryPanel::isEntrySelected)).map(e -&gt; e.getLastState() );</span>
	}

	/**
	 * 	Use this to iterate over all panel list entries.
	 *
	 * @param action The action which ought to be applied to all {@link JScrollPanels} entries.
	 */
	public void forEachEntry( Consumer&lt;EntryPanel&gt; action ) {
<span class="nc" id="L289">		Objects.requireNonNull(action);</span>
<span class="nc" id="L290">		Arrays.stream(_internal.getComponents())</span>
<span class="nc" id="L291">				.map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L292">				.forEach(action);</span>
<span class="nc" id="L293">	}</span>

	/**
	 * @param type The type of the entry which ought to be iterated over.
	 * @param action The action which ought to be applied to all {@link JScrollPanels} entries of the given type.
	 * @param &lt;T&gt; The entry value type parameter.
	 */
	public &lt;T extends JComponent&gt; void forEachEntry(Class&lt;T&gt; type, Consumer&lt;EntryPanel&gt; action) {
<span class="nc" id="L301">		Objects.requireNonNull(type);</span>
<span class="nc" id="L302">		Objects.requireNonNull(action);</span>
<span class="nc" id="L303">		Arrays.stream(_internal.getComponents())</span>
<span class="nc" id="L304">				.map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L305">				.filter( e -&gt; type.isAssignableFrom(e.getLastState().getClass()) )</span>
<span class="nc" id="L306">				.forEach(action);</span>
<span class="nc" id="L307">	}</span>

	/**
	 *  Use this to set entries as selected based on a condition lambda (predicate).
	 * @param type The type of the entry which ought to be selected.
	 * @param condition The condition which ought to be met for the entry to be selected.
	 * @param &lt;T&gt; The type of the entry which ought to be selected.
	 */
	public &lt;T extends JComponent&gt; void setSelectedFor(Class&lt;T&gt; type, Predicate&lt;T&gt; condition) {
<span class="nc" id="L316">		forEachEntry( e -&gt; e.setEntrySelected(false) );</span>
<span class="nc" id="L317">		forEachEntry(type, e -&gt; {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if ( condition.test((T) e.getLastState()) ) e.setEntrySelected(true);</span>
<span class="nc" id="L319">		});</span>
<span class="nc" id="L320">	}</span>

	private &lt;M extends EntryViewModel&gt; EntryPanel _createEntryPanel(
		String constraints,
		M entryProvider,
		ViewSupplier&lt;M&gt; viewSupplier,
		int index
	) {
<span class="fc" id="L328">		Objects.requireNonNull(entryProvider);</span>
<span class="fc" id="L329">		return new EntryPanel(</span>
<span class="nc" id="L330">						()-&gt; _entriesIn(_internal.getComponents()),</span>
						index,
						entryProvider,
						viewSupplier,
						constraints
					);
	}

	/**
	 * 	This panel holds the list panels.
	 * 	It wraps {@link EntryPanel} instances which themselves
	 * 	wrap user provided {@link JPanel} implementations rendering the actual content.
	 */
	private static class InternalPanel extends JPanel implements Scrollable
	{
		private final int _W, _H, _horizontalGap, _verticalGap;
		private final UI.Align _type;
		private final Dimension _size;


		private InternalPanel(
				List&lt;EntryPanel&gt; entryPanels,
				Dimension shape,
				UI.Align type
<span class="fc" id="L354">		) {</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">			shape = ( shape == null ? new Dimension(120, 100) : shape );</span>
<span class="fc" id="L356">			int n = entryPanels.size() / 2;</span>
<span class="fc" id="L357">			_W = (int) shape.getWidth(); // 120</span>
<span class="fc" id="L358">			_H = (int) shape.getHeight(); // 100</span>
<span class="fc" id="L359">			_type = type;</span>
			LayoutManager layout;
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">			if ( type == UI.Align.HORIZONTAL ) {</span>
<span class="nc" id="L362">				FlowLayout flow = new FlowLayout();</span>
<span class="nc" id="L363">				_horizontalGap = flow.getHgap();</span>
<span class="nc" id="L364">				_verticalGap = flow.getVgap();</span>
<span class="nc" id="L365">				layout = flow;</span>
<span class="nc" id="L366">			} else {</span>
<span class="fc" id="L367">				BoxLayout box = new BoxLayout(this, BoxLayout.Y_AXIS);</span>
<span class="fc" id="L368">				_horizontalGap = 5;</span>
<span class="fc" id="L369">				_verticalGap = 5;</span>
<span class="fc" id="L370">				layout = box;</span>
			}
<span class="fc" id="L372">			setLayout(layout);</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">			for ( EntryPanel c : entryPanels ) this.add(c);</span>

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">			if ( type == UI.Align.HORIZONTAL )</span>
<span class="nc" id="L376">				_size = new Dimension(n * _W + (n + 1) * _horizontalGap, _H + 2 * _verticalGap);</span>
			else
<span class="fc" id="L378">				_size = new Dimension(_W + 2 * _horizontalGap, n * _H + (n + 1) * _verticalGap);</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">			for ( EntryPanel c : entryPanels ) {</span>
<span class="nc" id="L381">				c.addMouseListener(</span>
<span class="nc" id="L382">						new MouseAdapter() {</span>
							@Override
							public void mouseClicked(MouseEvent e) {
<span class="nc" id="L385">								entryPanels.forEach( entry -&gt; entry.setEntrySelected(false) );</span>
<span class="nc" id="L386">								c.setEntrySelected(true);</span>
<span class="nc" id="L387">							}</span>
						}
				);
<span class="nc" id="L390">			}</span>
<span class="fc" id="L391">		}</span>

<span class="nc" id="L393">		@Override public Dimension getPreferredScrollableViewportSize() { return _size; }</span>

		@Override
		public Dimension getPreferredSize() {
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if ( _type == UI.Align.VERTICAL )</span>
<span class="nc" id="L398">				return new Dimension(</span>
<span class="nc" id="L399">							Math.max(_W, getParent().getWidth()),</span>
<span class="nc" id="L400">							(int) super.getPreferredSize().getHeight()</span>
						);
			else
<span class="nc" id="L403">				return new Dimension(</span>
<span class="nc" id="L404">							(int) super.getPreferredSize().getWidth(),</span>
<span class="nc" id="L405">							Math.max(_H, getParent().getHeight())</span>
						);
		}

		@Override
		public int getScrollableUnitIncrement(
				Rectangle visibleRect, int orientation, int direction
		) {
<span class="nc" id="L413">			return _incrementFrom(orientation);</span>
		}

		@Override
		public int getScrollableBlockIncrement(
				Rectangle visibleRect, int orientation, int direction
		) {
<span class="nc" id="L420">			return _incrementFrom(orientation) / 2;</span>
		}

<span class="nc bnc" id="L423" title="All 2 branches missed.">		private int _incrementFrom(int orientation) { return orientation == JScrollBar.HORIZONTAL ? _W + _horizontalGap : _H + _verticalGap; }</span>

<span class="nc" id="L425">		@Override public boolean getScrollableTracksViewportWidth()  { return false; }</span>
<span class="nc" id="L426">		@Override public boolean getScrollableTracksViewportHeight() { return false; }</span>
	}

	/**
	 * 	Filters the entry panels from the provided components array.
	 */
	private static List&lt;EntryPanel&gt; _entriesIn(Component[] components) {
<span class="nc" id="L433">		return Arrays.stream(components)</span>
<span class="nc" id="L434">				.filter( c -&gt; c instanceof EntryPanel )</span>
<span class="nc" id="L435">				.map( c -&gt; (EntryPanel) c )</span>
<span class="nc" id="L436">				.collect(Collectors.toList());</span>
	}

	/**
	 * 	Instances of this are entries of this {@link JScrollPanels}.
	 * 	{@link EntryPanel}s themselves are wrappers for whatever content should be displayed
	 * 	by the UI provided by {@link ViewSupplier}s wrapped by {@link EntryPanel}s.
	 * 	The {@link ViewSupplier} turn whatever kind of view model the user provides into
	 * 	a {@link JComponent} which is then wrapped by an {@link EntryPanel}.
	 */
	public static class EntryPanel extends JPanel
	{
<span class="fc" id="L448">		private static final Color HIGHLIGHT = Color.GREEN;</span>
<span class="fc" id="L449">		private static final Color LOW_LIGHT = Color.WHITE;</span>
		private final Function&lt;Boolean, JComponent&gt; _provider;
		private final EntryViewModel _viewable;
		private boolean _isSelected;
		private JComponent _lastState;


		private &lt;M extends EntryViewModel&gt; EntryPanel(
				Supplier&lt;List&lt;EntryPanel&gt;&gt; components,
				int position,
				M provider,
				ViewSupplier&lt;M&gt; viewSupplier,
				String constraints
<span class="fc" id="L462">		) {</span>
<span class="fc" id="L463">			Objects.requireNonNull(components);</span>
<span class="fc" id="L464">			Objects.requireNonNull(provider);</span>
			// We make the entry panel fit the outer (public) scroll panel.
<span class="fc" id="L466">			this.setLayout(new MigLayout(&quot;fill, insets 0&quot;, &quot;[grow]&quot;));</span>
<span class="fc" id="L467">			_viewable = provider;</span>
<span class="fc" id="L468">			_provider = isSelected -&gt; {</span>
<span class="fc" id="L469">								provider.position().set(From.VIEW, position);</span>
<span class="fc" id="L470">								provider.isSelected().set(From.VIEW, isSelected);</span>
<span class="fc" id="L471">								return (JComponent) viewSupplier.createViewFor(provider).getComponent();</span>
							};
<span class="fc" id="L473">			_lastState = _provider.apply(false);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">			this.add(_lastState, constraints != null ? constraints : &quot;grow&quot; );</span>
<span class="pc" id="L475">			_viewable.isSelected().onChange(From.VIEW_MODEL, it -&gt; _selectThis(components) );</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">			if ( _viewable.isSelected().is(true) )</span>
<span class="nc" id="L477">				_selectThis(components);</span>
<span class="fc" id="L478">			_viewable.position().set(From.VIEW, position);</span>
<span class="fc" id="L479">		}</span>

		private void _selectThis(
				Supplier&lt;List&lt;EntryPanel&gt;&gt; components
		) {
<span class="nc" id="L484">			SwingUtilities.invokeLater( () -&gt; {</span>
<span class="nc" id="L485">						components.get()</span>
<span class="nc" id="L486">								.stream()</span>
<span class="nc" id="L487">								.forEach( entry -&gt; entry.setEntrySelected(false) );</span>
<span class="nc" id="L488">						setEntrySelected(true);</span>
<span class="nc" id="L489">					}</span>
			);
<span class="nc" id="L491">		}</span>

<span class="nc" id="L493">		public JComponent getLastState() { return _lastState; }</span>

<span class="nc" id="L495">		public boolean isEntrySelected() { return _isSelected; }</span>

		public void setEntrySelected(Boolean isHighlighted) {
<span class="nc bnc" id="L498" title="All 2 branches missed.">			if ( _isSelected != isHighlighted ) {</span>
<span class="nc" id="L499">				this.remove(_lastState);</span>
				try {
<span class="nc" id="L501">					_lastState = _provider.apply(isHighlighted);</span>
<span class="nc" id="L502">				} catch (Exception e) {</span>
<span class="nc" id="L503">					log.error(&quot;Failed to create view for entry: &quot; + this, e);</span>
<span class="nc" id="L504">				}</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">				this.setBackground( isHighlighted ? HIGHLIGHT : LOW_LIGHT );</span>
<span class="nc" id="L506">				this.add(_lastState, &quot;grow&quot;);</span>
<span class="nc" id="L507">				this.validate();</span>
<span class="nc" id="L508">				_viewable.isSelected().set(From.VIEW, isHighlighted);</span>
			}
<span class="nc" id="L510">			_isSelected = isHighlighted;</span>
<span class="nc" id="L511">		}</span>

<span class="nc" id="L513">		@Override public String toString() { return &quot;EntryPanel[&quot; + _lastState + &quot;]&quot;; }</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>