<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImageConf.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">ImageConf.java</span></div><h1>ImageConf.java</h1><pre class="source lang-java linenums">package swingtree.style;

import com.google.errorprone.annotations.Immutable;
import org.jspecify.annotations.Nullable;
import swingtree.UI;
import swingtree.api.IconDeclaration;
import swingtree.layout.Size;

import javax.swing.ImageIcon;
import java.awt.*;
import java.util.Objects;
import java.util.Optional;

/**
 *  This class represents the style of an image which can be drawn onto the inner
 *  area of a component.
 *  &lt;b&gt;Note that the inner component area is the area enclosed by the border, which
 *  is itself not part of said area!&lt;/b&gt;
 *  &lt;p&gt;
 *  The following properties with their respective purpose are available:
 *  &lt;br&gt;
 *  &lt;ol&gt;
 *      &lt;li&gt;&lt;b&gt;Layer:&lt;/b&gt;
 *          The layer onto which the image will be drawn.
 *          Layers exist to determine the order in which something is drawn onto the component.
 *          Here a list of available layers:
 *          &lt;ul&gt;
 *              &lt;li&gt;{@link swingtree.UI.Layer#BACKGROUND}&lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.Layer#CONTENT}   &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.Layer#BORDER}    &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.Layer#FOREGROUND}&lt;/li&gt;
 *          &lt;/ul&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Primer:&lt;/b&gt;
 *          The primer color of the image style which will
 *          be used as a filler color for the image background.
 *          The background is the inner component area of the component.
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Image:&lt;/b&gt;
 *          The image which will be drawn onto the component,
 *          which may be specified as an instance of {@link Image}, {@link ImageIcon}
 *          or path to an image file (see {@link swingtree.UI#findIcon(String)}).
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Placement:&lt;/b&gt;
 *          The placement type determines where the image will be drawn onto the component.
 *          The following placement options are available:
 *          &lt;ul&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#CENTER} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#TOP_LEFT} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#TOP_RIGHT} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#BOTTOM_LEFT} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#BOTTOM_RIGHT} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#TOP} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#BOTTOM} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#LEFT} &lt;/li&gt;
 *              &lt;li&gt; {@link swingtree.UI.Placement#RIGHT} &lt;/li&gt;
 *          &lt;/ul&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Repeat:&lt;/b&gt;
 *          If this flag is set to {@code true}, then the image may be painted
 *          multiple times so that it fills up the entire inner component area.
 *          There will not be a noticeable effect of this flag if the
 *          image already fills out the inner component area (see {@link #autoFit(boolean)}, {@link #size(int, int)}).
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Fit-Mode:&lt;/b&gt;
 *          If this enum determines how the image will be stretched or shrunk
 *          to fill the inner component area dependent on the specified width and height,
 *          meaning that if the width was not specified explicitly through {@link #width(Integer)}
 *          then the image will be scaled to fit the inner component width,
 *          and if a height was not specified through {@link #height(Integer)} then
 *          the image will be scaled to fit the inner component height. &lt;br&gt;
 *          &lt;b&gt;Note that the inner component area is the area enclosed by the border, which
 *          is itself not part of said area!&lt;/b&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Width and Height:&lt;/b&gt;
 *          These properties allow you to specify the width and height of the image.
 *          If the width or height is not specified, then the image will be drawn
 *          with its original width or height or it will be scaled to fit the inner component area
 *          if {@link #autoFit(boolean)} is set to {@code true}.
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Opacity:&lt;/b&gt;
 *          This property allows you to specify the opacity of the image.
 *          The opacity must be between 0.0f and 1.0f, where 0.0f means that the image is completely transparent
 *          and 1.0f means that the image is completely opaque.
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Padding:&lt;/b&gt;
 *          This property allows you to specify the padding of the image.
 *          The padding is the space between the image and the inner component area.
 *          The padding can be specified for each side of the image individually
 *          or for all sides at once.
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Offset:&lt;/b&gt;
 *          The offset consists of two integers, one for the horizontal offset
 *          and one for the vertical offset. &lt;br&gt;
 *          It allows you to specify the offset of the image from the placement position.
 *          This means that after the image has been placed onto the component,
 *          it will be moved by the specified offset in the horizontal and vertical direction.
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Clip Area:&lt;/b&gt;
 *          The clip area determines onto which part of the component the image will be drawn.
 *          The following clip areas are available:
 *          &lt;ul&gt;
 *              &lt;li&gt;{@link swingtree.UI.ComponentArea#ALL} -
 *              The entire component, which is the union of all other clip
 *              areas ({@code INTERIOR + EXTERIOR + BORDER + CONTENT}).
 *              &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.ComponentArea#INTERIOR} -
 *              The inner component area, which is defined as {@code ALL - EXTERIOR - BORDER}.
 *              &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.ComponentArea#EXTERIOR} -
 *              The outer component area, which can be expressed as {@code ALL - INTERIOR - BORDER},
 *              or {@code ALL - CONTENT}.
 *              &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.ComponentArea#BORDER} -
 *              The border of the component, which is the area between the inner and outer component area
 *              and which can be expressed as {@code ALL - INTERIOR - EXTERIOR}.
 *              &lt;/li&gt;
 *              &lt;li&gt;{@link swingtree.UI.ComponentArea#BODY} -
 *              The body of the component is the inner component area including the border area.
 *              It can be expressed as {@code ALL - EXTERIOR}, or {@code INTERIOR + BORDER}.
 *              &lt;/li&gt;
 *          &lt;/ul&gt;
 *          &lt;b&gt;Note that the inner/interior component area is the area enclosed by (and excluding) the border,
 *          whereas the exterior component area is the area surrounding the border.
 *          The component body area is the interior/inner component area plus the border.&lt;/b&gt;
 *          &lt;p&gt;
 *          The default clip area is {@link swingtree.UI.ComponentArea#BODY}
 *          as this is the area which is most commonly used.
 *      &lt;/li&gt;
 *  &lt;/ol&gt;
 *  &lt;p&gt;
 *  &lt;b&gt;Take a look at the following example:&lt;/b&gt;
 *  &lt;pre&gt;{@code
 *      of(component).withStyle( it -&gt; it
 *          .image( image -&gt; image
 *              .layer(Layer.BACKGROUND)
 *              .image(image)
 *              .placement(Placement.CENTER)
 *              .autoFit(false)
 *              .repeat(true)
 *              .primer(Color.CYAN)
 *              .padding(12)
 *          )
 *      );
 *  }&lt;/pre&gt;
 *  &lt;p&gt;
 *      This will draw the specified image onto the background layer of the component.
 *      The image will be drawn at the center of the inner component area with a padding of 12,
 *      without being scaled to fit the inner component area, instead the size of the image
 *      will be used. &lt;br&gt;
 *      If it does not fill the entire inner component area based on its size, then
 *      it will be repeated across said area, and the primer color
 *      will be used as a filler color for the parts of the image which
 *      are transparent.
 *  &lt;/p&gt;
 **/
@Immutable
@SuppressWarnings(&quot;Immutable&quot;)
public final class ImageConf implements Simplifiable&lt;ImageConf&gt;
{
<span class="fc" id="L161">    static final UI.Layer DEFAULT_LAYER = UI.Layer.BACKGROUND;</span>
<span class="fc" id="L162">    private static final ImageConf _NONE = new ImageConf(</span>
                                                null,
                                                null,
                                                UI.Placement.UNDEFINED,
                                                false,
                                                UI.FitComponent.NO,
<span class="fc" id="L168">                                                Size.unknown(),</span>
                                                1.0f,
<span class="fc" id="L170">                                                Outline.none(),</span>
<span class="fc" id="L171">                                                Offset.none(),</span>
                                                UI.ComponentArea.BODY
                                            );

<span class="fc" id="L175">    static ImageConf none() { return _NONE; }</span>

    static ImageConf of(
        @Nullable Color     primer,
        @Nullable ImageIcon image,
        UI.Placement        placement,
        boolean             repeat,
        UI.FitComponent     fitMode,
        Size                size,
        float               opacity,
        Outline             padding,
        Offset              offset,
        UI.ComponentArea    clipArea
    ) {
<span class="fc" id="L189">        if (</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            Objects.equals( primer, _NONE._primer )   &amp;&amp;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            Objects.equals( image , _NONE._image  )   &amp;&amp;</span>
<span class="pc bpc" id="L192" title="1 of 4 branches missed.">            placement.equals( _NONE._placement ) &amp;&amp;</span>
            repeat   == _NONE._repeat            &amp;&amp;
<span class="fc bfc" id="L194" title="All 2 branches covered.">            fitMode  .equals( _NONE._fitMode   ) &amp;&amp;</span>
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">            size     .equals( _NONE._size      ) &amp;&amp;</span>
            opacity  == _NONE._opacity           &amp;&amp;
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            padding  .equals( _NONE._padding   ) &amp;&amp;</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            offset   .equals( _NONE._offset    ) &amp;&amp;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            clipArea .equals( _NONE._clipArea  )</span>
        )
<span class="fc" id="L201">            return _NONE;</span>
        else
<span class="fc" id="L203">            return new ImageConf(primer, image, placement, repeat, fitMode, size, opacity, padding, offset, clipArea);</span>
    }


    private final @Nullable Color     _primer;
    private final @Nullable ImageIcon _image;
    private final UI.Placement        _placement;
    private final boolean             _repeat;
    private final UI.FitComponent     _fitMode;
    private final Size                _size;
    private final float               _opacity;
    private final Outline             _padding;
    private final Offset              _offset;
    private final UI.ComponentArea    _clipArea;


    private ImageConf(
        @Nullable Color      primer,
        @Nullable ImageIcon  image,
        UI.Placement         placement,
        boolean              repeat,
        UI.FitComponent      fitMode,
        Size                 size,
        float                opacity,
        Outline              padding,
        Offset               offset,
        UI.ComponentArea     clipArea
<span class="fc" id="L230">    ) {</span>
<span class="fc" id="L231">        _primer    = primer;</span>
<span class="fc" id="L232">        _image     = image;</span>
<span class="fc" id="L233">        _placement = Objects.requireNonNull(placement);</span>
<span class="fc" id="L234">        _repeat    = repeat;</span>
<span class="fc" id="L235">        _fitMode   = Objects.requireNonNull(fitMode);</span>
<span class="fc" id="L236">        _size      = Objects.requireNonNull(size);</span>
<span class="fc" id="L237">        _opacity   = opacity;</span>
<span class="fc" id="L238">        _padding   = Objects.requireNonNull(padding);</span>
<span class="fc" id="L239">        _offset    = Objects.requireNonNull(offset);</span>
<span class="fc" id="L240">        _clipArea  = Objects.requireNonNull(clipArea);</span>
<span class="pc bpc" id="L241" title="2 of 4 branches missed.">        if ( _opacity &lt; 0.0f || _opacity &gt; 1.0f )</span>
<span class="nc" id="L242">            throw new IllegalArgumentException(&quot;transparency must be between 0.0f and 1.0f&quot;);</span>
<span class="fc" id="L243">    }</span>

<span class="fc" id="L245">    Optional&lt;Color&gt; primer() { return Optional.ofNullable(_primer); }</span>

<span class="fc" id="L247">    Optional&lt;ImageIcon&gt; image() { return Optional.ofNullable(_image); }</span>

    UI.Placement placement() {
<span class="fc bfc" id="L250" title="All 4 branches covered.">        if ( _placement == UI.Placement.UNDEFINED &amp;&amp; _image instanceof SvgIcon )</span>
<span class="fc" id="L251">            return ((SvgIcon) _image).getPreferredPlacement();</span>

<span class="fc" id="L253">        return _placement;</span>
    }

<span class="fc" id="L256">    boolean repeat() { return _repeat; }</span>

<span class="fc" id="L258">    UI.FitComponent fitMode() { return _fitMode; }</span>

<span class="fc" id="L260">    Optional&lt;Integer&gt; width() { return _size.width().map(Number::intValue); }</span>

<span class="fc" id="L262">    Optional&lt;Integer&gt; height() { return _size.height().map(Number::intValue); }</span>

<span class="fc" id="L264">    float opacity() { return _opacity; }</span>

<span class="fc" id="L266">    Outline padding() { return _padding; }</span>
    
<span class="fc" id="L268">    int horizontalOffset() { return (int) _offset.x(); }</span>
    
<span class="fc" id="L270">    int verticalOffset() { return (int) _offset.y(); }</span>

<span class="fc" id="L272">    UI.ComponentArea clipArea() { return _clipArea; }</span>

    /**
     *  Here you can specify the &lt;b&gt;primer color of the image style&lt;/b&gt; which will be used
     *  as a filler color for the image background. &lt;br&gt;
     *  Note that the primer color will not be visible if the image is opaque and it fills the entire component.
     *
     * @param color The primer color of the image style.
     * @return A new {@link ImageConf} instance with the specified primer color.
     */
    public ImageConf primer( Color color ) {
<span class="fc" id="L283">        Objects.requireNonNull(color, &quot;Use UI.Color.UNDEFINED instead of null to represent the absence of a color.&quot;);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if ( StyleUtil.isUndefinedColor(color) )</span>
<span class="fc" id="L285">            color = null;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if ( Objects.equals(color, _primer) )</span>
<span class="fc" id="L287">            return this;</span>
<span class="fc" id="L288">        return ImageConf.of(color, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Here you can specify the &lt;b&gt;image&lt;/b&gt; which will be drawn onto the component.
     *  The supplied object must be an instance of {@link Image} implementation.
     *
     * @param image The image which will be drawn onto the component.
     * @return A new {@link ImageConf} instance with the specified image.
     */
    public ImageConf image(Image image ) {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        return ImageConf.of(_primer, image == null ? null : new ImageIcon(image), _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Here you can specify the &lt;b&gt;image icon&lt;/b&gt; which will be drawn onto the component.
     *  The supplied object must be an instance of {@link ImageIcon} implementation.
     *
     * @param image The image icon which will be drawn onto the component.
     * @return A new {@link ImageConf} instance with the specified image.
     */
    public ImageConf image(ImageIcon image ) {
<span class="fc" id="L310">        return ImageConf.of(_primer, image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Here you can specify the &lt;b&gt;path to the image in the form of an {@link IconDeclaration}&lt;/b&gt;
     *  for which the icon will be loaded and drawn onto the component.
     *  If the icon could not be found, then the image will not be drawn.
     *  The path is relative to the classpath or may be an absolute path.
     *
     * @param image The path to the (icon) image in the form of an {@link IconDeclaration}.
     * @return A new {@link ImageConf} instance with the specified image.
     * @throws NullPointerException If the specified {@code image} is null.
     */
    public ImageConf image(IconDeclaration image ) {
<span class="fc" id="L324">        Objects.requireNonNull(image);</span>
<span class="fc" id="L325">        return image.find().map(this::image).orElse(this);</span>
    }

    /**
     *  Here you can specify the &lt;b&gt;path to the image&lt;/b&gt; for which the icon will be loaded,
     *  cached and drawn onto the component.
     *  If the icon could not be found, then the image will not be drawn.
     *  The path is relative to the classpath or may be an absolute path.
     *  (see {@link swingtree.UI#findIcon(String)}).
     *
     * @param path The path to the (icon) image.
     * @return A new {@link ImageConf} instance with the specified image.
     * @throws NullPointerException If the specified {@code path} is null.
     */
    public ImageConf image(String path ) {
<span class="fc" id="L340">        Objects.requireNonNull(path);</span>
<span class="fc" id="L341">        return image(() -&gt; path);</span>
    }

    /**
     *  Here you can specify the &lt;b&gt;placement&lt;/b&gt; of the image onto the component.
     *  The default placement is {@link swingtree.UI.Placement#CENTER}. &lt;br&gt;
     *  Here a list of available options and their effect:
     *  &lt;ul&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#CENTER} -
     *          The image will be drawn at the center of the component.
     *          So the center of the image will be at the center of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#TOP_LEFT} -
     *          The image will be drawn beginning at the top left corner of the inner component area.
     *          So the top left corner of the image will be in the top left corner of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#TOP_RIGHT} -
     *          The image will be placed in the top right corner of the inner component area.
     *          So the top right corner of the image will be in the top right corner of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#BOTTOM_LEFT} -
     *          The image will be drawn in the bottom left corner of the inner component area.
     *          So the bottom left corner of the image will be in the bottom left corner of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#BOTTOM_RIGHT} -
     *          The image will be drawn in the bottom right corner of the inner component area.
     *          So the bottom right corner of the image will be in the bottom right corner of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#TOP} -
     *          The image will be drawn in the top center of the inner component area.
     *          So the top center of the image will be in the top center of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#BOTTOM} -
     *          The image will be drawn in the bottom center of the inner component area.
     *          So the bottom center of the image will be in the bottom center of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#LEFT} -
     *          The image will be drawn in the left center of the inner component area.
     *          So the left center of the image will be in the left center of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#RIGHT} -
     *          The image will be drawn in the right center of the inner component area.
     *          So the right center of the image will be in the right center of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.Placement#UNDEFINED} -
     *          The image will be drawn at a position which is determined by other
     *          factors such as the image size and the component size.
     *  &lt;/ul&gt;
     *
     * @param placement The placement of the image onto the component.
     * @return A new {@link ImageConf} instance with the specified placement.
     */
    public ImageConf placement(UI.Placement placement ) {
<span class="fc" id="L394">        return ImageConf.of(_primer, _image, placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  If this flag is set to {@code true}, then the image may be painted
     *  multiple times so that it fills up the entire inner component area.
     *  There will not be a noticeable effect of this flag if the
     *  image already fills out the inner component area (see {@link #autoFit(boolean)}, {@link #size(int, int)}).
     *
     * @param repeat Weather the image should be painted repeatedly across the inner component area.
     * @return A new {@link ImageConf} instance with the specified {@code repeat} flag value.
     */
    public ImageConf repeat(boolean repeat ) {
<span class="fc" id="L407">        return ImageConf.of(_primer, _image, _placement, repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  If this flag is set to {@code true}, then the image will be stretched or shrunk
     *  to fill the inner component area dependent on the specified width and height,
     *  meaning that if the width was not specified explicitly through {@link #width(Integer)}
     *  then the image will be scaled to fit the inner component width,
     *  and if a height was not specified through {@link #height(Integer)} then
     *  the image will be scaled to fit the inner component height. &lt;br&gt;
     *  &lt;b&gt;Note that the inner component area is the area enclosed by the border, which
     *  is itself not part of said area!&lt;/b&gt;
     *
     * @param autoFit If true the image will be scaled to fit the inner component area for every
     *                dimension which was not specified,
     *                otherwise the image will not be scaled to fit the inner component area.
     * @return A new {@link ImageConf} instance with the specified {@code autoFit} flag value.
     */
    public ImageConf autoFit(boolean autoFit ) {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        UI.FitComponent fit = autoFit ? UI.FitComponent.WIDTH_AND_HEIGHT : UI.FitComponent.NO;</span>
<span class="fc" id="L427">        return ImageConf.of(_primer, _image, _placement, _repeat, fit, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  There are different kinds of strategies to fit the image onto the component.
     *  These strategies are identified using the {@link UI.FitComponent} enum
     *  which defines the following fit modes:
     *  &lt;ul&gt;
     *      &lt;li&gt;{@link UI.FitComponent#NO} -
     *          The image will not be scaled to fit the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link UI.FitComponent#WIDTH} -
     *          The image will be scaled to fit the inner component width.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link UI.FitComponent#HEIGHT} -
     *          The image will be scaled to fit the inner component height.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link UI.FitComponent#WIDTH_AND_HEIGHT} -
     *          The image will be scaled to fit both the component width and height.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link UI.FitComponent#MAX_DIM} -
     *          The image will be scaled to fit the smaller
     *          of the two dimension of the inner component area.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link UI.FitComponent#MIN_DIM} -
     *          The image will be scaled to fit the larger
     *          of the two dimension of the inner component area.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     * @param fit The fit mode of the image.
     * @return A new {@link ImageConf} instance with the specified {@code fit} mode.
     */
    public ImageConf fitMode( UI.FitComponent fit ) {
<span class="fc" id="L460">        return ImageConf.of(_primer, _image, _placement, _repeat, fit, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Ensures that the image has the specified width.
     *
     * @param width The width of the image.
     * @return A new {@link ImageConf} instance with the specified {@code width}.
     */
    public ImageConf width(Integer width ) {
<span class="fc" id="L470">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size.withWidth(width), _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Ensures that the image has the specified height.
     *
     * @param height The height of the image.
     * @return A new {@link ImageConf} instance with the specified {@code height}.
     */
    public ImageConf height( Integer height ) {
<span class="fc" id="L480">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size.withHeight(height), _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  Ensures that the image has the specified width and height.
     *
     * @param width The width of the image.
     * @param height The height of the image.
     * @return A new {@link ImageConf} instance with the specified {@code width} and {@code height}.
     */
    public ImageConf size(int width, int height ) {
<span class="fc" id="L491">        return size(Size.of(width, height));</span>
    }

    /**
     *  Ensures that the image has the specified width and height.
     *
     * @param size The size of the image.
     * @return A new {@link ImageConf} instance with the specified {@code size}.
     */
    public ImageConf size(Size size ) {
<span class="fc" id="L501">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, size, _opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  This method allows you to specify the opacity of the image.
     *  The opacity must be between 0.0f and 1.0f, where 0.0f means that the image is completely transparent
     *  and 1.0f means that the image is completely opaque.
     *
     * @param opacity The opacity of the image.
     * @return A new {@link ImageConf} instance with the specified opacity.
     */
    public ImageConf opacity(float opacity ) {
<span class="fc" id="L513">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, opacity, _padding, _offset, _clipArea);</span>
    }

    /**
     *  This method allows you to specify the padding of the image.
     *  The padding is the space between the image and the inner component area.
     *
     * @param padding The padding of the image.
     * @return A new {@link ImageConf} instance with the specified padding.
     */
    ImageConf padding(Outline padding ) {
<span class="fc" id="L524">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, padding, _offset, _clipArea);</span>
    }

    /**
     *  This method allows you to specify the padding of the image.
     *  The padding is the space between the image and the inner component area.
     *
     * @param top The top padding of the image.
     * @param right The right padding of the image.
     * @param bottom The bottom padding of the image.
     * @param left The left padding of the image.
     * @return A new {@link ImageConf} instance with the specified padding.
     */
    public ImageConf padding(int top, int right, int bottom, int left ) {
<span class="nc" id="L538">        return padding(Outline.of(top, right, bottom, left));</span>
    }

    /**
     *  This method allows you to specify the padding of the image.
     *  The padding is the space between the image and the inner component area.
     *
     * @param topBottom The top and bottom padding of the image.
     * @param leftRight The left and right padding of the image.
     * @return A new {@link ImageConf} instance with the specified padding.
     */
    public ImageConf padding(int topBottom, int leftRight ) {
<span class="nc" id="L550">        return padding(Outline.of(topBottom, leftRight, topBottom, leftRight));</span>
    }

    /**
     *  This method allows you to specify the padding for all sides of the image.
     *  The padding is the space between the image and the inner component area.
     *
     * @param padding The padding of the image.
     * @return A new {@link ImageConf} instance with the specified padding.
     */
    public ImageConf padding(int padding ) {
<span class="fc" id="L561">        return padding(Outline.of(padding, padding, padding, padding));</span>
    }

    /**
     *  Use this to specify the vertical and horizontal offset by which the image will be moved
     *  and drawn onto the component.
     *
     *  @param x The horizontal offset.
     *  @param y The vertical offset.
     *  @return A new {@link ImageConf} instance with the specified offset.
     */
    public ImageConf offset(int x, int y ) {
<span class="nc" id="L573">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, Offset.of(x, y), _clipArea);</span>
    }

    /**
     *  Use this to specify the horizontal offset by which the image will be moved
     *  and drawn onto the component.
     *
     *  @param x The horizontal offset.
     *  @return A new {@link ImageConf} instance with the specified offset.
     */
    public ImageConf horizontalOffset(int x ) {
<span class="nc" id="L584">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset.withX(x), _clipArea);</span>
    }

    /**
     *  Use this to specify the vertical offset by which the image will be moved
     *  and drawn onto the component.
     *
     *  @param y The vertical offset.
     *  @return A new {@link ImageConf} instance with the specified offset.
     */
    public ImageConf verticalOffset(int y ) {
<span class="nc" id="L595">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset.withY(y), _clipArea);</span>
    }

    /**
     *  Use this to specify the clip area of the image,
     *  which determines on which part of the component the image will be drawn.
     *  The {@link swingtree.UI.ComponentArea} enum defines the following clip areas:
     *  &lt;ul&gt;
     *      &lt;li&gt;{@link swingtree.UI.ComponentArea#ALL} -
     *      The image will be drawn onto the entire component, which
     *      is the union of all other clip areas ({@code INTERIOR + EXTERIOR + BORDER + CONTENT}).
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.ComponentArea#INTERIOR} -
     *      The image will be drawn onto the inner component area,
     *      which is defined as {@code ALL - EXTERIOR - BORDER}.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.ComponentArea#EXTERIOR} -
     *      The image will be drawn onto the outer component area,
     *      which can be expressed as {@code ALL - INTERIOR - BORDER},
     *      or {@code ALL - CONTENT}.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.ComponentArea#BORDER} -
     *      The image will be drawn onto the border of the component,
     *      which is the area between the inner and outer component area
     *      and which can be expressed as {@code ALL - INTERIOR - EXTERIOR}.
     *      &lt;/li&gt;
     *      &lt;li&gt;{@link swingtree.UI.ComponentArea#BODY} -
     *      The image will be drawn onto the component body,
     *      which is the inner component area including the border area.
     *      It can be expressed as {@code ALL - EXTERIOR}, or {@code INTERIOR + BORDER}.
     *      &lt;/li&gt;
     *  &lt;/ul&gt;
     *  The default clip area is {@link swingtree.UI.ComponentArea#INTERIOR},
     *  which means that the image will be drawn onto the inner component area.
     *  &lt;p&gt;
     *  Use {@link UI.ComponentArea#ALL} to draw the image without any additional clipping
     *  onto the entire component, which may also cover the border and margin area of the component.
     *
     *  @param clipArea The clip area of the image.
     *  @return A new {@link ImageConf} instance with the specified clip area.
     */
    public ImageConf clipTo(UI.ComponentArea clipArea ) {
<span class="nc" id="L637">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, clipArea);</span>
    }

    ImageConf _scale(double scaleFactor ) {
<span class="fc" id="L641">        return ImageConf.of(_primer, _image, _placement, _repeat, _fitMode, _size.scale(scaleFactor), _opacity, _padding.scale(scaleFactor), _offset.scale(scaleFactor), _clipArea);</span>
    }

    @Override
    public ImageConf simplified() {
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if ( this.equals(_NONE) )</span>
<span class="fc" id="L647">            return _NONE;</span>

<span class="fc bfc" id="L649" title="All 2 branches covered.">        ImageIcon simplifiedImage = _opacity == 0.0f ? null : _image;</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">        Color simplifiedPrimer = _primer == null || _primer.getAlpha() == 0 ? null : _primer;</span>

<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if ( StyleUtil.isUndefinedColor(simplifiedPrimer) )</span>
<span class="nc" id="L653">            simplifiedPrimer = null;</span>

<span class="fc bfc" id="L655" title="All 4 branches covered.">        if ( simplifiedImage == null &amp;&amp; simplifiedPrimer == null )</span>
<span class="fc" id="L656">            return none();</span>

<span class="fc" id="L658">        return ImageConf.of(</span>
                    simplifiedPrimer,
                    simplifiedImage,
                    _placement,
                    _repeat,
                    _fitMode,
                    _size,
                    _opacity,
<span class="fc" id="L666">                    _padding.simplified(),</span>
                    _offset,
                    _clipArea
                );
    }

    @Override
    public int hashCode() {
<span class="fc" id="L674">        return Objects.hash(_primer, _image, _placement, _repeat, _fitMode, _size, _opacity, _padding, _offset, _clipArea);</span>
    }

    @Override
    public boolean equals( Object obj ) {
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">        if ( obj == null ) return false;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if ( obj == this ) return true;</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        if ( obj.getClass() != getClass() ) return false;</span>
<span class="fc" id="L682">        ImageConf rhs = (ImageConf) obj;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        return Objects.equals(_primer,    rhs._primer)    &amp;&amp;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">               Objects.equals(_image,     rhs._image)     &amp;&amp;</span>
<span class="pc bpc" id="L685" title="2 of 4 branches missed.">               Objects.equals(_placement, rhs._placement) &amp;&amp;</span>
               _repeat == rhs._repeat    &amp;&amp;
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">               Objects.equals(_fitMode,   rhs._fitMode)   &amp;&amp;</span>
<span class="pc bpc" id="L688" title="1 of 4 branches missed.">               Objects.equals(_size,      rhs._size)      &amp;&amp;</span>
               _opacity == rhs._opacity   &amp;&amp;
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">               Objects.equals(_padding,   rhs._padding)   &amp;&amp;</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">               Objects.equals(_offset,    rhs._offset)    &amp;&amp;</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">               Objects.equals(_clipArea,  rhs._clipArea);</span>
    }

    @Override
    public String toString() {
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if ( this.equals(_NONE) ) return this.getClass().getSimpleName()+&quot;[NONE]&quot;;</span>
<span class="fc" id="L698">        return this.getClass().getSimpleName() + &quot;[&quot; +</span>
<span class="fc" id="L699">                    &quot;primer=&quot;        + StyleUtil.toString(_primer)                          + &quot;, &quot; +</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">                    &quot;image=&quot;         + ( _image == null ? &quot;?&quot; : _image.toString() )            + &quot;, &quot; +</span>
                    &quot;placement=&quot;     + _placement                                              + &quot;, &quot; +
                    &quot;repeat=&quot;        + _repeat                                                 + &quot;, &quot; +
                    &quot;fitComponent=&quot;  + _fitMode                                                + &quot;, &quot; +
<span class="fc" id="L704">                    &quot;width=&quot;         + _size.width().map(Objects::toString).orElse(&quot;?&quot;)  + &quot;, &quot; +</span>
<span class="fc" id="L705">                    &quot;height=&quot;        + _size.height().map(Objects::toString).orElse(&quot;?&quot;) + &quot;, &quot; +</span>
                    &quot;opacity=&quot;       + _opacity                                                + &quot;, &quot; +
                    &quot;padding=&quot;       + _padding                                                + &quot;, &quot; +
                    &quot;offset=&quot;        + _offset                                                 + &quot;, &quot; +
                    &quot;clipArea=&quot;      + _clipArea                                               +
                &quot;]&quot;;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>