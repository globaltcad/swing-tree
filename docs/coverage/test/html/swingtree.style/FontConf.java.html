<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FontConf.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">FontConf.java</span></div><h1>FontConf.java</h1><pre class="source lang-java linenums">package swingtree.style;

import com.google.errorprone.annotations.Immutable;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import swingtree.SwingTree;
import swingtree.UI;
import swingtree.api.Configurator;

import javax.swing.*;
import java.awt.*;
import java.awt.font.TextAttribute;
import java.awt.geom.AffineTransform;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

/**
 *  An immutable, wither-like method based config API for font styles
 *  that is part of the full {@link StyleConf} configuration object.
 *  &lt;p&gt;
 *  The following properties with their respective purpose are available:
 *  &lt;br&gt;
 *  &lt;ol&gt;
 *      &lt;li&gt;&lt;b&gt;Name&lt;/b&gt;
 *          &lt;p&gt;
 *              The name of the font, which is essentially the font family.
 *              This will ultimately translate to {@link Font#getFamily()}.&lt;br&gt;
 *              You may specify the font family name through the {@link #family(String)} method.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Size&lt;/b&gt;
 *          &lt;p&gt;
 *              The size of the font in points,
 *              which will ultimately translate to {@link Font#getSize()}.
 *              Use the {@link #size(int)} method to specify the size of the font.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Posture&lt;/b&gt;
 *          &lt;p&gt;
 *              The posture of the font, which is a value between 0 and 1.
 *              &lt;br&gt;
 *              A value of 0 means that the font is not italic,
 *              while a value of 1 means that the font is &quot;fully&quot; italic.
 *              &lt;br&gt;
 *              You can use the {@link #posture(float)} method to specify the posture of the font.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Weight&lt;/b&gt;
 *          &lt;p&gt;
 *              The weight of the font (boldness, see {@link Font#BOLD}),
 *              which is a value between 0 and 2.
 *          &lt;/p&gt;
 *          &lt;p&gt;
 *              The weight of the font can be specified using the {@link #weight(double)} method.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Spacing (Tracking)&lt;/b&gt;
 *          &lt;p&gt;
 *              This property controls the tracking which is a floating point number
 *              with the default value of
 *              {@code 0}, meaning no additional tracking is added to the font.
 *             
 *              &lt;p&gt;Useful constant values are the predefined {@link TextAttribute#TRACKING_TIGHT} and {@link
 *              TextAttribute#TRACKING_LOOSE} values, which represent values of {@code -0.04} and {@code 0.04},
 *             
 *              &lt;p&gt;The tracking value is multiplied by the font point size and
 *              passed through the font transform to determine an additional
 *              amount to add to the advance of each glyph cluster.  Positive
 *              tracking values will inhibit formation of optional ligatures.
 *              Tracking values are typically between {@code -0.1} and
 *              {@code 0.3}; values outside this range are generally not
 *              desirable.
 *          &lt;/p&gt;
 *          &lt;p&gt;
 *              You can use the {@link #spacing(float)} method to specify the tracking of the font.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Color&lt;/b&gt;
 *          &lt;p&gt;
 *              The color of the font, which translates to the text property
 *              {@link TextAttribute#FOREGROUND}.
 *          &lt;/p&gt;
 *          &lt;p&gt;
 *              You can use the {@link #color(Color)} or {@link #color(String)} methods to specify the color of the font.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Background Color&lt;/b&gt;
 *          &lt;p&gt;
 *              The background color of the font
 *              which translates to the text property {@link TextAttribute#BACKGROUND}.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Selection Color&lt;/b&gt;
 *          &lt;p&gt;
 *              The selection color of the font, which translates to
 *              {@link javax.swing.text.JTextComponent#setSelectionColor(Color)}.
 *              &lt;br&gt;
 *              Note that this property is only relevant for text components,
 *              most components do not support text selection.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Underlined&lt;/b&gt;
 *          &lt;p&gt;
 *              Whether or not the font is underlined.
 *              This will ultimately translate to {@link TextAttribute#UNDERLINE}.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Strike&lt;/b&gt;
 *          &lt;p&gt;
 *              Whether or not the font is strike through.
 *              This will ultimately translate to {@link TextAttribute#STRIKETHROUGH}.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Transform&lt;/b&gt;
 *          &lt;p&gt;
 *              The transform of the font, which is an {@link AffineTransform} instance.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Paint&lt;/b&gt;
 *          &lt;p&gt;
 *              The paint of the font, which is a {@link Paint} instance.
 *              Note that specifying a custom paint will override the effects of the color property
 *              as the color property is in essence merely a convenience property for a
 *              paint painting across the entire font area homogeneously using the specified color.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Background Paint&lt;/b&gt;
 *          &lt;p&gt;
 *              The background paint of the font, which is a {@link Paint} instance
 *              that is used to paint the background of the font.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Horizontal Alignment&lt;/b&gt;
 *          &lt;p&gt;
 *              The horizontal alignment of the font.
 *              &lt;br&gt;
 *              Note that this property is not relevant for all components,
 *              It will usually only be relevant for {@link JLabel}, {@link AbstractButton} and {@link JTextField}
 *              types or maybe some custom components.
 *              Not all components support horizontal alignment.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *      &lt;li&gt;&lt;b&gt;Vertical Alignment&lt;/b&gt;
 *          &lt;p&gt;
 *              The vertical alignment of the font.
 *              &lt;br&gt;
 *              Note that this property is not relevant for all components,
 *              It will usually only be relevant for {@link JLabel}, {@link AbstractButton} and {@link JTextField}
 *              types or maybe some custom components.
 *              Not all components support vertical alignment.
 *          &lt;/p&gt;
 *      &lt;/li&gt;
 *  &lt;/ol&gt;
 *  &lt;p&gt;
 *  You can use the {@link #none()} method to specify that no font should be used,
 *  as the instance returned by that method is a font style with an empty string as its name,
 *  and other properties set to their default values,
 *  effectively making it a representation of the absence of a font style.
 *  &lt;p&gt;
 *  Also note that this class is immutable, which means that wither-like methods
 *  will always return new instances of this class, leaving the original instance untouched.
 *  &lt;br&gt;
 *  This means that you can not modify a font style instance directly, but you can
 *  easily create a modified copy of it by calling one of the wither-like methods.
 *
 * @author Daniel Nepp
 */
@Immutable
@SuppressWarnings(&quot;Immutable&quot;)
public final class FontConf
{
<span class="fc" id="L174">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(FontConf.class);</span>

<span class="fc" id="L176">    private static final FontConf _NONE = new FontConf(</span>
                                                        &quot;&quot;,    // Font name (family)
                                                        0,     // size
                                                        0,     // posture
                                                        0,     // weight
                                                        0,     // spacing
                                                        null,  // selection color
                                                        null,  // is underlined
                                                        null,  // is strike through
                                                        null,  // transform
<span class="fc" id="L186">                                                        FontPaintConf.none(),  // paint</span>
<span class="fc" id="L187">                                                        FontPaintConf.none(),  // background paint</span>
                                                        UI.HorizontalAlignment.UNDEFINED,  // horizontal alignment
                                                        UI.VerticalAlignment.UNDEFINED   // vertical alignment
                                                    );

    /**
     * Returns a font style with all properties set to their no-op default values,
     * effectively making it a representation of the absence of a font style.
     *
     * @return A font style with all properties set to no-op default values.
     */
<span class="fc" id="L198">    public static FontConf none() { return _NONE; }</span>

    static FontConf of(
        String                     name,
        int                        fontSize,
        float                      posture,
        float                      weight,
        float                      spacing,
        @Nullable Color            selectionColor,
        @Nullable Boolean          isUnderline,
        @Nullable Boolean          isStrike,
        @Nullable AffineTransform  transform,
        FontPaintConf              paint,
        FontPaintConf              backgroundPaint,
        UI.HorizontalAlignment     horizontalAlignment,
        UI.VerticalAlignment       verticalAlignment
    ) {
<span class="fc" id="L215">        if (</span>
<span class="pc bpc" id="L216" title="3 of 18 branches missed.">            name.isEmpty() &amp;&amp;</span>
            fontSize == 0 &amp;&amp;
            posture == 0 &amp;&amp;
            weight == 0 &amp;&amp;
            spacing == 0 &amp;&amp;
            selectionColor == null &amp;&amp;
            isUnderline == null &amp;&amp;
            isStrike == null &amp;&amp;
            transform == null &amp;&amp;
<span class="fc bfc" id="L225" title="All 2 branches covered.">            paint.equals(FontPaintConf.none()) &amp;&amp;</span>
<span class="pc bpc" id="L226" title="3 of 6 branches missed.">            backgroundPaint.equals(FontPaintConf.none()) &amp;&amp;</span>
            horizontalAlignment == _NONE._horizontalAlignment &amp;&amp;
            verticalAlignment == _NONE._verticalAlignment
        )
<span class="nc" id="L230">            return _NONE;</span>
        else
<span class="fc" id="L232">            return new FontConf(</span>
                    name,
                    fontSize,
                    posture,
                    weight,
                    spacing,
                    selectionColor,
                    isUnderline,
                    isStrike,
                    transform,
                    paint,
                    backgroundPaint,
                    horizontalAlignment,
                    verticalAlignment
                );
    }

    private final String                    _familyName;
    private final int                       _size;
    private final float                     _posture;
    private final float                     _weight;
    private final float                     _spacing;
    private final @Nullable Color           _selectionColor; // Only relevant for text components with selection support.
    private final @Nullable Boolean         _isUnderlined;
    private final @Nullable Boolean         _isStrike;
    private final @Nullable AffineTransform _transform;
    private final FontPaintConf             _paint;
    private final FontPaintConf             _backgroundPaint;
    private final UI.HorizontalAlignment    _horizontalAlignment;
    private final UI.VerticalAlignment      _verticalAlignment;


    private FontConf(
        String                    name,
        int                       fontSize,
        float                     posture,
        float                     weight,
        float                     spacing,
        @Nullable Color           selectionColor,
        @Nullable Boolean         isUnderline,
        @Nullable Boolean         isStrike,
        @Nullable AffineTransform transform,
        FontPaintConf             paint,
        FontPaintConf             backgroundPaint,
        UI.HorizontalAlignment    horizontalAlignment,
        UI.VerticalAlignment      verticalAlignment
<span class="fc" id="L278">    ) {</span>
<span class="fc" id="L279">        _familyName = Objects.requireNonNull(name);</span>
<span class="fc" id="L280">        _size    = fontSize;</span>
<span class="fc" id="L281">        _posture = posture;</span>
<span class="fc" id="L282">        _weight  = weight;</span>
<span class="fc" id="L283">        _spacing = spacing;</span>
<span class="fc" id="L284">        _selectionColor  = selectionColor;</span>
<span class="fc" id="L285">        _isUnderlined    = isUnderline;</span>
<span class="fc" id="L286">        _isStrike        = isStrike;</span>
<span class="fc" id="L287">        _transform       = transform;</span>
<span class="fc" id="L288">        _paint           = paint;</span>
<span class="fc" id="L289">        _backgroundPaint = backgroundPaint;</span>
<span class="fc" id="L290">        _horizontalAlignment = horizontalAlignment;</span>
<span class="fc" id="L291">        _verticalAlignment   = verticalAlignment;</span>
<span class="fc" id="L292">    }</span>

<span class="fc" id="L294">    String family() { return _familyName; }</span>

<span class="fc" id="L296">    int size() { return _size; }</span>

<span class="fc" id="L298">    float posture() { return _posture; }</span>

<span class="nc" id="L300">    float weight() { return _weight; }</span>

<span class="nc" id="L302">    float spacing() { return _spacing; }</span>

<span class="fc" id="L304">    Optional&lt;Color&gt; selectionColor() { return Optional.ofNullable(_selectionColor); }</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">    boolean isUnderlined() { return _isUnderlined != null ? _isUnderlined : false; }</span>

<span class="nc" id="L308">    Optional&lt;AffineTransform&gt; transform() { return Optional.ofNullable(_transform); }</span>

    Optional&lt;Paint&gt; paint() {
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if ( FontPaintConf.none().equals(_paint) )</span>
<span class="fc" id="L312">            return Optional.empty();</span>
<span class="fc" id="L313">        return Optional.ofNullable(_paint.getFor(BoxModelConf.none()));</span>
    }

    Optional&lt;Paint&gt; backgroundPaint() {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if ( FontPaintConf.none().equals(_backgroundPaint) )</span>
<span class="nc" id="L318">            return Optional.empty();</span>
<span class="nc" id="L319">        return Optional.ofNullable(_backgroundPaint.getFor(BoxModelConf.none()));</span>
    }

<span class="fc" id="L322">    UI.HorizontalAlignment horizontalAlignment() { return _horizontalAlignment; }</span>

<span class="fc" id="L324">    UI.VerticalAlignment verticalAlignment() { return _verticalAlignment; }</span>

    /**
     * Returns an updated font config with the specified font family name.
     *
     * @param fontFamily The font family name to use for the {@link Font#getFamily()} property.
     * @return A new font style with the specified font family name.
     */
    public FontConf family( String fontFamily ) {
<span class="fc" id="L333">        return FontConf.of(fontFamily, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified font size,
     * which will translate to a {@link Font} instance with the specified size 
     * (see {@link Font#getSize()}).
     *
     * @param fontSize The font size to use for the {@link Font#getSize()} property.
     * @return A new font style with the specified font size.
     */
    public FontConf size( int fontSize ) {
<span class="fc" id="L345">        return FontConf.of(_familyName, fontSize, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified posture, defining the tilt of the font.
     * A {@link Font} with a higher posture value will be more italic.
     * (see {@link Font#isItalic()}).
     *
     * @param posture The posture to use for the {@link Font#isItalic()} property.
     * @return A new font style with the specified posture.
     */
    public FontConf posture( float posture ) {
<span class="fc" id="L357">        return FontConf.of(_familyName, _size, posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified weight, defining the boldness of the font.
     * A {@link Font} with a higher weight value will be bolder.
     * (see {@link Font#isBold()}).
     *
     * @param fontWeight The weight to use for the {@link Font#isBold()} property.
     * @return A new font style with the specified weight.
     */
    public FontConf weight( double fontWeight ) {
<span class="fc" id="L369">        return FontConf.of(_familyName, _size, _posture, (float) fontWeight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     *  Determines if the font should be plain, bold, italic or bold and italic
     *  based on the provided {@link UI.FontStyle} parameter,
     *  which may be {@link UI.FontStyle#PLAIN}, {@link UI.FontStyle#BOLD},
     *  {@link UI.FontStyle#ITALIC} or {@link UI.FontStyle#BOLD_ITALIC}.&lt;br&gt;
     *  &lt;b&gt;
     *      Note that this will override any previous bold or italic settings.
     *  &lt;/b&gt;
     * @param fontStyle The font style to use for the font in the {@link UI.FontStyle} enum.
     * @return An updated font config with the specified font style.
     */
    public FontConf style( UI.FontStyle fontStyle ) {
<span class="pc bpc" id="L384" title="2 of 5 branches missed.">        switch (fontStyle) {</span>
            case PLAIN:
<span class="nc" id="L386">                return weight(0).posture(0);</span>
            case BOLD:
<span class="fc" id="L388">                return weight(2).posture(0);</span>
            case ITALIC:
<span class="fc" id="L390">                return weight(0).posture(0.2f);</span>
            case BOLD_ITALIC:
<span class="fc" id="L392">                return weight(2).posture(0.2f);</span>
            default:
<span class="nc" id="L394">                return this;</span>
        }
    }

    /**
     * Returns an updated font config with the specified spacing, defining the tracking of the font.
     * The tracking value is multiplied by the font point size and
     * passed through the font transform to determine an additional
     * amount to add to the advance of each glyph cluster.  Positive
     * tracking values will inhibit formation of optional ligatures.
     * Tracking values are typically between {@code -0.1} and
     * {@code 0.3}; values outside this range are generally not
     * desirable.
     *
     * @param spacing The spacing to use for the {@link TextAttribute#TRACKING} property.
     * @return A new font style with the specified spacing.
     */
    public FontConf spacing( float spacing ) {
<span class="fc" id="L412">        return FontConf.of(_familyName, _size, _posture, _weight, spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified color,
     * which will be used for the {@link TextAttribute#FOREGROUND} property
     * of the resulting {@link Font} instance.
     *
     * @param color The color to use for the {@link TextAttribute#FOREGROUND} property.
     * @return A new font style with the specified color.
     */
    public FontConf color( Color color ) {
<span class="fc" id="L424">        Objects.requireNonNull(color);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if ( StyleUtil.isUndefinedColor(color) )</span>
<span class="fc" id="L426">            color = null;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if ( _paint.representsColor(color) )</span>
<span class="fc" id="L428">            return this;</span>

<span class="fc" id="L430">        FontPaintConf paintConf = FontPaintConf.of(color, null, null, null);</span>

<span class="fc" id="L432">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, paintConf, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified color string used to define the font color.
     * The color will be used for the {@link TextAttribute#FOREGROUND} property
     * of the resulting {@link Font} instance.
     *
     * @param colorString The color string to use for the {@link TextAttribute#FOREGROUND} property.
     * @return A new font style with the specified color.
     */
    public FontConf color( String colorString ) {
<span class="fc" id="L444">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if ( colorString.isEmpty() )</span>
<span class="fc" id="L448">                newColor = UI.Color.UNDEFINED;</span>
            else
<span class="fc" id="L450">                newColor = UI.color(colorString);</span>
<span class="nc" id="L451">        } catch ( Exception e ) {</span>
<span class="nc" id="L452">            log.error(SwingTree.get().logMarker(), &quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L453">            return this;</span>
<span class="fc" id="L454">        }</span>
<span class="fc" id="L455">        return color(newColor);</span>
    }

    /**
     * Returns an updated font config with the specified background color.
     * The color value will be used for the {@link TextAttribute#BACKGROUND} property
     * of the resulting {@link Font} instance.
     *
     * @param backgroundColor The background color to use for the {@link TextAttribute#BACKGROUND} property.
     * @return A new font style with the specified background color.
     */
    public FontConf backgroundColor( Color backgroundColor ) {
<span class="fc" id="L467">        Objects.requireNonNull(backgroundColor);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if ( StyleUtil.isUndefinedColor(backgroundColor) )</span>
<span class="fc" id="L469">            backgroundColor = null;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        if ( _backgroundPaint.representsColor(backgroundColor) )</span>
<span class="fc" id="L471">            return this;</span>

<span class="fc" id="L473">        FontPaintConf backgroundPaintConf = FontPaintConf.of(backgroundColor, null, null, null);</span>

<span class="fc" id="L475">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, backgroundPaintConf, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified background color string used to define the background color.
     * The background color will be used for the {@link TextAttribute#BACKGROUND} property
     * of the resulting {@link Font} instance.
     *
     * @param colorString The color string to use for the {@link TextAttribute#BACKGROUND} property.
     * @return A new font style with the specified background color.
     */
    public FontConf backgroundColor( String colorString ) {
<span class="fc" id="L487">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            if ( colorString.isEmpty() )</span>
<span class="nc" id="L491">                newColor = UI.Color.UNDEFINED;</span>
            else
<span class="fc" id="L493">                newColor = UI.color(colorString);</span>
<span class="nc" id="L494">        } catch ( Exception e ) {</span>
<span class="nc" id="L495">            log.error(SwingTree.get().logMarker(), &quot;Failed to parse color string: '{}'&quot;, colorString, e);</span>
<span class="nc" id="L496">            return this;</span>
<span class="fc" id="L497">        }</span>
<span class="fc" id="L498">        return backgroundColor(newColor);</span>
    }

    /**
     * Returns an updated font config with the specified selection color.
     * The selection color will be used for the selection color of the font.
     * Note that not all components support text selection, so this property may not
     * have an effect on all components.
     *
     * @param selectionColor The selection color to use for the selection color of the font.
     * @return A new font style with the specified selection color.
     */
    public FontConf selectionColor( Color selectionColor ) {
<span class="fc" id="L511">        Objects.requireNonNull(selectionColor);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if ( StyleUtil.isUndefinedColor(selectionColor) )</span>
<span class="fc" id="L513">            selectionColor = null;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if ( Objects.equals(selectionColor, _selectionColor) )</span>
<span class="fc" id="L515">            return this;</span>
<span class="fc" id="L516">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, selectionColor, _isUnderlined, _isStrike, _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified selection color string used to define the selection color.
     * The selection color will be used for the selection color of the font.
     * Note that not all components support text selection, so this property may not
     * have an effect on all components.
     *
     * @param colorString The color string to use for the selection color of the font.
     * @return A new font style with the specified selection color.
     */
    public FontConf selectionColor( String colorString ) {
<span class="fc" id="L529">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc bfc" id="L532" title="All 2 branches covered.">            if ( colorString.isEmpty() )</span>
<span class="fc" id="L533">                newColor = UI.Color.UNDEFINED;</span>
            else
<span class="fc" id="L535">                newColor = UI.color(colorString);</span>
<span class="nc" id="L536">        } catch ( Exception e ) {</span>
<span class="nc" id="L537">            log.error(SwingTree.get().logMarker(), &quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L538">            return this;</span>
<span class="fc" id="L539">        }</span>
<span class="fc" id="L540">        return selectionColor(newColor);</span>
    }

    /**
     * Returns an updated font config with the specified underlined property.
     * This boolean will translate to the {@link TextAttribute#UNDERLINE} property
     * of the resulting {@link Font} instance.
     *
     * @param underlined Whether the font should be underlined.
     * @return A new font style with the specified underlined property.
     */
    public FontConf underlined( boolean underlined ) {
<span class="fc" id="L552">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, underlined, _isStrike, _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified strike through property.
     * This boolean will translate to the {@link TextAttribute#STRIKETHROUGH} property
     * of the resulting {@link Font} instance.
     *
     * @param strike Whether the font should be strike through.
     * @return A new font style with the specified strike through property.
     */
    public FontConf strikeThrough( boolean strike ) {
<span class="fc" id="L564">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, strike, _transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified transform.
     * This transform will be used for the {@link TextAttribute#TRANSFORM} property
     * of the resulting {@link Font} instance.
     *
     * @param transform The transform to use for the {@link TextAttribute#TRANSFORM} property.
     * @return A new font style with the specified transform.
     */
    public FontConf transform( @Nullable AffineTransform transform ) {
<span class="fc" id="L576">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike, transform, _paint, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified paint.
     * This paint will be used for the {@link TextAttribute#FOREGROUND} property
     * of the resulting {@link Font} instance.
     * Note that specifying a custom paint will override the effects of the color property
     * as the color property is in essence merely a convenience property for a
     * paint painting across the entire font area homogeneously using the specified color.
     * &lt;br&gt;
     * Note that this will override the effects of the {@link #color(Color)}, {@link #color(String)},
     * {@link #noise(Configurator)} or {@link #gradient(Configurator)} methods
     * as a font can only have one paint.
     *
     * @param paint The paint to use for the {@link TextAttribute#FOREGROUND} property.
     * @return A new font style with the specified paint.
     */
    public FontConf paint( @Nullable Paint paint ) {
<span class="fc" id="L595">        FontPaintConf paintConf = FontPaintConf.of(null, paint, null, null);</span>
<span class="fc" id="L596">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, paintConf, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     *  Configures a noise function based {@link Paint} for the font appearance,
     *  using a configurator function that takes a {@link NoiseConf} instance
     *  and returns an updated {@link NoiseConf} instance with the desired properties.
     *  &lt;br&gt;
     *  Keep in mind that this will override the effects of the {@link #color(Color)},
     *  {@link #color(String)}, {@link #paint(Paint)} or {@link #gradient(Configurator)}
     *  methods as a font can only have one paint.
     *
     * @param configurator The configurator function that takes a {@link NoiseConf} instance
     *                     and returns an updated {@link NoiseConf} instance with the desired properties.
     * @return A new font style with the specified noise paint.
     */
    public FontConf noise( Configurator&lt;NoiseConf&gt; configurator ) {
<span class="fc" id="L613">        Objects.requireNonNull(configurator);</span>
<span class="fc" id="L614">        FontPaintConf paintConf = _paint.noise(configurator);</span>
<span class="fc" id="L615">        return _withPaintConf(paintConf);</span>
    }

    /**
     *  Configures a gradient function based {@link Paint} for the font appearance,
     *  using a configurator function that takes a {@link GradientConf} instance
     *  and returns an updated {@link GradientConf} instance with the desired properties.
     *  &lt;br&gt;
     *  Keep in mind that this will override the effects of the {@link #color(Color)},
     *  {@link #color(String)}, {@link #paint(Paint)} or {@link #noise(Configurator)}
     *  methods as a font can only have one paint.
     *
     * @param configurator The configurator function that takes a {@link GradientConf} instance
     *                     and returns an updated {@link GradientConf} instance with the desired properties.
     * @return A new font style with the specified gradient paint.
     */
    public FontConf gradient( Configurator&lt;GradientConf&gt; configurator ) {
<span class="fc" id="L632">        Objects.requireNonNull(configurator);</span>
<span class="fc" id="L633">        FontPaintConf paintConf = _paint.gradient(configurator);</span>
<span class="fc" id="L634">        return _withPaintConf(paintConf);</span>
    }

    private FontConf _withPaintConf( FontPaintConf paintConf ) {
<span class="fc" id="L638">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, paintConf, _backgroundPaint, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified background paint.
     * This paint will be used for the {@link TextAttribute#BACKGROUND} property
     * of the resulting {@link Font} instance.
     *
     * @param backgroundPaint The background paint to use for the {@link TextAttribute#BACKGROUND} property.
     * @return A new font style with the specified background paint.
     */
    public FontConf backgroundPaint( @Nullable Paint backgroundPaint ) {
<span class="fc" id="L650">        FontPaintConf backgroundPaintConf = FontPaintConf.of(null, backgroundPaint, null, null);</span>
<span class="fc" id="L651">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, backgroundPaintConf, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     *  Configures a noise function based {@link Paint} for the background of the font appearance,
     *  using a configurator function that takes a {@link NoiseConf} instance
     *  and returns an updated {@link NoiseConf} instance with the desired properties.
     *  &lt;br&gt;
     *  Note that the background can only have one paint, so specifying a noise based paint
     *  will override the effects of the {@link #backgroundPaint(Paint)}, {@link #backgroundGradient(Configurator)},
     *  and {@link #backgroundColor(String)} methods.
     *
     * @param configurator The configurator function that takes a {@link NoiseConf} instance
     *                     and returns an updated {@link NoiseConf} instance with the desired properties.
     * @return A new font style with the specified noise background paint.
     */
    public FontConf backgroundNoise( Configurator&lt;NoiseConf&gt; configurator ) {
<span class="fc" id="L668">        Objects.requireNonNull(configurator);</span>
<span class="fc" id="L669">        FontPaintConf backgroundPaintConf = _backgroundPaint.noise(configurator);</span>
<span class="fc" id="L670">        return _withBackgroundPaintConf(backgroundPaintConf);</span>
    }

    /**
     *  Configures a gradient function based {@link Paint} for the background of the font appearance,
     *  using a configurator function that takes a {@link GradientConf} instance
     *  and returns an updated {@link GradientConf} instance with the desired properties.
     *  &lt;br&gt;
     *  The background of a font can only have one paint, so specifying a gradient based paint
     *  will override the effects of the {@link #backgroundPaint(Paint)}, {@link #backgroundNoise(Configurator)},
     *  and {@link #backgroundColor(String)} methods.
     *
     * @param configurator The configurator function that takes a {@link GradientConf} instance
     *                     and returns an updated {@link GradientConf} instance with the desired properties.
     * @return A new font style with the specified gradient background paint.
     */
    public FontConf backgroundGradient( Configurator&lt;GradientConf&gt; configurator ) {
<span class="fc" id="L687">        Objects.requireNonNull(configurator);</span>
<span class="fc" id="L688">        FontPaintConf backgroundPaintConf = _backgroundPaint.gradient(configurator);</span>
<span class="fc" id="L689">        return _withBackgroundPaintConf(backgroundPaintConf);</span>
    }

    private FontConf _withBackgroundPaintConf( FontPaintConf backgroundPaintConf ) {
<span class="fc" id="L693">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, backgroundPaintConf, _horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified horizontal alignment.
     * This property is not relevant for all components,
     * It will usually only be relevant for {@link JLabel}, {@link AbstractButton} and {@link JTextField}
     * types or maybe some custom components.
     * Not all components support horizontal alignment.
     * This will also not have an effect for font configs which
     * are part of the {@link TextConf}.
     * &lt;b&gt;
     *     This method is deliberately package-private as it is not relevant for the
     *     {@link ComponentStyleDelegate#componentFont(Configurator)} or
     *     {@link TextConf#font(Configurator)} methods. &lt;br&gt;
     *     &lt;br&gt;
     *     It only makes sense to specify this property 
     *     through the {@link ComponentStyleDelegate#fontAlignment(UI.HorizontalAlignment)}
     *     method!!
     * &lt;/b&gt;
     *
     * @param horizontalAlignment The horizontal alignment to use for the font.
     * @return A new font style with the specified horizontal alignment.
     */
    FontConf horizontalAlignment( UI.HorizontalAlignment horizontalAlignment ) {
<span class="fc" id="L718">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, horizontalAlignment, _verticalAlignment);</span>
    }

    /**
     * Returns an updated font config with the specified vertical alignment.
     * This property is not relevant for all components,
     * It will usually only be relevant for {@link JLabel}, {@link AbstractButton} and {@link JTextField}
     * types or maybe some custom components.
     * Not all components support vertical alignment.
     * This will also not have an effect for font configs which
     * are part of the {@link TextConf}.
     * &lt;b&gt;
     *     This method is deliberately package-private as it is not relevant for the
     *     {@link ComponentStyleDelegate#componentFont(Configurator)} or
     *     {@link TextConf#font(Configurator)} methods. &lt;br&gt;
     *     &lt;br&gt;
     *     It only makes sense to specify this property 
     *     through the {@link ComponentStyleDelegate#fontAlignment(UI.VerticalAlignment)}
     *     method!!
     * &lt;/b&gt;
     *
     * @param verticalAlignment The vertical alignment to use for the font.
     * @return A new font style with the specified vertical alignment.
     */
    FontConf verticalAlignment( UI.VerticalAlignment verticalAlignment ) {
<span class="fc" id="L743">        return FontConf.of(_familyName, _size, _posture, _weight, _spacing, _selectionColor, _isUnderlined, _isStrike,  _transform, _paint, _backgroundPaint, _horizontalAlignment, verticalAlignment);</span>
    }

    FontConf withPropertiesFromFont( Font font )
    {
<span class="fc bfc" id="L748" title="All 2 branches covered.">        if ( StyleUtil.isUndefinedFont(font) )</span>
<span class="fc" id="L749">            return this;</span>

<span class="fc" id="L751">        Map&lt;TextAttribute, ?&gt; attributeMap = font.getAttributes();</span>

<span class="fc" id="L753">        String family = font.getFamily();</span>

<span class="fc" id="L755">        int size = font.getSize();</span>

<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        float posture = font.isItalic() ? 0.2f : 0f;</span>
        try {
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.POSTURE))</span>
<span class="nc" id="L760">                posture = ((Number) attributeMap.get(TextAttribute.POSTURE)).floatValue();</span>
<span class="fc" id="L761">        } catch (Exception e) {</span>
<span class="fc" id="L762">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.POSTURE in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="nc" id="L763">        }</span>

<span class="fc bfc" id="L765" title="All 2 branches covered.">        float weight = font.isBold() ? 2f : 0f;</span>
        try {
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.WEIGHT))</span>
<span class="fc" id="L768">                weight = ((Number) attributeMap.get(TextAttribute.WEIGHT)).floatValue();</span>
<span class="fc" id="L769">        } catch (Exception e) {</span>
<span class="fc" id="L770">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.WEIGHT in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="fc" id="L771">        }</span>

<span class="fc" id="L773">        float spacing = _spacing;</span>
        try {
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.TRACKING))</span>
<span class="nc" id="L776">                spacing = ((Number) attributeMap.get(TextAttribute.TRACKING)).floatValue();</span>
<span class="fc" id="L777">        } catch (Exception e) {</span>
<span class="fc" id="L778">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.TRACKING in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="nc" id="L779">        }</span>

<span class="fc" id="L781">        Color selectionColor = _selectionColor;</span>
        // The selection color is not a text attribute, but a component property, like for text areas.

<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        boolean isUnderline = ( _isUnderlined != null ? _isUnderlined : false );</span>
        try {
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.UNDERLINE))</span>
<span class="nc" id="L787">                isUnderline = Objects.equals(attributeMap.get(TextAttribute.UNDERLINE), TextAttribute.UNDERLINE_ON);</span>
<span class="nc" id="L788">        } catch (Exception e) {</span>
<span class="nc" id="L789">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.UNDERLINE in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="fc" id="L790">        }</span>

<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        boolean isStriked   = ( _isStrike != null ? _isStrike : false );</span>
        try {
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.STRIKETHROUGH))</span>
<span class="nc" id="L795">                isStriked   = Objects.equals(attributeMap.get(TextAttribute.STRIKETHROUGH), TextAttribute.STRIKETHROUGH_ON);</span>
<span class="nc" id="L796">        } catch (Exception e) {</span>
<span class="nc" id="L797">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.STRIKETHROUGH in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="fc" id="L798">        }</span>

<span class="fc" id="L800">        AffineTransform transform = _transform;</span>
        try {
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.TRANSFORM))</span>
<span class="fc" id="L803">                transform = (AffineTransform) attributeMap.get(TextAttribute.TRANSFORM);</span>
<span class="nc" id="L804">        } catch (Exception e) {</span>
<span class="nc" id="L805">            log.debug(SwingTree.get().logMarker(), &quot;Failed to fetch TextAttribute.TRANSFORM in font attributes '&quot; + attributeMap + &quot;' of font '&quot; + font + &quot;'&quot;, e);</span>
<span class="fc" id="L806">        }</span>

<span class="fc" id="L808">        FontPaintConf paint = _paint;</span>
        try {
<span class="fc" id="L810">            Paint found = null;</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.FOREGROUND))</span>
<span class="nc" id="L812">                found = (Paint) attributeMap.get(TextAttribute.FOREGROUND);</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">            if (found != null)</span>
<span class="nc" id="L814">                paint = FontPaintConf.of(null, found, null, null);</span>
<span class="nc" id="L815">        } catch (Exception e) {</span>
<span class="nc" id="L816">            log.warn(SwingTree.get().logMarker(), &quot;Failed to extract font attributes from font: &quot; + font, e);</span>
<span class="fc" id="L817">        }</span>

<span class="fc" id="L819">        FontPaintConf backgroundPaint = _backgroundPaint;</span>
        try {
<span class="fc" id="L821">            Paint found = null;</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            if (attributeMap.containsKey(TextAttribute.BACKGROUND))</span>
<span class="nc" id="L823">                found = (Paint) attributeMap.get(TextAttribute.BACKGROUND);</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">            if (found != null)</span>
<span class="nc" id="L825">                backgroundPaint = FontPaintConf.of(null, found, null, null);</span>
<span class="nc" id="L826">        } catch (Exception e) {</span>
<span class="nc" id="L827">            log.warn(SwingTree.get().logMarker(), &quot;Failed to extract font attributes from font: &quot; + font, e);</span>
<span class="fc" id="L828">        }</span>

<span class="fc" id="L830">        Objects.requireNonNull(font);</span>
<span class="fc" id="L831">        return FontConf.of(</span>
                    family,
                    size,
                    posture,
                    weight,
                    spacing,
                    selectionColor,
<span class="fc" id="L838">                    isUnderline,</span>
<span class="fc" id="L839">                    isStriked,</span>
                    transform,
                    paint,
                    backgroundPaint,
                    _horizontalAlignment,
                    _verticalAlignment
                );
    }

    Optional&lt;Font&gt; createDerivedFrom( Font existingFont, JComponent component ) {
<span class="fc" id="L849">        return _createDerivedFrom(existingFont, component);</span>
    }

    Optional&lt;Font&gt; createDerivedFrom( Font existingFont, BoxModelConf boxModel ) {
<span class="fc" id="L853">        return _createDerivedFrom(existingFont, boxModel);</span>
    }

    private Optional&lt;Font&gt; _createDerivedFrom( Font existingFont, Object boxModelOrComponent )
    {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        if ( this.equals(_NONE) )</span>
<span class="nc" id="L859">            return Optional.empty();</span>

<span class="fc" id="L861">        boolean isChange = false;</span>

<span class="fc bfc" id="L863" title="All 2 branches covered.">        if ( existingFont == null )</span>
<span class="fc" id="L864">            existingFont = new JLabel().getFont();</span>

<span class="fc" id="L866">        Map&lt;TextAttribute, Object&gt; currentAttributes = (Map&lt;TextAttribute, Object&gt;) existingFont.getAttributes();</span>
<span class="fc" id="L867">        Map&lt;TextAttribute, Object&gt; attributes = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L869" title="All 2 branches covered.">        if ( _size &gt; 0 ) {</span>
<span class="pc bpc" id="L870" title="2 of 4 branches missed.">            isChange = isChange || !Integer.valueOf(_size).equals(currentAttributes.get(TextAttribute.SIZE));</span>
<span class="fc" id="L871">            attributes.put(TextAttribute.SIZE, _size);</span>
        }
<span class="fc bfc" id="L873" title="All 2 branches covered.">        if ( _posture &gt; 0 ) {</span>
<span class="pc bpc" id="L874" title="3 of 4 branches missed.">            isChange = isChange || !Float.valueOf(_posture).equals(currentAttributes.get(TextAttribute.POSTURE));</span>
<span class="fc" id="L875">            attributes.put(TextAttribute.POSTURE, _posture);</span>
        }
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if ( _weight &gt; 0 ) {</span>
<span class="fc bfc" id="L878" title="All 4 branches covered.">            isChange = isChange || !Float.valueOf(_weight).equals(currentAttributes.get(TextAttribute.WEIGHT));</span>
<span class="fc" id="L879">            attributes.put(TextAttribute.WEIGHT, _weight);</span>
        }
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if ( _spacing != 0 ) {</span>
<span class="fc bfc" id="L882" title="All 4 branches covered.">            isChange = isChange || !Float.valueOf(_spacing).equals(currentAttributes.get(TextAttribute.TRACKING));</span>
<span class="fc" id="L883">            attributes.put(TextAttribute.TRACKING, _spacing);</span>
        }
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if ( _isUnderlined != null ) {</span>
<span class="pc bpc" id="L886" title="3 of 4 branches missed.">            isChange = isChange || !Objects.equals(_isUnderlined, currentAttributes.get(TextAttribute.UNDERLINE));</span>
<span class="fc" id="L887">            attributes.put(TextAttribute.UNDERLINE, _isUnderlined);</span>
        }
<span class="fc bfc" id="L889" title="All 2 branches covered.">        if ( _isStrike != null ) {</span>
<span class="pc bpc" id="L890" title="3 of 4 branches missed.">            isChange = isChange || !Objects.equals(_isStrike, currentAttributes.get(TextAttribute.STRIKETHROUGH));</span>
<span class="fc" id="L891">            attributes.put(TextAttribute.STRIKETHROUGH, _isStrike);</span>
        }
<span class="fc bfc" id="L893" title="All 2 branches covered.">        if ( _transform != null ) {</span>
<span class="pc bpc" id="L894" title="2 of 4 branches missed.">            isChange = isChange || !Objects.equals(_transform, currentAttributes.get(TextAttribute.TRANSFORM));</span>
<span class="fc" id="L895">            attributes.put(TextAttribute.TRANSFORM, _transform);</span>
        }
<span class="fc bfc" id="L897" title="All 2 branches covered.">        if ( !_familyName.isEmpty() ) {</span>
<span class="pc bpc" id="L898" title="1 of 4 branches missed.">            isChange = isChange || !Objects.equals(_familyName, currentAttributes.get(TextAttribute.FAMILY));</span>
<span class="fc" id="L899">            attributes.put(TextAttribute.FAMILY, _familyName);</span>
        }
<span class="fc bfc" id="L901" title="All 2 branches covered.">        if ( !_paint.equals(FontPaintConf.none()) ) {</span>
            try {
<span class="fc" id="L903">                Paint paint = null;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">                if ( boxModelOrComponent instanceof BoxModelConf )</span>
<span class="fc" id="L905">                    paint = _paint.getFor((BoxModelConf) boxModelOrComponent);</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">                else if ( boxModelOrComponent instanceof JComponent )</span>
<span class="fc" id="L907">                    paint = _paint.getFor((JComponent) boxModelOrComponent);</span>

<span class="fc bfc" id="L909" title="All 4 branches covered.">                isChange = isChange || !Objects.equals(paint, currentAttributes.get(TextAttribute.FOREGROUND));</span>
<span class="fc" id="L910">                attributes.put(TextAttribute.FOREGROUND, paint);</span>
<span class="nc" id="L911">            } catch ( Exception e ) {</span>
<span class="nc" id="L912">                log.error(SwingTree.get().logMarker(), &quot;Failed to create paint from paint config: &quot;+_paint, e);</span>
<span class="fc" id="L913">            }</span>
        }
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if ( !_backgroundPaint.equals(FontPaintConf.none()) ) {</span>
            try {
<span class="fc" id="L917">                Paint backgroundPaint = null;</span>
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">                if ( boxModelOrComponent instanceof BoxModelConf )</span>
<span class="nc" id="L919">                    backgroundPaint = _backgroundPaint.getFor((BoxModelConf) boxModelOrComponent);</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">                else if ( boxModelOrComponent instanceof JComponent )</span>
<span class="fc" id="L921">                    backgroundPaint = _backgroundPaint.getFor((JComponent) boxModelOrComponent);</span>

<span class="pc bpc" id="L923" title="3 of 4 branches missed.">                isChange = isChange || !Objects.equals(backgroundPaint, currentAttributes.get(TextAttribute.BACKGROUND));</span>
<span class="fc" id="L924">                attributes.put(TextAttribute.BACKGROUND, backgroundPaint);</span>
<span class="nc" id="L925">            } catch ( Exception e ) {</span>
<span class="nc" id="L926">                log.error(SwingTree.get().logMarker(), &quot;Failed to create paint from paint config: &quot;+_backgroundPaint, e);</span>
<span class="fc" id="L927">            }</span>
        }
<span class="fc bfc" id="L929" title="All 2 branches covered.">        if ( isChange )</span>
<span class="fc" id="L930">            return Optional.of(existingFont.deriveFont(attributes));</span>
        else
<span class="fc" id="L932">            return Optional.empty();</span>
    }

    FontConf _scale(double scale ) {
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if ( scale == 1.0 )</span>
<span class="nc" id="L937">            return this;</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">        else if ( this.equals(_NONE) )</span>
<span class="fc" id="L939">            return this;</span>
        else
<span class="fc" id="L941">            return FontConf.of(</span>
                    _familyName,
<span class="fc" id="L943">                    (int) Math.round(_size * scale),</span>
                    _posture,
                    _weight,
                    _spacing,
                    _selectionColor, 
                    _isUnderlined,
                    _isStrike,
                    _transform,
                    _paint,
                    _backgroundPaint,
                    _horizontalAlignment,
                    _verticalAlignment
                );
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L961">        int hash = 7;</span>
<span class="fc" id="L962">        hash = 97 * hash + Objects.hashCode(_familyName);</span>
<span class="fc" id="L963">        hash = 97 * hash + _size;</span>
<span class="fc" id="L964">        hash = 97 * hash + Float.hashCode(_posture);</span>
<span class="fc" id="L965">        hash = 97 * hash + Float.hashCode(_weight);</span>
<span class="fc" id="L966">        hash = 97 * hash + Float.hashCode(_spacing);</span>
<span class="fc" id="L967">        hash = 97 * hash + Objects.hashCode(_selectionColor);</span>
<span class="fc" id="L968">        hash = 97 * hash + Objects.hashCode(_isUnderlined);</span>
<span class="fc" id="L969">        hash = 97 * hash + Objects.hashCode(_transform);</span>
<span class="fc" id="L970">        hash = 97 * hash + Objects.hashCode(_paint);</span>
<span class="fc" id="L971">        hash = 97 * hash + Objects.hashCode(_backgroundPaint);</span>
<span class="fc" id="L972">        hash = 97 * hash + Objects.hashCode(_horizontalAlignment);</span>
<span class="fc" id="L973">        hash = 97 * hash + Objects.hashCode(_verticalAlignment);</span>
<span class="fc" id="L974">        return hash;</span>
    }

    @Override
    public boolean equals( Object obj )
    {
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">        if ( obj == null )</span>
<span class="nc" id="L981">            return false;</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">        if ( getClass() != obj.getClass() )</span>
<span class="nc" id="L983">            return false;</span>
<span class="fc" id="L984">        final FontConf other = (FontConf)obj;</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if ( !Objects.equals(_familyName, other._familyName) )</span>
<span class="fc" id="L986">            return false;</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if ( _size != other._size )</span>
<span class="fc" id="L988">            return false;</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if ( _posture != other._posture)</span>
<span class="fc" id="L990">            return false;</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">        if ( _weight != other._weight )</span>
<span class="fc" id="L992">            return false;</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        if ( _spacing != other._spacing )</span>
<span class="fc" id="L994">            return false;</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">        if ( !Objects.equals(_selectionColor, other._selectionColor) )</span>
<span class="fc" id="L996">            return false;</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">        if ( !Objects.equals(_isUnderlined, other._isUnderlined) )</span>
<span class="fc" id="L998">            return false;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">        if ( !Objects.equals(_transform, other._transform) )</span>
<span class="fc" id="L1000">            return false;</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if ( !Objects.equals(_paint, other._paint) )</span>
<span class="fc" id="L1002">            return false;</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if ( !Objects.equals(_backgroundPaint, other._backgroundPaint) )</span>
<span class="fc" id="L1004">            return false;</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        if ( _horizontalAlignment != other._horizontalAlignment )</span>
<span class="fc" id="L1006">            return false;</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if ( _verticalAlignment != other._verticalAlignment )</span>
<span class="fc" id="L1008">            return false;</span>

<span class="fc" id="L1010">        return true;</span>
    }

    @Override
    public String toString()
    {
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        if ( this.equals(_NONE) )</span>
<span class="fc" id="L1017">            return this.getClass().getSimpleName() + &quot;[NONE]&quot;;</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        String underline       = ( _isUnderlined        == null ? &quot;?&quot; : String.valueOf(_isUnderlined)   );</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        String strike          = ( _isStrike            == null ? &quot;?&quot; : String.valueOf(_isStrike)       );</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        String transform       = ( _transform           == null ? &quot;?&quot; : _transform.toString()           );</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        String horizontalAlign = ( _horizontalAlignment == UI.HorizontalAlignment.UNDEFINED ? &quot;?&quot; : _horizontalAlignment.toString() );</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        String verticalAlign   = ( _verticalAlignment   == UI.VerticalAlignment.UNDEFINED ? &quot;?&quot; : _verticalAlignment.toString()   );</span>
<span class="fc" id="L1023">        return this.getClass().getSimpleName() + &quot;[&quot; +</span>
                    &quot;family=&quot;              + _familyName + &quot;, &quot; +
                    &quot;size=&quot;                + _size                                   + &quot;, &quot; +
                    &quot;posture=&quot;             + _posture                                + &quot;, &quot; +
                    &quot;weight=&quot;              + _weight                                 + &quot;, &quot; +
                    &quot;spacing=&quot;             + _spacing                                + &quot;, &quot; +
                    &quot;underlined=&quot;          + underline                               + &quot;, &quot; +
                    &quot;strikeThrough=&quot;       + strike                                  + &quot;, &quot; +
<span class="fc" id="L1031">                    &quot;selectionColor=&quot;      + StyleUtil.toString(_selectionColor)     + &quot;, &quot; +</span>
                    &quot;transform=&quot;           + transform                               + &quot;, &quot; +
                    &quot;paint=&quot;               + _paint                                  + &quot;, &quot; +
                    &quot;backgroundPaint=&quot;     + _backgroundPaint                        + &quot;, &quot; +
                    &quot;horizontalAlignment=&quot; + horizontalAlign                         + &quot;, &quot; +
                    &quot;verticalAlignment=&quot;   + verticalAlign                           +
                &quot;]&quot;;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>