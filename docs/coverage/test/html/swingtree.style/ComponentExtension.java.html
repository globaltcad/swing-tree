<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComponentExtension.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">ComponentExtension.java</span></div><h1>ComponentExtension.java</h1><pre class="source lang-java linenums">package swingtree.style;

import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.DimConstraint;
import net.miginfocom.layout.UnitValue;
import net.miginfocom.swing.MigLayout;
import swingtree.UI;
import swingtree.animation.AnimationState;
import swingtree.api.Painter;
import swingtree.api.Styler;
import swingtree.components.JIcon;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.text.JTextComponent;
import java.awt.*;
import java.awt.geom.Area;
import java.util.List;
import java.util.*;
import java.util.function.Supplier;

/**
 *  Is attached to UI components in the form of a client property.
 *  It exists to give Swing-Tree components some custom style and animation capabilities.
 */
public final class ComponentExtension&lt;C extends JComponent&gt;
{
    /**
     * Returns the {@link ComponentExtension} associated with the given component.
     * If the component does not have an extension, a new one is created and associated with the component.
     *
     * @param comp The component for which to get the extension.
     * @return The extension associated with the component.
     * @param &lt;C&gt; The type of the component.
     */
    public static &lt;C extends JComponent&gt; ComponentExtension&lt;C&gt; from( C comp ) {
<span class="fc" id="L38">        ComponentExtension&lt;C&gt; ext = (ComponentExtension&lt;C&gt;) comp.getClientProperty( ComponentExtension.class );</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">        if ( ext == null ) {</span>
<span class="fc" id="L40">            ext = new ComponentExtension&lt;&gt;(comp);</span>
<span class="fc" id="L41">            comp.putClientProperty( ComponentExtension.class, ext );</span>
        }
<span class="fc" id="L43">        return ext;</span>
    }

    /**
     *  Initializes the given component with a new {@link ComponentExtension}.
     *  This method is called by a SwingTree builder node when it
     *  receives and builds a new component.
     *  The former extension of the component is replaced by a new one.
     *
     * @param comp The component to initialize.
     */
    public static void initializeFor( JComponent comp ) {
<span class="fc" id="L55">        comp.putClientProperty( ComponentExtension.class, new ComponentExtension&lt;&gt;(comp) );</span>
<span class="fc" id="L56">    }</span>

    private final C _owner;

<span class="fc" id="L60">    private final List&lt;Object&gt; _extraState = new ArrayList&lt;&gt;(0);</span>

<span class="fc" id="L62">    private final List&lt;String&gt; _styleGroups = new ArrayList&lt;&gt;(0);</span>


<span class="fc" id="L65">    private StylePainter&lt;C&gt; _stylePainter = StylePainter.none();</span>
<span class="fc" id="L66">    private DynamicLaF      _dynamicLaF   = DynamicLaF.none();</span>
<span class="fc" id="L67">    private StyleSource&lt;C&gt;  _styleSource  = StyleSource.create();</span>

<span class="fc" id="L69">    private Color _initialBackgroundColor = null;</span>

<span class="fc" id="L71">    private Shape _outerBaseClip = null;</span>

<span class="fc" id="L73">    public Shape _childrenClip = null;</span>


<span class="fc" id="L76">    private ComponentExtension( C owner ) { _owner = Objects.requireNonNull(owner); }</span>


<span class="fc" id="L79">    C getOwner() { return _owner; }</span>

    /**
     *  Allows for extra state to be attached to the component extension.
     *  (Conceptually similar to how Swing components can have client properties.)&lt;br&gt;
     *  If the component already has an object of the given type attached,
     *  that object is returned. Otherwise, the given fetcher is used to create
     *  a new object of the given type, which is then attached to the component
     *  and returned.
     *
     * @param type The type of the extra state to attach.
     * @param fetcher A supplier which is used to create a new object of the given type.
     * @return The extra state object of the given type which is attached to the component.
     * @param &lt;P&gt; The type of the extra state.
     */
    public &lt;P&gt; P getOrSet( Class&lt;P&gt; type, Supplier&lt;P&gt; fetcher ) {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for ( Object plugin : _extraState)</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">            if ( type.isInstance(plugin) )</span>
<span class="fc" id="L97">                return (P) plugin;</span>

<span class="fc" id="L99">        P plugin = fetcher.get();</span>
<span class="fc" id="L100">        _extraState.add(plugin);</span>
<span class="fc" id="L101">        return plugin;</span>
    }

    /**
     *   This method is used by {@link swingtree.UIForAnySwing#group(String...)} to attach
     *   so called &lt;i&gt;group tags&lt;/i&gt; to a component. &lt;br&gt;
     *   They are used by the SwingTree style engine to apply
     *   styles with the same tags, which
     *   is conceptually similar to CSS classes. &lt;br&gt;
     *   &lt;b&gt;It is advised to use the {@link #setStyleGroups(Enum[])} method
     *   instead of this method, as the usage of enums for modelling
     *   group tags offers much better compile time type safety!&lt;/b&gt;
     *
     * @param groupTags An array of group tags.
     */
    public void setStyleGroups( String... groupTags ) {
<span class="fc" id="L117">        Objects.requireNonNull(groupTags);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        boolean alreadyHasGroupTags = !_styleGroups.isEmpty();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if ( alreadyHasGroupTags )</span>
<span class="nc" id="L120">            _styleGroups.clear();</span>

<span class="fc" id="L122">        _styleGroups.addAll( java.util.Arrays.asList(groupTags) );</span>

<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if ( alreadyHasGroupTags )</span>
<span class="nc" id="L125">            calculateApplyAndInstallStyle(false);</span>
<span class="fc" id="L126">    }</span>

    /**
     *   This method is used by {@link swingtree.UIForAnySwing#group(String...)}
     *   to attach so called &lt;i&gt;group tags&lt;/i&gt; to a component. &lt;br&gt;
     *   They are used by the SwingTree style engine to apply
     *   styles with the same tags, which
     *   is conceptually similar to CSS classes. &lt;br&gt;
     *   It is advised to use this method over the {@link #setStyleGroups(String[])}
     *   method, as the usage of enums for modelling
     *   group tags offers much better compile time type safety!
     *
     * @param groupTags An array of group tags.
     * @param &lt;E&gt; The type of the enum.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; void setStyleGroups( E... groupTags ) {
<span class="fc" id="L143">        String[] stringTags = new String[groupTags.length];</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for ( int i = 0; i &lt; groupTags.length; i++ ) {</span>
<span class="fc" id="L145">            E group = groupTags[i];</span>
<span class="fc" id="L146">            Objects.requireNonNull(group);</span>
<span class="fc" id="L147">            stringTags[i] = group.getClass().getSimpleName() + &quot;.&quot; + group.name();</span>
        }
<span class="fc" id="L149">        setStyleGroups(stringTags);</span>
<span class="fc" id="L150">    }</span>

    /**
     * @return The group tags associated with the component
     *         in the form of an unmodifiable list of {@link String}s.
     */
<span class="fc" id="L156">    public List&lt;String&gt; getStyleGroups() { return Collections.unmodifiableList(_styleGroups); }</span>

    /**
     * @return {@code true} if the component belongs to the given group.
     */
<span class="fc" id="L161">    public boolean belongsToGroup( String group ) { return _styleGroups.contains(group); }</span>

    /**
     * @return {@code true} if the component belongs to the given group.
     */
    public boolean belongsToGroup( Enum&lt;?&gt; group ) {
<span class="nc" id="L167">        return belongsToGroup(group.getClass().getSimpleName() + &quot;.&quot; + group.name());</span>
    }

<span class="fc" id="L170">    Shape getCurrentOuterBaseClip() { return _outerBaseClip; }</span>

    /**
     * @return The current {@link Style} configuration of the component
     *         which is calculated based on the {@link Styler} lambdas
     *         associated with the component.
     */
<span class="fc" id="L177">    public Style getStyle() { return _stylePainter.getStyle(); }</span>

    /**
     *  Removes all animations from the component.
     *  This includes both {@link Painter} based animations
     *  as well as {@link Styler} based animations.
     */
    public void clearAnimations() {
<span class="fc" id="L185">        _stylePainter = _stylePainter.withoutAnimationPainters();</span>
<span class="fc" id="L186">        _styleSource  = _styleSource.withoutAnimationStylers();</span>
<span class="fc" id="L187">    }</span>

    /**
     *  Use this to add a {@link Painter} based animation to the component.
     *
     * @param state The {@link AnimationState} which defines when the animation is active.
     * @param painter The {@link Painter} which defines how the animation is rendered.
     */
    public void addAnimationPainter( AnimationState state, swingtree.api.Painter painter ) {
<span class="nc" id="L196">        _stylePainter = _stylePainter.withAnimationPainter(state.lifetime(), Objects.requireNonNull(painter));</span>
<span class="nc" id="L197">        _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="nc" id="L198">    }</span>

    /**
     *  Use this to add a {@link Styler} based animation to the component.
     *
     * @param state The {@link AnimationState} which defines when the animation is active.
     * @param styler The {@link Styler} which defines how the style of the component is changed during the animation.
     */
    public void addAnimationStyler( AnimationState state, Styler&lt;C&gt; styler ) {
<span class="fc" id="L207">        _styleSource = _styleSource.withAnimationStyler(state.lifetime(), styler);</span>
<span class="fc" id="L208">        _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc" id="L209">    }</span>

    /**
     *  SwingTree overrides the default Swing look and feel
     *  to enable custom styling and animation capabilities.
     *  This method is used to install the custom look and feel
     *  for the component, if possible.
     */
<span class="fc" id="L217">    public void installCustomUIIfPossible() { _dynamicLaF.installCustomUIFor(_owner); }</span>

    /**
     *  This method is used to paint the background style of the component
     *  using the provided {@link Graphics} object.
     *  The method is designed for components for which SwingTree could not install a custom UI,
     *  and it is intended to be used by custom {@link JComponent#paint(Graphics)}
     *  overrides, before calling the super implementation.
     *
     * @param g The {@link Graphics} object to use for rendering.
     */
    public void paintBackgroundStyle( Graphics g, Runnable lookAndFeelPaint )
    {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if ( _dynamicLaF.customLookAndFeelIsInstalled() ) {</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if ( lookAndFeelPaint != null )</span>
<span class="fc" id="L232">                lookAndFeelPaint.run();</span>
<span class="fc" id="L233">            return; // We render ĥere through the custom installed UI!</span>
        }
<span class="fc" id="L235">        _paintBackground(g, lookAndFeelPaint);</span>
<span class="fc" id="L236">    }</span>

    /**
     *  This method is used to paint the foreground style of the component
     *  using the provided {@link Graphics2D} object.
     *
     * @param g2d The {@link Graphics2D} object to use for rendering.
     */
    public void paintForegroundStyle( Graphics2D g2d )
    {
<span class="fc" id="L246">        establishStyleAndBeginPainting();</span>

        // We remember if antialiasing was enabled before we render:
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>
        // Reset antialiasing to its previous state:
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if ( StylePainter.DO_ANTIALIASING() )</span>
<span class="fc" id="L252">            g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );</span>

        // We remember the clip:
<span class="fc" id="L255">        Shape formerClip = g2d.getClip();</span>

<span class="fc" id="L257">        _stylePainter.paintForegroundStyle(g2d, _owner);</span>

        // We restore the clip:
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if ( g2d.getClip() != formerClip )</span>
<span class="fc" id="L261">            g2d.setClip(formerClip);</span>

        // Reset antialiasing to its previous state:
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>
<span class="fc" id="L265">    }</span>

<span class="fc" id="L267">    Shape getInnerComponentArea() { return _stylePainter._getBaseArea(_owner); }</span>

    /**
     *  Adds a {@link Styler} to the component.
     *  The styler will be used to calculate the style of the component.
     *
     * @param styler The styler to add.
     */
    public void addStyler( Styler&lt;C&gt; styler ) {
<span class="fc" id="L276">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L277">        _styleSource = _styleSource.withLocalStyler(styler, _owner);</span>
<span class="fc" id="L278">        calculateApplyAndInstallStyle(false);</span>
<span class="fc" id="L279">    }</span>

    /**
     *  Calculates a new {@link Style} object based on the {@link Styler} lambdas associated
     *  with the component...
     *
     * @return A new immutable {@link Style} configuration.
     */
    public Style calculateStyle() {
<span class="fc" id="L288">        return _styleSource.calculateStyleFor(_owner);</span>
    }

    /**
     *  Calculates a new {@link Style} object based on the {@link Styler} lambdas associated
     *  with the component and then applies it to the component after which
     *  a new {@link StylePainter} is installed for the component.
     *  If the calculated style is the same as the current style, nothing happens
     *  except in case the &lt;code&gt;force&lt;/code&gt; parameter is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param force If set to &lt;code&gt;true&lt;/code&gt;, the style will be applied even if it is the same as the current style.
     */
    public void calculateApplyAndInstallStyle( boolean force ) {
<span class="fc" id="L301">        _installStylePainterFor( _calculateAndApplyStyle(force) );</span>
<span class="fc" id="L302">    }</span>

    /**
     *  Applies the given {@link Style} to the component after which
     *  a new {@link StylePainter} is installed for the component.
     *  If the given style is the same as the current style, nothing happens
     *  except in case the &lt;code&gt;force&lt;/code&gt; parameter is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param style The style to apply.
     * @param force If set to &lt;code&gt;true&lt;/code&gt;, the style will be applied even if it is the same as the current style.
     */
    public void applyAndInstallStyle( Style style, boolean force ) {
<span class="fc" id="L314">        _installStylePainterFor( _applyStyleToComponentState(style, force) );</span>
<span class="fc" id="L315">    }</span>

    void establishStyleAndBeginPainting() {
<span class="fc" id="L318">        _stylePainter = _stylePainter.update( _calculateAndApplyStyle(false) );</span>
<span class="fc" id="L319">    }</span>

    private Style _calculateAndApplyStyle( boolean force ) {
<span class="fc" id="L322">        return _applyStyleToComponentState(calculateStyle(), force);</span>
    }

    private void _installStylePainterFor( Style style ) {
<span class="fc" id="L326">        _stylePainter = _stylePainter.update(style);</span>
<span class="fc" id="L327">    }</span>

    void _paintBackground( Graphics g, Runnable lookAndFeelPainting )
    {
        // If end the painting of the last painting cycle if it was not already ended:
<span class="fc" id="L332">        _stylePainter = _stylePainter.endPainting();</span>

<span class="fc" id="L334">        establishStyleAndBeginPainting();</span>

<span class="fc" id="L336">        _stylePainter.renderBackgroundStyle( (Graphics2D) g, _owner );</span>

<span class="fc" id="L338">        _outerBaseClip = g.getClip();</span>

<span class="fc bfc" id="L340" title="All 4 branches covered.">        if ( _outerBaseClip == null &amp;&amp; _owner.getParent() == null ) {</span>
            // Happens when rendering individual components (usually unit tests)!
<span class="fc" id="L342">            int x = (int) ((Graphics2D) g).getTransform().getTranslateX();</span>
<span class="fc" id="L343">            int y = (int) ((Graphics2D) g).getTransform().getTranslateY();</span>
<span class="fc" id="L344">            int w = _owner.getWidth();</span>
<span class="fc" id="L345">            int h = _owner.getHeight();</span>
<span class="fc" id="L346">            _outerBaseClip = new Rectangle(x,y,w,h);</span>
        }

<span class="fc" id="L349">        _childrenClip = _stylePainter._getBaseArea(_owner);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if ( lookAndFeelPainting != null ) {</span>
<span class="fc" id="L351">            Shape contentClip = null;</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if ( _stylePainter._getBaseArea() != null )</span>
<span class="fc" id="L353">                contentClip = _stylePainter._getBaseArea(_owner);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            else if ( _stylePainter.getStyle().margin().isPositive() )</span>
<span class="nc" id="L355">                contentClip = _stylePainter._getBaseArea(_owner);</span>

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if ( contentClip == null )</span>
<span class="nc" id="L358">                contentClip = _outerBaseClip;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            else if ( _outerBaseClip != null ) {</span>
<span class="fc" id="L360">                Area common = new Area(_outerBaseClip);</span>
<span class="fc" id="L361">                common.intersect(new Area(contentClip));</span>
<span class="fc" id="L362">                contentClip = common;</span>
            }

<span class="fc" id="L365">            _stylePainter._withClip((Graphics2D) g, contentClip, () -&gt; {</span>
                try {
<span class="fc" id="L367">                    lookAndFeelPainting.run();</span>
<span class="fc" id="L368">                    g.setClip(_outerBaseClip);</span>
<span class="nc" id="L369">                } catch (Exception e) {</span>
<span class="nc" id="L370">                    e.printStackTrace();</span>
<span class="fc" id="L371">                }</span>
<span class="fc" id="L372">            });</span>
<span class="fc" id="L373">            _outerBaseClip = null;</span>
        }
<span class="fc" id="L375">    }</span>

    void _paintBorderStyle( Graphics2D g2d, JComponent component ) {
<span class="fc" id="L378">        _stylePainter.paintBorderStyle(g2d, component);</span>
<span class="fc" id="L379">    }</span>

    void _renderAnimations( Graphics2D g2d )
    {
<span class="fc" id="L383">        _stylePainter.renderAnimations(g2d);</span>
<span class="fc" id="L384">        _stylePainter = _stylePainter.withoutExpiredAnimationPainters();</span>
<span class="fc" id="L385">    }</span>

    private Style _applyStyleToComponentState( Style style, boolean force )
    {
<span class="fc" id="L389">        _styleSource = _styleSource.withoutExpiredAnimationStylers(); // Clean up expired animation stylers!</span>

<span class="fc" id="L391">        Objects.requireNonNull(style);</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">        if ( _owner.getBorder() instanceof StyleAndAnimationBorder&lt;?&gt; ) {</span>
<span class="fc" id="L394">            StyleAndAnimationBorder&lt;C&gt; border = (StyleAndAnimationBorder&lt;C&gt;) _owner.getBorder();</span>
<span class="fc" id="L395">            border.recalculateInsets(style);</span>
        }

<span class="fc bfc" id="L398" title="All 4 branches covered.">        if ( _stylePainter.getStyle().equals(style) &amp;&amp; !force )</span>
<span class="fc" id="L399">            return style;</span>

<span class="fc" id="L401">        final Style.Report styleReport = style.getReport();</span>

<span class="fc" id="L403">        boolean isNotStyled                     = styleReport.isNotStyled();</span>
<span class="fc" id="L404">        boolean onlyDimensionalityIsStyled      = styleReport.onlyDimensionalityIsStyled();</span>
<span class="pc bpc" id="L405" title="5 of 18 branches missed.">        boolean styleCanBeRenderedThroughBorder = (</span>
                                                       styleReport.noBaseStyle    &amp;&amp;
                                                       (styleReport.noShadowStyle || styleReport.allShadowsAreBorderShadows)     &amp;&amp;
                                                       (styleReport.noPainters    || styleReport.allPaintersAreBorderPainters)   &amp;&amp;
                                                       (styleReport.noGradients   || styleReport.allGradientsAreBorderGradients) &amp;&amp;
                                                       (styleReport.noImages      || styleReport.allImagesAreBorderImages)
                                                   );

<span class="fc bfc" id="L413" title="All 4 branches covered.">        if ( isNotStyled || onlyDimensionalityIsStyled ) {</span>
<span class="fc" id="L414">            _dynamicLaF = _dynamicLaF._uninstallCustomLaF(_owner);</span>
<span class="pc bpc" id="L415" title="2 of 4 branches missed.">            if ( _styleSource.hasNoAnimationStylers() &amp;&amp; _stylePainter.hasNoPainters() )</span>
<span class="fc" id="L416">                _uninstallCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if ( _initialBackgroundColor != null ) {</span>
<span class="fc" id="L418">                _owner.setBackground(_initialBackgroundColor);</span>
<span class="fc" id="L419">                _initialBackgroundColor = null;</span>
            }
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if ( isNotStyled )</span>
<span class="fc" id="L422">                return style;</span>
        }

<span class="fc" id="L425">        boolean hasBorderRadius = style.border().hasAnyNonZeroArcs();</span>
<span class="fc" id="L426">        boolean hasBackground   = style.base().backgroundColor().isPresent();</span>

<span class="fc bfc" id="L428" title="All 4 branches covered.">        if ( hasBackground &amp;&amp; !Objects.equals( _owner.getBackground(), style.base().backgroundColor().get() ) ) {</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            _initialBackgroundColor = _initialBackgroundColor != null ? _initialBackgroundColor :  _owner.getBackground();</span>
<span class="fc" id="L430">            _owner.setBackground( style.base().backgroundColor().get() );</span>
        }

        // If the style has a border radius set we need to make sure that we have a background color:
<span class="fc bfc" id="L434" title="All 4 branches covered.">        if ( hasBorderRadius &amp;&amp; !hasBackground ) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            _initialBackgroundColor = _initialBackgroundColor != null ? _initialBackgroundColor :  _owner.getBackground();</span>
<span class="fc" id="L436">            style = style.backgroundColor(_initialBackgroundColor);</span>
        }

<span class="fc bfc" id="L439" title="All 4 branches covered.">        if ( style.base().foregroundColo().isPresent() &amp;&amp; !Objects.equals( _owner.getForeground(), style.base().foregroundColo().get() ) )</span>
<span class="fc" id="L440">            _owner.setForeground( style.base().foregroundColo().get() );</span>

<span class="fc" id="L442">        style.base().cursor().ifPresent( cursor -&gt; {</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getCursor(), cursor ) )</span>
<span class="fc" id="L444">                _owner.setCursor( cursor );</span>
<span class="fc" id="L445">        });</span>

<span class="fc" id="L447">        UI.FitComponent fit = style.base().fit();</span>
<span class="fc" id="L448">        style.base().icon().ifPresent( icon -&gt; {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if ( icon instanceof SvgIcon) {</span>
<span class="nc" id="L450">                SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="nc" id="L451">                icon = svgIcon.withFitComponent(fit);</span>
            }
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="nc" id="L454">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                if ( !Objects.equals( button.getIcon(), icon ) )</span>
<span class="nc" id="L456">                    button.setIcon( icon );</span>
            }
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if ( _owner instanceof JLabel ) {</span>
<span class="nc" id="L459">                JLabel label = (JLabel) _owner;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if ( !Objects.equals( label.getIcon(), icon ) )</span>
<span class="nc" id="L461">                    label.setIcon( icon );</span>
            }
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if ( _owner instanceof JIcon ) {</span>
<span class="nc" id="L464">                JIcon jIcon = (JIcon) _owner;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                if ( !Objects.equals( jIcon.getIcon(), icon ) )</span>
<span class="nc" id="L466">                    jIcon.setIcon( icon );</span>
            }
<span class="nc" id="L468">        });</span>

<span class="fc" id="L470">        style.layout().alignmentX().ifPresent( alignmentX -&gt; {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getAlignmentX(), alignmentX ) )</span>
<span class="fc" id="L472">                _owner.setAlignmentX( alignmentX );</span>
<span class="fc" id="L473">        });</span>

<span class="fc" id="L475">        style.layout().alignmentY().ifPresent( alignmentY -&gt; {</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getAlignmentY(), alignmentY ) )</span>
<span class="fc" id="L477">                _owner.setAlignmentY( alignmentY );</span>
<span class="fc" id="L478">        });</span>

<span class="fc" id="L480">        style.layout().layout().installFor( _owner );</span>

<span class="fc" id="L482">        _applyAlignmentToMigLayoutIfItExists(style.layout());</span>

<span class="fc bfc" id="L484" title="All 4 branches covered.">        if ( style.dimensionality().minWidth().isPresent() || style.dimensionality().minHeight().isPresent() ) {</span>
<span class="fc" id="L485">            Dimension minSize = _owner.getMinimumSize();</span>

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">            int minWidth  = style.dimensionality().minWidth().orElse(minSize == null ? 0 : minSize.width);</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            int minHeight = style.dimensionality().minHeight().orElse(minSize == null ? 0 : minSize.height);</span>

<span class="fc" id="L490">            Dimension newMinSize = new Dimension(minWidth, minHeight);</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">            if ( ! newMinSize.equals(minSize) )</span>
<span class="fc" id="L493">                _owner.setMinimumSize(newMinSize);</span>
        }

<span class="fc bfc" id="L496" title="All 4 branches covered.">        if ( style.dimensionality().maxWidth().isPresent() || style.dimensionality().maxHeight().isPresent() ) {</span>
<span class="fc" id="L497">            Dimension maxSize = _owner.getMaximumSize();</span>

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">            int maxWidth  = style.dimensionality().maxWidth().orElse(maxSize == null  ? Integer.MAX_VALUE : maxSize.width);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">            int maxHeight = style.dimensionality().maxHeight().orElse(maxSize == null ? Integer.MAX_VALUE : maxSize.height);</span>

<span class="fc" id="L502">            Dimension newMaxSize = new Dimension(maxWidth, maxHeight);</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">            if ( ! newMaxSize.equals(maxSize) )</span>
<span class="fc" id="L505">                _owner.setMaximumSize(newMaxSize);</span>
        }

<span class="fc bfc" id="L508" title="All 4 branches covered.">        if ( style.dimensionality().preferredWidth().isPresent() || style.dimensionality().preferredHeight().isPresent() ) {</span>
<span class="fc" id="L509">            Dimension prefSize = _owner.getPreferredSize();</span>

<span class="pc bpc" id="L511" title="1 of 2 branches missed.">            int prefWidth  = style.dimensionality().preferredWidth().orElse(prefSize == null ? 0 : prefSize.width);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            int prefHeight = style.dimensionality().preferredHeight().orElse(prefSize == null ? 0 : prefSize.height);</span>

<span class="fc" id="L514">            Dimension newPrefSize = new Dimension(prefWidth, prefHeight);</span>

<span class="fc bfc" id="L516" title="All 2 branches covered.">            if ( !newPrefSize.equals(prefSize) )</span>
<span class="fc" id="L517">                _owner.setPreferredSize(newPrefSize);</span>
        }

<span class="fc bfc" id="L520" title="All 4 branches covered.">        if ( style.dimensionality().width().isPresent() || style.dimensionality().height().isPresent() ) {</span>
<span class="fc" id="L521">            Dimension size = _owner.getSize();</span>

<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            int width  = style.dimensionality().width().orElse(size == null ? 0 : size.width);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            int height = style.dimensionality().height().orElse(size == null ? 0 : size.height);</span>

<span class="fc" id="L526">            Dimension newSize = new Dimension(width, height);</span>

<span class="fc bfc" id="L528" title="All 2 branches covered.">            if ( ! newSize.equals(size) )</span>
<span class="fc" id="L529">                _owner.setSize(newSize);</span>
        }

<span class="fc bfc" id="L532" title="All 2 branches covered.">        if ( _owner instanceof JTextComponent ) {</span>
<span class="fc" id="L533">            JTextComponent tc = (JTextComponent) _owner;</span>
<span class="fc bfc" id="L534" title="All 4 branches covered.">            if ( style.font().selectionColor().isPresent() &amp;&amp; ! Objects.equals( tc.getSelectionColor(), style.font().selectionColor().get() ) )</span>
<span class="fc" id="L535">                tc.setSelectionColor(style.font().selectionColor().get());</span>
        }

<span class="fc bfc" id="L538" title="All 2 branches covered.">        if ( _owner instanceof JComboBox ) {</span>
<span class="fc" id="L539">            int bottom = style.margin().bottom().orElse(0);</span>
            // We adjust the position of the popup menu:
            try {
<span class="nc" id="L542">                Point location = _owner.getLocationOnScreen();</span>
<span class="nc" id="L543">                int x = location.x;</span>
<span class="nc" id="L544">                int y = location.y + _owner.getHeight() - bottom;</span>
<span class="nc" id="L545">                JComboBox&lt;?&gt; comboBox = (JComboBox&lt;?&gt;) _owner;</span>
<span class="nc" id="L546">                JPopupMenu popup = (JPopupMenu) comboBox.getAccessibleContext().getAccessibleChild(0);</span>
<span class="nc" id="L547">                Point oldLocation = popup.getLocation();</span>
<span class="nc bnc" id="L548" title="All 6 branches missed.">                if ( popup.isShowing() &amp;&amp; (oldLocation.x != x || oldLocation.y != y) )</span>
<span class="nc" id="L549">                    popup.setLocation(x, y);</span>
<span class="fc" id="L550">            } catch ( Exception e ) {</span>
                // ignore
<span class="nc" id="L552">            }</span>
        }

<span class="fc" id="L555">        style.font()</span>
<span class="fc" id="L556">             .createDerivedFrom(_owner.getFont())</span>
<span class="fc" id="L557">             .ifPresent( newFont -&gt; {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                    if ( !newFont.equals(_owner.getFont()) )</span>
<span class="fc" id="L559">                        _owner.setFont( newFont );</span>
<span class="fc" id="L560">                });</span>

<span class="fc" id="L562">        style.font().horizontalAlignment().ifPresent( alignment -&gt; {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if ( _owner instanceof JLabel ) {</span>
<span class="fc" id="L564">                JLabel label = (JLabel) _owner;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                if ( !Objects.equals( label.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L566">                    label.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc bfc" id="L568" title="All 2 branches covered.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="fc" id="L569">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if ( !Objects.equals( button.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L571">                    button.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc bfc" id="L573" title="All 2 branches covered.">            if ( _owner instanceof JTextField ) {</span>
<span class="fc" id="L574">                JTextField textField = (JTextField) _owner;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                if ( !Objects.equals( textField.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L576">                    textField.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc" id="L578">        });</span>
<span class="fc" id="L579">        style.font().verticalAlignment().ifPresent( alignment -&gt; {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            if ( _owner instanceof JLabel ) {</span>
<span class="nc" id="L581">                JLabel label = (JLabel) _owner;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if ( !Objects.equals( label.getVerticalAlignment(), alignment.forSwing() ) )</span>
<span class="nc" id="L583">                    label.setVerticalAlignment( alignment.forSwing() );</span>
            }
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="nc" id="L586">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                if ( !Objects.equals( button.getVerticalAlignment(), alignment.forSwing() ) )</span>
<span class="nc" id="L588">                    button.setVerticalAlignment( alignment.forSwing() );</span>
            }
<span class="nc" id="L590">        });</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">        if ( !onlyDimensionalityIsStyled ) {</span>
<span class="fc" id="L593">            _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            if ( !styleCanBeRenderedThroughBorder )</span>
<span class="fc" id="L595">                _dynamicLaF = _dynamicLaF.establishLookAndFeelFor(style, _owner);</span>
        }

<span class="fc bfc" id="L598" title="All 2 branches covered.">        if ( style.hasCustomForegroundPainters() )</span>
<span class="fc" id="L599">            _makeAllChildrenTransparent(_owner);</span>

<span class="pc bpc" id="L601" title="1 of 4 branches missed.">        if ( style.hasActiveBackgroundGradients() &amp;&amp; _owner.isOpaque() )</span>
<span class="nc" id="L602">            _owner.setOpaque(false);</span>

<span class="fc" id="L604">        style.properties().forEach( property -&gt; {</span>

<span class="fc" id="L606">            Object oldValue = _owner.getClientProperty(property.name());</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            if ( property.style().equals(oldValue) )</span>
<span class="fc" id="L608">                return;</span>

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">            if ( property.style().isEmpty() )</span>
<span class="nc" id="L611">                _owner.putClientProperty(property.name(), null); // remove property</span>
            else
<span class="fc" id="L613">                _owner.putClientProperty(property.name(), property.style());</span>
<span class="fc" id="L614">        });</span>

<span class="fc" id="L616">        return style;</span>
    }

    private void _applyAlignmentToMigLayoutIfItExists(LayoutStyle style)
    {
<span class="fc" id="L621">        Optional&lt;Float&gt; alignmentX = style.alignmentX();</span>
<span class="fc" id="L622">        Optional&lt;Float&gt; alignmentY = style.alignmentY();</span>

<span class="pc bpc" id="L624" title="1 of 4 branches missed.">        if ( !alignmentX.isPresent() &amp;&amp; !alignmentY.isPresent() )</span>
<span class="fc" id="L625">            return;</span>

<span class="fc bfc" id="L627" title="All 2 branches covered.">        LayoutManager layout = ( _owner.getParent() == null ? null : _owner.getParent().getLayout() );</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">        if ( layout instanceof MigLayout ) {</span>
<span class="fc" id="L629">            MigLayout migLayout = (MigLayout) layout;</span>
<span class="fc" id="L630">            Object rawComponentConstraints = migLayout.getComponentConstraints(_owner);</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if ( rawComponentConstraints instanceof String )</span>
<span class="nc" id="L632">                rawComponentConstraints = ConstraintParser.parseComponentConstraint(rawComponentConstraints.toString());</span>

<span class="pc bpc" id="L634" title="1 of 2 branches missed.">            CC componentConstraints = (rawComponentConstraints instanceof CC ? (CC) rawComponentConstraints : null);</span>

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">            final CC finalComponentConstraints = ( componentConstraints == null ? new CC() : componentConstraints );</span>

<span class="fc" id="L638">            String x = alignmentX.map( a -&gt; (int) ( a * 100f ) )</span>
<span class="fc" id="L639">                                  .map( a -&gt; a + &quot;%&quot; )</span>
<span class="fc" id="L640">                                  .orElse(&quot;&quot;);</span>

<span class="fc" id="L642">            String y = alignmentY.map( a -&gt; (int) ( a * 100f ) )</span>
<span class="fc" id="L643">                                  .map( a -&gt; a + &quot;%&quot; )</span>
<span class="fc" id="L644">                                  .orElse(&quot;&quot;);</span>

<span class="fc" id="L646">            DimConstraint horizontalDimConstraint = finalComponentConstraints.getHorizontal();</span>
<span class="fc" id="L647">            DimConstraint verticalDimConstraint   = finalComponentConstraints.getVertical();</span>

<span class="fc" id="L649">            UnitValue xAlign = horizontalDimConstraint.getAlign();</span>
<span class="fc" id="L650">            UnitValue yAlign = verticalDimConstraint.getAlign();</span>

<span class="pc bpc" id="L652" title="2 of 4 branches missed.">            boolean xChange = !x.equals( xAlign == null ? &quot;&quot; : xAlign.getConstraintString() );</span>
<span class="pc bpc" id="L653" title="2 of 4 branches missed.">            boolean yChange = !y.equals( yAlign == null ? &quot;&quot; : yAlign.getConstraintString() );</span>

<span class="pc bpc" id="L655" title="2 of 4 branches missed.">            if ( !x.isEmpty() &amp;&amp; xChange )</span>
<span class="fc" id="L656">                finalComponentConstraints.alignX(x);</span>

<span class="pc bpc" id="L658" title="2 of 4 branches missed.">            if ( !y.isEmpty() &amp;&amp; yChange )</span>
<span class="fc" id="L659">                finalComponentConstraints.alignY(y);</span>

<span class="pc bpc" id="L661" title="3 of 4 branches missed.">            if ( xChange || yChange ) {</span>
<span class="fc" id="L662">                migLayout.setComponentConstraints(_owner, finalComponentConstraints);</span>
<span class="fc" id="L663">                _owner.getParent().revalidate();</span>
            }
        }
<span class="fc" id="L666">    }</span>

    /**
     *  Note that the foreground painter is intended to paint over all children of the component, &lt;br&gt;
     *  which is why it will be called at the end of {@code JComponent::paintChildren(Graphics)}.
     *  &lt;br&gt;
     *  However, there is a problem with this approach! &lt;br&gt;
     *  If not all children are transparent, the result of the foreground painter can be overwritten
     *  by {@link JComponent#paintImmediately(int, int, int, int)} when certain events occur
     *  (like a child component is a text field with a blinking cursor, or a button with hover effect).
     *  This type of repaint does unfortunately not call {@code JComponent::paintChildren(Graphics)},
     *  in fact it completely bypasses the rendering of this current component!
     *  In order to ensure that the stuff painted by the foreground painter is not overwritten
     *  in these types of cases,
     *  we make all children transparent (non-opaque) so that the foreground painter is always visible.
     *
     * @param c The component to make all children transparent.
     */
    private void _makeAllChildrenTransparent( JComponent c ) {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if ( c.isOpaque() )</span>
<span class="nc" id="L686">            c.setOpaque(false);</span>

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        for ( Component child : c.getComponents() ) {</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if ( child instanceof JComponent ) {</span>
<span class="nc" id="L690">                JComponent jChild = (JComponent) child;</span>
<span class="nc" id="L691">                _makeAllChildrenTransparent(jChild);</span>
            }
        }
<span class="fc" id="L694">    }</span>

    private void _installCustomBorderBasedStyleAndAnimationRenderer() {
<span class="fc" id="L697">        Border currentBorder = _owner.getBorder();</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if ( !(currentBorder instanceof StyleAndAnimationBorder) )</span>
<span class="fc" id="L699">            _owner.setBorder(new StyleAndAnimationBorder&lt;&gt;(this, currentBorder));</span>
<span class="fc" id="L700">    }</span>

    private void _uninstallCustomBorderBasedStyleAndAnimationRenderer() {
<span class="fc" id="L703">        Border currentBorder = _owner.getBorder();</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if ( currentBorder instanceof StyleAndAnimationBorder) {</span>
<span class="fc" id="L705">            StyleAndAnimationBorder&lt;?&gt; border = (StyleAndAnimationBorder&lt;?&gt;) currentBorder;</span>
<span class="fc" id="L706">            _owner.setBorder(border.getFormerBorder());</span>
        }
<span class="fc" id="L708">    }</span>

    static boolean _componentIsDeclaredInUI(JComponent comp ) {
        // The component must be a subtype of one of the classes enclosed in this UI class!
        // Let's get all the classes declared in UI:
<span class="nc" id="L713">        Class&lt;?&gt;[] declaredInUI = UI.class.getDeclaredClasses();</span>
        // We want to ensure that the component is a sub-type of any of the classes declared in UI.
<span class="nc" id="L715">        Class&lt;?&gt; clazz = comp.getClass();</span>
<span class="nc" id="L716">        boolean isSwingTreeComponent = false;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        while ( clazz != null ) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            for ( Class&lt;?&gt; c : declaredInUI )</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                if ( c.isAssignableFrom(clazz) ) {</span>
<span class="nc" id="L720">                    isSwingTreeComponent = true;</span>
<span class="nc" id="L721">                    break;</span>
                }

<span class="nc" id="L724">            clazz = clazz.getSuperclass();</span>
        }
<span class="nc" id="L726">        return isSwingTreeComponent;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>