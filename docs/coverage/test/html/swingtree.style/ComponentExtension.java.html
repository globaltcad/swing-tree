<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComponentExtension.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">ComponentExtension.java</span></div><h1>ComponentExtension.java</h1><pre class="source lang-java linenums">package swingtree.style;

import net.miginfocom.layout.CC;
import net.miginfocom.layout.ConstraintParser;
import net.miginfocom.layout.DimConstraint;
import net.miginfocom.layout.UnitValue;
import net.miginfocom.swing.MigLayout;
import swingtree.UI;
import swingtree.animation.AnimationState;
import swingtree.api.Painter;
import swingtree.api.Styler;
import swingtree.components.JIcon;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.text.JTextComponent;
import java.awt.*;
import java.util.List;
import java.util.*;
import java.util.function.Supplier;

/**
 *  Is attached to UI components in the form of a client property.
 *  It exists to give Swing-Tree components some custom style and animation capabilities.
 */
public final class ComponentExtension&lt;C extends JComponent&gt;
{
    /**
     * Returns the {@link ComponentExtension} associated with the given component.
     * If the component does not have an extension, a new one is created and associated with the component.
     *
     * @param comp The component for which to get the extension.
     * @return The extension associated with the component.
     * @param &lt;C&gt; The type of the component.
     */
    public static &lt;C extends JComponent&gt; ComponentExtension&lt;C&gt; from( C comp ) {
<span class="fc" id="L37">        ComponentExtension&lt;C&gt; ext = (ComponentExtension&lt;C&gt;) comp.getClientProperty( ComponentExtension.class );</span>
<span class="fc bfc" id="L38" title="All 2 branches covered.">        if ( ext == null ) {</span>
<span class="fc" id="L39">            ext = new ComponentExtension&lt;&gt;(comp);</span>
<span class="fc" id="L40">            comp.putClientProperty( ComponentExtension.class, ext );</span>
        }
<span class="fc" id="L42">        return ext;</span>
    }

    /**
     *  Initializes the given component with a new {@link ComponentExtension}.
     *  This method is called by a SwingTree builder node when it
     *  receives and builds a new component.
     *  The former extension of the component is replaced by a new one.
     *
     * @param comp The component to initialize.
     */
    public static void initializeFor( JComponent comp ) {
<span class="fc" id="L54">        from(comp);</span>
<span class="fc" id="L55">    }</span>

    private final C _owner;

<span class="fc" id="L59">    private final List&lt;Object&gt; _extraState = new ArrayList&lt;&gt;(0);</span>

<span class="fc" id="L61">    private final List&lt;String&gt; _styleGroups = new ArrayList&lt;&gt;(0);</span>


<span class="fc" id="L64">    private StyleEngine     _styleEngine = StyleEngine.create();</span>
<span class="fc" id="L65">    private DynamicLaF      _dynamicLaF   = DynamicLaF.none();</span>
<span class="fc" id="L66">    private StyleSource&lt;C&gt;  _styleSource  = StyleSource.create();</span>

<span class="fc" id="L68">    private Color _initialBackgroundColor = null;</span>

<span class="fc" id="L70">    private Shape _outerBaseClip = null;</span>


<span class="fc" id="L73">    private ComponentExtension( C owner ) { _owner = Objects.requireNonNull(owner); }</span>


<span class="fc" id="L76">    C getOwner() { return _owner; }</span>

    /**
     *  Allows for extra state to be attached to the component extension.
     *  (Conceptually similar to how Swing components can have client properties.)&lt;br&gt;
     *  If the component already has an object of the given type attached,
     *  that object is returned. Otherwise, the given fetcher is used to create
     *  a new object of the given type, which is then attached to the component
     *  and returned.
     *
     * @param type The type of the extra state to attach.
     * @param fetcher A supplier which is used to create a new object of the given type.
     * @return The extra state object of the given type which is attached to the component.
     * @param &lt;P&gt; The type of the extra state.
     */
    public &lt;P&gt; P getOrSet( Class&lt;P&gt; type, Supplier&lt;P&gt; fetcher ) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for ( Object plugin : _extraState)</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            if ( type.isInstance(plugin) )</span>
<span class="fc" id="L94">                return (P) plugin;</span>

<span class="fc" id="L96">        P plugin = fetcher.get();</span>
<span class="fc" id="L97">        _extraState.add(plugin);</span>
<span class="fc" id="L98">        return plugin;</span>
    }

    /**
     *   This method is used by {@link swingtree.UIForAnySwing#group(String...)} to attach
     *   so called &lt;i&gt;group tags&lt;/i&gt; to a component. &lt;br&gt;
     *   They are used by the SwingTree style engine to apply
     *   styles with the same tags, which
     *   is conceptually similar to CSS classes. &lt;br&gt;
     *   &lt;b&gt;It is advised to use the {@link #setStyleGroups(Enum[])} method
     *   instead of this method, as the usage of enums for modelling
     *   group tags offers much better compile time type safety!&lt;/b&gt;
     *
     * @param groupTags An array of group tags.
     */
    public void setStyleGroups( String... groupTags ) {
<span class="fc" id="L114">        Objects.requireNonNull(groupTags);</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        boolean alreadyHasGroupTags = !_styleGroups.isEmpty();</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if ( alreadyHasGroupTags )</span>
<span class="nc" id="L117">            _styleGroups.clear();</span>

<span class="fc" id="L119">        _styleGroups.addAll( java.util.Arrays.asList(groupTags) );</span>

<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if ( alreadyHasGroupTags )</span>
<span class="nc" id="L122">            gatherApplyAndInstallStyle(false);</span>
<span class="fc" id="L123">    }</span>

    /**
     *   This method is used by {@link swingtree.UIForAnySwing#group(String...)}
     *   to attach so called &lt;i&gt;group tags&lt;/i&gt; to a component. &lt;br&gt;
     *   They are used by the SwingTree style engine to apply
     *   styles with the same tags, which
     *   is conceptually similar to CSS classes. &lt;br&gt;
     *   It is advised to use this method over the {@link #setStyleGroups(String[])}
     *   method, as the usage of enums for modelling
     *   group tags offers much better compile time type safety!
     *
     * @param groupTags An array of group tags.
     * @param &lt;E&gt; The type of the enum.
     */
    @SafeVarargs
    public final &lt;E extends Enum&lt;E&gt;&gt; void setStyleGroups( E... groupTags ) {
<span class="fc" id="L140">        String[] stringTags = new String[groupTags.length];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for ( int i = 0; i &lt; groupTags.length; i++ ) {</span>
<span class="fc" id="L142">            E group = groupTags[i];</span>
<span class="fc" id="L143">            Objects.requireNonNull(group);</span>
<span class="fc" id="L144">            stringTags[i] = StyleUtility.toString(group);</span>
        }
<span class="fc" id="L146">        setStyleGroups(stringTags);</span>
<span class="fc" id="L147">    }</span>

    public final void setId( String id ) {
<span class="fc" id="L150">        _owner.setName(id);</span>
<span class="fc" id="L151">    }</span>

    public final &lt;E extends Enum&lt;E&gt;&gt; void setId( E id ) {
<span class="nc" id="L154">        this.setId(StyleUtility.toString(id));</span>
<span class="nc" id="L155">    }</span>

    public final boolean hasId( String id ) {
<span class="fc" id="L158">        return Objects.equals(_owner.getName(), id);</span>
    }

    public final boolean hasId( Enum&lt;?&gt; id ) {
<span class="nc" id="L162">        return hasId(StyleUtility.toString(id));</span>
    }

    final UI.Placement preferredIconPlacement() {
<span class="fc" id="L166">        UI.Placement preferredPlacement = UI.Placement.UNDEFINED;</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if ( _hasText(_owner) )</span>
<span class="nc" id="L168">            preferredPlacement = UI.Placement.LEFT;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if ( !Objects.equals(ComponentOrientation.UNKNOWN, _owner.getComponentOrientation()) ) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (  Objects.equals(ComponentOrientation.LEFT_TO_RIGHT, _owner.getComponentOrientation()) )</span>
<span class="nc" id="L171">                preferredPlacement = UI.Placement.LEFT;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (  Objects.equals(ComponentOrientation.RIGHT_TO_LEFT, _owner.getComponentOrientation()) )</span>
<span class="nc" id="L173">                preferredPlacement = UI.Placement.RIGHT;</span>
        }
<span class="fc" id="L175">        return preferredPlacement;</span>
    }

    private boolean _hasText( Component component ) {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        return !Optional.ofNullable( _findTextOf(component) ).map( String::isEmpty ).orElse(true);</span>
    }

    private String _findTextOf( Component component ) {
        // We go through all the components which can display text and return the first one we find:
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if ( component instanceof javax.swing.AbstractButton ) // Covers JButton, JToggleButton, JCheckBox, JRadioButton...</span>
<span class="fc" id="L185">            return ((javax.swing.AbstractButton) component).getText();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if ( component instanceof javax.swing.JLabel )</span>
<span class="nc" id="L187">            return ((javax.swing.JLabel) component).getText();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if ( component instanceof JTextComponent )</span>
<span class="nc" id="L189">            return ((JTextComponent) component).getText();</span>

<span class="nc" id="L191">        return &quot;&quot;;</span>
    }

    /**
     * @return The group tags associated with the component
     *         in the form of an unmodifiable list of {@link String}s.
     */
<span class="fc" id="L198">    public List&lt;String&gt; getStyleGroups() { return Collections.unmodifiableList(_styleGroups); }</span>

    /**
     * @param group The group to check.
     * @return {@code true} if the component belongs to the given group.
     */
<span class="fc" id="L204">    public boolean belongsToGroup( String group ) { return _styleGroups.contains(group); }</span>

    /**
     * @param group The group to check.
     * @return {@code true} if the component belongs to the given group.
     */
    public boolean belongsToGroup( Enum&lt;?&gt; group ) {
<span class="nc" id="L211">        return belongsToGroup(StyleUtility.toString(group));</span>
    }

<span class="fc" id="L214">    Shape getCurrentOuterBaseClip() { return _outerBaseClip; }</span>

    /**
     * @return The current {@link Style} configuration of the component
     *         which is calculated based on the {@link Styler} lambdas
     *         associated with the component.
     */
<span class="fc" id="L221">    public Style getStyle() { return _styleEngine.getComponentConf().style(); }</span>

    ComponentConf getConf() {
<span class="fc" id="L224">        return _styleEngine.getComponentConf();</span>
    }

    /**
     *  Removes all animations from the component.
     *  This includes both {@link Painter} based animations
     *  as well as {@link Styler} based animations.
     */
    public void clearAnimations() {
<span class="fc" id="L233">        _styleEngine = _styleEngine.withoutAnimationPainters();</span>
<span class="fc" id="L234">        _styleSource = _styleSource.withoutAnimationStylers();</span>
<span class="fc" id="L235">    }</span>

    /**
     *  Use this to add a {@link Painter} based animation to the component.
     *
     * @param state The {@link AnimationState} which defines when the animation is active.
     * @param painter The {@link Painter} which defines how the animation is rendered.
     */
    public void addAnimationPainter( AnimationState state, swingtree.api.Painter painter ) {
<span class="nc" id="L244">        _styleEngine = _styleEngine.withAnimationPainter(state.lifeSpan(), Objects.requireNonNull(painter));</span>
<span class="nc" id="L245">        _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="nc" id="L246">    }</span>

    /**
     *  Use this to add a {@link Styler} based animation to the component.
     *
     * @param state The {@link AnimationState} which defines when the animation is active.
     * @param styler The {@link Styler} which defines how the style of the component is changed during the animation.
     */
    public void addAnimationStyler( AnimationState state, Styler&lt;C&gt; styler ) {
<span class="fc" id="L255">        _styleSource = _styleSource.withAnimationStyler(state.lifeSpan(), styler);</span>
<span class="fc" id="L256">        _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc" id="L257">    }</span>

    /**
     *  SwingTree overrides the default Swing look and feel
     *  to enable custom styling and animation capabilities.
     *  This method is used to install the custom look and feel
     *  for the component, if possible.
     */
<span class="fc" id="L265">    public void installCustomUIIfPossible() { _dynamicLaF.installCustomUIFor(_owner); }</span>

    Insets getMarginInsets() {
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if ( _owner.getBorder() instanceof StyleAndAnimationBorder ) {</span>
<span class="fc" id="L269">            StyleAndAnimationBorder&lt;?&gt; styleBorder = (StyleAndAnimationBorder&lt;?&gt;) _owner.getBorder();</span>
<span class="fc" id="L270">            return styleBorder.getMarginInsets();</span>
        }
        else
<span class="nc" id="L273">            return new Insets(0,0,0,0);</span>
    }

    /**
     *  This method is used to paint the background style of the component
     *  using the provided {@link Graphics} object.
     *  The method is designed for components for which SwingTree could not install a custom UI,
     *  and it is intended to be used by custom {@link JComponent#paint(Graphics)}
     *  overrides, before calling the super implementation.
     *
     * @param g The {@link Graphics} object to use for rendering.
     * @param lookAndFeelPaint A {@link Runnable} which is used to paint the look and feel of the component.
     */
    public void paintBackgroundStyle( Graphics g, Runnable lookAndFeelPaint )
    {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if ( _dynamicLaF.customLookAndFeelIsInstalled() ) {</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if ( lookAndFeelPaint != null )</span>
<span class="fc" id="L290">                lookAndFeelPaint.run();</span>
<span class="fc" id="L291">            return; // We render ĥere through the custom installed UI!</span>
        }
<span class="fc" id="L293">        paintBackground(g, lookAndFeelPaint);</span>
<span class="fc" id="L294">    }</span>

    /**
     *  This method is used to paint the foreground style of the component
     *  using the provided {@link Graphics2D} object.
     *
     * @param g2d The {@link Graphics2D} object to use for rendering.
     * @param superPaint A {@link Runnable} which is used to paint the look and feel of the component.
     */
    public void paintForeground( Graphics2D g2d, Runnable superPaint )
    {
<span class="fc" id="L305">        gatherApplyAndInstallStyleConfig();</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">        Shape clip = _outerBaseClip != null ? _outerBaseClip : g2d.getClip();</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if ( _owner instanceof JScrollPane ) {</span>
            /*
                Scroll panes are not like other components, they have a viewport
                which clips the children.
                Now if we have a round border for the scroll pane, we want the
                children to be clipped by the round border (and the viewport).
                So we use the inner component area as the clip for the children.
            */
<span class="fc" id="L316">            clip = StyleUtility.intersect( _styleEngine.getComponentConf().componentArea().orElse(clip), clip );</span>
        }
<span class="fc" id="L318">        paintWithClip(g2d, clip, ()-&gt;{</span>
<span class="fc" id="L319">            superPaint.run();</span>
<span class="fc" id="L320">        });</span>

        // We remember if antialiasing was enabled before we render:
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>
        // Reset antialiasing to its previous state:
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if ( StyleEngine.IS_ANTIALIASING_ENABLED() )</span>
<span class="fc" id="L326">            g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );</span>

        // We remember the clip:
<span class="fc" id="L329">        Shape formerClip = g2d.getClip();</span>

<span class="fc" id="L331">        Font componentFont = _owner.getFont();</span>
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">        if ( componentFont != null &amp;&amp; !componentFont.equals(g2d.getFont()) )</span>
<span class="fc" id="L333">            g2d.setFont( componentFont );</span>

<span class="fc" id="L335">        _styleEngine.paintForeground(g2d);</span>

        // We restore the clip:
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if ( g2d.getClip() != formerClip )</span>
<span class="fc" id="L339">            g2d.setClip(formerClip);</span>

        // Reset antialiasing to its previous state:
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>
<span class="fc" id="L343">    }</span>

    void paintWithContentAreaClip( Graphics g, Runnable painter ) {
<span class="fc" id="L346">        gatherApplyAndInstallStyleConfig();</span>
<span class="fc" id="L347">        _styleEngine.getComponentConf().paintClippedTo(UI.ComponentArea.BODY, g, painter);</span>
<span class="fc" id="L348">    }</span>

    /**
     *  Adds a {@link Styler} to the component.
     *  The styler will be used to calculate the style of the component.
     *
     * @param styler The styler to add.
     */
    public void addStyler( Styler&lt;C&gt; styler ) {
<span class="fc" id="L357">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L358">        _styleSource = _styleSource.withLocalStyler(styler);</span>
<span class="fc" id="L359">        gatherApplyAndInstallStyle(false);</span>
<span class="fc" id="L360">    }</span>

    /**
     *  Calculates a new {@link Style} object based on the {@link Styler} lambdas associated
     *  with the component...
     *
     * @return A new immutable {@link Style} configuration.
     */
    public Style gatherStyle() {
<span class="fc" id="L369">        return _styleSource.gatherStyleFor(_owner);</span>
    }

    /**
     *  Calculates a new {@link Style} object based on the {@link Styler} lambdas associated
     *  with the component and then applies it to the component after which
     *  a new {@link StyleEngine} is installed for the component.
     *  If the calculated style is the same as the current style, nothing happens
     *  except in case the &lt;code&gt;force&lt;/code&gt; parameter is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param force If set to &lt;code&gt;true&lt;/code&gt;, the style will be applied even if it is the same as the current style.
     */
    public void gatherApplyAndInstallStyle( boolean force ) {
<span class="fc" id="L382">        _installStyle( _applyStyleToComponentState(gatherStyle(), force) );</span>
<span class="fc" id="L383">    }</span>

    /**
     *  Applies the given {@link Style} to the component after which
     *  a new {@link StyleEngine} is installed for the component.
     *  If the given style is the same as the current style, nothing happens
     *  except in case the &lt;code&gt;force&lt;/code&gt; parameter is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param style The style to apply.
     * @param force If set to &lt;code&gt;true&lt;/code&gt;, the style will be applied even if it is the same as the current style.
     */
    public void applyAndInstallStyle( Style style, boolean force ) {
<span class="fc" id="L395">        _installStyle( _applyStyleToComponentState(style, force) );</span>
<span class="fc" id="L396">    }</span>

    void gatherApplyAndInstallStyleConfig() {
<span class="fc" id="L399">        _installStyle( _applyStyleToComponentState(gatherStyle(), false) );</span>
<span class="fc" id="L400">    }</span>

    private void _installStyle( Style style ) {
<span class="fc" id="L403">        _styleEngine = _styleEngine.withNewStyleAndComponent(style, _owner);</span>
<span class="fc" id="L404">    }</span>

    void paintBackground( Graphics g, Runnable lookAndFeelPainting )
    {
<span class="fc" id="L408">        gatherApplyAndInstallStyleConfig();</span>

<span class="fc" id="L410">        _outerBaseClip = g.getClip();</span>

<span class="fc bfc" id="L412" title="All 4 branches covered.">        if ( _outerBaseClip == null &amp;&amp; _owner.getParent() == null ) {</span>
            // Happens when rendering individual components (usually unit tests)!
<span class="fc" id="L414">            int x = (int) ((Graphics2D) g).getTransform().getTranslateX();</span>
<span class="fc" id="L415">            int y = (int) ((Graphics2D) g).getTransform().getTranslateY();</span>
<span class="fc" id="L416">            int w = _owner.getWidth();</span>
<span class="fc" id="L417">            int h = _owner.getHeight();</span>
<span class="fc" id="L418">            _outerBaseClip = new Rectangle(x,y,w,h);</span>
        }

<span class="fc" id="L421">        Font componentFont = _owner.getFont();</span>
<span class="pc bpc" id="L422" title="1 of 4 branches missed.">        if ( componentFont != null &amp;&amp; !componentFont.equals(g.getFont()) )</span>
<span class="fc" id="L423">            g.setFont( componentFont );</span>

<span class="fc" id="L425">        _styleEngine.renderBackgroundStyle( (Graphics2D) g);</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">        if ( lookAndFeelPainting != null ) {</span>
<span class="fc" id="L428">            Shape contentClip = _styleEngine.getComponentConf().componentArea().orElse(null);</span>

<span class="fc" id="L430">            contentClip = StyleUtility.intersect( contentClip, _outerBaseClip );</span>

<span class="fc" id="L432">            paintWithClip((Graphics2D) g, contentClip, () -&gt; {</span>
                try {
<span class="fc" id="L434">                    lookAndFeelPainting.run();</span>
<span class="nc" id="L435">                } catch (Exception e) {</span>
<span class="nc" id="L436">                    e.printStackTrace();</span>
<span class="fc" id="L437">                }</span>
<span class="fc" id="L438">            });</span>
        }
<span class="fc" id="L440">    }</span>

    void paintBorderAndAnimations( Graphics2D g2d, Runnable formerBorderPainter )
    {
<span class="fc" id="L444">        gatherApplyAndInstallStyleConfig();</span>

<span class="fc" id="L446">        Shape former = g2d.getClip();</span>

<span class="fc bfc" id="L448" title="All 2 branches covered.">        if ( getCurrentOuterBaseClip() != null )</span>
<span class="fc" id="L449">            g2d.setClip( getCurrentOuterBaseClip() );</span>

<span class="fc" id="L451">        _styleEngine.paintBorder(g2d, formerBorderPainter);</span>
<span class="fc" id="L452">        _styleEngine.paintAnimations(g2d);</span>
<span class="fc" id="L453">        _styleEngine = _styleEngine.withoutExpiredAnimationPainters();</span>

<span class="fc" id="L455">        g2d.setClip(former);</span>
<span class="fc" id="L456">    }</span>

    private Style _applyStyleToComponentState( Style newStyle, boolean force )
    {
<span class="fc" id="L460">        _styleSource = _styleSource.withoutExpiredAnimationStylers(); // Clean up expired animation stylers!</span>

<span class="fc" id="L462">        Objects.requireNonNull(newStyle);</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">        if ( _owner.getBorder() instanceof StyleAndAnimationBorder&lt;?&gt; ) {</span>
<span class="fc" id="L465">            StyleAndAnimationBorder&lt;C&gt; border = (StyleAndAnimationBorder&lt;C&gt;) _owner.getBorder();</span>
<span class="fc" id="L466">            border.recalculateInsets(newStyle);</span>
        }

<span class="fc bfc" id="L469" title="All 4 branches covered.">        if ( _styleEngine.getComponentConf().style().equals(newStyle) &amp;&amp; !force )</span>
<span class="fc" id="L470">            return newStyle;</span>

<span class="fc" id="L472">        final Style.Report styleReport = newStyle.getReport();</span>

<span class="fc" id="L474">        boolean isNotStyled                     = styleReport.isNotStyled();</span>
<span class="fc" id="L475">        boolean onlyDimensionalityIsStyled      = styleReport.onlyDimensionalityIsStyled();</span>
<span class="pc bpc" id="L476" title="3 of 18 branches missed.">        boolean styleCanBeRenderedThroughBorder = (</span>
                                                       styleReport.noBaseStyle    &amp;&amp;
                                                       (styleReport.noShadowStyle || styleReport.allShadowsAreBorderShadows)     &amp;&amp;
                                                       (styleReport.noPainters    || styleReport.allPaintersAreBorderPainters)   &amp;&amp;
                                                       (styleReport.noGradients   || styleReport.allGradientsAreBorderGradients) &amp;&amp;
                                                       (styleReport.noImages      || styleReport.allImagesAreBorderImages)
                                                   );

<span class="fc bfc" id="L484" title="All 4 branches covered.">        if ( isNotStyled || onlyDimensionalityIsStyled ) {</span>
<span class="fc" id="L485">            _dynamicLaF = _dynamicLaF._uninstallCustomLaF(_owner);</span>
<span class="pc bpc" id="L486" title="2 of 4 branches missed.">            if ( _styleSource.hasNoAnimationStylers() &amp;&amp; _styleEngine.hasNoPainters() )</span>
<span class="fc" id="L487">                _uninstallCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            if ( _initialBackgroundColor != null ) {</span>
<span class="fc" id="L489">                _owner.setBackground(_initialBackgroundColor);</span>
<span class="fc" id="L490">                _initialBackgroundColor = null;</span>
            }
<span class="fc bfc" id="L492" title="All 2 branches covered.">            if ( isNotStyled )</span>
<span class="fc" id="L493">                return newStyle;</span>
        }

<span class="fc" id="L496">        boolean hasBorderRadius = newStyle.border().hasAnyNonZeroArcs();</span>
<span class="fc" id="L497">        boolean hasBackground   = newStyle.base().backgroundColor().isPresent();</span>

<span class="fc bfc" id="L499" title="All 4 branches covered.">        if ( hasBackground &amp;&amp; !Objects.equals( _owner.getBackground(), newStyle.base().backgroundColor().get() ) ) {</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            _initialBackgroundColor = _initialBackgroundColor != null ? _initialBackgroundColor :  _owner.getBackground();</span>
<span class="fc" id="L501">            Color newColor =  newStyle.base().backgroundColor().get();</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="fc" id="L503">                newColor = null;</span>
<span class="fc" id="L504">            _owner.setBackground( newColor );</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if ( _owner instanceof JScrollPane ) {</span>
<span class="fc" id="L506">                JScrollPane scrollPane = (JScrollPane) _owner;</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">                if ( scrollPane.getViewport() != null ) {</span>
<span class="fc" id="L508">                    newColor = newStyle.base().backgroundColor().get();</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                    if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="nc" id="L510">                        newColor = null;</span>
<span class="fc" id="L511">                    scrollPane.getViewport().setBackground( newColor );</span>
                }
            }
        }

        // If the style has a border radius set we need to make sure that we have a background color:
<span class="fc bfc" id="L517" title="All 4 branches covered.">        if ( hasBorderRadius &amp;&amp; !hasBackground ) {</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">            _initialBackgroundColor = _initialBackgroundColor != null ? _initialBackgroundColor :  _owner.getBackground();</span>
<span class="fc" id="L519">            newStyle = newStyle.backgroundColor(_initialBackgroundColor);</span>
        }

<span class="fc bfc" id="L522" title="All 4 branches covered.">        if ( newStyle.base().foregroundColor().isPresent() &amp;&amp; !Objects.equals( _owner.getForeground(), newStyle.base().foregroundColor().get() ) ) {</span>
<span class="fc" id="L523">            Color newColor = newStyle.base().foregroundColor().get();</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">            if ( newColor == UI.COLOR_UNDEFINED)</span>
<span class="fc" id="L525">                newColor = null;</span>
<span class="fc" id="L526">            _owner.setForeground( newColor );</span>
        }


<span class="fc" id="L530">        newStyle.base().cursor().ifPresent( cursor -&gt; {</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getCursor(), cursor ) )</span>
<span class="fc" id="L532">                _owner.setCursor( cursor );</span>
<span class="fc" id="L533">        });</span>

<span class="fc bfc" id="L535" title="All 2 branches covered.">        if ( newStyle.base().orientation() != UI.ComponentOrientation.UNKNOWN ) {</span>
<span class="fc" id="L536">            ComponentOrientation currentOrientation = _owner.getComponentOrientation();</span>
<span class="fc" id="L537">            UI.ComponentOrientation newOrientation = newStyle.base().orientation();</span>
<span class="pc bpc" id="L538" title="1 of 3 branches missed.">            switch ( newOrientation ) {</span>
                case LEFT_TO_RIGHT:
<span class="fc bfc" id="L540" title="All 2 branches covered.">                    if ( !Objects.equals( currentOrientation, ComponentOrientation.LEFT_TO_RIGHT ) )</span>
<span class="fc" id="L541">                        _owner.applyComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT);</span>
                    break;
                case RIGHT_TO_LEFT:
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if ( !Objects.equals( currentOrientation, ComponentOrientation.RIGHT_TO_LEFT ) )</span>
<span class="fc" id="L545">                        _owner.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);</span>
                    break;
                default:
<span class="nc bnc" id="L548" title="All 2 branches missed.">                    if ( !Objects.equals( currentOrientation, ComponentOrientation.UNKNOWN ) )</span>
<span class="nc" id="L549">                        _owner.applyComponentOrientation(ComponentOrientation.UNKNOWN);</span>
                    break;
            }
        }

<span class="fc" id="L554">        UI.FitComponent fit = newStyle.base().fit();</span>
<span class="fc" id="L555">        newStyle.base().icon().ifPresent( icon -&gt; {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if ( icon instanceof SvgIcon) {</span>
<span class="nc" id="L557">                SvgIcon svgIcon = (SvgIcon) icon;</span>
<span class="nc" id="L558">                icon = svgIcon.withFitComponent(fit);</span>
            }
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="nc" id="L561">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if ( !Objects.equals( button.getIcon(), icon ) )</span>
<span class="nc" id="L563">                    button.setIcon( icon );</span>
            }
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if ( _owner instanceof JLabel ) {</span>
<span class="nc" id="L566">                JLabel label = (JLabel) _owner;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                if ( !Objects.equals( label.getIcon(), icon ) )</span>
<span class="nc" id="L568">                    label.setIcon( icon );</span>
            }
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if ( _owner instanceof JIcon ) {</span>
<span class="nc" id="L571">                JIcon jIcon = (JIcon) _owner;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                if ( !Objects.equals( jIcon.getIcon(), icon ) )</span>
<span class="nc" id="L573">                    jIcon.setIcon( icon );</span>
            }
<span class="nc" id="L575">        });</span>

<span class="fc" id="L577">        newStyle.layout().alignmentX().ifPresent( alignmentX -&gt; {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getAlignmentX(), alignmentX ) )</span>
<span class="fc" id="L579">                _owner.setAlignmentX( alignmentX );</span>
<span class="fc" id="L580">        });</span>

<span class="fc" id="L582">        newStyle.layout().alignmentY().ifPresent( alignmentY -&gt; {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if ( !Objects.equals( _owner.getAlignmentY(), alignmentY ) )</span>
<span class="fc" id="L584">                _owner.setAlignmentY( alignmentY );</span>
<span class="fc" id="L585">        });</span>

<span class="fc" id="L587">        newStyle.layout().layout().installFor( _owner );</span>

<span class="fc" id="L589">        _applyAlignmentToMigLayoutIfItExists(newStyle.layout());</span>

<span class="fc bfc" id="L591" title="All 4 branches covered.">        if ( newStyle.dimensionality().minWidth().isPresent() || newStyle.dimensionality().minHeight().isPresent() ) {</span>
<span class="fc" id="L592">            Dimension minSize = _owner.getMinimumSize();</span>

<span class="pc bpc" id="L594" title="1 of 2 branches missed.">            int minWidth  = newStyle.dimensionality().minWidth().orElse(minSize == null ? 0 : minSize.width);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            int minHeight = newStyle.dimensionality().minHeight().orElse(minSize == null ? 0 : minSize.height);</span>

<span class="fc" id="L597">            Dimension newMinSize = new Dimension(minWidth, minHeight);</span>

<span class="fc bfc" id="L599" title="All 2 branches covered.">            if ( ! newMinSize.equals(minSize) )</span>
<span class="fc" id="L600">                _owner.setMinimumSize(newMinSize);</span>
        }

<span class="fc bfc" id="L603" title="All 4 branches covered.">        if ( newStyle.dimensionality().maxWidth().isPresent() || newStyle.dimensionality().maxHeight().isPresent() ) {</span>
<span class="fc" id="L604">            Dimension maxSize = _owner.getMaximumSize();</span>

<span class="pc bpc" id="L606" title="1 of 2 branches missed.">            int maxWidth  = newStyle.dimensionality().maxWidth().orElse(maxSize == null  ? Integer.MAX_VALUE : maxSize.width);</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            int maxHeight = newStyle.dimensionality().maxHeight().orElse(maxSize == null ? Integer.MAX_VALUE : maxSize.height);</span>

<span class="fc" id="L609">            Dimension newMaxSize = new Dimension(maxWidth, maxHeight);</span>

<span class="fc bfc" id="L611" title="All 2 branches covered.">            if ( ! newMaxSize.equals(maxSize) )</span>
<span class="fc" id="L612">                _owner.setMaximumSize(newMaxSize);</span>
        }

<span class="fc bfc" id="L615" title="All 4 branches covered.">        if ( newStyle.dimensionality().preferredWidth().isPresent() || newStyle.dimensionality().preferredHeight().isPresent() ) {</span>
<span class="fc" id="L616">            Dimension prefSize = _owner.getPreferredSize();</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            int prefWidth  = newStyle.dimensionality().preferredWidth().orElse(prefSize == null ? 0 : prefSize.width);</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            int prefHeight = newStyle.dimensionality().preferredHeight().orElse(prefSize == null ? 0 : prefSize.height);</span>

<span class="fc" id="L621">            Dimension newPrefSize = new Dimension(prefWidth, prefHeight);</span>

<span class="fc bfc" id="L623" title="All 2 branches covered.">            if ( !newPrefSize.equals(prefSize) )</span>
<span class="fc" id="L624">                _owner.setPreferredSize(newPrefSize);</span>
        }

<span class="fc bfc" id="L627" title="All 4 branches covered.">        if ( newStyle.dimensionality().width().isPresent() || newStyle.dimensionality().height().isPresent() ) {</span>
<span class="fc" id="L628">            Dimension size = _owner.getSize();</span>

<span class="pc bpc" id="L630" title="1 of 2 branches missed.">            int width  = newStyle.dimensionality().width().orElse(size == null ? 0 : size.width);</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            int height = newStyle.dimensionality().height().orElse(size == null ? 0 : size.height);</span>

<span class="fc" id="L633">            Dimension newSize = new Dimension(width, height);</span>

<span class="fc bfc" id="L635" title="All 2 branches covered.">            if ( ! newSize.equals(size) )</span>
<span class="fc" id="L636">                _owner.setSize(newSize);</span>
        }

<span class="fc bfc" id="L639" title="All 2 branches covered.">        if ( _owner instanceof JTextComponent ) {</span>
<span class="fc" id="L640">            JTextComponent tc = (JTextComponent) _owner;</span>
<span class="fc bfc" id="L641" title="All 4 branches covered.">            if ( newStyle.font().selectionColor().isPresent() &amp;&amp; ! Objects.equals( tc.getSelectionColor(), newStyle.font().selectionColor().get() ) )</span>
<span class="fc" id="L642">                tc.setSelectionColor(newStyle.font().selectionColor().get());</span>
        }

<span class="fc bfc" id="L645" title="All 2 branches covered.">        if ( _owner instanceof JComboBox ) {</span>
<span class="fc" id="L646">            int bottom = newStyle.margin().bottom().map(Number::intValue).orElse(0);</span>
            // We adjust the position of the popup menu:
            try {
<span class="nc" id="L649">                Point location = _owner.getLocationOnScreen();</span>
<span class="nc" id="L650">                int x = location.x;</span>
<span class="nc" id="L651">                int y = location.y + _owner.getHeight() - bottom;</span>
<span class="nc" id="L652">                JComboBox&lt;?&gt; comboBox = (JComboBox&lt;?&gt;) _owner;</span>
<span class="nc" id="L653">                JPopupMenu popup = (JPopupMenu) comboBox.getAccessibleContext().getAccessibleChild(0);</span>
<span class="nc" id="L654">                Point oldLocation = popup.getLocation();</span>
<span class="nc bnc" id="L655" title="All 6 branches missed.">                if ( popup.isShowing() &amp;&amp; (oldLocation.x != x || oldLocation.y != y) )</span>
<span class="nc" id="L656">                    popup.setLocation(x, y);</span>
<span class="fc" id="L657">            } catch ( Exception e ) {</span>
                // ignore
<span class="nc" id="L659">            }</span>
        }

<span class="fc" id="L662">        newStyle.font()</span>
<span class="fc" id="L663">             .createDerivedFrom(_owner.getFont())</span>
<span class="fc" id="L664">             .ifPresent( newFont -&gt; {</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                    if ( !newFont.equals(_owner.getFont()) )</span>
<span class="fc" id="L666">                        _owner.setFont( newFont );</span>
<span class="fc" id="L667">                });</span>

<span class="fc" id="L669">        newStyle.font().horizontalAlignment().ifPresent( alignment -&gt; {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if ( _owner instanceof JLabel ) {</span>
<span class="fc" id="L671">                JLabel label = (JLabel) _owner;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                if ( !Objects.equals( label.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L673">                    label.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="fc" id="L676">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                if ( !Objects.equals( button.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L678">                    button.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if ( _owner instanceof JTextField ) {</span>
<span class="fc" id="L681">                JTextField textField = (JTextField) _owner;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                if ( !Objects.equals( textField.getHorizontalAlignment(), alignment.forSwing() ) )</span>
<span class="fc" id="L683">                    textField.setHorizontalAlignment( alignment.forSwing() );</span>
            }
<span class="fc" id="L685">        });</span>
<span class="fc" id="L686">        newStyle.font().verticalAlignment().ifPresent( alignment -&gt; {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if ( _owner instanceof JLabel ) {</span>
<span class="nc" id="L688">                JLabel label = (JLabel) _owner;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if ( !Objects.equals( label.getVerticalAlignment(), alignment.forSwing() ) )</span>
<span class="nc" id="L690">                    label.setVerticalAlignment( alignment.forSwing() );</span>
            }
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if ( _owner instanceof AbstractButton ) {</span>
<span class="nc" id="L693">                AbstractButton button = (AbstractButton) _owner;</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if ( !Objects.equals( button.getVerticalAlignment(), alignment.forSwing() ) )</span>
<span class="nc" id="L695">                    button.setVerticalAlignment( alignment.forSwing() );</span>
            }
<span class="nc" id="L697">        });</span>

<span class="fc bfc" id="L699" title="All 2 branches covered.">        if ( !onlyDimensionalityIsStyled ) {</span>
<span class="fc" id="L700">            _installCustomBorderBasedStyleAndAnimationRenderer();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">            if ( !styleCanBeRenderedThroughBorder )</span>
<span class="fc" id="L702">                _dynamicLaF = _dynamicLaF.establishLookAndFeelFor(newStyle, _owner);</span>
        }

<span class="fc bfc" id="L705" title="All 2 branches covered.">        if ( newStyle.hasCustomForegroundPainters() )</span>
<span class="fc" id="L706">            _makeAllChildrenTransparent(_owner);</span>

<span class="pc bpc" id="L708" title="1 of 4 branches missed.">        if ( newStyle.hasActiveBackgroundGradients() &amp;&amp; _owner.isOpaque() )</span>
<span class="nc" id="L709">            _owner.setOpaque(false);</span>

<span class="fc" id="L711">        newStyle.properties().forEach( property -&gt; {</span>

<span class="fc" id="L713">            Object oldValue = _owner.getClientProperty(property.name());</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            if ( property.style().equals(oldValue) )</span>
<span class="fc" id="L715">                return;</span>

<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if ( property.style().isEmpty() )</span>
<span class="nc" id="L718">                _owner.putClientProperty(property.name(), null); // remove property</span>
            else
<span class="fc" id="L720">                _owner.putClientProperty(property.name(), property.style());</span>
<span class="fc" id="L721">        });</span>

<span class="fc" id="L723">        return newStyle;</span>
    }

    private void _applyAlignmentToMigLayoutIfItExists(LayoutStyle style)
    {
<span class="fc" id="L728">        Optional&lt;Float&gt; alignmentX = style.alignmentX();</span>
<span class="fc" id="L729">        Optional&lt;Float&gt; alignmentY = style.alignmentY();</span>

<span class="pc bpc" id="L731" title="1 of 4 branches missed.">        if ( !alignmentX.isPresent() &amp;&amp; !alignmentY.isPresent() )</span>
<span class="fc" id="L732">            return;</span>

<span class="fc bfc" id="L734" title="All 2 branches covered.">        LayoutManager layout = ( _owner.getParent() == null ? null : _owner.getParent().getLayout() );</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        if ( layout instanceof MigLayout ) {</span>
<span class="fc" id="L736">            MigLayout migLayout = (MigLayout) layout;</span>
<span class="fc" id="L737">            Object rawComponentConstraints = migLayout.getComponentConstraints(_owner);</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">            if ( rawComponentConstraints instanceof String )</span>
<span class="nc" id="L739">                rawComponentConstraints = ConstraintParser.parseComponentConstraint(rawComponentConstraints.toString());</span>

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">            CC componentConstraints = (rawComponentConstraints instanceof CC ? (CC) rawComponentConstraints : null);</span>

<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            final CC finalComponentConstraints = ( componentConstraints == null ? new CC() : componentConstraints );</span>

<span class="fc" id="L745">            String x = alignmentX.map( a -&gt; (int) ( a * 100f ) )</span>
<span class="fc" id="L746">                                  .map( a -&gt; a + &quot;%&quot; )</span>
<span class="fc" id="L747">                                  .orElse(&quot;&quot;);</span>

<span class="fc" id="L749">            String y = alignmentY.map( a -&gt; (int) ( a * 100f ) )</span>
<span class="fc" id="L750">                                  .map( a -&gt; a + &quot;%&quot; )</span>
<span class="fc" id="L751">                                  .orElse(&quot;&quot;);</span>

<span class="fc" id="L753">            DimConstraint horizontalDimConstraint = finalComponentConstraints.getHorizontal();</span>
<span class="fc" id="L754">            DimConstraint verticalDimConstraint   = finalComponentConstraints.getVertical();</span>

<span class="fc" id="L756">            UnitValue xAlign = horizontalDimConstraint.getAlign();</span>
<span class="fc" id="L757">            UnitValue yAlign = verticalDimConstraint.getAlign();</span>

<span class="pc bpc" id="L759" title="2 of 4 branches missed.">            boolean xChange = !x.equals( xAlign == null ? &quot;&quot; : xAlign.getConstraintString() );</span>
<span class="pc bpc" id="L760" title="2 of 4 branches missed.">            boolean yChange = !y.equals( yAlign == null ? &quot;&quot; : yAlign.getConstraintString() );</span>

<span class="pc bpc" id="L762" title="2 of 4 branches missed.">            if ( !x.isEmpty() &amp;&amp; xChange )</span>
<span class="fc" id="L763">                finalComponentConstraints.alignX(x);</span>

<span class="pc bpc" id="L765" title="2 of 4 branches missed.">            if ( !y.isEmpty() &amp;&amp; yChange )</span>
<span class="fc" id="L766">                finalComponentConstraints.alignY(y);</span>

<span class="pc bpc" id="L768" title="3 of 4 branches missed.">            if ( xChange || yChange ) {</span>
<span class="fc" id="L769">                migLayout.setComponentConstraints(_owner, finalComponentConstraints);</span>
<span class="fc" id="L770">                _owner.getParent().revalidate();</span>
            }
        }
<span class="fc" id="L773">    }</span>

    /**
     *  Note that the foreground painter is intended to paint over all children of the component, &lt;br&gt;
     *  which is why it will be called at the end of {@code JComponent::paintChildren(Graphics)}.
     *  &lt;br&gt;
     *  However, there is a problem with this approach! &lt;br&gt;
     *  If not all children are transparent, the result of the foreground painter can be overwritten
     *  by {@link JComponent#paintImmediately(int, int, int, int)} when certain events occur
     *  (like a child component is a text field with a blinking cursor, or a button with hover effect).
     *  This type of repaint does unfortunately not call {@code JComponent::paintChildren(Graphics)},
     *  in fact it completely bypasses the rendering of this current component!
     *  In order to ensure that the stuff painted by the foreground painter is not overwritten
     *  in these types of cases,
     *  we make all children transparent (non-opaque) so that the foreground painter is always visible.
     *
     * @param c The component to make all children transparent.
     */
    private void _makeAllChildrenTransparent( JComponent c ) {
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        if ( c.isOpaque() )</span>
<span class="nc" id="L793">            c.setOpaque(false);</span>

<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        for ( Component child : c.getComponents() ) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if ( child instanceof JComponent ) {</span>
<span class="nc" id="L797">                JComponent jChild = (JComponent) child;</span>
<span class="nc" id="L798">                _makeAllChildrenTransparent(jChild);</span>
            }
        }
<span class="fc" id="L801">    }</span>

    private void _installCustomBorderBasedStyleAndAnimationRenderer() {
<span class="fc" id="L804">        Border currentBorder = _owner.getBorder();</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">        if ( !(currentBorder instanceof StyleAndAnimationBorder) )</span>
<span class="fc" id="L806">            _owner.setBorder(new StyleAndAnimationBorder&lt;&gt;(this, currentBorder));</span>
<span class="fc" id="L807">    }</span>

    private void _uninstallCustomBorderBasedStyleAndAnimationRenderer() {
<span class="fc" id="L810">        Border currentBorder = _owner.getBorder();</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if ( currentBorder instanceof StyleAndAnimationBorder) {</span>
<span class="fc" id="L812">            StyleAndAnimationBorder&lt;?&gt; border = (StyleAndAnimationBorder&lt;?&gt;) currentBorder;</span>
<span class="fc" id="L813">            _owner.setBorder(border.getFormerBorder());</span>
        }
<span class="fc" id="L815">    }</span>


    static void paintWithClip( Graphics2D g2d, Shape clip, Runnable paintTask ) {
<span class="fc" id="L819">        Shape formerClip = g2d.getClip();</span>
<span class="fc" id="L820">        g2d.setClip(clip);</span>
        try {
<span class="fc" id="L822">            paintTask.run();</span>
        } finally {
<span class="fc" id="L824">            g2d.setClip(formerClip);</span>
        }
<span class="fc" id="L826">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>