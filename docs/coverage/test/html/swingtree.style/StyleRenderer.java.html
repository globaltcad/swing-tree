<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StyleRenderer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">StyleRenderer.java</span></div><h1>StyleRenderer.java</h1><pre class="source lang-java linenums">package swingtree.style;

import com.github.weisj.jsvg.geometry.size.FloatSize;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import swingtree.UI;
import swingtree.api.Painter;
import swingtree.layout.Bounds;
import swingtree.layout.Size;

import java.awt.*;
import java.awt.geom.*;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;

/**
 *  A stateless un-instantiable utility class that renders the style of a component
 *  using the immutable {@link LayerRenderConf} object containing the essential state
 *  needed for rendering, like for example the current {@link Bounds} and {@link StyleConf}
 *  of a particular component.
 */
final class StyleRenderer
{
<span class="fc" id="L30">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(StyleRenderer.class);</span>

    private StyleRenderer() {} // Un-instantiable!


    public static void renderStyleOn(
        UI.Layer layer,
        LayerRenderConf conf,
        Graphics2D g2d
    ) {
        // First we render things unique to certain layers:

        // Background stuff:
<span class="fc" id="L43">        conf.baseColors().foundationColor().ifPresent(outerColor -&gt; {</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            if ( outerColor.getAlpha() &gt; 0 ) { // Avoid rendering a fully transparent color!</span>
<span class="fc" id="L45">                g2d.setColor(outerColor);</span>
<span class="fc" id="L46">                g2d.fill(conf.areas().get(UI.ComponentArea.EXTERIOR));</span>
            }
<span class="fc" id="L48">        });</span>
<span class="fc" id="L49">        conf.baseColors().backgroundColor().ifPresent(color -&gt; {</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            if ( color.getAlpha() &gt; 0 ) { // Avoid rendering a fully transparent color!</span>
<span class="fc" id="L51">                g2d.setColor(color);</span>
<span class="fc" id="L52">                g2d.fill(conf.areas().get(UI.ComponentArea.BODY));</span>
            }
<span class="fc" id="L54">        });</span>

        // Border stuff:
<span class="fc" id="L57">        _drawBorder( conf, conf.baseColors().borderColor(), g2d);</span>

        // Now onto things every layer has in common:

        // Every layer has 4 things:
        // 1. A grounding serving as a base background, which is a filled color and/or an image:
<span class="fc bfc" id="L63" title="All 2 branches covered.">        for ( ImageConf imageConf : conf.layer().images().sortedByNames() )</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if ( !imageConf.equals(ImageConf.none()) )</span>
<span class="fc" id="L65">                _renderImage( conf, imageConf, conf.boxModel().size(), g2d);</span>

        // 2. Gradients, which are best used to give a component a nice surface lighting effect.
        // They may transition vertically, horizontally or diagonally over various different colors:
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for ( GradientConf gradient : conf.layer().gradients().sortedByNames() )</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if ( gradient.colors().length &gt; 0 ) {</span>
<span class="fc" id="L71">                _renderGradient( gradient, conf, g2d );</span>
            }

        // 3. Noise, which is a simple way to add a bit of texture to a component:
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for ( NoiseConf noise : conf.layer().noises().sortedByNames() )</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">            if ( noise.colors().length &gt; 0 ) {</span>
<span class="fc" id="L77">                _renderNoise( noise, conf, g2d );</span>
            }

        // 4. Shadows, which are simple gradient based drop shadows that can go inwards or outwards
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for ( ShadowConf shadow : conf.layer().shadows().sortedByNames() )</span>
<span class="fc" id="L82">            _renderShadows(conf, shadow, g2d);</span>

        // 5. Custom text, which can be rendered in any font and color:
<span class="fc bfc" id="L85" title="All 2 branches covered.">        for ( TextConf text : conf.layer().texts().sortedByNames() )</span>
<span class="fc" id="L86">            _renderText( text, conf, g2d );</span>

        // 6. Painters, which are provided by the user and can be anything
<span class="fc" id="L89">        List&lt;PainterConf&gt; painters = conf.layer().painters().sortedByNames();</span>

<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if ( !painters.isEmpty() )</span>
        {
<span class="fc bfc" id="L93" title="All 2 branches covered.">            for ( PainterConf painterConf : painters )</span>
            {
<span class="fc" id="L95">                Painter backgroundPainter = painterConf.painter();</span>

<span class="fc bfc" id="L97" title="All 2 branches covered.">                if ( backgroundPainter == Painter.none() )</span>
<span class="fc" id="L98">                    continue;</span>

<span class="fc" id="L100">                Shape allowedArea = conf.areas().get(painterConf.clipArea());</span>

<span class="fc" id="L102">                _paintClippedTo( allowedArea, g2d, () -&gt; {</span>
                    // We remember the current transform and clip so that we can reset them after each painter:
<span class="fc" id="L104">                    AffineTransform currentTransform = new AffineTransform(g2d.getTransform());</span>
<span class="fc" id="L105">                    Shape           currentClip      = g2d.getClip();</span>

                    // We remember if antialiasing was enabled before we render:
<span class="fc bfc" id="L108" title="All 2 branches covered.">                    boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>

                    try {
<span class="fc" id="L111">                        backgroundPainter.paint(g2d);</span>
<span class="nc" id="L112">                    } catch (Exception e) {</span>
<span class="nc" id="L113">                        log.warn(</span>
                            &quot;An exception occurred while executing painter '&quot; + backgroundPainter + &quot;' &quot; +
                            &quot;on layer '&quot; + layer + &quot;' for style '&quot; + conf + &quot;' &quot;,
                            e
                        );
                        /*
                            If exceptions happen in user provided painters, we don't want to
                            mess up the rendering of the rest of the component, so we catch them here!

                            We log as warning because exceptions during rendering are not considered
                            as harmful as elsewhere!

                            Hi there! If you are reading this, you are probably a developer using the SwingTree
                            library, thank you for using it! Good luck finding out what went wrong! :)
                        */
                    } finally {
                        // We do not know what the painter did to the graphics object, so we reset it:
<span class="fc" id="L130">                        g2d.setTransform(currentTransform);</span>
<span class="fc" id="L131">                        g2d.setClip(currentClip);</span>

                        // Reset antialiasing to its previous state:
<span class="fc bfc" id="L134" title="All 2 branches covered.">                        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>
                    }
<span class="fc" id="L136">                });</span>
<span class="fc" id="L137">            }</span>
        }
        // And that's it! We have rendered a style layer!
<span class="fc" id="L140">    }</span>


    private static void _paintClippedTo( @Nullable Shape newClip, Graphics g, Runnable painter ) {
<span class="fc" id="L144">        Shape oldClip = g.getClip();</span>

<span class="pc bpc" id="L146" title="2 of 4 branches missed.">        if ( newClip != null &amp;&amp; newClip != oldClip ) {</span>
<span class="fc" id="L147">            newClip = StyleUtil.intersect(newClip, oldClip);</span>
<span class="fc" id="L148">            g.setClip(newClip);</span>
        }

<span class="fc" id="L151">        painter.run();</span>

<span class="fc" id="L153">        g.setClip(oldClip);</span>
<span class="fc" id="L154">    }</span>

    private static void _drawBorder( LayerRenderConf conf, BorderColorsConf colors, Graphics2D g2d )
    {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if ( colors.equals(BorderColorsConf.none()) )</span>
<span class="fc" id="L159">            return;</span>

<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if ( !Outline.none().equals(conf.boxModel().widths()) ) {</span>
            try {
<span class="fc" id="L163">                Area borderArea = conf.areas().get(UI.ComponentArea.BORDER);</span>
<span class="fc" id="L164">                Objects.requireNonNull(borderArea);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if ( colors.isHomogeneous() ) {</span>
<span class="fc" id="L166">                    g2d.setColor(colors.bottom().orElse(UI.Color.BLACK));</span>
<span class="fc" id="L167">                    g2d.fill(borderArea);</span>
                } else {
<span class="fc" id="L169">                    Area[] borderEdgeRegions = conf.areas().getEdgeAreas();</span>
                    // We created clipped border areas:
<span class="fc" id="L171">                    Area topBorderArea = new Area(borderArea);</span>
<span class="fc" id="L172">                    topBorderArea.intersect(borderEdgeRegions[0]);</span>
<span class="fc" id="L173">                    Area rightBorderArea = new Area(borderArea);</span>
<span class="fc" id="L174">                    rightBorderArea.intersect(borderEdgeRegions[1]);</span>
<span class="fc" id="L175">                    Area bottomBorderArea = new Area(borderArea);</span>
<span class="fc" id="L176">                    bottomBorderArea.intersect(borderEdgeRegions[2]);</span>
<span class="fc" id="L177">                    Area leftBorderArea = new Area(borderArea);</span>
<span class="fc" id="L178">                    leftBorderArea.intersect(borderEdgeRegions[3]);</span>
                    // Now we can draw the borders:
<span class="fc" id="L180">                    g2d.setColor(colors.top().orElse(UI.Color.BLACK));</span>
<span class="fc" id="L181">                    g2d.fill(topBorderArea);</span>
<span class="fc" id="L182">                    g2d.setColor(colors.right().orElse(UI.Color.BLACK));</span>
<span class="fc" id="L183">                    g2d.fill(rightBorderArea);</span>
<span class="fc" id="L184">                    g2d.setColor(colors.bottom().orElse(UI.Color.BLACK));</span>
<span class="fc" id="L185">                    g2d.fill(bottomBorderArea);</span>
<span class="fc" id="L186">                    g2d.setColor(colors.left().orElse(UI.Color.BLACK));</span>
<span class="fc" id="L187">                    g2d.fill(leftBorderArea);</span>
                }
<span class="nc" id="L189">            } catch ( Exception e ) {</span>
<span class="nc" id="L190">                log.warn(</span>
<span class="nc" id="L191">                    &quot;An exception occurred while drawing the border of border style '&quot; + conf.boxModel() + &quot;' &quot;,</span>
                    e
                );
                /*
                    If exceptions happen in user provided painters, we don't want to
                    mess up the rendering of the rest of the component, so we catch them here!
                */
<span class="fc" id="L198">            }</span>
        }
<span class="fc" id="L200">    }</span>

    private static void _renderShadows(
        LayerRenderConf conf,
        ShadowConf    shadow,
        Graphics2D    g2d
    ) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if ( !shadow.color().isPresent() )</span>
<span class="fc" id="L208">            return;</span>

<span class="fc" id="L210">        Color shadowColor = shadow.color().orElse(Color.BLACK);</span>
<span class="fc" id="L211">        Size  size        = conf.boxModel().size();</span>

        // First let's check if we need to render any shadows at all
        // Is the shadow color transparent?
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if ( shadowColor.getAlpha() == 0 )</span>
<span class="nc" id="L216">            return;</span>

        // The background box is calculated from the margins and border radius:
<span class="fc" id="L219">        final float leftBorderWidth   = conf.boxModel().widths().left().orElse(0f);</span>
<span class="fc" id="L220">        final float topBorderWidth    = conf.boxModel().widths().top().orElse(0f);</span>
<span class="fc" id="L221">        final float rightBorderWidth  = conf.boxModel().widths().right().orElse(0f);</span>
<span class="fc" id="L222">        final float bottomBorderWidth = conf.boxModel().widths().bottom().orElse(0f);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        final float left   = Math.max(conf.boxModel().margin().left().orElse(0f),   0) + ( shadow.isInset() ? leftBorderWidth   : 0 );</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        final float top    = Math.max(conf.boxModel().margin().top().orElse(0f),    0) + ( shadow.isInset() ? topBorderWidth    : 0 );</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        final float right  = Math.max(conf.boxModel().margin().right().orElse(0f),  0) + ( shadow.isInset() ? rightBorderWidth  : 0 );</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        final float bottom = Math.max(conf.boxModel().margin().bottom().orElse(0f), 0) + ( shadow.isInset() ? bottomBorderWidth : 0 );</span>
<span class="fc" id="L227">        final float topLeftRadius     = Math.max(conf.boxModel().topLeftRadius(), 0);</span>
<span class="fc" id="L228">        final float topRightRadius    = Math.max(conf.boxModel().topRightRadius(), 0);</span>
<span class="fc" id="L229">        final float bottomRightRadius = Math.max(conf.boxModel().bottomRightRadius(), 0);</span>
<span class="fc" id="L230">        final float bottomLeftRadius  = Math.max(conf.boxModel().bottomLeftRadius(), 0);</span>

<span class="fc" id="L232">        final float width     = size.width().orElse(0f);</span>
<span class="fc" id="L233">        final float height    = size.height().orElse(0f);</span>

        // Calculate the shadow box bounds based on the padding and border thickness
<span class="fc" id="L236">        final float x = left + shadow.horizontalOffset();</span>
<span class="fc" id="L237">        final float y = top  + shadow.verticalOffset();</span>
<span class="fc" id="L238">        final float w = width  - left - right;</span>
<span class="fc" id="L239">        final float h = height - top  - bottom;</span>

<span class="fc" id="L241">        final float blurRadius   = Math.max(shadow.blurRadius(), 0);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        final float spreadRadius = !shadow.isOutset() ? shadow.spreadRadius() : -shadow.spreadRadius();</span>

<span class="fc" id="L244">        Rectangle2D.Float outerShadowRect = new Rectangle2D.Float(</span>
                                        x - blurRadius + spreadRadius,
                                        y - blurRadius + spreadRadius,
                                        w + blurRadius * 2 - spreadRadius * 2,
                                        h + blurRadius * 2 - spreadRadius * 2
                                    );

<span class="fc bfc" id="L251" title="All 2 branches covered.">        Function&lt;Integer, Integer&gt; offsetFunction = (radius) -&gt; (int)((radius * 2) / ( shadow.isInset() ? 4.5 : 3.79) );</span>

<span class="fc" id="L253">        final int averageCornerRadius = ((int) ( topLeftRadius + topRightRadius + bottomRightRadius + bottomLeftRadius )) / 4;</span>
<span class="fc" id="L254">        final int averageBorderWidth  = (int) (( leftBorderWidth + topBorderWidth + rightBorderWidth +  bottomBorderWidth ) / 4);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        final int shadowCornerRadius  = (int) Math.max( 0, averageCornerRadius + (shadow.isOutset() ? -spreadRadius-blurRadius*2 : -Math.max(averageBorderWidth,spreadRadius)) );</span>
<span class="fc" id="L256">        final int gradientStartOffset = 1 + offsetFunction.apply(shadowCornerRadius);</span>

<span class="fc" id="L258">        Rectangle2D.Float innerShadowRect = new Rectangle2D.Float(</span>
                                        x + blurRadius + gradientStartOffset + spreadRadius,
                                        y + blurRadius + gradientStartOffset + spreadRadius,
                                        w - blurRadius * 2 - gradientStartOffset * 2 - spreadRadius * 2,
                                        h - blurRadius * 2 - gradientStartOffset * 2 - spreadRadius * 2
                                    );

        final Area baseArea;

<span class="fc bfc" id="L267" title="All 2 branches covered.">        if ( shadow.isOutset() ) {</span>
<span class="fc" id="L268">            int artifactAdjustment = 1;</span>
<span class="fc" id="L269">            baseArea = ComponentAreas.calculateComponentBodyArea(conf.boxModel(), artifactAdjustment, artifactAdjustment, artifactAdjustment, artifactAdjustment);</span>
<span class="fc" id="L270">        }</span>
        else
<span class="fc" id="L272">            baseArea = new Area(conf.areas().get(UI.ComponentArea.BODY));</span>

        // Apply the clipping to avoid overlapping the shadow and the box
<span class="fc" id="L275">        Area shadowArea = new Area(outerShadowRect);</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">        if ( shadow.isOutset() )</span>
<span class="fc" id="L278">            shadowArea.subtract(baseArea);</span>
        else
<span class="fc" id="L280">            shadowArea.intersect(baseArea);</span>

        // Draw the corner shadows
<span class="fc" id="L283">        _renderCornerShadow(shadow, UI.Corner.TOP_LEFT,     shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L284">        _renderCornerShadow(shadow, UI.Corner.TOP_RIGHT,    shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L285">        _renderCornerShadow(shadow, UI.Corner.BOTTOM_LEFT,  shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L286">        _renderCornerShadow(shadow, UI.Corner.BOTTOM_RIGHT, shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>

        // Draw the edge shadows
<span class="fc" id="L289">        _renderEdgeShadow(shadow, UI.Edge.TOP,    shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L290">        _renderEdgeShadow(shadow, UI.Edge.RIGHT,  shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L291">        _renderEdgeShadow(shadow, UI.Edge.BOTTOM, shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L292">        _renderEdgeShadow(shadow, UI.Edge.LEFT,   shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>

<span class="fc" id="L294">        Area outerMostArea = new Area(outerShadowRect);</span>
        // If the base rectangle and the outer shadow box are not equal, then we need to fill the area of the base rectangle that is not covered by the outer shadow box!
<span class="fc" id="L296">        _renderShadowBody(shadow, baseArea, innerShadowRect, outerMostArea, g2d);</span>

<span class="fc" id="L298">    }</span>

    private static void _renderShadowBody(
        ShadowConf shadowConf,
        Area              baseArea,
        Rectangle2D.Float innerShadowRect,
        Area              outerShadowBox,
        Graphics2D        g2d
    ) {
<span class="fc" id="L307">        Graphics2D g2d2 = (Graphics2D) g2d.create();</span>
<span class="fc" id="L308">        g2d2.setColor(shadowConf.color().orElse(Color.BLACK));</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if ( !shadowConf.isOutset() ) {</span>
<span class="fc" id="L310">            baseArea.subtract(outerShadowBox);</span>
<span class="fc" id="L311">            g2d2.fill(baseArea);</span>
        } else {
<span class="fc" id="L313">            Area innerShadowArea = new Area(innerShadowRect);</span>
<span class="fc" id="L314">            innerShadowArea.subtract(baseArea);</span>
<span class="fc" id="L315">            g2d2.fill(innerShadowArea);</span>
        }
<span class="fc" id="L317">        g2d2.dispose();</span>
<span class="fc" id="L318">    }</span>

    private static void _renderCornerShadow(
        ShadowConf shadowConf,
        UI.Corner         corner,
        Area              areaWhereShadowIsAllowed,
        Rectangle2D.Float innerShadowRect,
        Rectangle2D.Float outerShadowRect,
        int               gradientStartOffset,
        Graphics2D        g2d
    ) {
        // We define a clipping box so that corners don't overlap
<span class="fc" id="L330">        float clipBoxWidth   = outerShadowRect.width / 2f;</span>
<span class="fc" id="L331">        float clipBoxHeight  = outerShadowRect.height / 2f;</span>
<span class="fc" id="L332">        float clipBoxCenterX = outerShadowRect.x + clipBoxWidth;</span>
<span class="fc" id="L333">        float clipBoxCenterY = outerShadowRect.y + clipBoxHeight;</span>
        Rectangle2D.Float cornerClipBox; // outer box!

        // The defining the corner shadow bound (where it starts and ends
        Rectangle2D.Float cornerBox;
        float cx;
        float cy;
        float cr; // depending on the corner, this is either the corner box width or height
<span class="pc bpc" id="L341" title="1 of 5 branches missed.">        switch (corner) {</span>
            case TOP_LEFT:
<span class="fc" id="L343">                cornerBox = new Rectangle2D.Float(</span>
                                    outerShadowRect.x, outerShadowRect.y,
                                    innerShadowRect.x - outerShadowRect.x,
                                    innerShadowRect.y - outerShadowRect.y
                                );
<span class="fc" id="L348">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX - clipBoxWidth, clipBoxCenterY - clipBoxHeight,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L353">                cx = cornerBox.x + cornerBox.width;</span>
<span class="fc" id="L354">                cy = cornerBox.y + cornerBox.height;</span>
<span class="fc" id="L355">                cr = cornerBox.width;</span>
<span class="fc" id="L356">                break;</span>
            case TOP_RIGHT:
<span class="fc" id="L358">                cornerBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x + innerShadowRect.width, outerShadowRect.y,
                                outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                                innerShadowRect.y - outerShadowRect.y
                            );
<span class="fc" id="L363">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX, clipBoxCenterY - clipBoxHeight,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L368">                cx = cornerBox.x;</span>
<span class="fc" id="L369">                cy = cornerBox.y + cornerBox.height;</span>
<span class="fc" id="L370">                cr = cornerBox.width;</span>
<span class="fc" id="L371">                break;</span>
            case BOTTOM_LEFT:
<span class="fc" id="L373">                cornerBox = new Rectangle2D.Float(</span>
                                outerShadowRect.x,
                                innerShadowRect.y + innerShadowRect.height,
                                innerShadowRect.x - outerShadowRect.x,
                                outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                            );
<span class="fc" id="L379">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX - clipBoxWidth, clipBoxCenterY,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L384">                cx = cornerBox.x + cornerBox.width;</span>
<span class="fc" id="L385">                cy = cornerBox.y;</span>
<span class="fc" id="L386">                cr = cornerBox.width;</span>
<span class="fc" id="L387">                break;</span>
            case BOTTOM_RIGHT:
<span class="fc" id="L389">                cornerBox = new Rectangle2D.Float(</span>
                            innerShadowRect.x + innerShadowRect.width, innerShadowRect.y + innerShadowRect.height,
                            outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                            outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                            );
<span class="fc" id="L394">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX, clipBoxCenterY,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L399">                cx = cornerBox.x;</span>
<span class="fc" id="L400">                cy = cornerBox.y;</span>
<span class="fc" id="L401">                cr = cornerBox.width;</span>
<span class="fc" id="L402">                break;</span>
            default:
<span class="nc" id="L404">                throw new IllegalArgumentException(&quot;Invalid corner: &quot; + corner);</span>
        }

<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if (cr &lt;= 0) return;</span>

        Color innerColor;
        Color outerColor;
<span class="fc" id="L411">        Color shadowBackgroundColor = _transparentShadowBackground(shadowConf);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if ( shadowConf.isOutset() ) {</span>
<span class="fc" id="L413">            innerColor = shadowConf.color().orElse(Color.BLACK);</span>
<span class="fc" id="L414">            outerColor = shadowBackgroundColor;</span>
        } else {
<span class="fc" id="L416">            innerColor = shadowBackgroundColor;</span>
<span class="fc" id="L417">            outerColor = shadowConf.color().orElse(Color.BLACK);</span>
        }
<span class="fc" id="L419">        float gradientStart = (float) gradientStartOffset / cr;</span>

        // The first thing we can do is to clip the corner box to the area where the shadow is allowed
<span class="fc" id="L422">        Area cornerArea = new Area(cornerBox);</span>
<span class="fc" id="L423">        cornerArea.intersect(areaWhereShadowIsAllowed);</span>

        // In the simplest case we don't need to do any gradient painting:
<span class="pc bpc" id="L426" title="2 of 4 branches missed.">        if ( gradientStart == 1f || gradientStart == 0f ) {</span>
            // Simple, we just draw a circle and clip it
<span class="nc" id="L428">            Area circle = new Area(new Ellipse2D.Float(cx - cr, cy - cr, cr * 2, cr * 2));</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if ( shadowConf.isInset() ) {</span>
<span class="nc" id="L430">                g2d.setColor(outerColor);</span>
<span class="nc" id="L431">                cornerArea.subtract(circle);</span>
            } else {
<span class="nc" id="L433">                g2d.setColor(innerColor);</span>
<span class="nc" id="L434">                cornerArea.intersect(circle);</span>
            }
<span class="nc" id="L436">            g2d.fill(cornerArea);</span>
<span class="nc" id="L437">            return;</span>
        }

        RadialGradientPaint cornerPaint;
<span class="pc bpc" id="L441" title="2 of 4 branches missed.">        if ( gradientStart &gt; 1f || gradientStart &lt; 0f )</span>
<span class="nc" id="L442">            cornerPaint = new RadialGradientPaint(</span>
                             cx, cy, cr,
                             new float[] {0f, 1f},
                             new Color[] {innerColor, outerColor}
                         );
        else
<span class="fc" id="L448">            cornerPaint = new RadialGradientPaint(</span>
                             cx, cy, cr,
                             new float[] {0f, gradientStart, 1f},
                             new Color[] {innerColor, innerColor, outerColor}
                         );

        // We need to clip the corner paint to the corner box
<span class="fc" id="L455">        cornerArea.intersect(new Area(cornerClipBox));</span>

<span class="fc" id="L457">        Graphics2D cornerG2d = (Graphics2D) g2d.create();</span>
<span class="fc" id="L458">        cornerG2d.setPaint(cornerPaint);</span>
<span class="fc" id="L459">        cornerG2d.fill(cornerArea);</span>
<span class="fc" id="L460">        cornerG2d.dispose();</span>
<span class="fc" id="L461">    }</span>

    private static void _renderEdgeShadow(
        ShadowConf        shadowConf,
        UI.Edge           edge,
        Area              contentArea,
        Rectangle2D.Float innerShadowRect,
        Rectangle2D.Float outerShadowRect,
        int               gradientStartOffset,
        Graphics2D        g2d
    ) {
        // We define a boundary center point and a clipping box so that edges don't overlap
<span class="fc" id="L473">        float clipBoundaryX = outerShadowRect.x + outerShadowRect.width / 2f;</span>
<span class="fc" id="L474">        float clipBoundaryY = outerShadowRect.y + outerShadowRect.height / 2f;</span>
<span class="fc" id="L475">        Rectangle2D.Float edgeClipBox = null;</span>

        Rectangle2D.Float edgeBox;
        float gradEndX;
        float gradEndY;
        float gradStartX;
        float gradStartY;
<span class="pc bpc" id="L482" title="1 of 5 branches missed.">        switch (edge) {</span>
            case TOP:
<span class="fc" id="L484">                edgeBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x, outerShadowRect.y,
                                innerShadowRect.width, innerShadowRect.y - outerShadowRect.y
                            );

<span class="fc bfc" id="L489" title="All 2 branches covered.">                if ( (edgeBox.y + edgeBox.height) &gt; clipBoundaryY )</span>
<span class="fc" id="L490">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x, edgeBox.y,
                            edgeBox.width, clipBoundaryY - edgeBox.y
                    );

<span class="fc" id="L495">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L496">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L497">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L498">                gradStartY = edgeBox.y + edgeBox.height;</span>
<span class="fc" id="L499">                break;</span>
            case RIGHT:
<span class="fc" id="L501">                edgeBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x + innerShadowRect.width, innerShadowRect.y,
                                outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                                innerShadowRect.height
                            );
<span class="fc bfc" id="L506" title="All 2 branches covered.">                if ( edgeBox.x &lt; clipBoundaryX )</span>
<span class="fc" id="L507">                    edgeClipBox = new Rectangle2D.Float(</span>
                                        clipBoundaryX, edgeBox.y,
                                        edgeBox.x + edgeBox.width - clipBoundaryX, edgeBox.height
                                    );
<span class="fc" id="L511">                gradEndX = edgeBox.x + edgeBox.width;</span>
<span class="fc" id="L512">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L513">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L514">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L515">                break;</span>
            case BOTTOM:
<span class="fc" id="L517">                edgeBox = new Rectangle2D.Float(</span>
                        innerShadowRect.x, innerShadowRect.y + innerShadowRect.height,
                        innerShadowRect.width, outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                    );
<span class="fc bfc" id="L521" title="All 2 branches covered.">                if ( edgeBox.y &lt; clipBoundaryY )</span>
<span class="fc" id="L522">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x,
                            clipBoundaryY,
                            edgeBox.width,
                            edgeBox.y + edgeBox.height - clipBoundaryY
                    );

<span class="fc" id="L529">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L530">                gradEndY = edgeBox.y + edgeBox.height;</span>
<span class="fc" id="L531">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L532">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L533">                break;</span>
            case LEFT:
<span class="fc" id="L535">                edgeBox = new Rectangle2D.Float(</span>
                            outerShadowRect.x,
                            innerShadowRect.y,
                            innerShadowRect.x - outerShadowRect.x,
                            innerShadowRect.height
                            );
<span class="fc bfc" id="L541" title="All 2 branches covered.">                if ( (edgeBox.x + edgeBox.width) &gt; clipBoundaryX )</span>
<span class="fc" id="L542">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x,
                            edgeBox.y,
                            clipBoundaryX - edgeBox.x,
                            edgeBox.height
                    );
<span class="fc" id="L548">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L549">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L550">                gradStartX = edgeBox.x + edgeBox.width;</span>
<span class="fc" id="L551">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L552">                break;</span>
            default:
<span class="nc" id="L554">                throw new IllegalArgumentException(&quot;Invalid edge: &quot; + edge);</span>
        }

<span class="pc bpc" id="L557" title="1 of 4 branches missed.">        if ( gradStartX == gradEndX &amp;&amp; gradStartY == gradEndY ) return;</span>

        Color innerColor;
        Color outerColor;
        // Same as shadow color but without alpha:
<span class="fc" id="L562">        Color shadowBackgroundColor = _transparentShadowBackground(shadowConf);</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (shadowConf.isOutset()) {</span>
<span class="fc" id="L564">            innerColor = shadowConf.color().orElse(Color.BLACK);</span>
<span class="fc" id="L565">            outerColor = shadowBackgroundColor;</span>
        } else {
<span class="fc" id="L567">            innerColor = shadowBackgroundColor;</span>
<span class="fc" id="L568">            outerColor = shadowConf.color().orElse(Color.BLACK);</span>
        }
        LinearGradientPaint edgePaint;
        // distance between start and end of gradient
<span class="fc" id="L572">        float dist = (float) Math.sqrt(</span>
                                    (gradEndX - gradStartX) * (gradEndX - gradStartX) +
                                    (gradEndY - gradStartY) * (gradEndY - gradStartY)
                                );
<span class="fc" id="L576">        float gradientStart = (float) gradientStartOffset / dist;</span>
<span class="pc bpc" id="L577" title="2 of 4 branches missed.">        if ( gradientStart &gt; 1f || gradientStart &lt; 0f )</span>
<span class="nc" id="L578">            edgePaint = new LinearGradientPaint(</span>
                               gradStartX, gradStartY,
                               gradEndX, gradEndY,
                               new float[] {0f, 1f},
                               new Color[] {innerColor, outerColor}
                           );
        else {
<span class="pc bpc" id="L585" title="2 of 4 branches missed.">            if ( gradientStart == 1f || gradientStart == 0f ) {</span>
                // The gradient does not really exist, so we can just fill the whole area and then return
<span class="nc" id="L587">                Area edgeArea = new Area(edgeBox);</span>
<span class="nc" id="L588">                g2d.setColor(innerColor);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                if ( shadowConf.isOutset() )</span>
<span class="nc" id="L590">                    edgeArea.intersect(contentArea);</span>
<span class="nc" id="L591">                g2d.fill(edgeArea);</span>
<span class="nc" id="L592">                return;</span>
            }
<span class="fc" id="L594">            edgePaint = new LinearGradientPaint(</span>
                             gradStartX, gradStartY,
                             gradEndX, gradEndY,
                             new float[] {0f, gradientStart, 1f},
                             new Color[] {innerColor, innerColor, outerColor}
                         );
        }

        // We need to clip the edge paint to the edge box
<span class="fc" id="L603">        Area edgeArea = new Area(edgeBox);</span>
<span class="fc" id="L604">        edgeArea.intersect(contentArea);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if ( edgeClipBox != null )</span>
<span class="fc" id="L606">            edgeArea.intersect(new Area(edgeClipBox));</span>

<span class="fc" id="L608">        Graphics2D edgeG2d = (Graphics2D) g2d.create();</span>
<span class="fc" id="L609">        edgeG2d.setPaint(edgePaint);</span>
<span class="fc" id="L610">        edgeG2d.fill(edgeArea);</span>
<span class="fc" id="L611">        edgeG2d.dispose();</span>
<span class="fc" id="L612">    }</span>

    private static Color _transparentShadowBackground(ShadowConf shadow) {
<span class="fc" id="L615">        return shadow.color()</span>
<span class="fc" id="L616">                    .map(c -&gt; new Color(c.getRed(), c.getGreen(), c.getBlue(), 0))</span>
<span class="fc" id="L617">                    .orElse(new Color(0.5f, 0.5f, 0.5f, 0f));</span>
    }

    private static Outline _insetsFrom(UI.ComponentBoundary boundary, BoxModelConf boxModel) {
<span class="fc" id="L621">        Outline insets = Outline.none();</span>
<span class="pc bpc" id="L622" title="3 of 6 branches missed.">        switch ( boundary ) {</span>
            case OUTER_TO_EXTERIOR:
<span class="nc" id="L624">                insets = Outline.none(); break;</span>
            case EXTERIOR_TO_BORDER:
<span class="fc" id="L626">                insets = boxModel.margin(); break;</span>
            case BORDER_TO_INTERIOR:
<span class="fc" id="L628">                insets = boxModel.margin().plus(boxModel.widths()); break;</span>
            case INTERIOR_TO_CONTENT:
<span class="fc" id="L630">                insets = boxModel.margin().plus(boxModel.widths()).plus(boxModel.padding()); break;</span>
            case CENTER_TO_CONTENT:
<span class="nc" id="L632">                insets = boxModel.margin().plus(boxModel.widths()).plus(boxModel.padding());</span>
<span class="nc" id="L633">                float deltaWidth = boxModel.size().width().orElse(0f) - boxModel.margin().left().orElse(0f) - boxModel.margin().right().orElse(0f);</span>
<span class="nc" id="L634">                float deltaHeight = boxModel.size().height().orElse(0f) - boxModel.margin().top().orElse(0f) - boxModel.margin().bottom().orElse(0f);</span>
<span class="nc" id="L635">                float halfWidth = deltaWidth / 2f;</span>
<span class="nc" id="L636">                float halfHeight = deltaHeight / 2f;</span>
<span class="nc" id="L637">                insets = insets.plus(Outline.of(halfHeight, halfWidth, halfHeight, halfWidth));</span>
            break;
        }
<span class="fc" id="L640">        return insets;</span>
    }

    private static void _renderGradient(
        final GradientConf    gradient,
        final LayerRenderConf conf,
        final Graphics2D g2d
    ) {
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if ( gradient.colors().length == 1 ) {</span>
<span class="nc" id="L649">            g2d.setColor(gradient.colors()[0]);</span>
<span class="nc" id="L650">            g2d.fill(conf.areas().get(gradient.area()));</span>
        }
        else {
<span class="fc" id="L653">            Paint paint = _createGradientPaint(conf.boxModel(), gradient);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if ( paint != null ) {</span>
<span class="fc" id="L655">                Area areaToFill = conf.areas().get(gradient.area());</span>
<span class="fc" id="L656">                g2d.setPaint(paint);</span>
<span class="fc" id="L657">                g2d.fill(areaToFill);</span>
            }
        }
<span class="fc" id="L660">    }</span>

    static @Nullable Paint _createGradientPaint(
        BoxModelConf boxModel,
        GradientConf gradient
    ) {
<span class="fc" id="L666">        final Size dimensions = boxModel.size();</span>
        Outline insets;
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if ( gradient.boundary() == UI.ComponentBoundary.CENTER_TO_CONTENT ) {</span>
<span class="fc" id="L669">            Outline contentIns = _insetsFrom(UI.ComponentBoundary.INTERIOR_TO_CONTENT, boxModel);</span>
<span class="fc" id="L670">            float verticalInset = dimensions.height().orElse(0f) / 2f;</span>
<span class="fc" id="L671">            float horizontalInset = dimensions.width().orElse(0f) / 2f;</span>
<span class="fc" id="L672">            insets = Outline.of(verticalInset, horizontalInset);</span>
<span class="pc bpc" id="L673" title="1 of 9 branches missed.">            switch ( gradient.span() ) {</span>
                case TOP_TO_BOTTOM:
<span class="fc" id="L675">                    insets = insets.withBottom(contentIns.bottom().orElse(0f));</span>
<span class="fc" id="L676">                    break;</span>
                case BOTTOM_TO_TOP:
<span class="fc" id="L678">                    insets = insets.withTop(contentIns.top().orElse(0f));</span>
<span class="fc" id="L679">                    break;</span>
                case LEFT_TO_RIGHT:
<span class="fc" id="L681">                    insets = insets.withRight(contentIns.right().orElse(0f));</span>
<span class="fc" id="L682">                    break;</span>
                case RIGHT_TO_LEFT:
<span class="fc" id="L684">                    insets = insets.withLeft(contentIns.left().orElse(0f));</span>
<span class="fc" id="L685">                    break;</span>
                case TOP_LEFT_TO_BOTTOM_RIGHT:
<span class="fc" id="L687">                    insets = insets.withBottom(contentIns.bottom().orElse(0f))</span>
<span class="fc" id="L688">                                    .withRight(contentIns.right().orElse(0f));</span>
<span class="fc" id="L689">                    break;</span>
                case BOTTOM_RIGHT_TO_TOP_LEFT:
<span class="fc" id="L691">                    insets = insets.withTop(contentIns.top().orElse(0f))</span>
<span class="fc" id="L692">                                    .withLeft(contentIns.left().orElse(0f));</span>
<span class="fc" id="L693">                    break;</span>
                case TOP_RIGHT_TO_BOTTOM_LEFT:
<span class="fc" id="L695">                    insets = insets.withBottom(contentIns.bottom().orElse(0f))</span>
<span class="fc" id="L696">                                    .withLeft(contentIns.left().orElse(0f));</span>
<span class="fc" id="L697">                    break;</span>
                case BOTTOM_LEFT_TO_TOP_RIGHT:
<span class="fc" id="L699">                    insets = insets.withTop(contentIns.top().orElse(0f))</span>
<span class="fc" id="L700">                                    .withRight(contentIns.right().orElse(0f));</span>
<span class="fc" id="L701">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L705">        } else {</span>
<span class="fc" id="L706">            insets = _insetsFrom(gradient.boundary(), boxModel);</span>
        }

<span class="fc" id="L709">        final float width  = dimensions.width().orElse(0f)  - ( insets.right().orElse(0f)  + insets.left().orElse(0f) );</span>
<span class="fc" id="L710">        final float height = dimensions.height().orElse(0f) - ( insets.bottom().orElse(0f) + insets.top().orElse(0f) );</span>
<span class="fc" id="L711">        final float realX  = insets.left().orElse(0f) + gradient.offset().x();</span>
<span class="fc" id="L712">        final float realY  = insets.top().orElse(0f)  + gradient.offset().y();</span>

        Point2D.Float corner1;
        Point2D.Float corner2;

<span class="fc" id="L717">        final UI.Span type = gradient.span();</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if ( type.isOneOf(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT) ) {</span>
<span class="fc" id="L719">            corner1 = new Point2D.Float(realX, realY);</span>
<span class="fc" id="L720">            corner2 = new Point2D.Float(realX + width, realY + height);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        } else if ( type.isOneOf(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT) ) {</span>
<span class="fc" id="L722">            corner1 = new Point2D.Float(realX, realY + height);</span>
<span class="fc" id="L723">            corner2 = new Point2D.Float(realX + width, realY);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        } else if ( type.isOneOf(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT) ) {</span>
<span class="fc" id="L725">            corner1 = new Point2D.Float(realX + width, realY);</span>
<span class="fc" id="L726">            corner2 = new Point2D.Float(realX, realY + height);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">        } else if ( type.isOneOf(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT) ) {</span>
<span class="fc" id="L728">            corner1 = new Point2D.Float(realX + width, realY + height);</span>
<span class="fc" id="L729">            corner2 = new Point2D.Float(realX, realY);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        } else if ( type == UI.Span.TOP_TO_BOTTOM ) {</span>
<span class="fc" id="L731">            corner1 = new Point2D.Float(realX, realY);</span>
<span class="fc" id="L732">            corner2 = new Point2D.Float(realX, realY + height);</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">        } else if ( type == UI.Span.LEFT_TO_RIGHT ) {</span>
<span class="fc" id="L734">            corner1 = new Point2D.Float(realX, realY);</span>
<span class="fc" id="L735">            corner2 = new Point2D.Float(realX + width, realY);</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        } else if ( type == UI.Span.BOTTOM_TO_TOP ) {</span>
<span class="fc" id="L737">            corner1 = new Point2D.Float(realX, realY + height);</span>
<span class="fc" id="L738">            corner2 = new Point2D.Float(realX, realY);</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        } else if ( type == UI.Span.RIGHT_TO_LEFT ) {</span>
<span class="fc" id="L740">            corner1 = new Point2D.Float(realX + width, realY);</span>
<span class="fc" id="L741">            corner2 = new Point2D.Float(realX, realY);</span>
        }
        else {
<span class="nc" id="L744">            log.warn(&quot;Unknown gradient type: &quot; + type, new Throwable());</span>
<span class="nc" id="L745">            return null;</span>
        }

<span class="fc bfc" id="L748" title="All 2 branches covered.">        if ( gradient.type() == UI.GradientType.CONIC )</span>
<span class="fc" id="L749">            return _createConicGradientPaint(corner1, corner2, gradient);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        else if ( gradient.type() == UI.GradientType.RADIAL )</span>
<span class="fc" id="L751">            return _createRadialGradientPaint(corner1, corner2, gradient);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">        else if ( gradient.span().isDiagonal() )</span>
<span class="fc" id="L753">            return _createDiagonalGradientPaint(corner1, corner2, gradient);</span>
        else
<span class="fc" id="L755">            return _createVerticalOrHorizontalGradientPaint(corner1, corner2, gradient);</span>

    }

    private static Paint _createConicGradientPaint(
        Point2D.Float  corner1,
        Point2D.Float  corner2,
        GradientConf   gradient
    ) {
<span class="fc" id="L764">        final Color[] colors    = gradient.colors();</span>
<span class="fc" id="L765">        final float[] fractions = _fractionsFrom(gradient);</span>
<span class="fc" id="L766">        float rotation = gradient.rotation() + _rotationBetween(corner1, corner2);</span>

        // we normalize the rotation to be between -180 and 180
<span class="fc" id="L769">        rotation = ((((rotation+180f) % 360f + 360f) % 360f)-180f);</span>

        // Now we convert the fractions to rotations:
<span class="fc bfc" id="L772" title="All 2 branches covered.">        for ( int i = 0; i &lt; fractions.length; i++ )</span>
<span class="fc" id="L773">            fractions[i] = (fractions[i] * 360f);// (((((fractions[i] * 360f)+180f) % 360f + 360f) % 360f)-180f);</span>

<span class="fc" id="L775">        return new ConicalGradientPaint(</span>
                        true,
                        corner1,
                        rotation,
                        fractions,
                        colors
                    );
    }

    private static void _renderNoise(
        final NoiseConf       noise,
        final LayerRenderConf conf,
        final Graphics2D g2d
    ) {
<span class="fc" id="L789">        Paint noisePaint = _createNoisePaint(conf.boxModel(), noise);</span>
<span class="fc" id="L790">        Area areaToFill = conf.areas().get(noise.area());</span>
<span class="fc" id="L791">        g2d.setPaint(noisePaint);</span>
<span class="fc" id="L792">        g2d.fill(areaToFill);</span>
<span class="fc" id="L793">    }</span>

    static Paint _createNoisePaint(
        final BoxModelConf   boxModel,
        final NoiseConf      noise
    ) {
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if ( noise.colors().length == 1 ) {</span>
<span class="nc" id="L800">            return noise.colors()[0];</span>
        } else {
<span class="fc" id="L802">            Size dimensions = boxModel.size();</span>
<span class="fc" id="L803">            Outline insets = Outline.none();</span>
<span class="pc bpc" id="L804" title="3 of 6 branches missed.">            switch ( noise.boundary() ) {</span>
                case OUTER_TO_EXTERIOR:
<span class="nc" id="L806">                    insets = Outline.none(); break;</span>
                case EXTERIOR_TO_BORDER:
<span class="fc" id="L808">                    insets = boxModel.margin(); break;</span>
                case BORDER_TO_INTERIOR:
<span class="nc" id="L810">                    insets = boxModel.margin().plus(boxModel.widths()); break;</span>
                case INTERIOR_TO_CONTENT:
<span class="fc" id="L812">                    insets = boxModel.margin().plus(boxModel.widths()).plus(boxModel.padding()); break;</span>
                case CENTER_TO_CONTENT:
<span class="fc" id="L814">                    float verticalInset   = dimensions.height().orElse(0f) / 2f;</span>
<span class="fc" id="L815">                    float horizontalInset = dimensions.width().orElse(0f) / 2f;</span>
<span class="fc" id="L816">                    insets = Outline.of(verticalInset, horizontalInset);</span>
            }

<span class="fc" id="L819">            Point2D.Float corner1 = new Point2D.Float(</span>
<span class="fc" id="L820">                                        insets.left().orElse(0f) + noise.offset().x(),</span>
<span class="fc" id="L821">                                        insets.top().orElse(0f) + noise.offset().y()</span>
                                    );

<span class="fc" id="L824">            return _createNoisePaint(corner1, noise);</span>
        }
    }

    private static Paint _createNoisePaint(
        final Point2D.Float  center,
        final NoiseConf      noise
    ) {
<span class="fc" id="L832">        final Color[] colors    = noise.colors();</span>
<span class="fc" id="L833">        final float[] fractions = _fractionsFrom(colors, noise.fractions());</span>
<span class="fc" id="L834">        float rotation = noise.rotation();</span>
<span class="fc" id="L835">        Scale scale = noise.scale();</span>
<span class="fc" id="L836">        float scaleX = scale.x();</span>
<span class="fc" id="L837">        float scaleY = scale.y();</span>

<span class="fc" id="L839">        return new NoiseGradientPaint(</span>
                        center,
                        scaleX,
                        scaleY,
                        rotation,
                        fractions,
                        colors,
<span class="fc" id="L846">                        noise.function()</span>
                    );
    }


    /**
     *  Renders a shade from the top left corner to the bottom right corner.
     *
     * @param corner1 The first corner of the shade.
     * @param corner2 The second corner of the shade.
     * @param gradient The shade to render.
     */
    private static Paint _createDiagonalGradientPaint(
        Point2D.Float        corner1,
        Point2D.Float        corner2,
        final GradientConf   gradient
    ) {
        {
<span class="fc" id="L864">            final float cx = ( corner1.x + corner2.x ) / 2;</span>
<span class="fc" id="L865">            final float cy = ( corner1.y + corner2.y ) / 2;</span>
<span class="fc" id="L866">            final float nx = ( corner2.x - corner1.x );</span>
<span class="fc" id="L867">            final float ny = ( corner1.y - corner2.y );</span>
            /*
                The above variables form 2 lines:
                    1. The line with direction n going through corner1.
                    2. The line with direction n going through corner2.
            */

            // project the center (cx,cy) onto the lines:
<span class="fc" id="L875">            corner1 = projectPointOntoLine(corner1, new Point2D.Float(nx, ny), new Point2D.Float(cx, cy));</span>
<span class="fc" id="L876">            corner2 = projectPointOntoLine(corner2, new Point2D.Float(nx, ny), new Point2D.Float(cx, cy));</span>
        }

<span class="fc" id="L879">        final UI.Cycle cycle  = gradient.cycle();</span>
<span class="fc" id="L880">        final Color[]  colors = gradient.colors();</span>

<span class="fc" id="L882">        final float size   = gradient.size();</span>

<span class="fc" id="L884">        final float corner1X = corner1.x;</span>
<span class="fc" id="L885">        final float corner1Y = corner1.y;</span>
<span class="fc" id="L886">        float corner2X = corner2.x;</span>
<span class="fc" id="L887">        float corner2Y = corner2.y;</span>

<span class="fc" id="L889">        float[] fractions = _fractionsFrom(gradient);</span>

<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if ( size &gt;= 0 ) {</span>
<span class="nc" id="L892">            float vectorX = corner2X - corner1X;</span>
<span class="nc" id="L893">            float vectorY = corner2Y - corner1Y;</span>
<span class="nc" id="L894">            float vectorLength2 = (float) Math.sqrt(vectorX * vectorX + vectorY * vectorY);</span>
<span class="nc" id="L895">            vectorX = (vectorX / vectorLength2);</span>
<span class="nc" id="L896">            vectorY = (vectorY / vectorLength2);</span>
<span class="nc" id="L897">            corner2X = corner1X + vectorX * size;</span>
<span class="nc" id="L898">            corner2Y = corner1Y + vectorY * size;</span>
        }

<span class="pc bpc" id="L901" title="1 of 2 branches missed.">        if ( gradient.rotation() % 360f != 0 ) {</span>
<span class="nc" id="L902">            Point2D.Float p1 = new Point2D.Float(corner1X, corner1Y);</span>
<span class="nc" id="L903">            Point2D.Float p2 = new Point2D.Float(corner2X, corner2Y);</span>
<span class="nc" id="L904">            p2 = _rotatePoint(p1, p2, gradient.rotation());</span>
<span class="nc" id="L905">            corner2X = p2.x;</span>
<span class="nc" id="L906">            corner2Y = p2.y;</span>
        }

<span class="pc bpc" id="L909" title="2 of 6 branches missed.">        if ( colors.length == 2 &amp;&amp; gradient.fractions().length == 0 &amp;&amp; cycle == UI.Cycle.NONE )</span>
<span class="fc" id="L910">            return new GradientPaint(</span>
                            corner1X, corner1Y, colors[0],
                            corner2X, corner2Y, colors[1]
                        );
        else
<span class="fc" id="L915">            return new LinearGradientPaint(</span>
                            corner1X, corner1Y,
                            corner2X, corner2Y,
                            fractions, colors,
<span class="fc" id="L919">                            _cycleMethodFrom(cycle)</span>
                        );
    }

    private static Paint _createVerticalOrHorizontalGradientPaint(
        Point2D.Float  corner1,
        Point2D.Float  corner2,
        GradientConf   gradient
    ) {
<span class="fc" id="L928">        final UI.Cycle      cycle      = gradient.cycle();</span>
<span class="fc" id="L929">        final Color[]       colors     = gradient.colors();</span>

<span class="fc" id="L931">        final float size   = gradient.size();</span>

<span class="fc" id="L933">        final float corner1X = corner1.x;</span>
<span class="fc" id="L934">        final float corner1Y = corner1.y;</span>
<span class="fc" id="L935">        float corner2X = corner2.x;</span>
<span class="fc" id="L936">        float corner2Y = corner2.y;</span>

<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if ( gradient.type() == UI.GradientType.LINEAR ) {</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            if ( size &gt;= 0 ) {</span>
<span class="nc" id="L940">                float vectorX = corner2X - corner1X;</span>
<span class="nc" id="L941">                float vectorY = corner2Y - corner1Y;</span>
<span class="nc" id="L942">                float vectorLength = (float) Math.sqrt(vectorX * vectorX + vectorY * vectorY);</span>
<span class="nc" id="L943">                vectorX = (vectorX / vectorLength);</span>
<span class="nc" id="L944">                vectorY = (vectorY / vectorLength);</span>
<span class="nc" id="L945">                corner2X = corner1X + vectorX * size;</span>
<span class="nc" id="L946">                corner2Y = corner1Y + vectorY * size;</span>
            }
        }

<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (</span>
            colors.length == 2 &amp;&amp;
<span class="pc bpc" id="L952" title="2 of 4 branches missed.">            gradient.fractions().length == 0 &amp;&amp;</span>
            cycle == UI.Cycle.NONE
        ) {
<span class="fc" id="L955">            return new GradientPaint(</span>
                        corner1X, corner1Y, colors[0],
                        corner2X, corner2Y, colors[1]
                    );
        } else {
<span class="fc" id="L960">            float[] fractions = _fractionsFrom(gradient);</span>

<span class="pc bpc" id="L962" title="1 of 2 branches missed.">            if ( gradient.rotation() % 360f != 0 ) {</span>
<span class="nc" id="L963">                Point2D.Float p1 = new Point2D.Float(corner1X, corner1Y);</span>
<span class="nc" id="L964">                Point2D.Float p2 = new Point2D.Float(corner2X, corner2Y);</span>
<span class="nc" id="L965">                p2 = _rotatePoint(p1, p2, gradient.rotation());</span>
<span class="nc" id="L966">                corner2X = p2.x;</span>
<span class="nc" id="L967">                corner2Y = p2.y;</span>
            }

<span class="fc" id="L970">            return new LinearGradientPaint(</span>
                        corner1X, corner1Y,
                        corner2X, corner2Y,
                        fractions, colors,
<span class="fc" id="L974">                        _cycleMethodFrom(cycle)</span>
                    );

        }
    }

    private static Point2D.Float projectPointOntoLine(Point2D.Float A, Point2D.Float n, Point2D.Float C) {
<span class="fc" id="L981">        Point2D.Float B = new Point2D.Float(A.x + n.x, A.y + n.y);</span>
<span class="fc" id="L982">        float t = ((C.x - A.x) * (B.x - A.x) + (C.y - A.y) * (B.y - A.y)) / ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));</span>
<span class="fc" id="L983">        return new Point2D.Float(A.x + t * (B.x - A.x), A.y + t * (B.y - A.y));</span>
    }

    private static Paint _createRadialGradientPaint(
        Point2D.Float  corner1,
        Point2D.Float  corner2,
        GradientConf   gradient
    ) {
<span class="fc" id="L991">        final UI.Cycle cycle  = gradient.cycle();</span>
<span class="fc" id="L992">        final Color[]  colors = gradient.colors();</span>

<span class="fc" id="L994">        final float size   = gradient.size();</span>

<span class="fc" id="L996">        final float corner1X = corner1.x;</span>
<span class="fc" id="L997">        final float corner1Y = corner1.y;</span>
<span class="fc" id="L998">        float corner2X = corner2.x;</span>
<span class="fc" id="L999">        float corner2Y = corner2.y;</span>


<span class="fc" id="L1002">        float[] fractions = _fractionsFrom(gradient);</span>

        float radius;

<span class="fc bfc" id="L1006" title="All 2 branches covered.">        if ( size &lt; 0 )</span>
<span class="fc" id="L1007">            radius = (float) Math.sqrt(</span>
                                 (corner2X - corner1X) * (corner2X - corner1X) +
                                 (corner2Y - corner1Y) * (corner2Y - corner1Y)
                             );
        else
<span class="fc" id="L1012">            radius = size;</span>

<span class="fc bfc" id="L1014" title="All 2 branches covered.">        if ( gradient.focus().equals(Offset.none()) ) {</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">            if ( colors.length == 2 )</span>
<span class="fc" id="L1016">                return new RadialGradientPaint(</span>
                        new Point2D.Float(corner1X, corner1Y),
                        radius,
                        fractions,
                        colors,
<span class="fc" id="L1021">                        _cycleMethodFrom(cycle)</span>
                    );
            else
<span class="nc" id="L1024">                return new RadialGradientPaint(</span>
                        new Point2D.Float(corner1X, corner1Y),
                        radius,
                        fractions,
                        colors,
<span class="nc" id="L1029">                        _cycleMethodFrom(cycle)</span>
                     );
        } else {
<span class="fc" id="L1032">            float focusX = corner1X + gradient.focus().x();</span>
<span class="fc" id="L1033">            float focusY = corner1Y + gradient.focus().y();</span>

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">            if ( gradient.rotation() % 360f != 0 ) {</span>
<span class="nc" id="L1036">                Point2D.Float p1 = new Point2D.Float(corner1X, corner1Y);</span>
<span class="nc" id="L1037">                Point2D.Float p2 = new Point2D.Float(focusX, focusY);</span>
<span class="nc" id="L1038">                p2 = _rotatePoint(p1, p2, gradient.rotation());</span>
<span class="nc" id="L1039">                focusX = p2.x;</span>
<span class="nc" id="L1040">                focusY = p2.y;</span>
            }

<span class="fc" id="L1043">            return new RadialGradientPaint(</span>
                    new Point2D.Float(corner1X, corner1Y),
                    radius,
                    new Point2D.Float(focusX, focusY),
                    fractions,
                    colors,
<span class="fc" id="L1049">                    _cycleMethodFrom(cycle)</span>
                );
        }
    }

    private static MultipleGradientPaint.CycleMethod _cycleMethodFrom(UI.Cycle cycle) {
<span class="pc bpc" id="L1055" title="3 of 4 branches missed.">        switch (cycle) {</span>
<span class="fc" id="L1056">            case NONE:     return MultipleGradientPaint.CycleMethod.NO_CYCLE;</span>
<span class="nc" id="L1057">            case REPEAT:   return MultipleGradientPaint.CycleMethod.REPEAT;</span>
<span class="nc" id="L1058">            case REFLECT:  return MultipleGradientPaint.CycleMethod.REFLECT;</span>
            default:
<span class="nc" id="L1060">                log.warn(&quot;Unknown cycle method: &quot; + cycle, new Throwable());</span>
<span class="nc" id="L1061">                return MultipleGradientPaint.CycleMethod.NO_CYCLE;</span>
        }
    }

    private static float[] _fractionsFrom(GradientConf style ) {
<span class="fc" id="L1066">        Color[] colors   = style.colors();</span>
<span class="fc" id="L1067">        float[] fractions = style.fractions();</span>
<span class="fc" id="L1068">        return _fractionsFrom(colors, fractions);</span>
    }

    private static float[] _fractionsFrom(
        Color[] colors,
        float[] fractions
    ) {
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if ( fractions.length == colors.length )</span>
<span class="nc" id="L1076">            return fractions;</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        else if ( fractions.length &gt; colors.length ) {</span>
<span class="nc" id="L1078">            float[] newFractions = new float[colors.length];</span>
<span class="nc" id="L1079">            System.arraycopy(fractions, 0, newFractions, 0, colors.length);</span>
<span class="nc" id="L1080">            return newFractions;</span>
        } else {
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">            if ( fractions.length == 0 ) {</span>
<span class="fc" id="L1083">                fractions = new float[colors.length];</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">                for ( int i = 0; i &lt; colors.length; i++ )</span>
<span class="fc" id="L1085">                    fractions[i] = (float) i / (float) (colors.length - 1);</span>
<span class="fc" id="L1086">                return fractions;</span>
            } else {
<span class="nc" id="L1088">                float[] newFractions = new float[colors.length];</span>
<span class="nc" id="L1089">                System.arraycopy(fractions, 0, newFractions, 0, fractions.length);</span>
                /*
                    Now simply complete th missing fractions by linear interpolation
                    between the last fraction and 1f
                */
<span class="nc" id="L1094">                float lastFraction = fractions[fractions.length - 1];</span>
<span class="nc" id="L1095">                float step = (1f - lastFraction) / (colors.length - fractions.length);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                for ( int i = fractions.length; i &lt; colors.length; i++ )</span>
<span class="nc" id="L1097">                    newFractions[i] = lastFraction + step * (i - fractions.length + 1);</span>
<span class="nc" id="L1098">                return newFractions;</span>
            }
        }
    }

    /**
     *  Takes two points {@code p1} and {@code p2} as well as
     *  a {@code rotation} float representing degrees and returns
     *  the point {@code p2} rotated around {@code p1} by {@code rotation} degrees.
     */
    private static Point2D.Float _rotatePoint(
        final Point2D.Float p1,
        final Point2D.Float p2,
        final float rotation
    ) {
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        if ( rotation == 0f )</span>
<span class="nc" id="L1114">            return p2;</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        else if ( rotation % 360f == 0f )</span>
<span class="nc" id="L1116">            return p2;</span>

<span class="nc" id="L1118">        final double angle = Math.toRadians(rotation);</span>
<span class="nc" id="L1119">        final double sin   = Math.sin(angle);</span>
<span class="nc" id="L1120">        final double cos   = Math.cos(angle);</span>

<span class="nc" id="L1122">        final double x = p2.x - p1.x;</span>
<span class="nc" id="L1123">        final double y = p2.y - p1.y;</span>

<span class="nc" id="L1125">        final double newX = x * cos - y * sin;</span>
<span class="nc" id="L1126">        final double newY = x * sin + y * cos;</span>

<span class="nc" id="L1128">        return new Point2D.Float((float) (p1.x + newX), (float) (p1.y + newY));</span>
    }

    /**
     *  Takes 2 points and calculates the rotation
     *  of point 2 around point 1.
     *
     * @param p1 The first point which serves as the center of rotation.
     * @param p2 The second point which is rotated around point 1.
     * @return The rotation in degrees.
     */
    private static final float _rotationBetween(
        final Point2D.Float p1,
        final Point2D.Float p2
    ){
<span class="fc" id="L1143">        final double x = p2.x - p1.x;</span>
<span class="fc" id="L1144">        final double y = p2.y - p1.y;</span>
<span class="fc" id="L1145">        return (float) Math.toDegrees(Math.atan2(y, x));</span>
    }

    private static void _renderImage(
        LayerRenderConf conf,
        ImageConf style,
        Size        componentSize,
        Graphics2D  g2d
    ) {
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        if ( style.primer().isPresent() ) {</span>
<span class="fc" id="L1155">            g2d.setColor(style.primer().get());</span>
<span class="fc" id="L1156">            g2d.fill(conf.areas().get(style.clipArea()));</span>
        }

<span class="fc" id="L1159">        style.image().ifPresent( imageIcon -&gt; {</span>
<span class="fc" id="L1160">            final UI.FitComponent fit          = style.fitMode();</span>
<span class="fc" id="L1161">            final UI.Placement placement       = style.placement();</span>
<span class="fc" id="L1162">            final Outline      padding         = style.padding();</span>
<span class="fc" id="L1163">            final int          componentWidth  = componentSize.width().orElse(0f).intValue();</span>
<span class="fc" id="L1164">            final int          componentHeight = componentSize.height().orElse(0f).intValue();</span>

<span class="fc" id="L1166">            int imgWidth  = style.width().orElse(imageIcon.getIconWidth());</span>
<span class="fc" id="L1167">            int imgHeight = style.height().orElse(imageIcon.getIconHeight());</span>

<span class="fc bfc" id="L1169" title="All 2 branches covered.">            if ( fit != UI.FitComponent.NO ) {</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">                if ( imageIcon instanceof SvgIcon) {</span>
                    // The SvgIcon does the fitting...
<span class="fc" id="L1172">                    imgWidth  = style.width().orElse(componentWidth);</span>
<span class="fc" id="L1173">                    imgHeight = style.height().orElse(componentHeight);</span>
                } else {
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">                    if ( fit == UI.FitComponent.WIDTH_AND_HEIGHT ) {</span>
<span class="fc" id="L1176">                        imgWidth  = style.width().orElse(componentWidth);</span>
<span class="fc" id="L1177">                        imgHeight = style.height().orElse(componentHeight);</span>
                    }
<span class="pc bpc" id="L1179" title="7 of 10 branches missed.">                    if (</span>
                        fit == UI.FitComponent.WIDTH ||
                        (fit == UI.FitComponent.MAX_DIM &amp;&amp; componentWidth &gt; componentHeight)  ||
                        (fit == UI.FitComponent.MIN_DIM &amp;&amp; componentWidth &lt; componentHeight )
                    ) {
<span class="nc" id="L1184">                        imgWidth = style.width().orElse(componentWidth);</span>
<span class="nc" id="L1185">                        double aspectRatio = (double) imageIcon.getIconHeight() / (double) imageIcon.getIconWidth();</span>
                        // We preserve the aspect ratio:
<span class="nc" id="L1187">                        imgHeight = (int) (imgWidth * aspectRatio);</span>
<span class="pc bpc" id="L1188" title="7 of 10 branches missed.">                    } if (</span>
                        fit == UI.FitComponent.HEIGHT ||
                        (fit == UI.FitComponent.MAX_DIM &amp;&amp; componentWidth &lt; componentHeight) ||
                        (fit == UI.FitComponent.MIN_DIM &amp;&amp; componentWidth &gt; componentHeight )
                    ) {
<span class="nc" id="L1193">                        imgHeight = style.height().orElse(componentHeight);</span>
<span class="nc" id="L1194">                        double aspectRatio = (double) imageIcon.getIconWidth() / (double) imageIcon.getIconHeight();</span>
                        // We preserve the aspect ratio:
<span class="nc" id="L1196">                        imgWidth = (int) (imgHeight * aspectRatio);</span>
                    }
                }
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">                imgWidth  = imgWidth  &gt;= 0 ? imgWidth  : componentWidth;</span>
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">                imgHeight = imgHeight &gt;= 0 ? imgHeight : componentHeight;</span>
            }
<span class="fc bfc" id="L1202" title="All 2 branches covered.">            if ( imageIcon instanceof SvgIcon ) {</span>
<span class="fc" id="L1203">                SvgIcon   svgIcon = (SvgIcon) imageIcon;</span>
<span class="fc" id="L1204">                FloatSize size    = svgIcon.getSvgSize();</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">                imgWidth  = imgWidth  &gt;= 0 ? imgWidth  : (int) size.width;</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                imgHeight = imgHeight &gt;= 0 ? imgHeight : (int) size.height;</span>
            }
<span class="fc" id="L1208">            int x = style.horizontalOffset();</span>
<span class="fc" id="L1209">            int y = style.verticalOffset();</span>

<span class="pc bpc" id="L1211" title="1 of 10 branches missed.">            switch ( placement ) {</span>
                case TOP:
<span class="fc" id="L1213">                    x += (componentWidth - imgWidth) / 2;</span>
<span class="fc" id="L1214">                    break;</span>
                case LEFT:
<span class="fc" id="L1216">                    y += (componentHeight - imgHeight) / 2;</span>
<span class="fc" id="L1217">                    break;</span>
                case BOTTOM:
<span class="fc" id="L1219">                    x += (componentWidth - imgWidth) / 2;</span>
<span class="fc" id="L1220">                    y += componentHeight - imgHeight;</span>
<span class="fc" id="L1221">                    break;</span>
                case RIGHT:
<span class="fc" id="L1223">                    x += componentWidth - imgWidth;</span>
<span class="fc" id="L1224">                    y += (componentHeight - imgHeight) / 2;</span>
<span class="fc" id="L1225">                    break;</span>
<span class="fc" id="L1226">                case TOP_LEFT: break;</span>
                case TOP_RIGHT:
<span class="fc" id="L1228">                    x += componentWidth - imgWidth;</span>
<span class="fc" id="L1229">                    break;</span>
                case BOTTOM_LEFT:
<span class="fc" id="L1231">                    y += componentHeight - imgHeight;</span>
<span class="fc" id="L1232">                    break;</span>
                case BOTTOM_RIGHT:
<span class="fc" id="L1234">                    x += componentWidth - imgWidth;</span>
<span class="fc" id="L1235">                    y += componentHeight - imgHeight;</span>
<span class="fc" id="L1236">                    break;</span>
                case CENTER:
                case UNDEFINED:
<span class="fc" id="L1239">                    x += (componentWidth - imgWidth) / 2;</span>
<span class="fc" id="L1240">                    y += (componentHeight - imgHeight) / 2;</span>
<span class="fc" id="L1241">                    break;</span>
                default:
<span class="nc" id="L1243">                    throw new IllegalArgumentException(&quot;Unknown placement: &quot; + placement);</span>
            }
            // We apply the padding:
<span class="fc" id="L1246">            x += padding.left().orElse(0f).intValue();</span>
<span class="fc" id="L1247">            y += padding.top().orElse(0f).intValue();</span>
<span class="fc" id="L1248">            imgWidth  -= padding.left().orElse(0f).intValue() + padding.right().orElse(0f).intValue();</span>
<span class="fc" id="L1249">            imgHeight -= padding.top().orElse(0f).intValue()  + padding.bottom().orElse(0f).intValue();</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">            if ( imageIcon instanceof SvgIcon ) {</span>
<span class="fc" id="L1251">                SvgIcon svgIcon = (SvgIcon) imageIcon;</span>
<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">                if ( imgWidth &gt; -1 &amp;&amp; svgIcon.getIconWidth() &lt; 0 )</span>
<span class="fc" id="L1253">                    svgIcon = svgIcon.withIconWidth(imgWidth);</span>
<span class="pc bpc" id="L1254" title="2 of 4 branches missed.">                if ( imgHeight &gt; -1 &amp;&amp; svgIcon.getIconHeight() &lt; 0 )</span>
<span class="fc" id="L1255">                    svgIcon = svgIcon.withIconHeight(imgHeight);</span>
<span class="fc" id="L1256">                imageIcon = svgIcon;</span>
            }

<span class="fc" id="L1259">            final boolean repeat  = style.repeat();</span>
<span class="fc" id="L1260">            final float   opacity = style.opacity();</span>

<span class="fc" id="L1262">            final Shape oldClip = g2d.getClip();</span>

<span class="fc" id="L1264">            Shape newClip = conf.areas().get(style.clipArea());</span>
            // We merge the new clip with the old one:
<span class="pc bpc" id="L1266" title="1 of 4 branches missed.">            if ( newClip != null &amp;&amp; oldClip != null )</span>
<span class="fc" id="L1267">                newClip = StyleUtil.intersect( newClip, oldClip );</span>

<span class="fc" id="L1269">            g2d.setClip(newClip);</span>

<span class="fc bfc" id="L1271" title="All 4 branches covered.">            if ( !repeat &amp;&amp; imageIcon instanceof SvgIcon ) {</span>
<span class="fc" id="L1272">                SvgIcon svgIcon = ((SvgIcon) imageIcon).withFitComponent(fit);</span>
<span class="fc" id="L1273">                svgIcon.withPreferredPlacement(UI.Placement.CENTER)</span>
<span class="fc" id="L1274">                        .paintIcon(null, g2d, x, y, imgWidth, imgHeight);</span>
<span class="fc" id="L1275">            }</span>
            else
            {
                Image image;
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">                if ( imageIcon instanceof SvgIcon) {</span>
<span class="nc" id="L1280">                    SvgIcon svgIcon = (SvgIcon) imageIcon;</span>
<span class="nc" id="L1281">                    svgIcon = svgIcon.withIconWidth(imgWidth);</span>
<span class="nc" id="L1282">                    svgIcon = svgIcon.withIconHeight(imgHeight);</span>
<span class="nc" id="L1283">                    image   = svgIcon.getImage(); // This will render the SVGIcon with the new size</span>
<span class="nc" id="L1284">                }</span>
                else
<span class="fc" id="L1286">                    image = imageIcon.getImage();</span>

<span class="fc" id="L1288">                Composite oldComposite = g2d.getComposite();</span>

                try {
<span class="fc" id="L1291">                    g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity));</span>
<span class="fc bfc" id="L1292" title="All 2 branches covered.">                    if (repeat) {</span>
<span class="fc" id="L1293">                        Paint oldPaint = g2d.getPaint();</span>
                        try {
<span class="fc" id="L1295">                            g2d.setPaint(new TexturePaint((BufferedImage) image, new Rectangle(x, y, imgWidth, imgHeight)));</span>
<span class="fc" id="L1296">                            g2d.fill(conf.areas().get(UI.ComponentArea.BODY));</span>
                        } finally {
<span class="fc" id="L1298">                            g2d.setPaint(oldPaint);</span>
                        }
<span class="fc" id="L1300">                    }</span>
                    else
<span class="fc" id="L1302">                        g2d.drawImage(image, x, y, imgWidth, imgHeight, null);</span>

                } finally {
<span class="fc" id="L1305">                    g2d.setComposite(oldComposite);</span>
                }
            }
<span class="fc" id="L1308">            g2d.setClip(oldClip);</span>
<span class="fc" id="L1309">        });</span>
<span class="fc" id="L1310">    }</span>

    private static void _renderText(
        final TextConf        text,
        final LayerRenderConf conf,
        final Graphics2D      g2d
    ) {
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        if ( text.content().isEmpty() )</span>
<span class="fc" id="L1318">            return;</span>

<span class="fc" id="L1320">        final BoxModelConf boxModel = conf.boxModel();</span>

<span class="fc" id="L1322">        final Font initialFont = g2d.getFont();</span>
<span class="fc" id="L1323">        final Shape oldClip = g2d.getClip();</span>

<span class="fc" id="L1325">        final String               textToRender      = text.content();</span>
<span class="fc" id="L1326">        final UI.ComponentArea     clipArea          = text.clipArea();</span>
<span class="fc" id="L1327">        final UI.ComponentBoundary placementBoundary = text.placementBoundary();</span>
<span class="fc" id="L1328">        final UI.Placement         placement         = text.placement();</span>
<span class="fc" id="L1329">        final Offset               offset            = text.offset();</span>

<span class="fc" id="L1331">        Font font = Optional.ofNullable(initialFont).orElse(new Font(Font.DIALOG, Font.PLAIN, UI.scale(12)));</span>
<span class="fc" id="L1332">        font = text.fontConf().createDerivedFrom(font, boxModel).orElse(font);</span>
<span class="fc" id="L1333">        g2d.setFont(font);</span>
<span class="fc" id="L1334">        FontMetrics fm = g2d.getFontMetrics(font);</span>
<span class="fc" id="L1335">        Rectangle2D rect = fm.getStringBounds(textToRender, g2d);</span>

<span class="fc" id="L1337">        Outline insets = _insetsFrom(placementBoundary, boxModel);</span>
<span class="fc" id="L1338">        float x = insets.left().orElse(0f); // Top left is always the starting point</span>
<span class="fc" id="L1339">        float y = insets.top().orElse(0f) ;</span>
        {
<span class="fc" id="L1341">            float leftX = insets.left().orElse(0f);</span>
<span class="fc" id="L1342">            float topY = insets.top().orElse(0f);</span>
<span class="fc" id="L1343">            float localWidth = boxModel.size().width().orElse(0f) - (leftX + insets.right().orElse(0f));</span>
<span class="fc" id="L1344">            float localHeight = boxModel.size().height().orElse(0f) - (topY + insets.bottom().orElse(0f));</span>
<span class="fc" id="L1345">            float rightX = leftX + localWidth;</span>
<span class="fc" id="L1346">            float bottomY = topY + localHeight;</span>

<span class="pc bpc" id="L1348" title="1 of 10 branches missed.">            switch (placement) {</span>
                case CENTER:
<span class="fc" id="L1350">                    float centerX = leftX + localWidth / 2f;</span>
<span class="fc" id="L1351">                    float centerY = topY + localHeight / 2f;</span>
<span class="fc" id="L1352">                    x = centerX - (float) rect.getWidth() / 2f;</span>
<span class="fc" id="L1353">                    y = centerY - (float) rect.getHeight() / 2f;</span>
<span class="fc" id="L1354">                break;</span>
                case TOP:
<span class="fc" id="L1356">                    x = leftX + (localWidth - (float) rect.getWidth()) / 2f;</span>
<span class="fc" id="L1357">                    y = topY;</span>
<span class="fc" id="L1358">                break;</span>
                case LEFT:
<span class="fc" id="L1360">                    x = leftX;</span>
<span class="fc" id="L1361">                    y = topY + (localHeight - (float) rect.getHeight()) / 2f;</span>
<span class="fc" id="L1362">                break;</span>
                case BOTTOM:
<span class="fc" id="L1364">                    x = leftX + (localWidth - (float) rect.getWidth()) / 2f;</span>
<span class="fc" id="L1365">                    y = bottomY - (float) rect.getHeight();</span>
<span class="fc" id="L1366">                break;</span>
                case RIGHT:
<span class="fc" id="L1368">                    x = rightX - (float) rect.getWidth();</span>
<span class="fc" id="L1369">                    y = topY + (localHeight - (float) rect.getHeight()) / 2f;</span>
<span class="fc" id="L1370">                break;</span>
                case TOP_LEFT:
<span class="fc" id="L1372">                    x = leftX;</span>
<span class="fc" id="L1373">                    y = topY;</span>
<span class="fc" id="L1374">                break;</span>
                case TOP_RIGHT:
<span class="fc" id="L1376">                    x = rightX - (float) rect.getWidth();</span>
<span class="fc" id="L1377">                    y = topY;</span>
<span class="fc" id="L1378">                break;</span>
                case BOTTOM_LEFT:
<span class="fc" id="L1380">                    x = leftX;</span>
<span class="fc" id="L1381">                    y = bottomY - (float) rect.getHeight();</span>
<span class="fc" id="L1382">                break;</span>
                case BOTTOM_RIGHT:
<span class="fc" id="L1384">                    x = rightX - (float) rect.getWidth();</span>
<span class="fc" id="L1385">                    y = bottomY - (float) rect.getHeight();</span>
<span class="fc" id="L1386">                break;</span>
                case UNDEFINED:
                break;
            }
        }

        try {
<span class="fc" id="L1393">            x += (offset.x() - (float) rect.getX());</span>
<span class="fc" id="L1394">            y += (offset.y() - (float) rect.getY());</span>
<span class="fc" id="L1395">            g2d.setClip(conf.areas().get(clipArea));</span>
            // Render the text:
<span class="fc" id="L1397">            g2d.drawString(textToRender, x, y);</span>
        } finally {
<span class="fc" id="L1399">            g2d.setFont(initialFont);</span>
<span class="fc" id="L1400">            g2d.setClip(oldClip);</span>
        }
<span class="fc" id="L1402">    }</span>

    static void renderParentFilter(
        FilterConf    filterConf,
        BufferedImage parentRendering,
        Graphics2D    g2d,
        int offsetX,
        int offsetY,
        BoxModelConf boxModelConf
    ) {
<span class="fc" id="L1412">        final Size       size   = boxModelConf.size();</span>
<span class="fc" id="L1413">        final float      width  = size.width().orElse(0f);</span>
<span class="fc" id="L1414">        final float      height = size.height().orElse(0f);</span>
<span class="fc" id="L1415">        final Offset     center = filterConf.offset();</span>
<span class="fc" id="L1416">        final Scale      scale  = filterConf.scale();</span>
<span class="fc" id="L1417">        final KernelConf kernel = filterConf.kernel();</span>
<span class="fc" id="L1418">        final float      blur   = filterConf.blur();</span>

<span class="fc" id="L1420">        BufferedImage filtered = parentRendering;</span>

<span class="pc bpc" id="L1422" title="2 of 4 branches missed.">        if ( !center.equals(Offset.none()) || !scale.equals(Scale.none()) ) {</span>
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">            if ( scale.equals(Scale.none()) ) {</span>
<span class="nc" id="L1424">                offsetX += (int) center.x();</span>
<span class="nc" id="L1425">                offsetY += (int) center.y();</span>
            } else {
<span class="fc" id="L1427">                AffineTransform at = new AffineTransform();</span>
<span class="fc" id="L1428">                float vx = center.x() + offsetX + width / 2f;</span>
<span class="fc" id="L1429">                float vy = center.y() + offsetY + height / 2f;</span>
<span class="fc" id="L1430">                at.translate(vx, vy);</span>
<span class="fc" id="L1431">                at.scale(scale.x(), scale.y());</span>
<span class="fc" id="L1432">                at.translate(-vx, -vy);</span>
<span class="fc" id="L1433">                AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);</span>
<span class="fc" id="L1434">                filtered = scaleOp.filter(filtered, null);</span>
            }
        }

<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        if ( !kernel.equals(KernelConf.none()) ) {</span>
<span class="nc" id="L1439">            Kernel awtKernel = kernel.toAwtKernel();</span>
<span class="nc" id="L1440">            ConvolveOp convolve = new ConvolveOp(awtKernel, ConvolveOp.EDGE_NO_OP, null);</span>
<span class="nc" id="L1441">            filtered = convolve.filter(filtered, null);</span>
        }

<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">        if ( blur &gt; 0 ) {</span>
<span class="nc" id="L1445">            Kernel blurKernelHorizontal = _makeKernel(blur, false);</span>
<span class="nc" id="L1446">            ConvolveOp blurOp = new ConvolveOp(blurKernelHorizontal, ConvolveOp.EDGE_NO_OP, null);</span>
<span class="nc" id="L1447">            BufferedImage blurred = blurOp.filter(filtered, null);</span>
<span class="nc" id="L1448">            Kernel blurKernelVertical = _makeKernel(blur, true);</span>
<span class="nc" id="L1449">            blurOp = new ConvolveOp(blurKernelVertical, ConvolveOp.EDGE_NO_OP, null);</span>
<span class="nc" id="L1450">            filtered = blurOp.filter(blurred, filtered);</span>
        }

<span class="fc" id="L1453">        Shape oldClip = g2d.getClip();</span>
        try {
<span class="fc" id="L1455">            ComponentAreas areas = boxModelConf.areas();</span>
<span class="fc" id="L1456">            Shape newClip = areas.get(filterConf.area());</span>
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">            if (newClip == null) {</span>
<span class="nc" id="L1458">                newClip = new Rectangle(0, 0, (int) width, (int) height);</span>
            }
<span class="fc" id="L1460">            g2d.setClip(newClip);</span>
<span class="fc" id="L1461">            g2d.drawImage(filtered, -offsetX, -offsetY, null);</span>
<span class="nc" id="L1462">        } catch (Exception e) {</span>
<span class="nc" id="L1463">            log.error(&quot;Failed to successfully render filtered parent buffer!&quot;, e);</span>
        } finally {
<span class="fc" id="L1465">            g2d.setClip(oldClip);</span>
        }
<span class="fc" id="L1467">    }</span>

    private static Kernel _makeKernel( float radius, boolean transpose ) {
<span class="nc" id="L1470">        final int maxRadius = (int)Math.ceil(radius);</span>
<span class="nc" id="L1471">        final int rows = maxRadius * 2 + 1;</span>
<span class="nc" id="L1472">        final float[] matrix = new float[rows];</span>
<span class="nc" id="L1473">        final float sigma = radius / 3;</span>
<span class="nc" id="L1474">        final float sigma22 = 2*sigma*sigma;</span>
<span class="nc" id="L1475">        final float sigmaPi2 = (float) ( 2 * Math.PI * sigma );</span>
<span class="nc" id="L1476">        final float sqrtSigmaPi2 = (float)Math.sqrt(sigmaPi2);</span>
<span class="nc" id="L1477">        final float radius2 = radius*radius;</span>

<span class="nc" id="L1479">        float total = 0;</span>
<span class="nc" id="L1480">        int   index = 0;</span>

<span class="nc bnc" id="L1482" title="All 2 branches missed.">        for (int row = -maxRadius; row &lt;= maxRadius; row++) {</span>
<span class="nc" id="L1483">            float distance = row*row;</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            if (distance &gt; radius2)</span>
<span class="nc" id="L1485">                matrix[index] = 0;</span>
            else
<span class="nc" id="L1487">                matrix[index] = (float)Math.exp(-distance/sigma22) / sqrtSigmaPi2;</span>
<span class="nc" id="L1488">            total += matrix[index];</span>
<span class="nc" id="L1489">            index++;</span>
        }
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        for ( int i = 0; i &lt; rows; i++ )</span>
<span class="nc" id="L1492">            matrix[i] /= total;</span>

<span class="nc bnc" id="L1494" title="All 4 branches missed.">        return new Kernel( transpose ? 1 : rows, transpose ? rows : 1, matrix );</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>