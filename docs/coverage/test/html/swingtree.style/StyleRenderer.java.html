<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StyleRenderer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">StyleRenderer.java</span></div><h1>StyleRenderer.java</h1><pre class="source lang-java linenums">package swingtree.style;

import swingtree.UI;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;
import java.util.Objects;
import java.util.function.Function;

/**
 *  This used to smoothly render
 *  custom graphics on top of Swing components without requiring
 *  the user to override the paint method of the component.
 *  This is especially important to allow for declarative UI.
 */
public final class StyleRenderer&lt;C extends JComponent&gt;
{
    static boolean DO_ANTIALIASING(){
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">        return UI.scale() &lt; 1.5;</span>
    }

    private final C _comp;
    private final Style style;
<span class="fc" id="L25">    private Area baseArea = null;</span>


<span class="fc" id="L28">    public StyleRenderer( C comp, Style style ) {</span>
<span class="fc" id="L29">        _comp = Objects.requireNonNull(comp);</span>
<span class="fc" id="L30">        this.style = style;</span>
<span class="fc" id="L31">    }</span>

    private Area _getBaseArea() {
<span class="fc bfc" id="L34" title="All 2 branches covered.">        if ( baseArea == null )</span>
<span class="fc" id="L35">            baseArea = _calculateBaseArea(style, 0, 0, 0, 0);</span>
<span class="fc" id="L36">        return baseArea;</span>
    }

    public void renderBaseStyle( Graphics2D g2d )
    {
<span class="fc" id="L41">        baseArea = null;</span>

        // We remember if antialiasing was enabled before we render:
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">        boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>

        // We enable antialiasing:
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">        if ( DO_ANTIALIASING() )</span>
<span class="fc" id="L48">            g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );</span>

<span class="fc" id="L50">        Font componentFont = _comp.getFont();</span>
<span class="pc bpc" id="L51" title="1 of 4 branches missed.">        if ( componentFont != null &amp;&amp; !componentFont.equals(g2d.getFont()) )</span>
<span class="fc" id="L52">            g2d.setFont( componentFont );</span>

<span class="fc" id="L54">        style.background().foundationColor().ifPresent(outerColor -&gt; {</span>
<span class="fc" id="L55">            _fillOuterFoundationBackground(outerColor, g2d);</span>
<span class="fc" id="L56">        });</span>
<span class="fc" id="L57">        style.background().color().ifPresent(color -&gt; {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            if ( color.getAlpha() == 0 ) return;</span>
<span class="fc" id="L59">            g2d.setColor(color);</span>
<span class="fc" id="L60">            g2d.fill(_getBaseArea());</span>
<span class="fc" id="L61">        });</span>

<span class="fc" id="L63">        _renderOn(Layer.BACKGROUND, g2d);</span>

        // Reset antialiasing to its previous state:
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">        if ( baseArea != null )</span>
<span class="fc" id="L69">            g2d.setClip(_getBaseArea());</span>
<span class="fc" id="L70">    }</span>

    private void _renderOn(Layer layer, Graphics2D g2d) {
        // Every layer has 3 things:
        // 1. Shades, which are simple gradient effects
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for ( ShadeStyle shade : style.shades(layer) ) {</span>
<span class="pc bpc" id="L76" title="1 of 4 branches missed.">            if ( shade.colors().length &gt; 0 &amp;&amp; !shade.strategy().isNone() ) {</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                if ( shade.strategy().isDiagonal() )</span>
<span class="fc" id="L78">                    _renderDiagonalShade(g2d, _comp, style.margin(), shade, _getBaseArea());</span>
                else
<span class="fc" id="L80">                    _renderVerticalOrHorizontalShade(g2d, _comp, style.margin(), shade, _getBaseArea());</span>
            }
<span class="fc" id="L82">        }</span>
        // 2. Shadows, which are simple drop shadows that cn go inwards or outwards
<span class="fc bfc" id="L84" title="All 2 branches covered.">        for ( ShadowStyle shadow : style.shadows(layer) )</span>
<span class="fc" id="L85">            shadow.color().ifPresent(color -&gt; {</span>
<span class="fc" id="L86">                _renderShadows(style, shadow, _comp, g2d, color);</span>
<span class="fc" id="L87">            });</span>

        // 3. Painters, which are provided by the user and can be anything
<span class="fc" id="L90">        style.painters(layer).forEach( backgroundPainter -&gt; {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            if ( backgroundPainter == Painter.none() ) return;</span>
<span class="fc" id="L92">            g2d.setClip(_getBaseArea());</span>
<span class="fc" id="L93">            backgroundPainter.paint(g2d);</span>
<span class="fc" id="L94">        });</span>
<span class="fc" id="L95">    }</span>

    public void renderBorderStyle(Graphics2D g2d) {
        // We remember if antialiasing was enabled before we render:
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>

        // We enable antialiasing:
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if ( DO_ANTIALIASING() )</span>
<span class="fc" id="L103">            g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );</span>

<span class="fc" id="L105">        _renderOn(Layer.CONTENT, g2d);</span>

<span class="fc" id="L107">        style.border().color().ifPresent( color -&gt; {</span>
<span class="fc" id="L108">            _drawBorder(style, color, g2d);</span>
<span class="fc" id="L109">        });</span>

<span class="fc" id="L111">        _renderOn(Layer.BORDER, g2d);</span>

        // Reset antialiasing to its previous state:
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>
<span class="fc" id="L115">    }</span>

    public void renderForegroundStyle(Graphics2D g2d)
    {
        // We remember if antialiasing was enabled before we render:
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        boolean antialiasingWasEnabled = g2d.getRenderingHint( RenderingHints.KEY_ANTIALIASING ) == RenderingHints.VALUE_ANTIALIAS_ON;</span>

        // We enable antialiasing:
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if ( DO_ANTIALIASING() )</span>
<span class="fc" id="L124">            g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );</span>

<span class="fc" id="L126">        Font componentFont = _comp.getFont();</span>
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">        if ( componentFont != null &amp;&amp; !componentFont.equals(g2d.getFont()) )</span>
<span class="nc" id="L128">            g2d.setFont( componentFont );</span>

<span class="fc" id="L130">        _renderOn(Layer.FOREGROUND, g2d);</span>

        // Reset antialiasing to its previous state:
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, antialiasingWasEnabled ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF );</span>
<span class="fc" id="L134">    }</span>

    private void _drawBorder( Style style, Color color, Graphics2D g2d ) {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if ( !Outline.none().equals(style.border().widths()) ) {</span>
<span class="fc" id="L138">            int leftBorderWidth   = style.border().widths().left().orElse(0);</span>
<span class="fc" id="L139">            int topBorderWidth    = style.border().widths().top().orElse(0);</span>
<span class="fc" id="L140">            int rightBorderWidth  = style.border().widths().right().orElse(0);</span>
<span class="fc" id="L141">            int bottomBorderWidth = style.border().widths().bottom().orElse(0);</span>
<span class="fc" id="L142">            Area baseArea = _getBaseArea();</span>
<span class="fc" id="L143">            Area innerArea = _calculateBaseArea(style, topBorderWidth, leftBorderWidth, bottomBorderWidth, rightBorderWidth);</span>
<span class="fc" id="L144">            baseArea.subtract(innerArea);</span>
<span class="fc" id="L145">            g2d.setColor(color);</span>
<span class="fc" id="L146">            g2d.fill(baseArea);</span>

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if ( style.border().shades().size() &gt; 0 )  {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                for ( ShadeStyle shade : style.border().shades() ) {</span>
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">                    if ( shade.colors().length &gt; 0 &amp;&amp; !shade.strategy().isNone() ) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">                        if ( shade.strategy().isDiagonal() )</span>
<span class="fc" id="L152">                            _renderDiagonalShade(g2d, _comp, style.margin(), shade, baseArea);</span>
                        else
<span class="nc" id="L154">                            _renderVerticalOrHorizontalShade(g2d, _comp, style.margin(), shade, baseArea);</span>
                    }
<span class="fc" id="L156">                }</span>
            }

        }
<span class="fc" id="L160">    }</span>

    private Area _calculateBaseArea( Style style, int insTop, int insLeft, int insBottom, int insRight )
    {
        // The background box is calculated from the margins and border radius:
<span class="fc" id="L165">        int left      = Math.max(style.margin().left().orElse(0), 0)   + insLeft  ;</span>
<span class="fc" id="L166">        int top       = Math.max(style.margin().top().orElse(0), 0)    + insTop   ;</span>
<span class="fc" id="L167">        int right     = Math.max(style.margin().right().orElse(0), 0)  + insRight ;</span>
<span class="fc" id="L168">        int bottom    = Math.max(style.margin().bottom().orElse(0), 0) + insBottom;</span>
<span class="fc" id="L169">        int width     = _comp.getWidth() ;</span>
<span class="fc" id="L170">        int height    = _comp.getHeight();</span>

<span class="pc bpc" id="L172" title="2 of 6 branches missed.">        boolean insAllTheSame = insTop == insLeft &amp;&amp; insLeft == insBottom &amp;&amp; insBottom == insRight;</span>

<span class="pc bpc" id="L174" title="1 of 4 branches missed.">        if ( style.border().allCornersShareTheSameArc() &amp;&amp; insAllTheSame ) {</span>
<span class="fc" id="L175">            int arcWidth  = style.border().topLeftArc().map( a -&gt; Math.max(0,a.width() ) ).orElse(0);</span>
<span class="fc" id="L176">            int arcHeight = style.border().topLeftArc().map( a -&gt; Math.max(0,a.height()) ).orElse(0);</span>
            // We can return a simple round rectangle:
<span class="fc" id="L178">            return new Area(new RoundRectangle2D.Float(</span>
                    left, top, width - left - right, height - top - bottom,
<span class="fc" id="L180">                    Math.max(0, arcWidth  - insTop),</span>
<span class="fc" id="L181">                    Math.max(0, arcHeight - insTop)</span>
                ));
        } else {
<span class="fc" id="L184">            Arc topLeftArc     = style.border().topLeftArc().orElse(null);</span>
<span class="fc" id="L185">            Arc topRightArc    = style.border().topRightArc().orElse(null);</span>
<span class="fc" id="L186">            Arc bottomRightArc = style.border().bottomRightArc().orElse(null);</span>
<span class="fc" id="L187">            Arc bottomLeftArc  = style.border().bottomLeftArc().orElse(null);</span>
<span class="fc" id="L188">            Area area = new Area();</span>

<span class="fc" id="L190">            int topLeftRoundnessAdjustment     = Math.min(insLeft,   insTop  );</span>
<span class="fc" id="L191">            int topRightRoundnessAdjustment    = Math.min(insTop,    insRight);</span>
<span class="fc" id="L192">            int bottomRightRoundnessAdjustment = Math.min(insBottom, insRight);</span>
<span class="fc" id="L193">            int bottomLeftRoundnessAdjustment  = Math.min(insBottom, insLeft );</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            int arcWidthTL  = Math.max(0, topLeftArc     == null ? 0 : topLeftArc.width()      - topLeftRoundnessAdjustment);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            int arcHeightTL = Math.max(0, topLeftArc     == null ? 0 : topLeftArc.height()     - topLeftRoundnessAdjustment);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            int arcWidthTR  = Math.max(0, topRightArc    == null ? 0 : topRightArc.width()     - topRightRoundnessAdjustment);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            int arcHeightTR = Math.max(0, topRightArc    == null ? 0 : topRightArc.height()    - topRightRoundnessAdjustment);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            int arcWidthBR  = Math.max(0, bottomRightArc == null ? 0 : bottomRightArc.width()  - bottomRightRoundnessAdjustment);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            int arcHeightBR = Math.max(0, bottomRightArc == null ? 0 : bottomRightArc.height() - bottomRightRoundnessAdjustment);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            int arcWidthBL  = Math.max(0, bottomLeftArc  == null ? 0 : bottomLeftArc.width()   - bottomLeftRoundnessAdjustment);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            int arcHeightBL = Math.max(0, bottomLeftArc  == null ? 0 : bottomLeftArc.height()  - bottomLeftRoundnessAdjustment);</span>

            // Top left:
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if ( topLeftArc != null ) {</span>
<span class="fc" id="L206">                area.add(new Area(new Arc2D.Float(</span>
                        left, top,
                        arcWidthTL, arcHeightTL,
                        90, 90, Arc2D.PIE
                )));
            }
            // Top right:
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if ( topRightArc != null ) {</span>
<span class="fc" id="L214">                area.add(new Area(new Arc2D.Float(</span>
<span class="fc" id="L215">                        width - right - topRightArc.width() + topRightRoundnessAdjustment,</span>
                        top,
                        arcWidthTR, arcHeightTR,
                        0, 90, Arc2D.PIE
                )));
            }
            // Bottom right:
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if ( bottomRightArc != null ) {</span>
<span class="fc" id="L223">                area.add(new Area(new Arc2D.Float(</span>
<span class="fc" id="L224">                        width  - right  - bottomRightArc.width()  + bottomRightRoundnessAdjustment,</span>
<span class="fc" id="L225">                        height - bottom - bottomRightArc.height() + bottomRightRoundnessAdjustment,</span>
                        arcWidthBR, arcHeightBR,
                        270, 90, Arc2D.PIE
                )));
            }
            // Bottom left:
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if ( bottomLeftArc != null ) {</span>
<span class="fc" id="L232">                area.add(new Area(new Arc2D.Float(</span>
                        left,
<span class="fc" id="L234">                        height - bottom - bottomLeftArc.height() + bottomLeftRoundnessAdjustment,</span>
                        arcWidthBL, arcHeightBL,
                        180, 90, Arc2D.PIE
                )));
            }
            /*
                Now we are going to have to fill four rectangles for each side of the partially rounded background box
                and then a single rectangle for the center.
                The four outer rectangles are calculated from the arcs and the margins.
             */
<span class="fc" id="L244">            int topDistance    = 0;</span>
<span class="fc" id="L245">            int rightDistance  = 0;</span>
<span class="fc" id="L246">            int bottomDistance = 0;</span>
<span class="fc" id="L247">            int leftDistance   = 0;</span>
            // top:
<span class="pc bpc" id="L249" title="3 of 4 branches missed.">            if ( topLeftArc != null || topRightArc != null ) {</span>
<span class="fc" id="L250">                int arcWidthLeft   = (int) Math.floor(arcWidthTL  / 2.0);</span>
<span class="fc" id="L251">                int arcHeightLeft  = (int) Math.floor(arcHeightTL / 2.0);</span>
<span class="fc" id="L252">                int arcWidthRight  = (int) Math.floor(arcWidthTR  / 2.0);</span>
<span class="fc" id="L253">                int arcHeightRight = (int) Math.floor(arcHeightTR / 2.0);</span>
<span class="fc" id="L254">                topDistance = Math.max(arcHeightLeft, arcHeightRight);// This is where the center rectangle will start!</span>
<span class="fc" id="L255">                int innerLeft   = left + arcWidthLeft;</span>
<span class="fc" id="L256">                int innerRight  = width - right - arcWidthRight;</span>
<span class="fc" id="L257">                int edgeRectangleHeight = topDistance;</span>
<span class="fc" id="L258">                area.add(new Area(new Rectangle2D.Float(</span>
                        innerLeft, top, innerRight - innerLeft, edgeRectangleHeight
                    )));
            }
            // right:
<span class="pc bpc" id="L263" title="3 of 4 branches missed.">            if ( topRightArc != null || bottomRightArc != null ) {</span>
<span class="fc" id="L264">                int arcWidthTop    = (int) Math.floor(arcWidthTR  / 2.0);</span>
<span class="fc" id="L265">                int arcHeightTop   = (int) Math.floor(arcHeightTR / 2.0);</span>
<span class="fc" id="L266">                int arcWidthBottom = (int) Math.floor(arcWidthBR  / 2.0);</span>
<span class="fc" id="L267">                int arcHeightBottom= (int) Math.floor(arcHeightBR / 2.0);</span>
<span class="fc" id="L268">                rightDistance = Math.max(arcWidthTop, arcWidthBottom);// This is where the center rectangle will start!</span>
<span class="fc" id="L269">                int innerTop    = top + arcHeightTop;</span>
<span class="fc" id="L270">                int innerBottom = height - bottom - arcHeightBottom;</span>
<span class="fc" id="L271">                int edgeRectangleWidth = rightDistance;</span>
<span class="fc" id="L272">                area.add(new Area(new Rectangle2D.Float(</span>
                        width - right - edgeRectangleWidth, innerTop, edgeRectangleWidth, innerBottom - innerTop
                    )));
            }
            // bottom:
<span class="pc bpc" id="L277" title="3 of 4 branches missed.">            if ( bottomRightArc != null || bottomLeftArc != null ) {</span>
<span class="fc" id="L278">                int arcWidthRight  = (int) Math.floor(arcWidthBR  / 2.0);</span>
<span class="fc" id="L279">                int arcHeightRight = (int) Math.floor(arcHeightBR / 2.0);</span>
<span class="fc" id="L280">                int arcWidthLeft   = (int) Math.floor(arcWidthBL  / 2.0);</span>
<span class="fc" id="L281">                int arcHeightLeft  = (int) Math.floor(arcHeightBL / 2.0);</span>
<span class="fc" id="L282">                bottomDistance = Math.max(arcHeightRight, arcHeightLeft);// This is where the center rectangle will start!</span>
<span class="fc" id="L283">                int innerLeft   = left + arcWidthLeft;</span>
<span class="fc" id="L284">                int innerRight  = width - right - arcWidthRight;</span>
<span class="fc" id="L285">                int edgeRectangleHeight = bottomDistance;</span>
<span class="fc" id="L286">                area.add(new Area(new Rectangle2D.Float(</span>
                        innerLeft, height - bottom - edgeRectangleHeight, innerRight - innerLeft, edgeRectangleHeight
                    )));
            }
            // left:
<span class="pc bpc" id="L291" title="3 of 4 branches missed.">            if ( bottomLeftArc != null || topLeftArc != null ) {</span>
<span class="fc" id="L292">                int arcWidthBottom = (int) Math.floor(arcWidthBL  / 2.0);</span>
<span class="fc" id="L293">                int arcHeightBottom= (int) Math.floor(arcHeightBL / 2.0);</span>
<span class="fc" id="L294">                int arcWidthTop    = (int) Math.floor(arcWidthTL  / 2.0);</span>
<span class="fc" id="L295">                int arcHeightTop   = (int) Math.floor(arcHeightTL / 2.0);</span>
<span class="fc" id="L296">                leftDistance = Math.max(arcWidthBottom, arcWidthTop);// This is where the center rectangle will start!</span>
<span class="fc" id="L297">                int innerTop    = top + arcHeightTop;</span>
<span class="fc" id="L298">                int innerBottom = height - bottom - arcHeightBottom;</span>
<span class="fc" id="L299">                int edgeRectangleWidth = leftDistance;</span>
<span class="fc" id="L300">                area.add(new Area(new Rectangle2D.Float(</span>
                        left, innerTop, edgeRectangleWidth, innerBottom - innerTop
                    )));
            }
            // Now we add the center:
<span class="fc" id="L305">            area.add(new Area(</span>
                        new Rectangle2D.Float(
                            left + leftDistance, top + topDistance,
                            width - left - leftDistance - right - rightDistance,
                            height - top - topDistance - bottom - bottomDistance
                        )
                    ));
<span class="fc" id="L312">            return area;</span>
        }
    }

    private void _fillOuterFoundationBackground( Color color, Graphics2D g2d ) {
        // Check if the color is transparent
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if ( color.getAlpha() == 0 )</span>
<span class="fc" id="L319">            return;</span>

<span class="fc" id="L321">        int width     = _comp.getWidth();</span>
<span class="fc" id="L322">        int height    = _comp.getHeight();</span>

<span class="fc" id="L324">        Rectangle2D.Float outerRect = new Rectangle2D.Float(0, 0, width, height);</span>

<span class="fc" id="L326">        Area outer = new Area(outerRect);</span>
<span class="fc" id="L327">        Area inner = _getBaseArea();</span>
<span class="fc" id="L328">        outer.subtract(inner);</span>

<span class="fc" id="L330">        g2d.setColor(color);</span>
<span class="fc" id="L331">        g2d.fill(outer);</span>
<span class="fc" id="L332">    }</span>

    private void _renderShadows(
        Style style,
        ShadowStyle shadow,
        JComponent comp,
        Graphics2D g2d,
        Color shadowColor
    ) {
        // First let's check if we need to render any shadows at all
        // Is the shadow color transparent?
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if ( shadowColor.getAlpha() == 0 )</span>
<span class="nc" id="L344">            return;</span>

        // The background box is calculated from the margins and border radius:
<span class="fc" id="L347">        int leftBorderWidth   = style.border().widths().left().orElse(0);</span>
<span class="fc" id="L348">        int topBorderWidth    = style.border().widths().top().orElse(0);</span>
<span class="fc" id="L349">        int rightBorderWidth  = style.border().widths().right().orElse(0);</span>
<span class="fc" id="L350">        int bottomBorderWidth = style.border().widths().bottom().orElse(0);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        int left      = Math.max(style.margin().left().orElse(0),   0) + ( style.shadow().isInset() ? leftBorderWidth   : 0 );</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        int top       = Math.max(style.margin().top().orElse(0),    0) + ( style.shadow().isInset() ? topBorderWidth    : 0 );</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        int right     = Math.max(style.margin().right().orElse(0),  0) + ( style.shadow().isInset() ? rightBorderWidth  : 0 );</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        int bottom    = Math.max(style.margin().bottom().orElse(0), 0) + ( style.shadow().isInset() ? bottomBorderWidth : 0 );</span>
<span class="fc" id="L355">        int topLeftRadius     = Math.max(style.border().topLeftRadius(), 0);</span>
<span class="fc" id="L356">        int topRightRadius    = Math.max(style.border().topRightRadius(), 0);</span>
<span class="fc" id="L357">        int bottomRightRadius = Math.max(style.border().bottomRightRadius(), 0);</span>
<span class="fc" id="L358">        int bottomLeftRadius  = Math.max(style.border().bottomLeftRadius(), 0);</span>
<span class="fc" id="L359">        int width     = comp.getWidth();</span>
<span class="fc" id="L360">        int height    = comp.getHeight();</span>
<span class="fc" id="L361">        int borderWidth = 0;</span>

        // Calculate the shadow box bounds based on the padding and border thickness
<span class="fc" id="L364">        int xOffset = shadow.horizontalOffset();</span>
<span class="fc" id="L365">        int yOffset = shadow.verticalOffset();</span>
<span class="fc" id="L366">        int x = left + xOffset;</span>
<span class="fc" id="L367">        int y = top + yOffset;</span>
<span class="fc" id="L368">        int w = width  - left - right  - borderWidth;</span>
<span class="fc" id="L369">        int h = height - top  - bottom - borderWidth;</span>

<span class="fc" id="L371">        int blurRadius   = Math.max(shadow.blurRadius(), 0);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        int spreadRadius = !shadow.isOutset() ? shadow.spreadRadius() : -shadow.spreadRadius();</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">        int artifactAdjustment = shadow.isOutset() ? +1 : 0;</span>
<span class="fc" id="L375">        Area baseArea = _calculateBaseArea(style, artifactAdjustment, artifactAdjustment, artifactAdjustment, artifactAdjustment);</span>

<span class="fc" id="L377">        int shadowInset  = blurRadius;</span>
<span class="fc" id="L378">        int shadowOutset = blurRadius;</span>
<span class="fc" id="L379">        int borderWidthOffset = 0;</span>

<span class="fc" id="L381">        Rectangle outerShadowRect = new Rectangle(</span>
                                        x - shadowOutset + spreadRadius + borderWidthOffset,
                                        y - shadowOutset + spreadRadius + borderWidthOffset,
                                     w + shadowOutset * 2 - spreadRadius * 2,
                                        h + shadowOutset * 2 - spreadRadius * 2
                                    );

<span class="fc bfc" id="L388" title="All 4 branches covered.">        Function&lt;Integer, Integer&gt; offsetFunction = (radius) -&gt; (int)((radius * 2) / ( shadow.isInset() ? 4.5 : 3.79) + ( shadow.isInset() ? 0 : borderWidth ));</span>

<span class="fc" id="L390">        int cornerRadius = ( topLeftRadius + topRightRadius + bottomRightRadius + bottomLeftRadius ) / 4;</span>
<span class="fc" id="L391">        int gradientStartOffset = 1 + offsetFunction.apply(cornerRadius);</span>

<span class="fc" id="L393">        Rectangle innerShadowRect = new Rectangle(</span>
                                        x + shadowInset + gradientStartOffset + spreadRadius + borderWidthOffset,
                                        y + shadowInset + gradientStartOffset + spreadRadius + borderWidthOffset,
                                        w - shadowInset * 2 - gradientStartOffset * 2 - spreadRadius * 2,
                                        h - shadowInset * 2 - gradientStartOffset * 2 - spreadRadius * 2
                                    );

        Area outerMostArea;

        // Create the shadow shape based on the box bounds and corner arc widths/heights
<span class="fc" id="L403">        Rectangle outerShadowBox = new Rectangle(</span>
                                        outerShadowRect.x,
                                        outerShadowRect.y,
                                        outerShadowRect.width,
                                        outerShadowRect.height
                                    );

        // Apply the clipping to avoid overlapping the shadow and the box
<span class="fc" id="L411">        Area shadowArea = new Area(outerShadowBox);</span>

<span class="fc bfc" id="L413" title="All 2 branches covered.">        if ( shadow.isOutset() )</span>
<span class="fc" id="L414">            shadowArea.subtract(baseArea);</span>
        else
<span class="fc" id="L416">            shadowArea.intersect(baseArea);</span>

        // Draw the corner shadows
<span class="fc" id="L419">        _renderCornerShadow(shadow, Corner.TOP_LEFT,     shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L420">        _renderCornerShadow(shadow, Corner.TOP_RIGHT,    shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L421">        _renderCornerShadow(shadow, Corner.BOTTOM_LEFT,  shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L422">        _renderCornerShadow(shadow, Corner.BOTTOM_RIGHT, shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>

        // Draw the edge shadows
<span class="fc" id="L425">        _renderEdgeShadow(shadow, Edge.TOP,    shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L426">        _renderEdgeShadow(shadow, Edge.RIGHT,  shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L427">        _renderEdgeShadow(shadow, Edge.BOTTOM, shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>
<span class="fc" id="L428">        _renderEdgeShadow(shadow, Edge.LEFT,   shadowArea, innerShadowRect, outerShadowRect, gradientStartOffset, g2d);</span>

<span class="fc" id="L430">        outerMostArea = new Area(outerShadowBox);</span>
        // If the base rectangle and the outer shadow box are not equal, then we need to fill the area of the base rectangle that is not covered by the outer shadow box!
<span class="fc" id="L432">        _renderShadowBody(shadow, baseArea, innerShadowRect, outerMostArea, g2d);</span>

<span class="fc" id="L434">    }</span>

    private static void _renderShadowBody(
        ShadowStyle shadowStyle,
        Area baseArea,
        Rectangle innerShadowRect,
        Area outerShadowBox,
        Graphics2D g2d
    ) {
<span class="fc" id="L443">        Graphics2D g2d2 = (Graphics2D) g2d.create();</span>
<span class="fc" id="L444">        g2d2.setColor(shadowStyle.color().orElse(Color.BLACK));</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if ( !shadowStyle.isOutset() ) {</span>
<span class="fc" id="L446">            baseArea.subtract(outerShadowBox);</span>
<span class="fc" id="L447">            g2d2.fill(baseArea);</span>
        } else {
<span class="fc" id="L449">            Area innerShadowArea = new Area(innerShadowRect);</span>
<span class="fc" id="L450">            innerShadowArea.subtract(baseArea);</span>
<span class="fc" id="L451">            g2d2.fill(innerShadowArea);</span>
        }
<span class="fc" id="L453">        g2d2.dispose();</span>
<span class="fc" id="L454">    }</span>

    private static void _renderCornerShadow(
        ShadowStyle shadowStyle,
        Corner corner,
        Area areaWhereShadowIsAllowed,
        Rectangle innerShadowRect,
        Rectangle outerShadowRect,
        int gradientStartOffset,
        Graphics2D g2d
    ) {
        // We define a clipping box so that corners don't overlap
<span class="fc" id="L466">        float clipBoxWidth   = outerShadowRect.width / 2f;</span>
<span class="fc" id="L467">        float clipBoxHeight  = outerShadowRect.height / 2f;</span>
<span class="fc" id="L468">        float clipBoxCenterX = outerShadowRect.x + clipBoxWidth;</span>
<span class="fc" id="L469">        float clipBoxCenterY = outerShadowRect.y + clipBoxHeight;</span>
        Rectangle2D.Float cornerClipBox; // outer box!

        // The defining the corner shadow bound (where it starts and ends
        Rectangle2D.Float cornerBox;
        float cx;
        float cy;
        float cr; // depending on the corner, this is either the corner box width or height
<span class="pc bpc" id="L477" title="1 of 5 branches missed.">        switch (corner) {</span>
            case TOP_LEFT:
<span class="fc" id="L479">                cornerBox = new Rectangle2D.Float(</span>
                                    outerShadowRect.x, outerShadowRect.y,
                                    innerShadowRect.x - outerShadowRect.x,
                                    innerShadowRect.y - outerShadowRect.y
                                );
<span class="fc" id="L484">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX - clipBoxWidth, clipBoxCenterY - clipBoxHeight,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L489">                cx = cornerBox.x + cornerBox.width;</span>
<span class="fc" id="L490">                cy = cornerBox.y + cornerBox.height;</span>
<span class="fc" id="L491">                cr = cornerBox.width;</span>
<span class="fc" id="L492">                break;</span>
            case TOP_RIGHT:
<span class="fc" id="L494">                cornerBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x + innerShadowRect.width, outerShadowRect.y,
                                outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                                innerShadowRect.y - outerShadowRect.y
                            );
<span class="fc" id="L499">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX, clipBoxCenterY - clipBoxHeight,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L504">                cx = cornerBox.x;</span>
<span class="fc" id="L505">                cy = cornerBox.y + cornerBox.height;</span>
<span class="fc" id="L506">                cr = cornerBox.width;</span>
<span class="fc" id="L507">                break;</span>
            case BOTTOM_LEFT:
<span class="fc" id="L509">                cornerBox = new Rectangle2D.Float(</span>
                                outerShadowRect.x,
                                innerShadowRect.y + innerShadowRect.height,
                                innerShadowRect.x - outerShadowRect.x,
                                outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                            );
<span class="fc" id="L515">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX - clipBoxWidth, clipBoxCenterY,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L520">                cx = cornerBox.x + cornerBox.width;</span>
<span class="fc" id="L521">                cy = cornerBox.y;</span>
<span class="fc" id="L522">                cr = cornerBox.width;</span>
<span class="fc" id="L523">                break;</span>
            case BOTTOM_RIGHT:
<span class="fc" id="L525">                cornerBox = new Rectangle2D.Float(</span>
                            innerShadowRect.x + innerShadowRect.width, innerShadowRect.y + innerShadowRect.height,
                            outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                            outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                            );
<span class="fc" id="L530">                cornerClipBox = new Rectangle2D.Float(</span>
                                    clipBoxCenterX, clipBoxCenterY,
                                    clipBoxWidth, clipBoxHeight
                                );

<span class="fc" id="L535">                cx = cornerBox.x;</span>
<span class="fc" id="L536">                cy = cornerBox.y;</span>
<span class="fc" id="L537">                cr = cornerBox.width;</span>
<span class="fc" id="L538">                break;</span>
            default:
<span class="nc" id="L540">                throw new IllegalArgumentException(&quot;Invalid corner: &quot; + corner);</span>
        }

<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (cr &lt;= 0) return;</span>

        Color innerColor;
        Color outerColor;
<span class="fc" id="L547">        Color shadowBackgroundColor = _transparentShadowBackground(shadowStyle);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if ( shadowStyle.isOutset() ) {</span>
<span class="fc" id="L549">            innerColor = shadowStyle.color().orElse(Color.BLACK);</span>
<span class="fc" id="L550">            outerColor = shadowBackgroundColor;</span>
        } else {
<span class="fc" id="L552">            innerColor = shadowBackgroundColor;</span>
<span class="fc" id="L553">            outerColor = shadowStyle.color().orElse(Color.BLACK);</span>
        }
<span class="fc" id="L555">        float gradientStart = (float) gradientStartOffset / cr;</span>

        // The first thing we can do is to clip the corner box to the area where the shadow is allowed
<span class="fc" id="L558">        Area cornerArea = new Area(cornerBox);</span>
<span class="fc" id="L559">        cornerArea.intersect(areaWhereShadowIsAllowed);</span>

        // In the simplest case we don't need to do any gradient painting:
<span class="pc bpc" id="L562" title="2 of 4 branches missed.">        if ( gradientStart == 1f || gradientStart == 0f ) {</span>
            // Simple, we just draw a circle and clip it
<span class="nc" id="L564">            Area circle = new Area(new Ellipse2D.Float(cx - cr, cy - cr, cr * 2, cr * 2));</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if ( shadowStyle.isInset() ) {</span>
<span class="nc" id="L566">                g2d.setColor(outerColor);</span>
<span class="nc" id="L567">                cornerArea.subtract(circle);</span>
            } else {
<span class="nc" id="L569">                g2d.setColor(innerColor);</span>
<span class="nc" id="L570">                cornerArea.intersect(circle);</span>
            }
<span class="nc" id="L572">            g2d.fill(cornerArea);</span>
<span class="nc" id="L573">            return;</span>
        }

        RadialGradientPaint cornerPaint;
<span class="pc bpc" id="L577" title="2 of 4 branches missed.">        if ( gradientStart &gt; 1f || gradientStart &lt; 0f )</span>
<span class="nc" id="L578">            cornerPaint = new RadialGradientPaint(</span>
                             cx, cy, cr,
                             new float[] {0f, 1f},
                             new Color[] {innerColor, outerColor}
                         );
        else
<span class="fc" id="L584">            cornerPaint = new RadialGradientPaint(</span>
                             cx, cy, cr,
                             new float[] {0f, gradientStart, 1f},
                             new Color[] {innerColor, innerColor, outerColor}
                         );

        // We need to clip the corner paint to the corner box
<span class="fc" id="L591">        cornerArea.intersect(new Area(cornerClipBox));</span>

<span class="fc" id="L593">        Graphics2D cornerG2d = (Graphics2D) g2d.create();</span>
<span class="fc" id="L594">        cornerG2d.setPaint(cornerPaint);</span>
<span class="fc" id="L595">        cornerG2d.fill(cornerArea);</span>
<span class="fc" id="L596">        cornerG2d.dispose();</span>
<span class="fc" id="L597">    }</span>

    private static void _renderEdgeShadow(
            ShadowStyle shadowStyle,
            Edge edge,
            Area contentArea,
            Rectangle innerShadowRect,
            Rectangle outerShadowRect,
            int gradientStartOffset,
            Graphics2D g2d
    ) {
        // We define a boundary center point and a clipping box so that edges don't overlap
<span class="fc" id="L609">        float clipBoundaryX = outerShadowRect.x + outerShadowRect.width / 2f;</span>
<span class="fc" id="L610">        float clipBoundaryY = outerShadowRect.y + outerShadowRect.height / 2f;</span>
<span class="fc" id="L611">        Rectangle2D.Float edgeClipBox = null;</span>

        Rectangle2D.Float edgeBox;
        float gradEndX;
        float gradEndY;
        float gradStartX;
        float gradStartY;
<span class="pc bpc" id="L618" title="1 of 5 branches missed.">        switch (edge) {</span>
            case TOP:
<span class="fc" id="L620">                edgeBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x, outerShadowRect.y,
                                innerShadowRect.width, innerShadowRect.y - outerShadowRect.y
                            );

<span class="fc bfc" id="L625" title="All 2 branches covered.">                if ( (edgeBox.y + edgeBox.height) &gt; clipBoundaryY )</span>
<span class="fc" id="L626">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x, edgeBox.y,
                            edgeBox.width, clipBoundaryY - edgeBox.y
                    );

<span class="fc" id="L631">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L632">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L633">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L634">                gradStartY = edgeBox.y + edgeBox.height;</span>
<span class="fc" id="L635">                break;</span>
            case RIGHT:
<span class="fc" id="L637">                edgeBox = new Rectangle2D.Float(</span>
                                innerShadowRect.x + innerShadowRect.width, innerShadowRect.y,
                                outerShadowRect.x + outerShadowRect.width - innerShadowRect.x - innerShadowRect.width,
                                innerShadowRect.height
                            );
<span class="fc bfc" id="L642" title="All 2 branches covered.">                if ( edgeBox.x &lt; clipBoundaryX )</span>
<span class="fc" id="L643">                    edgeClipBox = new Rectangle2D.Float(</span>
                                        clipBoundaryX, edgeBox.y,
                                        edgeBox.x + edgeBox.width - clipBoundaryX, edgeBox.height
                                    );
<span class="fc" id="L647">                gradEndX = edgeBox.x + edgeBox.width;</span>
<span class="fc" id="L648">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L649">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L650">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L651">                break;</span>
            case BOTTOM:
<span class="fc" id="L653">                edgeBox = new Rectangle2D.Float(</span>
                        innerShadowRect.x, innerShadowRect.y + innerShadowRect.height,
                        innerShadowRect.width, outerShadowRect.y + outerShadowRect.height - innerShadowRect.y - innerShadowRect.height
                    );
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if ( edgeBox.y &lt; clipBoundaryY )</span>
<span class="fc" id="L658">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x,
                            clipBoundaryY,
                            edgeBox.width,
                            edgeBox.y + edgeBox.height - clipBoundaryY
                    );

<span class="fc" id="L665">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L666">                gradEndY = edgeBox.y + edgeBox.height;</span>
<span class="fc" id="L667">                gradStartX = edgeBox.x;</span>
<span class="fc" id="L668">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L669">                break;</span>
            case LEFT:
<span class="fc" id="L671">                edgeBox = new Rectangle2D.Float(</span>
                            outerShadowRect.x,
                            innerShadowRect.y,
                            innerShadowRect.x - outerShadowRect.x,
                            innerShadowRect.height
                            );
<span class="fc bfc" id="L677" title="All 2 branches covered.">                if ( (edgeBox.x + edgeBox.width) &gt; clipBoundaryX )</span>
<span class="fc" id="L678">                    edgeClipBox = new Rectangle2D.Float(</span>
                            edgeBox.x,
                            edgeBox.y,
                            clipBoundaryX - edgeBox.x,
                            edgeBox.height
                    );
<span class="fc" id="L684">                gradEndX = edgeBox.x;</span>
<span class="fc" id="L685">                gradEndY = edgeBox.y;</span>
<span class="fc" id="L686">                gradStartX = edgeBox.x + edgeBox.width;</span>
<span class="fc" id="L687">                gradStartY = edgeBox.y;</span>
<span class="fc" id="L688">                break;</span>
            default:
<span class="nc" id="L690">                throw new IllegalArgumentException(&quot;Invalid edge: &quot; + edge);</span>
        }

<span class="pc bpc" id="L693" title="1 of 4 branches missed.">        if ( gradStartX == gradEndX &amp;&amp; gradStartY == gradEndY ) return;</span>

        Color innerColor;
        Color outerColor;
        // Same as shadow color but without alpha:
<span class="fc" id="L698">        Color shadowBackgroundColor = _transparentShadowBackground(shadowStyle);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (shadowStyle.isOutset()) {</span>
<span class="fc" id="L700">            innerColor = shadowStyle.color().orElse(Color.BLACK);</span>
<span class="fc" id="L701">            outerColor = shadowBackgroundColor;</span>
        } else {
<span class="fc" id="L703">            innerColor = shadowBackgroundColor;</span>
<span class="fc" id="L704">            outerColor = shadowStyle.color().orElse(Color.BLACK);</span>
        }
        LinearGradientPaint edgePaint;
        // distance between start and end of gradient
<span class="fc" id="L708">        float dist = (float) Math.sqrt(</span>
                                    (gradEndX - gradStartX) * (gradEndX - gradStartX) +
                                    (gradEndY - gradStartY) * (gradEndY - gradStartY)
                                );
<span class="fc" id="L712">        float gradientStart = (float) gradientStartOffset / dist;</span>
<span class="pc bpc" id="L713" title="2 of 4 branches missed.">        if ( gradientStart &gt; 1f || gradientStart &lt; 0f )</span>
<span class="nc" id="L714">            edgePaint = new LinearGradientPaint(</span>
                               gradStartX, gradStartY,
                               gradEndX, gradEndY,
                               new float[] {0f, 1f},
                               new Color[] {innerColor, outerColor}
                           );
        else {
<span class="pc bpc" id="L721" title="2 of 4 branches missed.">            if ( gradientStart == 1f || gradientStart == 0f ) {</span>
                // The gradient does not really exist, so we can just fill the whole area and then return
<span class="nc" id="L723">                Area edgeArea = new Area(edgeBox);</span>
<span class="nc" id="L724">                g2d.setColor(innerColor);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                if ( shadowStyle.isOutset() )</span>
<span class="nc" id="L726">                    edgeArea.intersect(contentArea);</span>
<span class="nc" id="L727">                g2d.fill(edgeArea);</span>
<span class="nc" id="L728">                return;</span>
            }
<span class="fc" id="L730">            edgePaint = new LinearGradientPaint(</span>
                             gradStartX, gradStartY,
                             gradEndX, gradEndY,
                             new float[] {0f, gradientStart, 1f},
                             new Color[] {innerColor, innerColor, outerColor}
                         );
        }

        // We need to clip the edge paint to the edge box
<span class="fc" id="L739">        Area edgeArea = new Area(edgeBox);</span>
<span class="fc" id="L740">        edgeArea.intersect(contentArea);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">        if ( edgeClipBox != null )</span>
<span class="fc" id="L742">            edgeArea.intersect(new Area(edgeClipBox));</span>

<span class="fc" id="L744">        Graphics2D edgeG2d = (Graphics2D) g2d.create();</span>
<span class="fc" id="L745">        edgeG2d.setPaint(edgePaint);</span>
<span class="fc" id="L746">        edgeG2d.fill(edgeArea);</span>
<span class="fc" id="L747">        edgeG2d.dispose();</span>
<span class="fc" id="L748">    }</span>

    private static Color _transparentShadowBackground(ShadowStyle shadow) {
<span class="fc" id="L751">        return shadow.color()</span>
<span class="fc" id="L752">                    .map(c -&gt; new Color(c.getRed(), c.getGreen(), c.getBlue(), 0))</span>
<span class="fc" id="L753">                    .orElse(new Color(0.5f, 0.5f, 0.5f, 0f));</span>
    }

    /**
     *  Renders a shade from the top left corner to the bottom right corner.
     *
     * @param g2d The graphics object to render to.
     * @param component The component to render the shade for.
     * @param margin The margin of the component.
     * @param shade The shade to render.
     */
    private static void _renderDiagonalShade(
        Graphics2D g2d,
        JComponent component,
        Outline margin,
        ShadeStyle shade,
        Area specificArea
    ) {
<span class="fc" id="L771">        ShadingStrategy type = shade.strategy();</span>
<span class="fc" id="L772">        Color[] colors = shade.colors();</span>
<span class="fc" id="L773">        Dimension size = component.getSize();</span>
<span class="fc" id="L774">        size.width  -= (margin.right().orElse(0) + margin.left().orElse(0));</span>
<span class="fc" id="L775">        size.height -= (margin.bottom().orElse(0) + margin.top().orElse(0));</span>
<span class="fc" id="L776">        int width  = size.width;</span>
<span class="fc" id="L777">        int height = size.height;</span>
<span class="fc" id="L778">        int realX = margin.left().orElse(0);</span>
<span class="fc" id="L779">        int realY = margin.top().orElse(0);</span>

        int corner1X;
        int corner1Y;
        int corner2X;
        int corner2Y;
        int diagonalCorner1X;
        int diagonalCorner1Y;
        int diagonalCorner2X;
        int diagonalCorner2Y;

<span class="pc bpc" id="L790" title="1 of 2 branches missed.">        if ( type == ShadingStrategy.TOP_RIGHT_TO_BOTTOM_LEFT ) {</span>
<span class="nc" id="L791">            type = ShadingStrategy.BOTTOM_LEFT_TO_TOP_RIGHT;</span>
<span class="nc" id="L792">            Color tmp = colors[0];</span>
<span class="nc" id="L793">            colors[0] = colors[1];</span>
<span class="nc" id="L794">            colors[1] = tmp;</span>
        }
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if ( type == ShadingStrategy.BOTTOM_RIGHT_TO_TOP_LEFT ) {</span>
<span class="fc" id="L797">            type = ShadingStrategy.TOP_LEFT_TO_BOTTOM_RIGHT;</span>
<span class="fc" id="L798">            Color tmp = colors[0];</span>
<span class="fc" id="L799">            colors[0] = colors[1];</span>
<span class="fc" id="L800">            colors[1] = tmp;</span>
        }

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if ( type == ShadingStrategy.TOP_LEFT_TO_BOTTOM_RIGHT ) {</span>
<span class="fc" id="L804">            corner1X = realX;</span>
<span class="fc" id="L805">            corner1Y = realY;</span>
<span class="fc" id="L806">            corner2X = realX + width;</span>
<span class="fc" id="L807">            corner2Y = realY + height;</span>
<span class="fc" id="L808">            diagonalCorner1X = realX;</span>
<span class="fc" id="L809">            diagonalCorner1Y = realY + height;</span>
<span class="fc" id="L810">            diagonalCorner2X = realX + width;</span>
<span class="fc" id="L811">            diagonalCorner2Y = realY;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        } else if ( type == ShadingStrategy.BOTTOM_LEFT_TO_TOP_RIGHT ) {</span>
<span class="nc" id="L813">            corner1X = realX + width;</span>
<span class="nc" id="L814">            corner1Y = realY;</span>
<span class="nc" id="L815">            corner2X = realX;</span>
<span class="nc" id="L816">            corner2Y = realY + height;</span>
<span class="nc" id="L817">            diagonalCorner1X = realX + width;</span>
<span class="nc" id="L818">            diagonalCorner1Y = realY + height;</span>
<span class="nc" id="L819">            diagonalCorner2X = realX;</span>
<span class="nc" id="L820">            diagonalCorner2Y = realY;</span>
        }
        else
<span class="nc" id="L823">            throw new IllegalArgumentException(&quot;Invalid shading strategy: &quot; + type);</span>

<span class="fc" id="L825">        int diagonalCenterX = (diagonalCorner1X + diagonalCorner2X) / 2;</span>
<span class="fc" id="L826">        int diagonalCenterY = (diagonalCorner1Y + diagonalCorner2Y) / 2;</span>

<span class="fc" id="L828">        double vector1X = diagonalCorner1X - diagonalCenterX;</span>
<span class="fc" id="L829">        double vector1Y = diagonalCorner1Y - diagonalCenterY;</span>
<span class="fc" id="L830">        double vector2X = diagonalCorner2X - diagonalCenterX;</span>
<span class="fc" id="L831">        double vector2Y = diagonalCorner2Y - diagonalCenterY;</span>

<span class="fc" id="L833">        double vectorLength = Math.sqrt(vector1X * vector1X + vector1Y * vector1Y);</span>
<span class="fc" id="L834">        vector1X = (vector1X / vectorLength);</span>
<span class="fc" id="L835">        vector1Y = (vector1Y / vectorLength);</span>

<span class="fc" id="L837">        vectorLength = Math.sqrt(vector2X * vector2X + vector2Y * vector2Y);</span>
<span class="fc" id="L838">        vector2X = (vector2X / vectorLength);</span>
<span class="fc" id="L839">        vector2Y = (vector2Y / vectorLength);</span>

<span class="fc" id="L841">        double nVector1X = -vector1Y;</span>
<span class="fc" id="L842">        double nVector1Y = vector1X;</span>
<span class="fc" id="L843">        double nVector2X = -vector2Y;</span>
<span class="fc" id="L844">        double nVector2Y = vector2X;</span>

<span class="fc" id="L846">        double distance1 = (corner1X - diagonalCenterX) * nVector1X + (corner1Y - diagonalCenterY) * nVector1Y;</span>
<span class="fc" id="L847">        double distance2 = (corner2X - diagonalCenterX) * nVector2X + (corner2Y - diagonalCenterY) * nVector2Y;</span>

<span class="fc" id="L849">        int gradientStartX = (int) (diagonalCenterX + nVector1X * distance1);</span>
<span class="fc" id="L850">        int gradientStartY = (int) (diagonalCenterY + nVector1Y * distance1);</span>
<span class="fc" id="L851">        int gradientEndX = (int) (diagonalCenterX + nVector2X * distance2);</span>
<span class="fc" id="L852">        int gradientEndY = (int) (diagonalCenterY + nVector2Y * distance2);</span>

<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if ( colors.length == 2 )</span>
<span class="fc" id="L855">            g2d.setPaint(</span>
                    new GradientPaint(
                            gradientStartX, gradientStartY, colors[0],
                            gradientEndX, gradientEndY, colors[1]
                        )
                );
        else {
<span class="nc" id="L862">            float[] fractions = new float[colors.length];</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            for ( int i = 0; i &lt; colors.length; i++ )</span>
<span class="nc" id="L864">                fractions[i] = (float) i / (float) (colors.length - 1);</span>
<span class="nc" id="L865">            g2d.setPaint(</span>
                    new LinearGradientPaint(
                            gradientStartX, gradientStartY,
                            gradientEndX, gradientEndY,
                            fractions, colors
                        )
                );
        }
<span class="fc" id="L873">        g2d.fill(specificArea);</span>
<span class="fc" id="L874">    }</span>

    private static void _renderVerticalOrHorizontalShade(
        Graphics2D g2d,
        JComponent component,
        Outline margin,
        ShadeStyle shade,
        Area specificArea
    ) {
<span class="fc" id="L883">        ShadingStrategy type = shade.strategy();</span>
<span class="fc" id="L884">        Color[] colors = shade.colors();</span>
<span class="fc" id="L885">        Dimension size = component.getSize();</span>
<span class="fc" id="L886">        size.width  -= (margin.right().orElse(0) + margin.left().orElse(0));</span>
<span class="fc" id="L887">        size.height -= (margin.bottom().orElse(0) + margin.top().orElse(0));</span>
<span class="fc" id="L888">        int width  = size.width;</span>
<span class="fc" id="L889">        int height = size.height;</span>
<span class="fc" id="L890">        int realX = margin.left().orElse(0);</span>
<span class="fc" id="L891">        int realY = margin.top().orElse(0);</span>

        int corner1X;
        int corner1Y;
        int corner2X;
        int corner2Y;

<span class="pc bpc" id="L898" title="1 of 2 branches missed.">        if ( type == ShadingStrategy.TOP_TO_BOTTOM ) {</span>
<span class="nc" id="L899">            corner1X = realX;</span>
<span class="nc" id="L900">            corner1Y = realY;</span>
<span class="nc" id="L901">            corner2X = realX;</span>
<span class="nc" id="L902">            corner2Y = realY + height;</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">        } else if ( type == ShadingStrategy.LEFT_TO_RIGHT ) {</span>
<span class="fc" id="L904">            corner1X = realX;</span>
<span class="fc" id="L905">            corner1Y = realY;</span>
<span class="fc" id="L906">            corner2X = realX + width;</span>
<span class="fc" id="L907">            corner2Y = realY;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        } else if ( type == ShadingStrategy.BOTTOM_TO_TOP ) {</span>
<span class="nc" id="L909">            corner1X = realX;</span>
<span class="nc" id="L910">            corner1Y = realY + height;</span>
<span class="nc" id="L911">            corner2X = realX;</span>
<span class="nc" id="L912">            corner2Y = realY;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        } else if ( type == ShadingStrategy.RIGHT_TO_LEFT ) {</span>
<span class="nc" id="L914">            corner1X = realX + width;</span>
<span class="nc" id="L915">            corner1Y = realY;</span>
<span class="nc" id="L916">            corner2X = realX;</span>
<span class="nc" id="L917">            corner2Y = realY;</span>
        }
<span class="nc" id="L919">        else throw new IllegalArgumentException(&quot;Unknown shading strategy: &quot; + type);</span>

<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        if ( colors.length == 2 )</span>
<span class="nc" id="L922">            g2d.setPaint(</span>
                    new GradientPaint(
                            corner1X, corner1Y, colors[0],
                            corner2X, corner2Y, colors[1]
                        )
                );
        else {
<span class="fc" id="L929">            float[] fractions = new float[colors.length];</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">            for ( int i = 0; i &lt; colors.length; i++ )</span>
<span class="fc" id="L931">                fractions[i] = (float) i / (float) (colors.length - 1);</span>
<span class="fc" id="L932">            g2d.setPaint(</span>
                    new LinearGradientPaint(
                            corner1X, corner1Y,
                            corner2X, corner2Y,
                            fractions, colors
                        )
                );
        }
<span class="fc" id="L940">        g2d.fill(specificArea);</span>
<span class="fc" id="L941">    }</span>

    public Insets calculateBorderInsets(Insets formerInsets) {
<span class="fc" id="L944">        int left      = style.margin().left().orElse(formerInsets.left);</span>
<span class="fc" id="L945">        int top       = style.margin().top().orElse(formerInsets.top);</span>
<span class="fc" id="L946">        int right     = style.margin().right().orElse(formerInsets.right);</span>
<span class="fc" id="L947">        int bottom    = style.margin().bottom().orElse(formerInsets.bottom);</span>
        // Add padding:
<span class="fc" id="L949">        left   += style.padding().left().orElse(0);</span>
<span class="fc" id="L950">        top    += style.padding().top().orElse(0);</span>
<span class="fc" id="L951">        right  += style.padding().right().orElse(0);</span>
<span class="fc" id="L952">        bottom += style.padding().bottom().orElse(0);</span>
        // Add border widths:
<span class="fc" id="L954">        left   += Math.max(style.border().widths().left().orElse(0),   0);</span>
<span class="fc" id="L955">        top    += Math.max(style.border().widths().top().orElse(0),    0);</span>
<span class="fc" id="L956">        right  += Math.max(style.border().widths().right().orElse(0),  0);</span>
<span class="fc" id="L957">        bottom += Math.max(style.border().widths().bottom().orElse(0), 0);</span>
<span class="fc" id="L958">        return new Insets(top, left, bottom, right);</span>
    }

    public Insets calculateMarginInsets() {
<span class="fc" id="L962">        int left   = style.margin().left().orElse(0);</span>
<span class="fc" id="L963">        int top    = style.margin().top().orElse(0);</span>
<span class="fc" id="L964">        int right  = style.margin().right().orElse(0);</span>
<span class="fc" id="L965">        int bottom = style.margin().bottom().orElse(0);</span>

        // Add border widths:
<span class="fc" id="L968">        left   += Math.max(style.border().widths().left().orElse(0),   0);</span>
<span class="fc" id="L969">        top    += Math.max(style.border().widths().top().orElse(0),    0);</span>
<span class="fc" id="L970">        right  += Math.max(style.border().widths().right().orElse(0),  0);</span>
<span class="fc" id="L971">        bottom += Math.max(style.border().widths().bottom().orElse(0), 0);</span>

<span class="fc" id="L973">        return new Insets(top, left, bottom, right);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>