<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StyleSheet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">StyleSheet.java</span></div><h1>StyleSheet.java</h1><pre class="source lang-java linenums">package swingtree.style;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import sprouts.Event;
import sprouts.Observable;
import swingtree.SwingTreeConfigurator;
import swingtree.api.Styler;

import javax.swing.JComponent;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 *  An abstract class intended to be extended to create custom CSS look-alike
 *  source code based style sheets for your Swing application.
 *  &lt;p&gt;
 *  A style sheet object is in essence merely a collection of
 *  {@link StyleTrait}s and corresponding {@link Styler} lambdas
 *  which are used by the SwingTree style engine
 *  to calculate component {@link StyleConf} configurations
 *  in a functional and side effect free manner. &lt;br&gt;
 *  Implement the {@link #configure()} method and
 *  use the {@link #add(StyleTrait, Styler)} method to
 *  add {@link StyleTrait}s and corresponding {@link Styler} lambdas
 *  to the style sheet.
 *  There are also various factory methods for creating {@link StyleTrait}s
 *  in the form of {@link #id(String)}, {@link #group(String)}, {@link #group(Enum)}, {@link #type(Class)}.
 *  This is designed to make your style sheet code more readable and maintainable.
 *  &lt;br&gt;&lt;br&gt;
 *  Here an example of how this class is
 *  typically used to create a custom style sheet:
 *  &lt;pre&gt;{@code
 *  class MyStyleSheet extends StyleSheet {
 *    {@literal @}Override
 *    protected void configure() {
 *      add(group(&quot;MyButton&quot;), it -&gt; it
 *        .margin(12)
 *        .padding(16)
 *        .backgroundColor(Color.YELLOW)
 *      );
 *      add(type(JLabel.class).id(&quot;Foo&quot;), it-&gt; it
 *        .borderRadius(5)
 *        .gradient(&quot;Bar&quot;, ... )
 *      );
 *      add(group(Group.ERROR), it -&gt; it
 *        .backgroundColor(Color.RED)
 *        .borderColor(Color.YELLOW)
 *        .borderWidth(2)
 *      );
 *    }
 *  }
 *  }&lt;/pre&gt;
 *  This API design is inspired by the CSS styling language, and the use of immutable objects
 *  is a key feature of the style API, which makes it possible to safely compose
 *  {@link swingtree.api.Styler} lambdas into any kind of style inheritance hierarchy
 *  without having to worry about side effects.
 *  &lt;br&gt;&lt;br&gt;
 *  Note that the {@link #configure()} method, here the {@link Styler} lambdas
 *  are intended to be registered, is not called eagerly in the constructor of the style sheet,
 *  but rather lazily when the style sheet is first used to calculate
 *  the style configuration for a particular component, which happens through the
 *  {@link #computeStyleFrom(JComponent)} or {@link #computeStyleFrom(JComponent, StyleConf)} methods.
 *  &lt;br&gt;
 *  The intended way to use a {@link StyleSheet} is by configuring it globally
 *  through {@link swingtree.SwingTree#initialiseUsing(SwingTreeConfigurator)}, or if
 *  you want to apply ste sheets to specific scopes through {@link swingtree.UI#use(StyleSheet, Supplier)}.
 *  The second argument is a supplier lambda for your SwingTree GUI declaration where each component
 *  will be bound to the {@link StyleSheet} you supplied!
 */
public abstract class StyleSheet
{
<span class="pc" id="L74">    protected final Logger log = org.slf4j.LoggerFactory.getLogger(getClass());</span>

<span class="fc" id="L76">    private static final StyleSheet _NONE = new StyleSheet() { @Override protected void configure() {} };</span>

    /**
     *  A factory method for getting the empty style sheet representing no style whatsoever.
     *  It is especially useful instead of null.
     *
     * @return A style sheet without any traits and stylers.
     */
<span class="fc" id="L84">    public static StyleSheet none() { return _NONE; }</span>


<span class="pc" id="L87">    private final Event _styleSheetChangeEvent = Event.create();</span>
    private final BiFunction&lt;JComponent, StyleConf, StyleConf&gt; _defaultStyle;
<span class="pc" id="L89">    private final Map&lt;StyleTrait&lt;?&gt;, Styler&lt;?&gt;&gt; _styleDeclarations = new LinkedHashMap&lt;&gt;();</span>
<span class="pc" id="L90">    private StyleTrait&lt;?&gt;[][] _traitPaths = {}; // The paths are calculated from the above map and used to apply the styles.</span>

<span class="pc" id="L92">    private boolean _traitGraphBuilt = false;</span>
<span class="pc" id="L93">    private boolean _initialized     = false;</span>


<span class="fc" id="L96">    protected StyleSheet() {</span>
<span class="fc" id="L97">        _defaultStyle = (c, startingStyle) -&gt; startingStyle;</span>
<span class="fc" id="L98">    }</span>

    /**
     *  Use this method to inherit styles from the supplied {@code parentStyleSheet}.
     *  All styles in the parent will be reused in this style, but you may overwrite
     *  parent styles in the local {@link #configure()} method...
     *
     * @param parentStyleSheet Another {@link StyleSheet} from which this one should inherit all styles!
     */
<span class="nc" id="L107">    protected StyleSheet( StyleSheet parentStyleSheet ) {</span>
<span class="nc" id="L108">        Objects.requireNonNull(parentStyleSheet, &quot;Use StyleSheet.none() instead of null.&quot;);</span>
<span class="nc" id="L109">        _defaultStyle = parentStyleSheet::_applyTo;</span>
<span class="nc" id="L110">    }</span>

    /**
     *  Creates and returns an {@link Observable} on an internal
     *  {@link Event} which is triggered after every time this {@link StyleSheet}
     *  is being configured through the {@link #configure()} method.&lt;br&gt;
     *  Components created from SwingTree use this observable to recompute
     *  and apply their style from this style sheet...&lt;br&gt;
     *  &lt;b&gt;
     *      Note that the instance returned by this method is weakly referenced
     *      by the source {@link Event}. This means that when a call-site no longer
     *      holds on to their observer, then it will be garbage collected alongside
     *      all of the {@link sprouts.Observer} (event listeners) registered on it!
     *  &lt;/b&gt;
     * @return A weakly referenced {@link Observable} which can be used to react to
     *         {@link StyleSheet} re-configurations...
     */
    public final Observable observable() {
<span class="fc" id="L128">        return _styleSheetChangeEvent.observable();</span>
    }

    /**
     *  Essentially (re)initiates the style sheet by clearing all previously registered
     *  {@link StyleTrait}s and {@link Styler}s, and then calling the {@link #configure()}
     *  method again to establish a potentially completely new style.&lt;br&gt;
     *  You can use this method to build highly dynamic styling behavior.
     *  For example, during the new configuration you may want to add switch to a completely
     *  a different set of traits with different {@link Styler}s depending on the current
     *  theme of the application, which you also want the user to change at runtime
     *  (but don't forget to repaint the components to see the effect).
     */
    public final void reconfigure() {
<span class="fc" id="L142">        _traitGraphBuilt = false;</span>
<span class="fc" id="L143">        _traitPaths      = new StyleTrait&lt;?&gt;[0][];</span>
<span class="fc" id="L144">        _styleDeclarations.clear();</span>
        try {
<span class="fc" id="L146">            configure(); // The subclass will add traits to this style sheet using the add(..) method.</span>
<span class="fc" id="L147">        } catch ( Exception e ) {</span>
<span class="fc" id="L148">            log.warn(</span>
<span class="fc" id="L149">                &quot;An exception occurred while configuring style sheet &quot; + getClass().getSimpleName() + &quot;!&quot;,</span>
                e
            );
            /*
                Exceptions inside a style sheet should not be fatal.
                We just log the stack trace for debugging purposes
                and then continue to prevent the GUI from breaking.

				We log as warning because exceptions during styling
				are usually rather harmless!
            */
<span class="fc" id="L160">        }</span>
<span class="fc" id="L161">        _buildAndSetStyleTraitPaths();</span>
<span class="fc" id="L162">        _initialized = true;</span>
<span class="fc" id="L163">        _styleSheetChangeEvent.fire(); // Triggers GUI repaints...</span>
<span class="fc" id="L164">    }</span>

    /**
     *  A factory method for a {@link StyleTrait} targeting components
     *  with the given id/name (see {@link JComponent#setName(String)}).
     *  This is intended to be used in the {@link #configure()} method of the style sheet.
     *  Note that this method does not set the id/name of the component, it expects there to be a component with
     *  the given id/name already in the component hierarchy so that a corresponding {@link Styler} lambda can be applied to it.
     *  &lt;br&gt;&lt;br&gt;
     *  This is intended to be used in the {@link #configure()} method of the style sheet. &lt;br&gt;
     *  Here an example of how to use this method in the {@link #configure()} method:
     *  &lt;pre&gt;{@code
     *      add(id(&quot;myButton&quot;), it -&gt; it.backgroundColor(Color.CYAN));
     *  }&lt;/pre&gt;
     *
     * @param id The id/name of the component to target.
     * @return A {@link StyleTrait} targeting components with the given id/name.
     */
<span class="fc" id="L182">    protected StyleTrait&lt;JComponent&gt; id( String id ) { return new StyleTrait&lt;&gt;().id(id); }</span>

    /**
     *  A factory method for a {@link StyleTrait} targeting components
     *  belonging to the given string group (see {@link swingtree.UIForAnySwing#group(String...)}.
     *  A group is conceptually similar to a CSS class, meaning that you can add a group to any component
     *  and then target all components belonging to that group with a single {@link StyleTrait}.
     *  Note that this method does not add the group to any component, it expects there to be a component with
     *  the given group already in the component hierarchy so that a corresponding {@link Styler} lambda can be applied to it.
     *  &lt;br&gt;&lt;br&gt;
     *  This is intended to be used in the {@link #configure()} method of the style sheet. &lt;br&gt;
     *  Here an example of how to use this method in the {@link #configure()} method:
     *  &lt;pre&gt;{@code
     *      add(group(&quot;myGroup&quot;), it -&gt; it.backgroundColor(Color.RED));
     *  }&lt;/pre&gt;
     *  &lt;b&gt;Although using {@link String}s is a convenient way of grouping components,
     *  it is not ideal with respect to compile time safety. Please use {@link #group(Enum)} and {@link swingtree.UIForAnySwing#group(Enum[])}
     *  instead...&lt;/b&gt;
     *
     * @param group The group to target in the form of a string.
     * @return A {@link StyleTrait} targeting components belonging to the given group.
     */
<span class="fc" id="L204">    protected StyleTrait&lt;JComponent&gt; group( String group ) { return new StyleTrait&lt;&gt;().group(group); }</span>

    /**
     *  A factory method for a {@link StyleTrait} targeting components
     *  belonging to the given enum group (see {@link swingtree.UIForAnySwing#group(Enum...)}.
     *  A group is conceptually similar to a CSS class, meaning that you can add a group to any component
     *  and then target all components belonging to that group with a single {@link StyleTrait}.
     *  Note that this method does not add the group to any component, it expects there to be a component with
     *  the given group already in the component hierarchy so that a corresponding {@link Styler} lambda can be applied to it.
     *  &lt;br&gt;&lt;br&gt;
     *  This is intended to be used in the {@link #configure()} method of the style sheet. &lt;br&gt;
     *  Here an example of how to use this method in the {@link #configure()} method:
     *  &lt;pre&gt;{@code
     *      add(group(Group.ERROR), it -&gt; it.backgroundColor(Color.RED));
     *  }&lt;/pre&gt;
     *
     * @param group The group to target in the form of an enum.
     * @return A {@link StyleTrait} targeting components belonging to the given group.
     * @param &lt;E&gt; The type of the enum defining the group to target.
     */
<span class="fc" id="L224">    protected &lt;E extends Enum&lt;E&gt;&gt; StyleTrait&lt;JComponent&gt; group( E group ) { return new StyleTrait&lt;&gt;().group(group); }</span>

    /**
     *  A factory method for a {@link StyleTrait} targeting components
     *  which are of a given type (see {@link JComponent#getClass()}.
     *  Note that this method does not set the type of any component, it expects there to be a component of
     *  the given type already in the component hierarchy so that a corresponding {@link Styler} lambda can be applied to it.
     *  &lt;br&gt;&lt;br&gt;
     *  This is intended to be used in the {@link #configure()} method of the style sheet. &lt;br&gt;
     *  Here an example of how to use this method in the {@link #configure()} method:
     *  &lt;pre&gt;{@code
     *      add(type(JButton.class), it -&gt; it.backgroundColor(Color.RED));
     *  }&lt;/pre&gt;
     *
     * @param type The type of the component to target.
     * @return A {@link StyleTrait} targeting components of the given type.
     * @param &lt;C&gt; The type of the components to target for styling.
     */
<span class="fc" id="L242">    protected &lt;C extends JComponent&gt; StyleTrait&lt;C&gt; type( Class&lt;C&gt; type ) { return new StyleTrait&lt;&gt;().type(type); }</span>

    /**
     *  Use this to register style rules in you {@link #configure()} implementation by providing a {@link StyleTrait}
     *  targeting the components you want to style (see {@link #id(String)}, {@link #group(String)}, {@link #group(Enum)}, {@link #type(Class)}),
     *  and a corresponding {@link Styler} lambda which will be applied to the components targeted by the {@link StyleTrait}.
     *  &lt;br&gt;&lt;br&gt;
     *  Here an example of how to use this method in the {@link #configure()} method:
     *  &lt;pre&gt;&lt;code&gt;
     *  {@literal @}Override
     *  protected void configure() {
     *      add(id(&quot;arial-button&quot;), it -&amp;gt; it.font(new Font(&quot;Arial&quot;, Font.BOLD, 12)));
     *      add(type(JButton).group(&quot;FooBar&quot;), it -&amp;gt; it.borderRadius(5));
     *      add(group(Group.ERROR), it -&amp;gt; it.backgroundColor(Color.RED));
     *      // ...
     *  }
     *  &lt;/code&gt;&lt;/pre&gt;
     *
     * @param trait The {@link StyleTrait} targeting the components you want to style.
     * @param traitStyler The {@link Styler} lambda which will be applied to the components targeted by the {@link StyleTrait}.
     * @param &lt;C&gt; The type of the components targeted by the {@link StyleTrait}.
     */
    protected &lt;C extends JComponent&gt; void add( StyleTrait&lt;C&gt; trait, Styler&lt;C&gt; traitStyler ) {
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if ( _traitGraphBuilt )</span>
<span class="nc" id="L266">            throw new IllegalStateException(</span>
                    &quot;The trait graph has already been built. &quot; +
                    &quot;You cannot add more traits to a fully built style sheet.&quot;
                );

        // First let's make sure the trait does not already exist.
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if ( _styleDeclarations.containsKey(trait) )</span>
<span class="fc" id="L273">            throw new IllegalArgumentException(&quot;The trait &quot; + trait.group() + &quot; already exists in this style sheet.&quot;);</span>

        // Finally we fulfill the purpose of this method, we add the trait to the style sheet.
<span class="fc" id="L276">        _styleDeclarations.put( trait, traitStyler );</span>
<span class="fc" id="L277">    }</span>

    /**
     *  Override this method to configure the style sheet
     *  by adding {@link StyleTrait}s and corresponding {@link Styler} lambdas
     *  to the style sheet through the {@link #add(StyleTrait, Styler)} method. &lt;br&gt;
     *  &lt;br&gt;
     *  Example:
     *  &lt;pre&gt;&lt;code&gt;
     *  {@literal @}Override
     *  protected void configure() {
     *      add(type(JComponent.class), it -&amp;gt; it
     *        .backgroundColor(new Color(0.7f, 0.85f, 1f))
     *        .padding(4)
     *        .margin(5)
     *      );
     *      add(type(JButton.class), it -&amp;gt; it
     *         .padding(12)
     *         .margin(16)
     *         .gradient(&quot;default&quot;, shade -&amp;gt; shade
     *             .strategy(ShadingStrategy.TOP_LEFT_TO_BOTTOM_RIGHT)
     *             .colors(it.component().getBackground().brighter(), Color.CYAN)
     *         )
     *      );
     *      // ...
     *   }
     * &lt;/code&gt;&lt;/pre&gt;
     */
    protected abstract void configure();

    /**
     *  Uses this style sheet to compute the {@link StyleConf} for a component
     *  derived from the {@link StyleConf#none()} constant as a basis.
     *  Note that the style sheet is expected to already be configured at this point,
     *  because the {@link #configure()} method is called in the constructor of the style sheet.
     *  &lt;br&gt;&lt;br&gt;
     *  Example:
     *  &lt;pre&gt;{@code
     *      MyStyleSheet styleSheet = new MyStyleSheet();
     *      JComboBox&lt;String&gt; comboBox = new JComboBox&lt;&gt;();
     *      var style = styleSheet.computeStyleFrom(comboBox);
     * }&lt;/pre&gt;
     * &lt;b&gt;
     *     Note that this method does NOT install the style
     *     on the supplied component! Style installation is
     *     intended to happen when you SwingTree UI declarations
     *     are bound to a particular {@link StyleSheet} through
     *     the {@link swingtree.UI#use(StyleSheet, Supplier)} method.
     * &lt;/b&gt;
     *
     * @param toBeStyled The component to apply the style sheet to.
     * @return The {@link StyleConf} that was applied to the component.
     */
    public final StyleConf computeStyleFrom( JComponent toBeStyled ) {
<span class="fc" id="L331">        return computeStyleFrom( toBeStyled, StyleConf.none() );</span>
    }

    /**
     *  Uses this style sheet to compute the {@link StyleConf} for a component
     *  derived from the supplied {@link StyleConf} as a basis.
     *  Note that the style sheet must already be configured at this point,
     *  because the {@link #configure()} method needs to be called before
     *  in the constructor of the style sheet to bei able to compute the style.
     *  &lt;p&gt;
     *  Example:
     *  &lt;pre&gt;{@code
     *      MyStyleSheet styleSheet = new MyStyleSheet();
     *      JComboBox&lt;String&gt; comboBox = new JComboBox&lt;&gt;();
     *      var style = styleSheet.computeStyleFrom(comboBox, Style.none());
     * }&lt;/pre&gt;
     * &lt;b&gt;
     *     Note that this method does NOT install the style
     *     on the supplied component! Style installation is
     *     intended to happen when you SwingTree UI declarations
     *     are bound to a particular {@link StyleSheet} through
     *     the {@link swingtree.UI#use(StyleSheet, Supplier)} method.
     * &lt;/b&gt;
     *
     * @param toBeStyled The component for which a style ought to be computed and returned.
     * @param startingStyle The {@link StyleConf} to start with when applying the style sheet.
     * @return The {@link StyleConf} that was applied to the component.
     * @throws NullPointerException If either argument is null.
     */
    public final StyleConf computeStyleFrom( JComponent toBeStyled, StyleConf startingStyle ) {
<span class="fc" id="L361">        Objects.requireNonNull(toBeStyled);</span>
<span class="fc" id="L362">        Objects.requireNonNull(startingStyle);</span>
<span class="fc" id="L363">        return _applyTo( toBeStyled, _defaultStyle.apply(toBeStyled, startingStyle) );</span>
    }

    private StyleConf _applyTo(JComponent toBeStyled, StyleConf startingStyle )
    {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if ( !_initialized )</span>
<span class="fc" id="L369">            reconfigure();</span>

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if ( !_traitGraphBuilt )</span>
<span class="nc" id="L372">            _buildAndSetStyleTraitPaths();</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">        if ( _traitPaths.length == 0 )</span>
<span class="fc" id="L375">            return startingStyle;</span>

        // Now we run the starting style through the trait graph.
        // We do this by finding valid trait paths from the root traits to the leaf traits.
<span class="fc" id="L379">        int deepestValidPath = -1;</span>
<span class="fc" id="L380">        List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; validTraitPaths = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for ( StyleTrait&lt;?&gt;[] traitPath : _traitPaths ) {</span>
<span class="fc" id="L382">            int lastValidTrait = -1;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">            for ( int i = 0; i &lt; traitPath.length; i++ ) {</span>
<span class="fc" id="L384">                boolean valid = traitPath[i].isApplicableTo(toBeStyled);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                if (valid) lastValidTrait = i;</span>
            }
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if ( lastValidTrait &gt;= 0 ) {</span>
                // We add the path up to the last valid trait to the list of valid traits.
                // This is done by slicing the trait path array from 0 to lastValidTrait + 1.
<span class="fc" id="L390">                validTraitPaths.add(Arrays.asList(Arrays.copyOfRange(traitPath, 0, lastValidTrait + 1)));</span>
            }

<span class="fc bfc" id="L393" title="All 2 branches covered.">            if ( lastValidTrait &gt; deepestValidPath )</span>
<span class="fc" id="L394">                deepestValidPath = lastValidTrait;</span>
        }

        // Now we are going to create one common path from the valid trait paths by merging them!
        // So first we add all the traits from path step 0, then 1, then 2, etc.
<span class="fc" id="L399">        List&lt;StyleTrait&lt;?&gt;&gt; subToSuper = new java.util.ArrayList&lt;&gt;(); // The final merged path.</span>
<span class="fc" id="L400">        List&lt;String&gt; inheritedTraits = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc" id="L401">        StyleTrait&lt;?&gt; lastAdded = null;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for ( int i = 0; i &lt;= deepestValidPath; i++ ) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if ( !inheritedTraits.isEmpty() ) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                for ( String inheritedTrait : new ArrayList&lt;&gt;(inheritedTraits) ) {</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                    for ( List&lt;StyleTrait&lt;?&gt;&gt; validTraitPath : validTraitPaths ) {</span>
<span class="fc" id="L406">                        int index = validTraitPath.size() - i - 1;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                        if ( index &gt;= 0 ) {</span>
<span class="fc" id="L408">                            StyleTrait&lt;?&gt; current = validTraitPath.get(index);</span>
<span class="fc bfc" id="L409" title="All 4 branches covered.">                            if ( !subToSuper.contains(current) &amp;&amp; current.group().equals(inheritedTrait) )</span>
<span class="fc" id="L410">                                lastAdded = _merge(current, lastAdded, subToSuper, inheritedTraits);</span>
                        }
<span class="fc" id="L412">                    }</span>
<span class="fc" id="L413">                }</span>
            }
<span class="fc bfc" id="L415" title="All 2 branches covered.">            for ( List&lt;StyleTrait&lt;?&gt;&gt; validTraitPath : validTraitPaths ) {</span>
<span class="fc" id="L416">                int index = validTraitPath.size() - i - 1;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if ( index &gt;= 0 ) {</span>
<span class="fc" id="L418">                    StyleTrait&lt;?&gt; trait = validTraitPath.get(index);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                    if ( !subToSuper.contains(trait) )</span>
<span class="fc" id="L420">                        lastAdded = _merge(trait, lastAdded, subToSuper, inheritedTraits);</span>
                }
<span class="fc" id="L422">            }</span>
        }

        // Now we apply the valid traits to the starting style.
<span class="fc bfc" id="L426" title="All 2 branches covered.">        for ( int i = subToSuper.size() - 1; i &gt;= 0; i-- ) {</span>
<span class="fc" id="L427">            StyleTrait&lt;?&gt; trait = subToSuper.get(i);</span>
<span class="fc" id="L428">            ComponentStyleDelegate delegate = new ComponentStyleDelegate&lt;&gt;(toBeStyled, startingStyle);</span>
<span class="fc" id="L429">            Styler&lt;?&gt; styler = _styleDeclarations.get(trait);</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            if ( styler != null ) {</span>
                try {
<span class="fc" id="L432">                    startingStyle = styler.style(delegate).style();</span>
<span class="nc" id="L433">                } catch ( Exception e ) {</span>
<span class="nc" id="L434">                    log.error(</span>
                        &quot;An exception occurred while applying the style for trait '&quot; + trait + &quot;' &quot; +
                        &quot;to component '&quot; + toBeStyled + &quot;' using styler '&quot; + styler + &quot;'!&quot;,
                        e
                    );
                    /*
                        Exceptions inside a style sheet should not be fatal.
                        We just log the stack trace for debugging purposes
                        and then continue to prevent the GUI from breaking.
                     */
<span class="fc" id="L444">                }</span>
            }
        }

<span class="fc" id="L448">        return startingStyle;</span>
    }

    private @Nullable StyleTrait&lt;?&gt; _merge(
        StyleTrait&lt;?&gt;           currentTrait,
        @Nullable StyleTrait&lt;?&gt; lastAdded,
        List&lt;StyleTrait&lt;?&gt;&gt;     subToSuper,
        List&lt;String&gt;            inheritedTraits
    ) {
<span class="fc bfc" id="L457" title="All 6 branches covered.">        boolean lastIsSuper = lastAdded != null &amp;&amp; lastAdded.group().isEmpty() &amp;&amp; !lastAdded.thisInherits(currentTrait);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if ( lastIsSuper )</span>
<span class="fc" id="L459">            subToSuper.add(subToSuper.size() - 1, currentTrait);</span>
        else {
<span class="fc" id="L461">            subToSuper.add(currentTrait);</span>
<span class="fc" id="L462">            lastAdded = currentTrait;</span>
        }
<span class="fc" id="L464">        inheritedTraits.remove(currentTrait.group());</span>
<span class="fc" id="L465">        inheritedTraits.addAll(Arrays.asList(currentTrait.toInherit()));</span>
<span class="fc" id="L466">        return lastAdded;</span>
    }

    /**
     *  Establishes an array of {@link StyleTrait} arrays which represent
     *  all the possible paths from the root traits to the leaf traits.
     *  These paths are used to determine the order in which the styles
     *  of the traits are calculated.
     */
    private void _buildAndSetStyleTraitPaths() {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if ( !_styleDeclarations.isEmpty() )</span>
<span class="fc" id="L477">            _traitPaths = new GraphPathsBuilder().buildTraitGraphPathsFrom(_styleDeclarations);</span>
<span class="fc" id="L478">        _traitGraphBuilt = true;</span>
<span class="fc" id="L479">    }</span>

<span class="fc" id="L481">    private static class GraphPathsBuilder</span>
    {
<span class="fc" id="L483">        private final Map&lt;StyleTrait&lt;?&gt;, List&lt;StyleTrait&lt;?&gt;&gt;&gt; _traitGraph = new LinkedHashMap&lt;&gt;();</span>


        private StyleTrait&lt;?&gt;[][] buildTraitGraphPathsFrom(
            Map&lt;StyleTrait&lt;?&gt;, Styler&lt;?&gt;&gt; _traitStylers
        ) {
            // Let's clear the trait graph. Just in case.
<span class="fc" id="L490">            _traitGraph.clear();</span>

            /*
                First we need to initialize the trait graph.
                We compare each trait to every other trait to see if it inherits from it.
                If it does, we add the trait to the other trait's list of extensions (the value in the map).
            */
<span class="fc bfc" id="L497" title="All 2 branches covered.">            for ( StyleTrait&lt;?&gt; trait1 : _traitStylers.keySet() ) {</span>
<span class="fc" id="L498">                List&lt;StyleTrait&lt;?&gt;&gt; traits = _traitGraph.computeIfAbsent(trait1, k -&gt; new java.util.ArrayList&lt;&gt;());</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                for ( StyleTrait&lt;?&gt; trait2 : _traitStylers.keySet() )</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">                    if ( !trait2.equals(trait1) &amp;&amp; trait2.thisInherits(trait1) )</span>
<span class="fc" id="L501">                        traits.add(trait2);</span>
<span class="fc" id="L502">            }</span>

            /*
                Now we have a graph of traits that inherit from other traits.
                We can use this graph to determine the order in which we apply the traits to a style.
                But first we need to make sure there are no cycles in the graph.

                We do this by performing a depth-first search on the graph.
            */
<span class="fc bfc" id="L511" title="All 2 branches covered.">            for ( StyleTrait&lt;?&gt; trait : _traitGraph.keySet() ) {</span>
                // We create a stack onto which we will push the traits we visit and then pop them off.
<span class="fc" id="L513">                List&lt;StyleTrait&lt;?&gt;&gt; visited = new java.util.ArrayList&lt;&gt;();</span>
                // We pop the trait off the stack when we return from the recursive call.
<span class="fc" id="L515">                _depthFirstSearch(trait, visited);</span>
<span class="fc" id="L516">            }</span>

            // We copy into a simple array and return it. Arrays are a little faster than lists.
<span class="fc" id="L519">            List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; result = _findRootAndLeaveTraits();</span>
<span class="fc" id="L520">            StyleTrait&lt;?&gt;[][] resultArray = new StyleTrait&lt;?&gt;[result.size()][];</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            for ( int i = 0; i &lt; result.size(); i++ )</span>
<span class="fc" id="L522">                resultArray[i] = result.get(i).toArray(new StyleTrait&lt;?&gt;[0]);</span>

<span class="fc" id="L524">            return resultArray;</span>
        }

        private void _depthFirstSearch( StyleTrait&lt;?&gt; current, List&lt;StyleTrait&lt;?&gt;&gt; visited ) {
            // If the current trait is already in the visited list, then we have a cycle.
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            if ( visited.contains(current) )</span>
<span class="nc" id="L530">                throw new IllegalStateException(&quot;The style sheet contains a cycle.&quot;);</span>

            // We add the current trait to the visited list.
<span class="fc" id="L533">            visited.add(current);</span>

            // We recursively call the dfs method on each of the current trait's extensions.

<span class="fc" id="L537">            List&lt;StyleTrait&lt;?&gt;&gt; traits = _traitGraph.get(current);</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">            if ( traits != null )</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                for ( StyleTrait&lt;?&gt; extension : traits )</span>
<span class="fc" id="L540">                    _depthFirstSearch(extension, visited);</span>

            // We remove the current trait from the visited list.
<span class="fc" id="L543">            visited.remove(current);</span>
<span class="fc" id="L544">        }</span>

        private List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; _findRootAndLeaveTraits() {
        /*
            We find the root traits by finding the traits, which have extensions,
            but are not referenced by any other trait as an extension.
         */
<span class="fc" id="L551">            List&lt;StyleTrait&lt;?&gt;&gt; rootTraits = new java.util.ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">            for ( StyleTrait&lt;?&gt; trait1 : _traitGraph.keySet() ) {</span>
<span class="fc" id="L554">                boolean isLeaf = true;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                for ( StyleTrait&lt;?&gt; trait2 : _traitGraph.keySet() )</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">                    if ( _traitGraph.get(trait2).contains(trait1) ) {</span>
<span class="fc" id="L557">                        isLeaf = false;</span>
<span class="fc" id="L558">                        break;</span>
                    }
<span class="fc bfc" id="L560" title="All 2 branches covered.">                if ( isLeaf )</span>
<span class="fc" id="L561">                    rootTraits.add(trait1);</span>
<span class="fc" id="L562">            }</span>
        /*
            Finally we can calculate all the possible paths from the root traits to the leaf traits.
        */
<span class="fc" id="L566">            return _findPathsFor(rootTraits);</span>
        }

        private List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; _findPathsFor( List&lt;StyleTrait&lt;?&gt;&gt; traits ) {
<span class="fc" id="L570">            List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; paths = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            for ( StyleTrait&lt;?&gt; root : traits ) {</span>
<span class="fc" id="L572">                List&lt;StyleTrait&lt;?&gt;&gt; stack = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc" id="L573">                _traverse(root, paths, stack);</span>
<span class="fc" id="L574">            }</span>
<span class="fc" id="L575">            return paths;</span>
        }

        private void _traverse(
                StyleTrait&lt;?&gt; current,
                List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; paths,
                List&lt;StyleTrait&lt;?&gt;&gt; stack
        ) {
<span class="fc" id="L583">            stack.add(current);</span>
<span class="fc" id="L584">            List&lt;StyleTrait&lt;?&gt;&gt; traits = _traitGraph.get(current);</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">            if ( traits != null ) {</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                if ( traits.isEmpty() ) {</span>
<span class="fc" id="L587">                    List&lt;List&lt;StyleTrait&lt;?&gt;&gt;&gt; newPath = Collections.singletonList(new ArrayList&lt;&gt;(stack));</span>
                    // We remove the last trait from the stack.
<span class="fc" id="L589">                    stack.remove(stack.size() - 1);</span>
<span class="fc" id="L590">                    paths.addAll(newPath);</span>
<span class="fc" id="L591">                    return;</span>
                }

<span class="fc bfc" id="L594" title="All 2 branches covered.">                for ( StyleTrait&lt;?&gt; extension : traits )</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                    if ( !extension.equals(current) )</span>
<span class="fc" id="L596">                        _traverse(extension, paths, stack);</span>
            }

            // We remove the last trait from the stack.
<span class="fc" id="L600">            stack.remove(stack.size() - 1);</span>
<span class="fc" id="L601">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>