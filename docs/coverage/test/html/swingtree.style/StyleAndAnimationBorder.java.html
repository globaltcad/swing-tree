<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StyleAndAnimationBorder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">StyleAndAnimationBorder.java</span></div><h1>StyleAndAnimationBorder.java</h1><pre class="source lang-java linenums">package swingtree.style;

import swingtree.api.Styler;

import javax.swing.AbstractButton;
import javax.swing.JComponent;
import javax.swing.border.Border;
import java.awt.*;

/**
 *  A custom {@link Border} implementation which is capable of painting large parts of
 *  the styles defined by SwingTree user through the style API (see {@link swingtree.UIForAnySwing#withStyle(Styler)})
 *  as well as the previously installed {@link Border} of a component,
 *  to which it delegates the painting of the border if the current {@link Style}
 *  does not override the looks of the former border.
 *  Not only does this paint borders, shadows and animation lambda, but it also
 *  calculates the border insets of the component based on the margins, paddings and border widths
 *  specified by the user of the style API. &lt;br&gt;
 *  This class is mostly responsible for making styling compatible with
 *  any plain old Swing component...
 *
 * @param &lt;C&gt; The type of the component that is being styled, animated or sized in a particular way...
 */
final class StyleAndAnimationBorder&lt;C extends JComponent&gt; implements Border
{
    private final ComponentExtension&lt;C&gt; _compExt;
    private final Border _formerBorder;
    private final boolean _borderWasNotPainted;

    private Insets _insets;
<span class="fc" id="L31">    private final Insets _marginInsets = new Insets(0, 0, 0, 0);</span>
<span class="fc" id="L32">    private final Insets _paddingInsets = new Insets(0, 0, 0, 0);</span>
<span class="fc" id="L33">    private final Insets _fullPaddingInsets = new Insets(0, 0, 0, 0);</span>


<span class="fc" id="L36">    StyleAndAnimationBorder( ComponentExtension&lt;C&gt; compExt, Border formerBorder ) {</span>
<span class="fc" id="L37">        _compExt       = compExt;</span>
<span class="fc" id="L38">        _insets        = null;</span>
<span class="fc" id="L39">        _formerBorder  = formerBorder;</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if ( _compExt.getOwner() instanceof AbstractButton ) {</span>
<span class="fc" id="L41">            AbstractButton b = (AbstractButton) _compExt.getOwner();</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">            _borderWasNotPainted = !b.isBorderPainted();</span>
<span class="fc" id="L43">            b.setBorderPainted(true);</span>
<span class="fc" id="L44">        }</span>
        else
<span class="fc" id="L46">            _borderWasNotPainted = false;</span>
<span class="fc" id="L47">    }</span>

<span class="fc" id="L49">    Border getFormerBorder() { return _formerBorder; }</span>

<span class="fc" id="L51">    Insets getMarginInsets() { return _marginInsets; }</span>

<span class="nc" id="L53">    Insets getPaddingInsets() { return _paddingInsets; }</span>

<span class="fc" id="L55">    Insets getFullPaddingInsets() { return _fullPaddingInsets; }</span>

    @Override
    public void paintBorder( Component c, Graphics g, int x, int y, int width, int height )
    {
<span class="fc" id="L60">        _compExt.establishStyleAndBeginPainting();</span>

<span class="fc" id="L62">        Shape formerClip = g.getClip();</span>
<span class="fc" id="L63">        g.setClip(null);</span>
        /*
            The border should not be clipped as the current clip may be the inner component area
            which can produce ugly artifacts between the inner component area
            and the area around the component (margin), which is not covered by the border.
            Resetting the clip here is visually especially very important for rounded borders and shadows.
        */

<span class="fc" id="L71">        _paintBorderAndBorderLayerStyles( (Graphics2D) g );</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">        if ( _formerBorder != null &amp;&amp; !_borderWasNotPainted ) {</span>
<span class="fc" id="L73">            BorderStyle borderStyle = _compExt.getStyle().border();</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">            if ( !borderStyle.isVisible() )</span>
<span class="fc" id="L75">                _paintFormerBorder(c, g, x, y, width, height);</span>
        }
<span class="fc" id="L77">        _compExt._renderAnimations((Graphics2D) g);</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if ( formerClip != null )</span>
<span class="fc" id="L80">            g.setClip(formerClip);</span>
<span class="fc" id="L81">    }</span>

    private void _paintFormerBorder( Component c, Graphics g, int x, int y, int width, int height ) {
        try {
<span class="fc" id="L85">            _formerBorder.paintBorder(</span>
                    c, g,
                    x + _marginInsets.left,
                    y + _marginInsets.top,
                    width   - _marginInsets.left - _marginInsets.right,
                    height - _marginInsets.top  - _marginInsets.bottom
                );
<span class="nc" id="L92">        } catch (Exception ex) {</span>
<span class="nc" id="L93">            ex.printStackTrace();</span>
            /*
                 Note that if any exceptions happen in the former Border implementation,
                 then we don't want to mess up the execution of the rest of the component painting...
                 Therefore, we catch any exceptions that happen in the above code.

                 Ideally this would be logged in the logging framework of the user
                 who implemented the Border,
                 but we don't know which logging framework that is, so we just print
                 the stack trace to the console so that any developers can see what went wrong.
            */
<span class="fc" id="L104">        }</span>
<span class="fc" id="L105">    }</span>

    /**
     *  Not only paints the border but also styles which are configured to be painted
     *  on the border layer (see {@link swingtree.UI.Layer#BORDER}).
     *
     * @param g The graphics context that is used for painting.
     */
    private void _paintBorderAndBorderLayerStyles( Graphics2D g ) {
        try {
<span class="fc" id="L115">            _compExt._paintBorderStyle( g, _compExt.getOwner() );</span>
<span class="nc" id="L116">        } catch ( Exception ex ) {</span>
<span class="nc" id="L117">            ex.printStackTrace();</span>
            /*
                Note that if any exceptions happen during the border style painting,
                then we don't want to mess up how the rest of the component is painted...
                Therefore, we catch any exceptions that happen in the above code.
            */
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">    }</span>

    @Override
    public Insets getBorderInsets( Component c ) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if ( _insets == null )</span>
<span class="fc" id="L129">            _compExt.calculateApplyAndInstallStyle(false);</span>
<span class="fc" id="L130">        return _insets;</span>
    }

    void recalculateInsets(Style style)
    {
<span class="fc" id="L135">        _calculateMarginInsets(style);</span>
<span class="fc" id="L136">        _calculatePaddingInsets(style);</span>
<span class="fc" id="L137">        _calculateFullPaddingInsets(style);</span>
<span class="fc" id="L138">        _calculateBorderInsets(style,</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">                _formerBorder == null</span>
<span class="fc" id="L140">                    ? new Insets(0, 0, 0, 0)</span>
<span class="fc" id="L141">                    : _formerBorder.getBorderInsets(_compExt.getOwner())</span>
            );
<span class="fc" id="L143">    }</span>

    Insets getFormerBorderInsets() {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if ( _borderWasNotPainted )</span>
<span class="nc" id="L147">            return new Insets(0, 0, 0, 0);</span>
        else
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            return _formerBorder == null</span>
<span class="nc" id="L150">                        ? new Insets(0, 0, 0, 0)</span>
<span class="fc" id="L151">                        : _formerBorder.getBorderInsets(_compExt.getOwner());</span>
    }

    @Override
<span class="nc" id="L155">    public boolean isBorderOpaque() { return false; }</span>


    private void _calculateBorderInsets( Style style, Insets formerInsets )
    {
<span class="fc" id="L160">        int left      = style.margin().left().orElse(formerInsets.left);</span>
<span class="fc" id="L161">        int top       = style.margin().top().orElse(formerInsets.top);</span>
<span class="fc" id="L162">        int right     = style.margin().right().orElse(formerInsets.right);</span>
<span class="fc" id="L163">        int bottom    = style.margin().bottom().orElse(formerInsets.bottom);</span>
        // Add padding:
<span class="fc" id="L165">        left   += style.padding().left().orElse(0);</span>
<span class="fc" id="L166">        top    += style.padding().top().orElse(0);</span>
<span class="fc" id="L167">        right  += style.padding().right().orElse(0);</span>
<span class="fc" id="L168">        bottom += style.padding().bottom().orElse(0);</span>
        // Add border widths:
<span class="fc" id="L170">        left   += Math.max(style.border().widths().left().orElse(0),   0);</span>
<span class="fc" id="L171">        top    += Math.max(style.border().widths().top().orElse(0),    0);</span>
<span class="fc" id="L172">        right  += Math.max(style.border().widths().right().orElse(0),  0);</span>
<span class="fc" id="L173">        bottom += Math.max(style.border().widths().bottom().orElse(0), 0);</span>

<span class="pc bpc" id="L175" title="3 of 10 branches missed.">        if (</span>
            _insets == null         ||
            _insets.left   != left  ||
            _insets.top    != top   ||
            _insets.right  != right ||
            _insets.bottom != bottom
        ) {
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if ( _insets == null )</span>
<span class="fc" id="L183">                _insets = new Insets(top, left, bottom, right);</span>
            else
<span class="fc" id="L185">                _insets.set(top, left, bottom, right);</span>

<span class="fc" id="L187">            _compExt.getOwner().revalidate();</span>
        }
<span class="fc" id="L189">    }</span>

    private void _calculateMarginInsets( Style style )
    {
<span class="fc" id="L193">        int left   = style.margin().left().orElse(0);</span>
<span class="fc" id="L194">        int top    = style.margin().top().orElse(0);</span>
<span class="fc" id="L195">        int right  = style.margin().right().orElse(0);</span>
<span class="fc" id="L196">        int bottom = style.margin().bottom().orElse(0);</span>

        // Add border widths:
<span class="fc" id="L199">        left   += Math.max(style.border().widths().left().orElse(0),   0);</span>
<span class="fc" id="L200">        top    += Math.max(style.border().widths().top().orElse(0),    0);</span>
<span class="fc" id="L201">        right  += Math.max(style.border().widths().right().orElse(0),  0);</span>
<span class="fc" id="L202">        bottom += Math.max(style.border().widths().bottom().orElse(0), 0);</span>

<span class="fc" id="L204">        _marginInsets.top    = top;</span>
<span class="fc" id="L205">        _marginInsets.left   = left;</span>
<span class="fc" id="L206">        _marginInsets.right  = right;</span>
<span class="fc" id="L207">        _marginInsets.bottom = bottom;</span>
<span class="fc" id="L208">    }</span>

    private void _calculatePaddingInsets( Style style )
    {
<span class="fc" id="L212">        _paddingInsets.top    = style.padding().left().orElse(0);</span>
<span class="fc" id="L213">        _paddingInsets.left   = style.padding().top().orElse(0);</span>
<span class="fc" id="L214">        _paddingInsets.right  = style.padding().right().orElse(0);</span>
<span class="fc" id="L215">        _paddingInsets.bottom = style.padding().bottom().orElse(0);</span>
<span class="fc" id="L216">    }</span>

    private void _calculateFullPaddingInsets( Style style )
    {
<span class="fc" id="L220">        _fullPaddingInsets.top    = style.padding().left().orElse(0)   + style.margin().left().orElse(0);</span>
<span class="fc" id="L221">        _fullPaddingInsets.left   = style.padding().top().orElse(0)    + style.margin().top().orElse(0);</span>
<span class="fc" id="L222">        _fullPaddingInsets.right  = style.padding().right().orElse(0)  + style.margin().right().orElse(0);</span>
<span class="fc" id="L223">        _fullPaddingInsets.bottom = style.padding().bottom().orElse(0) + style.margin().bottom().orElse(0);</span>
<span class="fc" id="L224">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>