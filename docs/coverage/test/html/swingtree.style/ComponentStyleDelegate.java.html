<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComponentStyleDelegate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.style</a> &gt; <span class="el_source">ComponentStyleDelegate.java</span></div><h1>ComponentStyleDelegate.java</h1><pre class="source lang-java linenums">package swingtree.style;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import swingtree.UI;
import swingtree.api.*;
import swingtree.api.Painter;
import swingtree.layout.LayoutConstraint;
import swingtree.layout.Size;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;

/**
 *  A {@link ComponentStyleDelegate} is a delegate for a {@link JComponent} and its {@link StyleConf} configuration
 *  used to apply further specify the style of said {@link JComponent}.
 *  Instances of this will be exposed to you via the {@link swingtree.UIForAnySwing#withStyle(Styler)}
 *  method, where you can specify a lambda that takes a {@link ComponentStyleDelegate} and returns a
 *  transformed {@link StyleConf} object, as well as inside of {@link StyleSheet} extensions
 *  where you can declare similar styling lambdas for {@link StyleTrait}s, which are
 *  styling rules... &lt;br&gt;
 *
 * @param &lt;C&gt; The type of {@link JComponent} this {@link ComponentStyleDelegate} is for.
 */
public final class ComponentStyleDelegate&lt;C extends JComponent&gt;
{
<span class="fc" id="L31">    private static final Logger log = org.slf4j.LoggerFactory.getLogger(ComponentStyleDelegate.class);</span>

    private final C _component;
    private final StyleConf _styleConf;


<span class="fc" id="L37">    ComponentStyleDelegate( C component, StyleConf styleConf) {</span>
<span class="fc" id="L38">        _component = Objects.requireNonNull(component);</span>
<span class="fc" id="L39">        _styleConf = Objects.requireNonNull(styleConf);</span>
<span class="fc" id="L40">    }</span>

    ComponentStyleDelegate&lt;C&gt; _withStyle( StyleConf styleConf) {
<span class="fc" id="L43">        return new ComponentStyleDelegate&lt;&gt;(_component, styleConf);</span>
    }

    /**
     *  Returns the {@link JComponent} this {@link ComponentStyleDelegate} is defining a {@link StyleConf} for.
     *  This is useful if you want to make the styling of a component based on its state,
     *  like for example determining the background color of a {@link JCheckBox} based on
     *  whether it is selected or not...
     * 
     * @return The {@link JComponent} this {@link ComponentStyleDelegate} is for.
     */
<span class="fc" id="L54">    public C component() { return _component; }</span>

    /**
     *  Exposes the parent {@link Container} of the {@link JComponent} delegated by this {@link ComponentStyleDelegate}
     *  through an {@link Optional} in case the parent is null.
     *  You may use this to make your styling dependent on the properties of the parent container.
     *
     * @return An optional parent {@link Container} of the {@link JComponent} this {@link ComponentStyleDelegate} is for.
     */
<span class="fc" id="L63">    public Optional&lt;Container&gt; parent() { return Optional.ofNullable(_component.getParent()); }</span>

    /**
     *  Use this to peek at the {@link JComponent} of this {@link ComponentStyleDelegate}
     *  to perform some style-related component specific actions on it
     *  which are otherwise not found in the {@link ComponentStyleDelegate} API.
     *
     * @param peeker A {@link Peeker} that takes the {@link JComponent} of this {@link ComponentStyleDelegate}
     * @return This {@link ComponentStyleDelegate} instance.
     */
    public ComponentStyleDelegate&lt;C&gt; peek( Peeker&lt;C&gt; peeker )
    {
<span class="nc" id="L75">        Objects.requireNonNull(peeker);</span>
        try {
<span class="nc" id="L77">            peeker.accept(_component);</span>
<span class="nc" id="L78">        } catch( Exception e ) {</span>
<span class="nc" id="L79">            log.error(&quot;Peeker threw an exception: &quot; + e.getMessage(), e);</span>
            // We don't want to crash the application if the peeker throws an exception.
<span class="nc" id="L81">        }</span>
<span class="nc" id="L82">        return this;</span>
    }

    /**
     *   Allows you to apply styles based on a condition.
     *   So if the first argument, the condition, is true,
     *   then it causes the supplied {@link Styler} to
     *   update the style, if however the condition is false,
     *   then the styler will simply be ignored
     *   and the style will not be updated.
     *   &lt;br&gt;
     *   Here a simple usage example:
     *   &lt;pre&gt;{@code
     *       UI.panel().withStyle( it -&gt; it
     *          .border(3, Color.BLACK)
     *          .borderRadius(24)
     *          .applyIf(it.component().isEnabled(), it2 -&gt; it2
     *              .borderColor(Color.LIGHT_GRAY)
     *              .backgroundColor(Color.CYAN)
     *          )
     *          .margin(3)
     *          .padding(4)
     *       );
     *   }&lt;/pre&gt;
     *   This is conceptually similar to {@link swingtree.UIForAnySwing#applyIf(boolean, Consumer)}
     *   with the difference that it is based on a {@link Styler} instead of a consumer,
     *   as the style API is based on immutable types whose updated results must be returned
     *   by the conditional scope.
     *
     * @param condition The condition determining if the provided {@code styler} should be executed.
     * @param styler A supplier for
     * @return This instance if the condition is false, or the supplied {@code styler} threw an exception,
     *         a new style delegate updated according to the {@code styler}.
     */
    public ComponentStyleDelegate&lt;C&gt; applyIf(
        boolean condition,
        Styler&lt;C&gt; styler
    ) {
<span class="fc" id="L120">        Objects.requireNonNull(styler);</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">        if ( !condition )</span>
<span class="fc" id="L123">            return this;</span>

        try {
<span class="fc" id="L126">            return styler.style(this);</span>
<span class="nc" id="L127">        } catch( Exception e ) {</span>
<span class="nc" id="L128">            log.error(&quot;Conditional styler threw an exception: &quot; + e.getMessage(), e);</span>
            // We don't want to crash the application if the conditional styler throws an exception.
        }
<span class="nc" id="L131">        return this;</span>
    }

    /**
     *  Returns the {@link StyleConf} this {@link ComponentStyleDelegate} is defining for the {@link JComponent}
     *  returned by {@link #component()}.
     * &lt;p&gt;
     * @return The {@link StyleConf} this {@link ComponentStyleDelegate} is for.
     */
<span class="fc" id="L140">    StyleConf style() { return _styleConf; }</span>

    /**
     *  Creates a new {@link StyleConf} with the provided top, right, left and bottom margin distances.
     *  It determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     * 
     * @param top The top padding distance in pixels.
     * @param right The right padding distance in pixels.
     * @param bottom The bottom padding distance in pixels.
     * @param left The left padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distances.
     */
    public ComponentStyleDelegate&lt;C&gt; margin( double top, double right, double bottom, double left ) {
<span class="fc" id="L155">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(Outline.of(top, right, bottom, left))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for all sides of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; margin( double margin ) {
<span class="fc" id="L168">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(Outline.of((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the top side of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     * 
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginTop( double margin ) {
<span class="fc" id="L181">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withTop((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the right side of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginRight( double margin ) {
<span class="fc" id="L194">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withRight((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the bottom side of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginBottom( double margin ) {
<span class="nc" id="L207">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withBottom((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the left side of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginLeft( double margin ) {
<span class="fc" id="L220">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withLeft((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the top and bottom sides of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginVertical( double margin ) {
<span class="nc" id="L233">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withTop((float) margin).withBottom((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided margin distance for the left and right sides of the component.
     *  The margin determines the amount of space between the component's outer bounds and the beginning
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param margin The margin distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided margin distance.
     */
    public ComponentStyleDelegate&lt;C&gt; marginHorizontal( double margin ) {
<span class="nc" id="L246">        return _withStyle(_styleConf._withBorder(_styleConf.border().withMargin(_styleConf.border().margin().withLeft((float) margin).withRight((float) margin))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided top, right, left and bottom pad distances.
     *  It determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param top The top padding distance in pixels.
     * @param right The right padding distance in pixels.
     * @param bottom The bottom padding distance in pixels.
     * @param left The left padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distances.
     */
    public ComponentStyleDelegate&lt;C&gt; padding( double top, double right, double bottom, double left ) {
<span class="fc" id="L262">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(Outline.of(top, right, bottom, left))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for all sides of the component.
     *  It determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; padding( double padding ) {
<span class="fc" id="L275">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(Outline.of((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the top side of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingTop( double padding ) {
<span class="fc" id="L288">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withTop((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the right side of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  of the inner border, background region and shadow frame
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingRight( double padding ) {
<span class="fc" id="L302">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withRight((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the bottom side of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingBottom( double padding ) {
<span class="fc" id="L315">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withBottom((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the left side of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingLeft( double padding ) {
<span class="fc" id="L328">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withLeft((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the top and bottom sides of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     *
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingVertical( double padding ) {
<span class="nc" id="L341">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withTop((float) padding).withBottom((float) padding))));</span>
    }

    /**
     *  Creates a new {@link StyleConf} with the provided padding distance for the left and right sides of the component.
     *  The padding determines the amount of space between the inner bounds (the inner border, background region and shadow frame)
     *  and the component's content.
     *  (see {@link #borderWidth(double)}, {@link #backgroundColor(Color)}, {@link #shadowColor(Color)}).
     * 
     * @param padding The padding distance in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided padding distance.
     */
    public ComponentStyleDelegate&lt;C&gt; paddingHorizontal( double padding ) {
<span class="nc" id="L354">        return _withStyle(_styleConf._withBorder(_styleConf.border().withPadding(_styleConf.border().padding().withLeft((float) padding).withRight((float) padding))));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border width and border color.
     *  The border will be rendered with an inset space based on the margin defined by the {@link StyleConf}.
     *
     * @param width The border width in pixels.
     * @param color The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and border color.
     */
    public ComponentStyleDelegate&lt;C&gt; border( double width, Color color ) {
<span class="fc" id="L366">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidth(width).withColor(color)));</span>
    }

    /**
     *   Returns a new {@link StyleConf} with the provided border width and border colors.
     *   The border will be rendered with an inset space based on the margin defined by the {@link StyleConf}.
     *   You may configure the border colors for each side of the component individually.
     * @param width The border width in pixels.
     * @param top The color for the top part of the border.
     * @param right The color for the right part of the border.
     * @param bottom The color for the bottom part of the border.
     * @param left The color for the left part of the border.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and border colors.
     */
    public ComponentStyleDelegate&lt;C&gt; border( double width, Color top, Color right, Color bottom, Color left ) {
<span class="nc" id="L381">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidth(width).withColors(top, right, bottom, left)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border widths and border color.
     *  The border will be rendered with an inset space based on the margin defined by the {@link StyleConf}.
     *
     * @param top The border width in pixels for the top side of the component.
     * @param right The border width in pixels for the right side of the component.
     * @param bottom The border width in pixels for the bottom side of the component.
     * @param left The border width in pixels for the left side of the component.
     * @param color The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border widths and border color.
     */
    public ComponentStyleDelegate&lt;C&gt; border( double top, double right, double bottom, double left, Color color ) {
<span class="fc" id="L396">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidths(Outline.of(top, right, bottom, left)).withColor(color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border width and border color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties
     *  (See {@link swingtree.UI#color(String)} for more information on the supported color formats).
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param width The border width in pixels.
     * @param colorString The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and border color.
     */
    public ComponentStyleDelegate&lt;C&gt; border( double width, String colorString ) {
<span class="fc" id="L410">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L413">            newColor = UI.color(colorString);</span>
<span class="nc" id="L414">        } catch ( Exception e ) {</span>
<span class="nc" id="L415">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L416">            return this;</span>
<span class="fc" id="L417">        }</span>
<span class="fc" id="L418">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidth(width).withColor(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border width and border colors in the form of strings.
     *  The strings can be either hex color strings, color names or color constants from the system properties.
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param width The border width in pixels.
     * @param top The color for the top part of the border.
     * @param right The color for the right part of the border.
     * @param bottom The color for the bottom part of the border.
     * @param left The color for the left part of the border.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and border colors.
     */
    public ComponentStyleDelegate&lt;C&gt; border( double width, String top, String right, String bottom, String left ) {
<span class="nc" id="L434">        Color topColor = UI.color(top);</span>
<span class="nc" id="L435">        Color rightColor = UI.color(right);</span>
<span class="nc" id="L436">        Color bottomColor = UI.color(bottom);</span>
<span class="nc" id="L437">        Color leftColor = UI.color(left);</span>
<span class="nc" id="L438">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidth(width).withColors(topColor, rightColor, bottomColor, leftColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border width.
     *  &lt;p&gt;
     *  Note that in order for the border to be visible you also
     *  have to specify it's color, which you can do through
     *  {@link #borderColor(Color)} or {@link #borderColor(String)}.
     *  You may also specify different colors for each side of the border
     *  through {@link #borderColors(Color, Color, Color, Color)} or {@link #borderColors(String, String, String, String)}.
     *
     * @param width The border width in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border width.
     */
    public ComponentStyleDelegate&lt;C&gt; borderWidth( double width ) {
<span class="fc" id="L454">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidth(width)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border colors,
     *  which are stored in the order of top, right, bottom, left.
     *  Note that a component border will be rendered with an inset
     *  space based on the padding defined by the {@link StyleConf}.
     *  &lt;p&gt;
     *  Instead of null, the {@link swingtree.UI.Color#UNDEFINED}
     *  constant is used to indicate that a border color is not set.
     *
     * @param top The color for the top part of the border.
     * @param right The color for the right part of the border.
     * @param bottom The color for the bottom part of the border.
     * @param left The color for the left part of the border.
     * @return A new {@link ComponentStyleDelegate} with the provided border colors.
     */
    public ComponentStyleDelegate&lt;C&gt; borderColors( Color top, Color right, Color bottom, Color left ) {
<span class="fc" id="L473">        return _withStyle(_styleConf._withBorder(_styleConf.border().withColors(top, right, bottom, left)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border colors in the form of strings.
     *  The strings can be either hex color strings, color names or color constants from the system properties
     *  (See {@link swingtree.UI#color(String)} for more information on the supported color formats).
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param top The color for the top part of the border.
     * @param right The color for the right part of the border.
     * @param bottom The color for the bottom part of the border.
     * @param left The color for the left part of the border.
     * @return A new {@link ComponentStyleDelegate} with the provided border colors.
     */
    public ComponentStyleDelegate&lt;C&gt; borderColors( String top, String right, String bottom, String left ) {
<span class="fc" id="L489">        Color topColor = UI.color(top);</span>
<span class="fc" id="L490">        Color rightColor = UI.color(right);</span>
<span class="fc" id="L491">        Color bottomColor = UI.color(bottom);</span>
<span class="fc" id="L492">        Color leftColor = UI.color(left);</span>
<span class="fc" id="L493">        return _withStyle(_styleConf._withBorder(_styleConf.border().withColors(topColor, rightColor, bottomColor, leftColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border width for the specified edge.
     *  &lt;p&gt;
     *  Note that in order for the border to be visible you also
     *  have to specify it's color, which you can do through
     *  {@link #borderColor(Color)} or {@link #borderColor(String)}.
     *
     * @param edge The edge to set the border width for.
     * @param width The border width in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border width for the specified edge.
     */
    public ComponentStyleDelegate&lt;C&gt; borderWidthAt( UI.Edge edge, double width ) {
<span class="fc" id="L508">        Objects.requireNonNull(edge);</span>
<span class="fc" id="L509">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidthAt(edge, (float) width)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided width and color used to define
     *  the border for the specified edge of the component.
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param edge The edge to set the border width and color for, you may use {@link UI.Edge#EVERY}
     *             to set the same width and color for all edges.
     * @param width The border width in pixels.
     * @param color The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and color for the specified edge.
     */
    public ComponentStyleDelegate&lt;C&gt; borderAt( UI.Edge edge, double width, Color color ) {
<span class="fc" id="L524">        Objects.requireNonNull(edge);</span>
<span class="fc" id="L525">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidthAt(edge, (float) width).withColorAt(edge, color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided width and color string used to define
     *  the border for the specified edge of the component.
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *  &lt;p&gt;
     *  The color is specified as a string, which can be either a hex color string, a color name or a color constant
     *  from the system properties (See {@link swingtree.UI#color(String)} for more information on the supported color formats).
     *
     * @param edge The edge to set the border width and color for, you may use {@link UI.Edge#EVERY}
     *             to set the same width and color for all edges.
     * @param width The border width in pixels.
     * @param colorString The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border width and color for the specified edge.
     */
    public ComponentStyleDelegate&lt;C&gt; borderAt( UI.Edge edge, double width, String colorString ) {
<span class="fc" id="L543">        Objects.requireNonNull(edge);</span>
        Color newColor;
        try {
<span class="fc" id="L546">            newColor = UI.color(colorString);</span>
<span class="nc" id="L547">        } catch ( Exception e ) {</span>
<span class="nc" id="L548">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L549">            return this;</span>
<span class="fc" id="L550">        }</span>
<span class="fc" id="L551">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidthAt(edge, (float) width).withColorAt(edge, newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided top, right, bottom and left border widths.
     *  &lt;p&gt;
     *  The border widths are specified in the following order: top, right, bottom, left.
     *  &lt;p&gt;
     *  Example:
     *  &lt;pre&gt;{@code
     *      UI.panel().withStyle( it -&gt; it.borderWidths(1, 2, 3, 4) )
     *  }&lt;/pre&gt;
     *  &lt;p&gt;
     *  Note that in order for the border to be visible you also
     *  have to specify it's color, which you can do through
     *  {@link #borderColor(Color)} or {@link #borderColor(String)}.
     *
     * @param top The top border width in pixels.
     * @param right The right border width in pixels.
     * @param bottom The bottom border width in pixels.
     * @param left The left border width in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided top, right, bottom and left border widths.
     * @see #borderWidth(double)
     * @see #borderWidthAt(UI.Edge, double)
     */
    public ComponentStyleDelegate&lt;C&gt; borderWidths( double top, double right, double bottom, double left ) {
<span class="fc" id="L577">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidths(Outline.of(top, right, bottom, left))));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided top/bottom and left/right border widths.
     *  &lt;p&gt;
     *  Example:
     *  &lt;pre&gt;{@code
     *      UI.panel().withStyle( it -&gt; it.borderWidths(1, 2) )
     *  }&lt;/pre&gt;
     *  &lt;p&gt;
     *  Note that in order for the border to be visible you also
     *  have to specify it's color, which you can do through
     *  {@link #borderColor(Color)} or {@link #borderColor(String)}.
     *
     * @param topBottom The top and bottom border width in pixels.
     * @param leftRight The left and right border width in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided top/bottom and left/right border widths.
     * @see #borderWidth(double)
     * @see #borderWidthAt(UI.Edge, double)
     */
    public ComponentStyleDelegate&lt;C&gt; borderWidths( double topBottom, double leftRight ) {
<span class="nc" id="L599">        return _withStyle(_styleConf._withBorder(_styleConf.border().withWidths(Outline.of(topBottom, leftRight, topBottom, leftRight))));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border color.
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param color The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border color.
     */
    public ComponentStyleDelegate&lt;C&gt; borderColor( Color color ) {
<span class="fc" id="L610">        return _withStyle(_styleConf._withBorder(_styleConf.border().withColor(color)));</span>
    }

    /**
     *  Returns an updated {@link StyleConf} with the provided border color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties.
     *  The border will be rendered with an inset space based on the padding defined by the {@link StyleConf}.
     *
     * @param colorString The border color.
     * @return A new {@link ComponentStyleDelegate} with the provided border color.
     */
    public ComponentStyleDelegate&lt;C&gt; borderColor( String colorString ) {
<span class="fc" id="L622">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L625">            newColor = UI.color(colorString);</span>
<span class="nc" id="L626">        } catch ( Exception e ) {</span>
<span class="nc" id="L627">            log.error(&quot;Failed to parse color string: '{}'&quot;, colorString, e);</span>
<span class="nc" id="L628">            return this;</span>
<span class="fc" id="L629">        }</span>
<span class="fc" id="L630">        return _withStyle(_styleConf._withBorder(_styleConf.border().withColor(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border radius
     *  set for all 4 corners of the target component.
     *  This will override both the arc width and arc height of each corner.
     *  The border will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *
     * @param radius The border radius in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border radius.
     */
    public ComponentStyleDelegate&lt;C&gt; borderRadius( double radius ) {
<span class="fc" id="L643">        return _withStyle(_styleConf._withBorder(_styleConf.border().withArcWidth(radius).withArcHeight(radius)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border arc width and arc height
     *  set for all 4 corners of the target component.
     *  Note that the border will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *
     * @param arcWidth The border arc width in pixels.
     * @param arcHeight The border arc height in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border arc width and arc height.
     */
    public ComponentStyleDelegate&lt;C&gt; borderRadius( double arcWidth, double arcHeight ) {
<span class="fc" id="L656">        return _withStyle(_styleConf._withBorder(_styleConf.border().withArcWidth(arcWidth).withArcHeight(arcHeight)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border arc width and arc height for the specified corner.
     *  Note that the border will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *
     * @param corner The corner to apply the border radius to.
     * @param arcWidth The border arc width in pixels.
     * @param arcHeight The border arc height in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border arc width and arc height for the specified corner.
     */
    public ComponentStyleDelegate&lt;C&gt; borderRadiusAt( UI.Corner corner, double arcWidth, double arcHeight ) {
<span class="fc" id="L669">        return _withStyle(_styleConf._withBorder(_styleConf.border().withArcWidthAt(corner, arcWidth).withArcHeightAt(corner, arcHeight)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided border radius for the specified corner.
     *  This will override both the arc width and arc height of the border.
     *  Note that the border will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *
     * @param corner The corner to apply the border radius to.
     * @param radius The border radius in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided border radius for the specified corner.
     */
    public ComponentStyleDelegate&lt;C&gt; borderRadiusAt( UI.Corner corner, double radius ) {
<span class="fc" id="L682">        return this.borderRadiusAt(corner, radius, radius);</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided {@link ImageIcon} as the icon
     *  for the current component (see {@link #component()}).
     *  Note that this will only produce a result for components that actually support icons.
     *  Like for example all the various {@link AbstractButton} subclasses, {@link JLabel}
     *  and {@link swingtree.components.JIcon}.
     *
     * @param icon The icon.
     * @return A new {@link ComponentStyleDelegate} with the provided icon.
     */
    public ComponentStyleDelegate&lt;C&gt; icon( ImageIcon icon ) {
<span class="nc" id="L696">        return _withStyle(_styleConf._withBase(_styleConf.base().icon(icon)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided {@link ImageIcon} as the icon
     *  for the current component (see {@link #component()}) and the provided fit mode
     *  determining how the icon should be fitted to the component.
     *  Note that this will only work for components that support icons.
     *  Like for example all the various {@link AbstractButton} subclasses, {@link JLabel}
     *  and {@link swingtree.components.JIcon}.
     *
     * @param icon The icon in the form of an {@link ImageIcon}.
     * @param fit The fit mode for the icon (mostly intended for {@link SvgIcon}).
     * @return A new {@link ComponentStyleDelegate} with the provided icon.
     */
    public ComponentStyleDelegate&lt;C&gt; icon( ImageIcon icon, UI.FitComponent fit ) {
<span class="nc" id="L712">        return _withStyle(_styleConf._withBase(_styleConf.base().icon(icon).fit(fit)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided {@link IconDeclaration} as the
     *  source for the icon of the current component (see {@link #component()}).
     *  Note that this will only have an effect for components that support icons.
     *  Like for example all the various {@link AbstractButton} subclasses, {@link JLabel}
     *  and {@link swingtree.components.JIcon}.
     *
     * @param icon The icon declaration, which will be resolved to an {@link ImageIcon}.
     * @return A new {@link ComponentStyleDelegate} with the provided icon.
     */
    public ComponentStyleDelegate&lt;C&gt; icon( IconDeclaration icon ) {
<span class="nc" id="L726">        return icon.find().map(this::icon).orElse(this);</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided {@link IconDeclaration} as the
     *  source for the icon of the current component (see {@link #component()}) and the provided fit mode
     *  determining how the icon should be fitted to the component.
     *  Note that this will only have an effect for components that support icons.
     *  Like for example all the various {@link AbstractButton} subclasses, {@link JLabel}
     *  and {@link swingtree.components.JIcon}.
     *
     * @param icon The icon declaration, which will be resolved to an {@link ImageIcon}.
     * @param fit The fit mode for the icon (mostly intended for {@link SvgIcon}).
     * @return A new {@link ComponentStyleDelegate} with the provided icon.
     */
    public ComponentStyleDelegate&lt;C&gt; icon( IconDeclaration icon, UI.FitComponent fit ) {
<span class="nc" id="L742">        return icon.find().map(it -&gt; icon(it, fit)).orElse(this);</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided background foundation color.
     *  The foundation color covers the {@link UI.ComponentArea#EXTERIOR}, which
     *  starts at the outer bounds of the component and the beginning of the border.
     *  So the space spanned by the margins of the component including the additional
     *  exterior space exposed by the border radius.
     *
     * @param color The background color.
     * @return A new {@link ComponentStyleDelegate} with the provided background color.
     */
    public ComponentStyleDelegate&lt;C&gt; foundationColor( Color color ) {
<span class="fc" id="L756">        Objects.requireNonNull(color, &quot;Use 'UI.Color.UNDEFINED' instead of 'null'.&quot;);</span>
<span class="fc" id="L757">        return _withStyle(_styleConf._withBase(_styleConf.base().foundationColor(color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided background foundation color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties.
     *  The foundation color covers the {@link UI.ComponentArea#EXTERIOR}, which
     *  starts at the outer bounds of the component and the beginning of the border.
     *  So the space spanned by the margins of the component including the additional
     *  exterior space exposed by the border radius.
     *
     * @param colorString The background color.
     * @return A new {@link ComponentStyleDelegate} with the provided background color.
     */
    public ComponentStyleDelegate&lt;C&gt; foundationColor( String colorString ) {
<span class="fc" id="L772">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L775">            newColor = UI.color(colorString);</span>
<span class="nc" id="L776">        } catch ( Exception e ) {</span>
<span class="nc" id="L777">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L778">            return this;</span>
<span class="fc" id="L779">        }</span>
<span class="fc" id="L780">        return _withStyle(_styleConf._withBase(_styleConf.base().foundationColor(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided background foundation color
     *  defined by the supplied red, green and blue color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  The foundation color covers the {@link UI.ComponentArea#EXTERIOR}, which
     *  starts at the outer bounds of the component and the beginning of the border.
     *  So the space spanned by the margins of the component including the additional
     *  exterior space exposed by the border radius.
     *
     * @param r The red component of the background color in the range of 0.0 to 1.0.
     * @param g The green component of the background color in the range of 0.0 to 1.0.
     * @param b The blue component of the background color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided background color.
     */
    public ComponentStyleDelegate&lt;C&gt; foundationColor( double r, double g, double b ) {
<span class="nc" id="L798">        return foundationColor(new Color((float) r, (float) g, (float) b));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided background foundation color
     *  defined by the supplied red, green, blue and alpha color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  The foundation color covers the {@link UI.ComponentArea#EXTERIOR}, which
     *  starts at the outer bounds of the component and the beginning of the border.
     *  So the space spanned by the margins of the component including the additional
     *  exterior space exposed by the border radius.
     *
     * @param r The red component of the background color in the range of 0.0 to 1.0.
     * @param g The green component of the background color in the range of 0.0 to 1.0.
     * @param b The blue component of the background color in the range of 0.0 to 1.0.
     * @param a The alpha component of the background color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided background color.
     */
    public ComponentStyleDelegate&lt;C&gt; foundationColor( double r, double g, double b, double a ) {
<span class="nc" id="L817">        return foundationColor(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided inner Background color.
     *  The background color covers the {@link UI.ComponentArea#INTERIOR}, which, when going inwards,
     *  starts at the end of the component's border area ({@link UI.ComponentArea#BORDER}),
     *  (which is defined by {@link UI.ComponentBoundary#BORDER_TO_INTERIOR})
     *  and then completely fills the component's inner bounds ({@link UI.ComponentArea#INTERIOR}),
     *  including both the space spanned by the padding and the content area.
     *
     * @param color The inner background color.
     * @return A new {@link ComponentStyleDelegate} with the provided inner background color.
     */
    public ComponentStyleDelegate&lt;C&gt; backgroundColor( Color color ) {
<span class="fc" id="L832">        Objects.requireNonNull(color, &quot;Use 'UI.Color.UNDEFINED' instead of 'null'.&quot;);</span>
<span class="fc" id="L833">        return _withStyle(_styleConf._withBase(_styleConf.base().backgroundColor(color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided inner Background color
     *  defined by the supplied red, green and blue color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  The background color covers the {@link UI.ComponentArea#INTERIOR}, which, when going inwards,
     *  starts at the end of the component's border area ({@link UI.ComponentArea#BORDER}),
     *  (which is defined by {@link UI.ComponentBoundary#BORDER_TO_INTERIOR})
     *  and then completely fills the component's inner bounds ({@link UI.ComponentArea#INTERIOR}),
     *  including both the space spanned by the padding and the content area.
     *
     * @param r The red component of the inner background color in the range of 0.0 to 1.0.
     * @param g The green component of the inner background color in the range of 0.0 to 1.0.
     * @param b The blue component of the inner background color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided inner background color.
     */
    public ComponentStyleDelegate&lt;C&gt; backgroundColor( double r, double g, double b ) {
<span class="nc" id="L852">        return backgroundColor(new Color((float) r, (float) g, (float) b));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided inner Background color
     *  defined by the supplied red, green, blue and alpha color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  The background color covers the {@link UI.ComponentArea#INTERIOR}, which, when going inwards,
     *  starts at the end of the component's border area ({@link UI.ComponentArea#BORDER}),
     *  (which is defined by {@link UI.ComponentBoundary#BORDER_TO_INTERIOR})
     *  and then completely fills the component's inner bounds ({@link UI.ComponentArea#INTERIOR}),
     *  including both the space spanned by the padding and the content area.
     *
     * @param r The red component of the inner background color in the range of 0.0 to 1.0.
     * @param g The green component of the inner background color in the range of 0.0 to 1.0.
     * @param b The blue component of the inner background color in the range of 0.0 to 1.0.
     * @param a The alpha component of the inner background color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided inner background color.
     */
    public ComponentStyleDelegate&lt;C&gt; backgroundColor( double r, double g, double b, double a ) {
<span class="fc" id="L872">        return backgroundColor(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided inner Background color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties.
     *  The background color covers the {@link UI.ComponentArea#INTERIOR}, which, when going inwards,
     *  starts at the end of the component's border area ({@link UI.ComponentArea#BORDER}),
     *  (which is defined by {@link UI.ComponentBoundary#BORDER_TO_INTERIOR})
     *  and then completely fills the component's inner bounds ({@link UI.ComponentArea#INTERIOR}),
     *  including both the space spanned by the padding and the content area.
     *
     * @param colorString The inner background color.
     * @return A new {@link ComponentStyleDelegate} with the provided inner background color.
     */
    public ComponentStyleDelegate&lt;C&gt; backgroundColor( String colorString ) {
<span class="fc" id="L888">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L891">            newColor = UI.color(colorString);</span>
<span class="nc" id="L892">        } catch ( Exception e ) {</span>
<span class="nc" id="L893">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L894">            return this;</span>
<span class="fc" id="L895">        }</span>
<span class="fc" id="L896">        return _withStyle(_styleConf._withBase(_styleConf.base().backgroundColor(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided custom {@link swingtree.api.Painter}, which
     *  will be called using the {@link Graphics2D} of the current component.
     *  You may use this to render a custom background for the component.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *    Note that your custom painter will yield the best performance if they are value based in the sense that
     *    they have {@link Object#hashCode()} and {@link Object#equals(Object)} implementation which
     *    are based on the data that the painter uses to render the component.
     *    This is because it allows SwingTree to cache the rendering of the painters and avoid unnecessary repaints. &lt;br&gt;
     *    If you do not want to create a custom class just for painting but instead
     *    just want to pass an immutable cache key to a painter, then consider using the
     *    {@link Painter#of(Object, Painter)} factory method to create a painter that has the
     *    with {@link Object#hashCode()} and {@link Object#equals(Object)} implemented
     *    based on the provided cache key.
     *  &lt;/b&gt;
     *
     * @param layer The layer on which the painter should do its work.
     *              It is an enum instance which
     *              gives the painter a particular rank in the painting order.
     *              So the {@link swingtree.UI.Layer#BACKGROUND} will be painted first,
     *              followed by the {@link swingtree.UI.Layer#CONTENT} and so on...
     *              &lt;br&gt;
     *              The following layers are available:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param painter A custom painter, which receives the {@link Graphics2D} instance of the current component.
     * @return A new {@link ComponentStyleDelegate} with the provided background renderer.
     */
    public ComponentStyleDelegate&lt;C&gt; painter( UI.Layer layer, swingtree.api.Painter painter ) {
<span class="fc" id="L933">        return _withStyle(_styleConf.painter(layer, UI.ComponentArea.INTERIOR, StyleUtil.DEFAULT_KEY, painter));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided custom {@link swingtree.api.Painter}, which
     *  will be called using the {@link Graphics2D} of the current component.
     *  You may use this to render a custom background for the component on the specified {@link swingtree.UI.Layer}
     *  and {@link swingtree.UI.ComponentArea}.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *    Note that your custom painter will yield the best performance if they are value based in the sense that
     *    they have {@link Object#hashCode()} and {@link Object#equals(Object)} implementation which
     *    are based on the data that the painter uses to render the component.
     *    This is because it allows SwingTree to cache the rendering of the painters and avoid unnecessary repaints. &lt;br&gt;
     *    If you do not want to create a custom class just for painting but instead
     *    just want to pass an immutable cache key to a painter, then consider using the
     *    {@link Painter#of(Object, Painter)} factory method to create a painter that has the
     *    with {@link Object#hashCode()} and {@link Object#equals(Object)} implemented
     *    based on the provided cache key.
     *  &lt;/b&gt;
     * @param layer The layer on which the painter should do its work.
     *              It is an enum instance which
     *              gives the painter a particular rank in the painting order.
     *              So the {@link swingtree.UI.Layer#BACKGROUND} will be painted first,
     *              followed by the {@link swingtree.UI.Layer#CONTENT} and so on...
     *              &lt;br&gt;
     *              The following layers are available:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param clipArea The area to which the painting should be confined. Paint operations outside of this area will be clipped away.
     *                 The following areas are available:
     *                 &lt;ul&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#ALL}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#EXTERIOR}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#BORDER}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#INTERIOR}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#BODY}&lt;/li&gt;
     *                 &lt;/ul&gt;
     * @param painter A custom painter, which receives the {@link Graphics2D} instance of the current component.
     * @return A new {@link ComponentStyleDelegate} with the provided background renderer.
     */
    public ComponentStyleDelegate&lt;C&gt; painter(
        UI.Layer              layer,
        UI.ComponentArea      clipArea,
        swingtree.api.Painter painter
    ) {
<span class="nc" id="L983">        return _withStyle(_styleConf.painter(layer, clipArea, StyleUtil.DEFAULT_KEY, painter));</span>
    }


    /**
     *  Returns a new {@link StyleConf} with the provided named {@link swingtree.api.Painter}, which
     *  will be called using the {@link Graphics2D} instance of the current component.
     *  You may use this to render custom styles for the component... &lt;br&gt;
     *  The name can be used to override {@link swingtree.api.Painter} instances with that same name
     *  or use a unique name to ensure that you style is not overridden by another style.
     *  This allows you to attach an arbitrary number of custom painters to a component.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *    Note that your custom painter will yield the best performance if they are value based in the sense that
     *    they have {@link Object#hashCode()} and {@link Object#equals(Object)} implementation which
     *    are based on the data that the painter uses to render the component.
     *    This is because it allows SwingTree to cache the rendering of the painters and avoid unnecessary repaints. &lt;br&gt;
     *    If you do not want to create a custom class just for painting but instead
     *    just want to pass an immutable cache key to a painter, then consider using the
     *    {@link Painter#of(Object, Painter)} factory method to create a painter that has the
     *    with {@link Object#hashCode()} and {@link Object#equals(Object)} implemented
     *    based on the provided cache key.
     *  &lt;/b&gt;
     *
     * @param layer The layer on which the painter should do its work.
     *              It is an enum instance which
     *              gives the painter a particular rank in the painting order.
     *              So the {@link swingtree.UI.Layer#BACKGROUND} will be painted first,
     *              followed by the {@link swingtree.UI.Layer#CONTENT} and so on...
     *              &lt;br&gt;
     *              The following layers are available:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param painterName The name of the painter.
     * @param painter The custom painter lambda to which the {@link Graphics2D} instance of the current component will be passed.
     * @return A new {@link ComponentStyleDelegate} with the provided background renderer.
     */
    public ComponentStyleDelegate&lt;C&gt; painter( UI.Layer layer, String painterName, swingtree.api.Painter painter ) {
<span class="fc" id="L1025">        return _withStyle(_styleConf.painter(layer, UI.ComponentArea.INTERIOR, painterName, painter));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided named {@link swingtree.api.Painter}, which
     *  will be called using the {@link Graphics2D} instance of the current component.
     *  You may use this to render custom styles for the component... &lt;br&gt;
     *  The name can be used to override {@link swingtree.api.Painter} instances with that same name
     *  or use a unique name to ensure that you style is not overridden by another style.
     *  This allows you to attach an arbitrary number of custom painters to a component.
     *  &lt;br&gt;&lt;br&gt;
     *  &lt;b&gt;
     *    Note that your custom painter will yield the best performance if they are value based in the sense that
     *    they have {@link Object#hashCode()} and {@link Object#equals(Object)} implementation which
     *    are based on the data that the painter uses to render the component.
     *    This is because it allows SwingTree to cache the rendering of the painters and avoid unnecessary repaints. &lt;br&gt;
     *    If you do not want to create a custom class just for painting but instead
     *    just want to pass an immutable cache key to a painter, then consider using the
     *    {@link Painter#of(Object, Painter)} factory method to create a painter that has the
     *    with {@link Object#hashCode()} and {@link Object#equals(Object)} implemented
     *    based on the provided cache key.
     *  &lt;/b&gt;
     *
     * @param layer The layer on which the painter should do its work.
     *              It is an enum instance which
     *              gives the painter a particular rank in the painting order.
     *              So the {@link swingtree.UI.Layer#BACKGROUND} will be painted first,
     *              followed by the {@link swingtree.UI.Layer#CONTENT} and so on...
     *              &lt;br&gt;
     *              The following layers are available:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param clipArea The area to which the painting should be confined. Paint operations outside of this area will be clipped away.
     *                 The following areas are available:
     *                 &lt;ul&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#ALL}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#EXTERIOR}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#BORDER}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#INTERIOR}&lt;/li&gt;
     *                      &lt;li&gt;{@link UI.ComponentArea#BODY}&lt;/li&gt;
     *                 &lt;/ul&gt;
     * @param painterName The name of the painter.
     * @param painter The custom painter lambda to which the {@link Graphics2D} instance of the current component will be passed.
     * @return A new {@link ComponentStyleDelegate} with the provided background renderer.
     */
    public ComponentStyleDelegate&lt;C&gt; painter(
        UI.Layer              layer,
        UI.ComponentArea      clipArea,
        String                painterName,
        swingtree.api.Painter painter
    ) {
<span class="fc" id="L1080">        return _withStyle(_styleConf.painter(layer, clipArea, painterName, painter));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided foreground color.
     *
     * @param color The foreground color.
     * @return A new {@link ComponentStyleDelegate} with the provided foreground color.
     */
    public ComponentStyleDelegate&lt;C&gt; foregroundColor( Color color ) {
<span class="fc" id="L1090">        Objects.requireNonNull(color, &quot;Use 'UI.Color.UNDEFINED' instead of 'null'.&quot;);</span>
<span class="fc" id="L1091">        return _withStyle(_styleConf._withBase(_styleConf.base().foregroundColor(color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided foreground color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties.
     *
     * @param colorString The foreground color.
     * @return A new {@link ComponentStyleDelegate} with the provided foreground color.
     */
    public ComponentStyleDelegate&lt;C&gt; foregroundColor( String colorString ) {
<span class="fc" id="L1102">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L1105">            newColor = UI.color(colorString);</span>
<span class="nc" id="L1106">        } catch ( Exception e ) {</span>
<span class="nc" id="L1107">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L1108">            return this;</span>
<span class="fc" id="L1109">        }</span>
<span class="fc" id="L1110">        return _withStyle(_styleConf._withBase(_styleConf.base().foregroundColor(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided horizontal shadow offset applied to all shadow configs.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call {@link #shadowSpreadRadius(double)},
     *  {@link #shadowBlurRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param offset The shadow offset in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided horizontal shadow offset.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowHorizontalOffset( double offset ) {
<span class="fc" id="L1125">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.horizontalOffset((float) offset)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided vertical shadow offset applied to all shadow configs.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call {@link #shadowSpreadRadius(double)},
     *  {@link #shadowBlurRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param offset The shadow offset in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided vertical shadow offset.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowVerticalOffset( double offset ) {
<span class="fc" id="L1140">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.verticalOffset((float) offset)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow offset applied to all shadow configs.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call {@link #shadowSpreadRadius(double)},
     *  {@link #shadowBlurRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param horizontalOffset The horizontal shadow offset in pixels.
     * @param verticalOffset The vertical shadow offset in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow offset.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowOffset( double horizontalOffset, double verticalOffset ) {
<span class="fc" id="L1156">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.horizontalOffset((float) horizontalOffset).verticalOffset((float) verticalOffset)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided horizontal and vertical shadow offset.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call {@link #shadowSpreadRadius(double)},
     *  {@link #shadowBlurRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param horizontalAndVerticalOffset The horizontal and vertical shadow offset in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow offset.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowOffset( double horizontalAndVerticalOffset ) {
<span class="fc" id="L1171">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.horizontalOffset((float) horizontalAndVerticalOffset).verticalOffset((float) horizontalAndVerticalOffset)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow blur radius applied to all shadow configs.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowSpreadRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param radius The shadow blur radius in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow blur radius.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowBlurRadius( double radius ) {
<span class="fc" id="L1186">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.blurRadius((float) radius)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow spread radius applied to all shadow configs.
     *  The shadow will be rendered with an inset space based on the padding defined by this {@link StyleConf}.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowBlurRadius(double)} and {@link #shadowColor(Color)}. &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}.
     *
     * @param radius The shadow spread radius in pixels.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow spread radius.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowSpreadRadius( double radius ) {
<span class="fc" id="L1201">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.spreadRadius((float) radius)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow color applied to the default shadow.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowBlurRadius(double)} and {@link #shadowSpreadRadius(double)}. &lt;br&gt;
     *  The shadow will be rendered on the {@link UI.Layer#CONTENT} layer,
     *  if you want it to be rendered on a different layer, you
     *  may want to take a look at {@link #shadow(UI.Layer, String, Configurator)}. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}
     *  (and which are also rendered on the {@link UI.Layer#CONTENT} layer).
     *
     * @param color The shadow color.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow color.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowColor( Color color ) {
<span class="fc" id="L1220">        return _withStyle(_styleConf._withShadow(ShadowConf.DEFAULT_LAYER, shadow -&gt; shadow.color(color)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow color in the form of a string.
     *  The string can be either a hex color string, a color name or a color constant from the system properties.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowBlurRadius(double)} and {@link #shadowSpreadRadius(double)}. &lt;br&gt;
     *  The shadow will be rendered on the {@link UI.Layer#CONTENT} layer,
     *  if you want it to be rendered on a different layer, you
     *  may want to take a look at {@link #shadow(UI.Layer, String, Configurator)}. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}
     *  (and which are also rendered on the {@link UI.Layer#CONTENT} layer).
     *
     * @param colorString The shadow color.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow color.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowColor( String colorString ) {
<span class="fc" id="L1240">        Objects.requireNonNull(colorString);</span>
        Color newColor;
        try {
<span class="fc" id="L1243">            newColor = UI.color(colorString);</span>
<span class="nc" id="L1244">        } catch ( Exception e ) {</span>
<span class="nc" id="L1245">            log.error(&quot;Failed to parse color string: '&quot;+colorString+&quot;'&quot;, e);</span>
<span class="nc" id="L1246">            return this;</span>
<span class="fc" id="L1247">        }</span>
<span class="fc" id="L1248">        return _withStyle(_styleConf._withShadow(ShadowConf.DEFAULT_LAYER, shadow -&gt; shadow.color(newColor)));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow color
     *  defined by the supplied red, green and blue color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowBlurRadius(double)} and {@link #shadowSpreadRadius(double)}. &lt;br&gt;
     *  The shadow will be rendered on the {@link UI.Layer#CONTENT} layer,
     *  if you want it to be rendered on a different layer, you
     *  may want to take a look at {@link #shadow(UI.Layer, String, Configurator)}. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}
     *  (and which are also rendered on the {@link UI.Layer#CONTENT} layer).
     *
     * @param r The red component of the shadow color in the range of 0.0 to 1.0.
     * @param g The green component of the shadow color in the range of 0.0 to 1.0.
     * @param b The blue component of the shadow color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow color.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowColor( double r, double g, double b ) {
<span class="nc" id="L1271">        return shadowColor(new Color((float) r, (float) g, (float) b));</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided shadow color
     *  defined by the supplied red, green, blue and alpha color channels in
     *  the form of doubles expected to be in the range of 0.0 to 1.0.
     *  Note that in order to see the shadow, you may also need to call
     *  {@link #shadowBlurRadius(double)} and {@link #shadowSpreadRadius(double)}. &lt;br&gt;
     *  The shadow will be rendered on the {@link UI.Layer#CONTENT} layer,
     *  if you want it to be rendered on a different layer, you
     *  may want to take a look at {@link #shadow(UI.Layer, String, Configurator)}. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that this property will not only be applied to the default shadow, but also any
     *  other named shadow that you may have defined using {@link #shadow(String, Configurator)}
     *  (and which are also rendered on the {@link UI.Layer#CONTENT} layer).
     *
     * @param r The red component of the shadow color in the range of 0.0 to 1.0.
     * @param g The green component of the shadow color in the range of 0.0 to 1.0.
     * @param b The blue component of the shadow color in the range of 0.0 to 1.0.
     * @param a The alpha component of the shadow color in the range of 0.0 to 1.0.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow color.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowColor( double r, double g, double b, double a ) {
<span class="nc" id="L1295">        return shadowColor(new Color((float) r, (float) g, (float) b, (float) a));</span>
    }

    /**
     *  Use this to control whether your shadows should be rendered inwards or outwards. &lt;br&gt;
     *  Note that this property will be applied to all shadow effects of all layers, including
     *  the default shadow and named shadows defined using {@link #shadow(String, Configurator)}. &lt;br&gt;
     *  The default value is {@code false}.
     *
     * @param inwards Whether the shadow should be rendered inwards or outwards.
     * @return A new {@link ComponentStyleDelegate} with the provided shadow inset flag.
     */
    public ComponentStyleDelegate&lt;C&gt; shadowIsInset( boolean inwards ) {
<span class="fc" id="L1308">        return _withStyle(_styleConf._withShadow(shadow -&gt; shadow.isInset(inwards)));</span>
    }

    /**
     *  This method makes it possible to define multiple shadows for a single component
     *  on the {@link UI.Layer#CONTENT} layer, by giving the shadow config a unique name.
     *  This is useful when you want to do advanced shadow effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .withStyle( it -&gt; it
     *          .shadow(&quot;dark shading&quot;, shadow -&gt; shadow
     *              .color(&quot;#000000&quot;)
     *              .horizontalOffset(5)
     *              .verticalOffset(5)
     *              .blurRadius(10)
     *              .spreadRadius(0)
     *          )
     *          .shadow(&quot;light shading&quot;, shadow -&gt; shadow
     *              .color(&quot;#ffffff&quot;)
     *              .horizontalOffset(-5)
     *              .verticalOffset(-5)
     *              .blurRadius(10)
     *              .spreadRadius(0)
     *          )
     *  }&lt;/pre&gt;
     *  Note that the shadows will be rendered in
     *  alphabetical order based on their name (within a particular layer).
     *
     * @param shadowName The name of the shadow.
     * @param styler A function that takes a {@link ShadowConf} and returns a new {@link ShadowConf}.
     * @return A new {@link ComponentStyleDelegate} with a named shadow defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; shadow( String shadowName, Configurator&lt;ShadowConf&gt; styler ) {
<span class="fc" id="L1342">        return shadow(ShadowConf.DEFAULT_LAYER, shadowName, styler);</span>
    }

    /**
     *  This method makes it possible to define multiple shadows for a single component
     *  on a custom layer, by giving the shadow config a unique name.
     *  This is useful when you want to do advanced shadow effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *      UI.panel()
     *      .withStyle( it -&gt; it
     *          .shadow(UI.Layer.CONTENT, &quot;dark shading&quot;, shadow -&gt; shadow
     *              .color(&quot;#000000&quot;)
     *              .horizontalOffset(5)
     *              .verticalOffset(5)
     *              .blurRadius(10)
     *              .spreadRadius(0)
     *          )
     *          .shadow(UI.Layer.CONTENT, &quot;light shading&quot;, shadow -&gt; shadow
     *              .color(&quot;#ffffff&quot;)
     *              .horizontalOffset(-5)
     *              .verticalOffset(-5)
     *              .blurRadius(10)
     *              .spreadRadius(0)
     *          )
     *  }&lt;/pre&gt;
     *  Note that the shadows will be rendered in
     *  alphabetical order based on their name (within a particular layer).
     *
     * @param layer The layer of the shadow is an enum instance which
     *              gives the shadow effect a rank in the painting order.
     *              So the {@link swingtree.UI.Layer#BACKGROUND} will be painted first,
     *              followed by the {@link swingtree.UI.Layer#CONTENT} and so on...
     *              &lt;br&gt;
     *              The following layers are available:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param shadowName The name of the shadow.
     * @param styler A function that takes a {@link ShadowConf} and returns a new {@link ShadowConf}.
     * @return A new {@link ComponentStyleDelegate} with a named shadow defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; shadow(
        UI.Layer layer,
        String shadowName,
        Configurator&lt;ShadowConf&gt; styler
    ) {
<span class="fc" id="L1392">        Objects.requireNonNull(shadowName);</span>
<span class="fc" id="L1393">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1394">        ShadowConf shadow = Optional.ofNullable(_styleConf.shadow(layer, shadowName)).orElse(ShadowConf.none());</span>
        // We clone the shadow map:
<span class="fc" id="L1396">        NamedConfigs&lt;ShadowConf&gt; newShadows = _styleConf.shadowsMap(layer).withNamedStyle(shadowName, styler.configure(shadow));</span>
<span class="fc" id="L1397">        return _withStyle(_styleConf._withShadow(layer, newShadows));</span>
    }

    /**
     *  This method makes it possible to define multiple background gradient for a single component
     *  on the {@link UI.Layer#BACKGROUND} layer, by giving the gradient config a unique name.
     *  This is useful when you want to do advanced background effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *      .gradient(&quot;dark shading&quot;, conf -&gt; conf
     *        .colors(&quot;#000000&quot;, &quot;#000000&quot;)
     *        .transition(UI.Transition.TOP_TO_BOTTOM)
     *      )
     *      .gradient(&quot;light shading&quot;, conf -&gt; conf
     *        .colors(&quot;#ffffff&quot;, &quot;#ffffff&quot;)
     *        .transition(UI.Transition.TOP_TO_BOTTOM))
     *      )
     *    )
     * }&lt;/pre&gt;
     * Note that the background shades will be rendered in alphabetical order based on the name of the shade.&lt;br&gt;
     * This method translates to {@link #gradient(UI.Layer, String, Configurator)} but with the
     * layer set to {@link UI.Layer#BACKGROUND}.
     *
     * @param shadeName The name of the background shade.
     * @param styler A function that takes a {@link GradientConf} and returns a new {@link GradientConf}.
     * @return A new {@link ComponentStyleDelegate} with a named background shade defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; gradient( String shadeName, Configurator&lt;GradientConf&gt; styler ) {
<span class="fc" id="L1427">        return gradient(GradientConf.DEFAULT_LAYER, shadeName, styler);</span>
    }

    /**
     *  This method makes it possible to define multiple background gradient for a single component
     *  on a particular layer, by giving the gradient config a unique name.
     *  This is useful when you want to do advanced background effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *      .gradient(UI.Layer.BACKGROUND, &quot;dark shading&quot;, conf -&gt; conf
     *        .colors(&quot;#000000&quot;, &quot;#000000&quot;)
     *        .transition(UI.Transition.TOP_TO_BOTTOM)
     *      )
     *      .gradient(UI.Layer.BACKGROUND, &quot;light shading&quot;, conf -&gt; conf
     *        .colors(&quot;#ffffff&quot;, &quot;#ffffff&quot;)
     *        .transition(UI.Transition.TOP_TO_BOTTOM))
     *      )
     *    )
     * }&lt;/pre&gt;
     * Note that within a particular layer the gradients will be rendered in alphabetical order
     * based on the provided name.
     *
     * @param layer The layer on which the gradient should be rendered.
     * @param shadeName The name of the background shade.
     * @param styler A function that takes a {@link GradientConf} and returns a new {@link GradientConf}.
     * @return A new {@link ComponentStyleDelegate} with a named background shade defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; gradient(
        UI.Layer layer,
        String shadeName,
        Configurator&lt;GradientConf&gt; styler
    ) {
<span class="fc" id="L1461">        Objects.requireNonNull(shadeName);</span>
<span class="fc" id="L1462">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1463">        return _withStyle(_styleConf.gradient(layer, shadeName, styler));</span>
    }

    /**
     *  This method makes it possible to define a background shade for your components.
     *  This is useful when you want to do advanced background effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .gradient( conf -&gt; conf
     *            .colors(&quot;#000000&quot;, &quot;#000000&quot;)
     *            .transition(UI.Transition.TOP_TO_BOTTOM)
     *        )
     *    )
     * }&lt;/pre&gt;
     * This method translates to {@link #gradient(UI.Layer, String, Configurator)} but with the
     * layer set to {@link UI.Layer#BACKGROUND} and the name being the &quot;default&quot; style name
     *
     * @param styler A function that takes a {@link GradientConf} and returns a new {@link GradientConf}.
     * @return A new {@link ComponentStyleDelegate} with a background shade defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; gradient( Configurator&lt;GradientConf&gt; styler ) {
<span class="fc" id="L1486">        return gradient(GradientConf.DEFAULT_LAYER, StyleUtil.DEFAULT_KEY, styler);</span>
    }

    /**
     *  This method makes it possible to define a gradient effect on a particular layer for your components.
     *  This is useful when you want to do advanced background effects, such as neumorphism a.k.a. soft UI. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .gradient(UI.Layer.BACKGROUND, conf -&gt; conf
     *            .colors(&quot;#000000&quot;, &quot;#000000&quot;)
     *            .transition(UI.Transition.TOP_TO_BOTTOM)
     *        )
     *    )
     * }&lt;/pre&gt;
     * Note that this method translates to {@link #gradient(UI.Layer, String, Configurator)} but with the
     * name being the &quot;default&quot; style name.
     *
     * @param layer The layer on which the gradient should be rendered.
     * @param styler A function that takes a {@link GradientConf} and returns a new {@link GradientConf}.
     * @return A new {@link ComponentStyleDelegate} with a background shade defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; gradient( UI.Layer layer, Configurator&lt;GradientConf&gt; styler ) {
<span class="fc" id="L1510">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1511">        return _withStyle(_styleConf.gradient(layer, StyleUtil.DEFAULT_KEY, styler));</span>
    }

    /**
     *  This method makes it possible to define a background noise for your components.
     *  This is useful when you want to give component surfaces some naturally looking texture
     *  or special effects. &lt;br&gt;
     *  &lt;br&gt;
     *  Here is an example of how to use it:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .noise(&quot;my-noise&quot; conf -&gt; conf
     *            .scale(2, 3).rotation(45)
     *            .colors(Color.BLACK, Color.WHITE)
     *            .offset(64,85)
     *        )
     *    )
     * }&lt;/pre&gt;
     * Note that this method translates to {@link #noise(UI.Layer, String, Configurator)} but with the
     * layer set to {@link UI.Layer#BACKGROUND}.
     *
     * @param noiseName The name of the noise which is used to create, identify and possibly override a noise with the same name.
     * @param styler A function that takes a {@link NoiseConf} and returns a new {@link NoiseConf}.
     * @return A new {@link ComponentStyleDelegate} with a background noise defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; noise( String noiseName, Configurator&lt;NoiseConf&gt; styler ) {
<span class="nc" id="L1538">        Objects.requireNonNull(noiseName);</span>
<span class="nc" id="L1539">        Objects.requireNonNull(styler);</span>
<span class="nc" id="L1540">        return noise(NoiseConf.DEFAULT_LAYER, noiseName, styler);</span>
    }

    /**
     *  This method makes it possible to define a background noise for your components.
     *  This is useful when you want to give component surfaces some naturally looking texture
     *  or special effects. &lt;br&gt;
     *  &lt;br&gt;
     *  Here is an example of how to use the method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .noise(UI.Layer.BACKGROUND, &quot;my-noise&quot; conf -&gt; conf
     *            .scale(2, 3).rotation(45)
     *            .colors(Color.BLACK, Color.WHITE)
     *            .offset(64,85)
     *        )
     *    )
     * }&lt;/pre&gt;
     *
     * @param layer The layer on which the noise should be rendered.
     * @param styler A function that takes a {@link NoiseConf} and returns a new {@link NoiseConf}.
     * @return A new {@link ComponentStyleDelegate} with a background noise defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; noise( UI.Layer layer, String noiseName, Configurator&lt;NoiseConf&gt; styler ) {
<span class="fc" id="L1565">        Objects.requireNonNull(noiseName);</span>
<span class="fc" id="L1566">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1567">        return _withStyle(_styleConf.noise(layer, noiseName, styler));</span>
    }

    /**
     *  This method makes it possible to define a background noise for your components.
     *  This is useful when you want to give component surfaces some naturally looking texture
     *  or special effects. &lt;br&gt;
     *  &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .noise( conf -&gt; conf
     *            .scale(2, 3).rotation(45)
     *            .colors(Color.BLACK, Color.WHITE)
     *            .offset(64,85)
     *        )
     *    )
     * }&lt;/pre&gt;
     * Note that this method translates to {@link #noise(UI.Layer, String, Configurator)} but with the
     * layer set to {@link UI.Layer#BACKGROUND} and the name being the &quot;default&quot; style name.
     *
     * @param styler A function that takes a {@link NoiseConf} and returns a new {@link NoiseConf}.
     * @return A new {@link ComponentStyleDelegate} with a background noise defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; noise( Configurator&lt;NoiseConf&gt; styler ) {
<span class="fc" id="L1593">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1594">        return noise(NoiseConf.DEFAULT_LAYER, StyleUtil.DEFAULT_KEY, styler);</span>
    }

    /**
     *  This method makes it possible to define multiple background styles for a single component
     *  rendered on the {@link UI.Layer#BACKGROUND} layer, by giving the background config a unique name.
     *  This is useful when you want to do advanced backgrounds
     *  displaying multiple images on top of each other. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *      .image(&quot;ground 1&quot;, image -&gt; image
     *        .image(loadImageFrom(&quot;my/path/to/image1.png&quot;))
     *      )
     *      .ground(&quot;ground 2&quot;, ground -&gt; ground
     *        .color(&quot;blue&quot;)
     *      )
     *    )
     * }&lt;/pre&gt;
     * Note that the background images will be rendered in alphabetical order based on the name of the image.
     *
     * @param imageName The name of the background image.
     * @param styler A function that takes a {@link ImageConf} and returns a new {@link ImageConf}.
     * @return A new {@link ComponentStyleDelegate} with a named background image defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; image( String imageName, Configurator&lt;ImageConf&gt; styler ) {
<span class="fc" id="L1621">        Objects.requireNonNull(imageName);</span>
<span class="fc" id="L1622">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1623">        return image(ImageConf.DEFAULT_LAYER, imageName, styler);</span>
    }

    /**
     *  This method makes it possible to define multiple background styles for a single component
     *  rendered on a particular layer, by giving the background config a unique name.
     *  This is useful when you want to do advanced layer backgrounds
     *  displaying multiple images on top of each other. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *      .image(UI.Layer.BACKGROUND, &quot;ground 1&quot;, image -&gt; image
     *        .image(loadImageFrom(&quot;my/path/to/image1.png&quot;))
     *      )
     *      .ground(UI.Layer.BACKGROUND, &quot;ground 2&quot;, ground -&gt; ground
     *        .color(&quot;blue&quot;)
     *      )
     *    )
     * }&lt;/pre&gt;
     * Note that the background images will be rendered in alphabetical order based on the name of the image.
     *
     * @param layer The layer defines at which step in the rendering process the image should be rendered.
     *              The default layer is the background layer, which will be rendered first.
     *              Here a list of available layers:
     *              &lt;ul&gt;
     *                  &lt;li&gt;{@link swingtree.UI.Layer#BACKGROUND}&lt;/li&gt;
     *                  &lt;li&gt;{@link swingtree.UI.Layer#CONTENT}&lt;/li&gt;
     *                  &lt;li&gt;{@link swingtree.UI.Layer#BORDER}&lt;/li&gt;
     *                  &lt;li&gt;{@link swingtree.UI.Layer#FOREGROUND}&lt;/li&gt;
     *              &lt;/ul&gt;
     * @param imageName The name of the background image.
     * @param styler A function that takes a {@link ImageConf} and returns a new {@link ImageConf}.
     * @return A new {@link ComponentStyleDelegate} with a named background image defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; image( UI.Layer layer, String imageName, Configurator&lt;ImageConf&gt; styler ) {
<span class="fc" id="L1659">        Objects.requireNonNull(imageName);</span>
<span class="fc" id="L1660">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1661">        return _withStyle(_styleConf.images(layer, imageName, styler));</span>
    }

    /**
     *  Allows for the rendering of a background image on your components.
     *  This is useful when you want to do advanced backgrounds
     *  displaying multiple images on top of each other. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .image( image -&gt; image
     *            .image(loadImageFrom(&quot;my/path/to/image1.png&quot;))
     *            .color(&quot;green&quot;)
     *        )
     *    )
     * }&lt;/pre&gt;
     * Note that this method translates to {@link #image(UI.Layer, String, Configurator)} but with the
     * layer set to {@link UI.Layer#BACKGROUND} and the name being the &quot;default&quot; style name.
     *
     * @param styler A function that takes a {@link ImageConf} and returns a new {@link ImageConf}.
     * @return A new {@link ComponentStyleDelegate} with a background image defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; image( Configurator&lt;ImageConf&gt; styler ) {
<span class="fc" id="L1685">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1686">        return image(ImageConf.DEFAULT_LAYER, StyleUtil.DEFAULT_KEY, styler);</span>
    }

    /**
     *  Allows for the rendering of an image on a particular component layer.
     *  This is useful when you want to do advanced layer backgrounds
     *  displaying multiple images on top of each other. &lt;br&gt;
     *  Here is an example of how to use this method:
     *  &lt;pre&gt;{@code
     *    UI.panel()
     *    .withStyle( it -&gt; it
     *        .image(UI.Layer.CONTENT, image -&gt; image
     *            .image(loadImageFrom(&quot;my/path/to/image1.png&quot;))
     *            .color(&quot;green&quot;)
     *        )
     *    )
     * }&lt;/pre&gt;
     * Note that this method translates to {@link #image(UI.Layer, String, Configurator)} but with the
     * name being the &quot;default&quot; style name.
     *
     * @param layer The layer on which the image should be rendered.
     * @param styler A function that takes a {@link ImageConf} and returns a new {@link ImageConf}.
     * @return A new {@link ComponentStyleDelegate} with a background image defined by the provided styler lambda.
     */
    public ComponentStyleDelegate&lt;C&gt; image( UI.Layer layer, Configurator&lt;ImageConf&gt; styler ) {
<span class="fc" id="L1711">        Objects.requireNonNull(layer);</span>
<span class="fc" id="L1712">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1713">        return _withStyle(_styleConf.images(layer, StyleUtil.DEFAULT_KEY, styler));</span>
    }

    /**
     *  Returns an updated {@link StyleConf} with a named text style
     *  configurator for the default {@link TextConf} of the component. &lt;br&gt;
     *  The sub-style exposed by this method adds &lt;b&gt;support for text rendering to
     *  all components not just text components&lt;/b&gt;. &lt;br&gt;
     *  If you only want to style the {@link JComponent#getFont()} property of the component,
     *  you can use {@link #componentFont(Configurator)} instead. &lt;br&gt;
     *  &lt;br&gt;
     *  The first parameter is the name of the text style, which allows
     *  you to define any number of text styles for a single component
     *  by using different names. &lt;br&gt;
     *  Two sub-styles with the same name will override each other. &lt;br&gt;
     *
     * @param styler A configurator function that takes a {@link TextConf} and returns an updated {@link TextConf}.
     *               The configurator function is called with the default text style of the component.
     * @return A new {@link ComponentStyleDelegate} with the provided text style.
     *         Each unique name creates an additional text style for the component.
     * @see #text(UI.Layer, String, Configurator)
     * @see #text(Configurator)
     * @throws NullPointerException If the provided styler or textName is {@code null}.
     */
    public ComponentStyleDelegate&lt;C&gt; text( String textName, Configurator&lt;TextConf&gt; styler ) {
<span class="nc" id="L1738">        Objects.requireNonNull(textName);</span>
<span class="nc" id="L1739">        Objects.requireNonNull(styler);</span>
<span class="nc" id="L1740">        return text(TextConf.DEFAULT_LAYER, textName, styler);</span>
    }

    /**
     *  Returns an updated {@link StyleConf} with the provided named text style
     *  configurator for the default {@link TextConf} of the component. &lt;br&gt;
     *  The sub-style exposed by this method adds &lt;b&gt;support for text rendering to
     *  all components not just text components&lt;/b&gt;. &lt;br&gt;
     *  If you only want to style the {@link JComponent#getFont()} property of the component,
     *  you can use {@link #componentFont(Configurator)} instead. &lt;br&gt;
     *  &lt;br&gt;
     *  The first parameter is the name of the text style, which allows
     *  you to define any number of text styles for a single component
     *  by using different names. &lt;br&gt;
     *  Two sub-styles with the same name will override each other. &lt;br&gt;
     *
     * @param layer The layer on which the text should be rendered.
     * @param textName The name of the text style that you want to define.
     *                 Each unique name creates an additional text style for the component.
     * @param styler A configurator function that takes a {@link TextConf} and returns an updated {@link TextConf}.
     *               The configurator function is called with the default text style of the component.
     * @return A new {@link ComponentStyleDelegate} with the provided text style.
     * @see #text(String, Configurator)
     * @see #text(Configurator)
     * @throws NullPointerException If the provided styler or textName is {@code null}.
     */
    public ComponentStyleDelegate&lt;C&gt; text( UI.Layer layer, String textName, Configurator&lt;TextConf&gt; styler ) {
<span class="fc" id="L1767">        Objects.requireNonNull(textName);</span>
<span class="fc" id="L1768">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1769">        return _withStyle(_styleConf.text(layer, textName, styler));</span>
    }

    /**
     *  Returns an updated {@link StyleConf} with the provided text style
     *  configurator for the default {@link TextConf} of the component. &lt;br&gt;
     *  The sub-style exposed by this method adds &lt;b&gt;support for text rendering to
     *  all components not just text components&lt;/b&gt;. &lt;br&gt;
     *  If you only want to style the {@link JComponent#getFont()} property of the component,
     *  you can use {@link #componentFont(Configurator)} instead. &lt;br&gt;
     *
     * @param styler A configurator function that takes a {@link TextConf} and returns an updated {@link TextConf}.
     *               The configurator function is called with the default text style of the component.
     * @return A new {@link ComponentStyleDelegate} with the provided text style.
     * @see #text(UI.Layer, String, Configurator)
     * @see #text(String, Configurator)
     * @throws NullPointerException If the provided styler is {@code null}.
     */
    public ComponentStyleDelegate&lt;C&gt; text( Configurator&lt;TextConf&gt; styler ) {
<span class="fc" id="L1788">        Objects.requireNonNull(styler);</span>
<span class="fc" id="L1789">        return text(TextConf.DEFAULT_LAYER, StyleUtil.DEFAULT_KEY, styler);</span>
    }

    /**
     *  Allow for the specification of client properties on the styled component.
     *  This is useful when you want to store arbitrary configuration data on the component,
     *  which is usually read and used by look and feel implementations to
     *  apply custom appearance and behavior to the component. &lt;br&gt;
     *  &lt;br&gt;
     *  If you want a particular property to be removed, you can pass and empty String {@code &quot;&quot;} as the value. &lt;br&gt;
     *  &lt;b&gt;A {@code null} reference is not allowed as a value and will throw a {@link NullPointerException}.&lt;/b&gt;
     *
     * @param key The key of the property.
     * @param value The value of the property.
     * @return A new {@link ComponentStyleDelegate} with the provided client property.
     * @see JComponent#putClientProperty(Object, Object)
     * @see JComponent#getClientProperty(Object)
     * @throws NullPointerException If the value is {@code null}! (Use {@code &quot;&quot;} to remove a property)
     */
    public ComponentStyleDelegate&lt;C&gt; property( String key, String value ) {
<span class="fc" id="L1809">        Objects.requireNonNull(key);</span>
<span class="fc" id="L1810">        Objects.requireNonNull(value);</span>
<span class="fc" id="L1811">        return _withStyle(_styleConf.property(key, value));</span>
    }

    public ComponentStyleDelegate&lt;C&gt; parentFilter( Configurator&lt;FilterConf&gt; filterStyler ) {
<span class="fc" id="L1815">        Objects.requireNonNull(filterStyler);</span>
<span class="fc" id="L1816">        return _withStyle(_styleConf._withLayers(_styleConf.layers().filter(filterStyler)));</span>
    }

    private ComponentStyleDelegate&lt;C&gt; _withFont( Configurator&lt;FontConf&gt; fontStyler ) {
<span class="fc" id="L1820">        Objects.requireNonNull(fontStyler);</span>
<span class="fc" id="L1821">        StyleConf updatedStyle = _styleConf._withFont(fontStyler.configure(_styleConf.font()));</span>
        // We also update the text style, if it exists:
<span class="fc" id="L1823">        updatedStyle = updatedStyle.text( text -&gt; text.font(fontStyler) );</span>
<span class="fc" id="L1824">        return _withStyle(updatedStyle);</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided font style applied to the
     *  font property of the component (see {@link JComponent#getFont()}). &lt;br&gt;
     *  If you want to style the text of the entire component, which includes both
     *  the component font property as well as the style engine based font render
     *  (see {@link #text(String, Configurator)}), you can simply
     *  call the regular font styling methods such as {@link #font(String, int)},
     *  {@link #font(Font)}, {@link #fontFamily(String)}, {@link #fontSize(int)},
     *  {@link #fontBold(boolean)}, {@link #fontItalic(boolean)}, {@link #fontUnderline(boolean)}...
     *
     * @param fontStyler A function that takes a {@link FontConf} and returns a new {@link FontConf}
     *                   that is exclusively applied to the font property of the component.
     * @return A new {@link ComponentStyleDelegate} with the provided font style
     *          applied to the font property of the component.
     */
    public final ComponentStyleDelegate&lt;C&gt; componentFont( Configurator&lt;FontConf&gt; fontStyler ) {
<span class="fc" id="L1843">        Objects.requireNonNull(fontStyler);</span>
<span class="fc" id="L1844">        StyleConf updatedStyle = _styleConf._withFont(fontStyler.configure(_styleConf.font()));</span>
<span class="fc" id="L1845">        return _withStyle(updatedStyle);</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided font name and size.&lt;br&gt;
     *  Note that the font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param name The font name.
     * @param size The font size.
     * @return A new {@link ComponentStyleDelegate} with the provided font name and size.
     */
    public ComponentStyleDelegate&lt;C&gt; font( String name, int size ) {
<span class="fc" id="L1863">        Objects.requireNonNull(name);</span>
<span class="fc" id="L1864">        return _withFont( f -&gt; f.family(name).size(size) );</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided font family name.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param name The font name.
     * @return A new {@link ComponentStyleDelegate} with the provided font name.
     */
    public ComponentStyleDelegate&lt;C&gt; fontFamily( String name ) {
<span class="fc" id="L1881">        Objects.requireNonNull(name);</span>
<span class="fc" id="L1882">        return _withFont( f -&gt; f.family(name) );</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided {@link Font}.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param font The {@link Font}.
     * @return A new {@link ComponentStyleDelegate} with the provided {@link Font}.
     * @throws NullPointerException If the font is {@code null}.
     *         Use {@link UI.Font#UNDEFINED} to remove the font style.
     */
    public ComponentStyleDelegate&lt;C&gt; font( Font font ) {
<span class="fc" id="L1901">        Objects.requireNonNull(font, &quot;The font cannot be null! Use UI.FONT_UNDEFINED to remove the font style.&quot;);</span>
<span class="fc" id="L1902">        return _withFont( f -&gt; f.withPropertiesFromFont(font) );</span>
    }

    /**
     *  Returns a new {@link StyleConf} with the provided font size.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param size The font size.
     * @return A new {@link ComponentStyleDelegate} with the provided font size.
     */
    public ComponentStyleDelegate&lt;C&gt; fontSize( int size ) {
<span class="fc" id="L1919">        return _withFont( f -&gt; f.size(size) );</span>
    }

    /**
     *  Makes the font bold or not bold depending on the value of the {@code isBold} parameter.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param bold Whether the font should be bold or not.
     * @return A new {@link ComponentStyleDelegate} with the provided font boldness.
     */
    public ComponentStyleDelegate&lt;C&gt; fontBold( boolean bold ) {
<span class="fc bfc" id="L1936" title="All 2 branches covered.">        return _withFont( f -&gt; f.weight( bold ? 2 : 1 ) );</span>
    }

    /**
     *  Makes the font italic or not italic depending on the value of the {@code italic} parameter.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param italic Whether the font should be italic or not.
     * @return A new {@link ComponentStyleDelegate} with the provided font italicness.
     */
    public ComponentStyleDelegate&lt;C&gt; fontItalic( boolean italic ) {
<span class="fc bfc" id="L1953" title="All 2 branches covered.">        return _withFont( f -&gt; f.posture( italic ? 0.2f : 0f ) );</span>
    }

    /**
     *  Determines if the font should be plain, bold, italic or bold and italic
     *  based on the provided {@link UI.FontStyle} parameter,
     *  which may be {@link UI.FontStyle#PLAIN}, {@link UI.FontStyle#BOLD},
     *  {@link UI.FontStyle#ITALIC} or {@link UI.FontStyle#BOLD_ITALIC}.&lt;br&gt;
     *  &lt;b&gt;
     *      Note that this will override any previous bold or italic settings.
     *  &lt;/b&gt;
     * @param style The font style in form of a {@link UI.FontStyle}.
     * @return An updated {@link ComponentStyleDelegate} with the provided font style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontStyle( UI.FontStyle style ) {
<span class="nc" id="L1968">        return _withFont( f -&gt; f.style(style) );</span>
    }

    /**
     *  Makes the font underlined or not underlined depending on the value of the {@code underline} parameter.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param underline Whether the font should be underlined or not.
     * @return A new {@link ComponentStyleDelegate} with the provided font underlinedness.
     */
    public ComponentStyleDelegate&lt;C&gt; fontUnderline( boolean underline ) {
<span class="fc" id="L1985">        return _withFont( f -&gt; f.underlined(underline) );</span>
    }

    /**
     *  Makes the font struck through or not struck through depending on the value of the {@code strikeThrough} parameter.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param strikeThrough Whether the font should be struck through or not.
     * @return A new {@link ComponentStyleDelegate} with the provided font struck throughness.
     */
    public ComponentStyleDelegate&lt;C&gt; fontStrikeThrough( boolean strikeThrough ) {
<span class="fc" id="L2002">        return _withFont( f -&gt; f.strikeThrough(strikeThrough) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font color is set to the provided {@link Color}.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param color The {@link Color}.
     * @return A new {@link ComponentStyleDelegate} with the provided font color.
     * @throws NullPointerException If the color is {@code null}.
     *         Use {@link UI.Color#UNDEFINED} to remove the font color style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontColor( Color color ) {
<span class="fc" id="L2021">        Objects.requireNonNull(color, &quot;The color cannot be null! Use UI.Color.UNDEFINED to remove the font color style.&quot;);</span>
<span class="fc" id="L2022">        return _withFont( f -&gt; f.color(color) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font color is set to a color parsed from the provided string.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param colorString The {@link Color} as a string.
     * @return A new {@link ComponentStyleDelegate} with the provided font color.
     */
    public ComponentStyleDelegate&lt;C&gt; fontColor( String colorString ) {
<span class="fc" id="L2039">        Objects.requireNonNull(colorString, &quot;The color string cannot be null! Use an empty string to remove the font color style.&quot;);</span>
<span class="fc" id="L2040">        return _withFont( f -&gt; f.color(colorString) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font background color is set to the provided {@link Color}.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param color The {@link Color}.
     * @return A new {@link ComponentStyleDelegate} with the provided font background color.
     * @throws NullPointerException If the color is {@code null}.
     *          Use {@link UI.Color#UNDEFINED} to remove the font background color style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontBackgroundColor( Color color ) {
<span class="fc" id="L2059">        Objects.requireNonNull(color);</span>
<span class="fc" id="L2060">        return _withFont( f -&gt; f.backgroundColor(color) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font color is set to a color parsed from the provided string.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param colorString The {@link Color} as a string.
     * @return A new {@link ComponentStyleDelegate} with the provided font color.
     */
    public ComponentStyleDelegate&lt;C&gt; fontBackgroundColor( String colorString ) {
<span class="fc" id="L2077">        Objects.requireNonNull(colorString);</span>
<span class="fc" id="L2078">        return _withFont( f -&gt; f.backgroundColor(colorString) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font selection color is set to the provided {@link Color}.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param color The {@link Color}.
     * @return A new {@link ComponentStyleDelegate} with the provided font selection color.
     * @throws NullPointerException If the color is {@code null}.
     *         Use {@link UI.Color#UNDEFINED} to remove the font selection color style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontSelectionColor( Color color ) {
<span class="fc" id="L2097">        Objects.requireNonNull(color);</span>
<span class="fc" id="L2098">        return _withFont( f -&gt; f.selectionColor(color) );</span>
    }

    /**
     *  Creates a new {@link StyleConf} where the font selection color is set to a color parsed from the provided string.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     *
     * @param colorString The {@link Color} as a string.
     * @return A new {@link ComponentStyleDelegate} with the provided font selection color.
     */
    public ComponentStyleDelegate&lt;C&gt; fontSelectionColor( String colorString ) {
<span class="fc" id="L2115">        return _withFont( f -&gt; f.selectionColor(colorString) );</span>
    }

    /**
     *  The {@link AffineTransform} property of a font defines how the font is
     *  rotated, scaled, skewed or translated. This method allows you to apply
     *  a custom {@link AffineTransform} to the fonts of the component.
     *
     * @param transform The {@link AffineTransform} to apply to the font.
     * @return A new {@link ComponentStyleDelegate} with the provided font transform.
     */
    public ComponentStyleDelegate&lt;C&gt; fontTransform( @Nullable AffineTransform transform ) {
<span class="fc" id="L2127">        return _withStyle(_styleConf._withFont(_styleConf.font().transform(transform)));</span>
    }

    /**
     *  Creates an updated style config with the provided font paint
     *  applied to all font configurations of the component.
     *
     * @param paint The {@link Paint} to use for the foreground of the font, which translates to the
     *              {@link java.awt.font.TextAttribute#FOREGROUND} attribute.
     * @return A new {@link ComponentStyleDelegate} with the provided font paint.
     */
    public ComponentStyleDelegate&lt;C&gt; fontPaint( @Nullable Paint paint ) {
<span class="fc" id="L2139">        return _withFont( f-&gt; f.paint(paint) );</span>
    }

    /**
     *  Updates this style delegate with the supplied {@link Paint} object
     *  used for the background of the font, which translates to the
     *  {@link java.awt.font.TextAttribute#BACKGROUND} attribute.
     *  
     * @param paint The {@link Paint} to use for the background of the font, which translates to the
     *              {@link java.awt.font.TextAttribute#BACKGROUND} attribute.
     * @return A new {@link ComponentStyleDelegate} with the provided font background paint.
     */
    public ComponentStyleDelegate&lt;C&gt; fontBackgroundPaint( @Nullable Paint paint ) {
<span class="fc" id="L2152">        return _withFont( f -&gt; f.backgroundPaint(paint) );</span>
    }


    /**
     *  Use this to define the weight of the default font of the component.
     *  The default value is 1.0 (see {@link java.awt.font.TextAttribute#WEIGHT_REGULAR}),
     *  whereas a bold font typically has a font weight
     *  of 2.0 (see {@link java.awt.font.TextAttribute#WEIGHT_BOLD}).
     *  &lt;p&gt;
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}).&lt;br&gt;
     *  &lt;p&gt;
     *  Note that this font style will be applied to both the component font property
     *  and the style engine based text (see {@link #text(String, Configurator)}).
     *  If you only want to style the component font property, you can use
     *  {@link #componentFont(Configurator)}.
     * @param weight The weight of the font.
     * @return A new {@link ComponentStyleDelegate} with the provided font weight.
     */
    public ComponentStyleDelegate&lt;C&gt; fontWeight( float weight ) {
<span class="fc" id="L2173">        return _withFont( f -&gt; f.weight(weight) );</span>
    }

    /**
     *  The font spacing, which is also known as tracking, is the space between characters in a font.
     *  See {@link java.awt.font.TextAttribute#TRACKING} for more information.
     *
     * @param spacing The spacing of the default font of the component, which translates to the
     *                {@link java.awt.font.TextAttribute#TRACKING} attribute.
     * @return A new {@link ComponentStyleDelegate} with the provided font spacing.
     */
    public ComponentStyleDelegate&lt;C&gt; fontSpacing( float spacing ) {
<span class="fc" id="L2185">        return _withFont( f -&gt; f.spacing(spacing) );</span>
    }

    /**
     *  Use this to define the horizontal alignment of the default font of the component.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}). &lt;br&gt;
     *  Also note that not all text based components support text alignment.
     *  @param alignment The horizontal alignment of the font.
     *                   See {@link UI.HorizontalAlignment} for more information.
     *  @return A new {@link ComponentStyleDelegate} with the provided font alignment.
     * @throws NullPointerException If the alignment is {@code null}.
     *         Use {@link UI.HorizontalAlignment#UNDEFINED} to remove the font alignment style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontAlignment( UI.HorizontalAlignment alignment ) {
<span class="fc" id="L2200">        Objects.requireNonNull(alignment);</span>
<span class="fc" id="L2201">        return _withFont( f -&gt; f.horizontalAlignment(alignment) );</span>
    }

    /**
     *  Use this to define the vertical alignment of the default font of the component.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}). &lt;br&gt;
     *  Also note that not all text based components support text alignment.
     *  @param alignment The vertical alignment of the font.
     *                   See {@link UI.VerticalAlignment} for more information.
     *  @return A new {@link ComponentStyleDelegate} with the provided font alignment.
     *  throws NullPointerException If the alignment is {@code null}.
     *       Use {@link UI.VerticalAlignment#UNDEFINED} to remove the font alignment style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontAlignment( UI.VerticalAlignment alignment ) {
<span class="fc" id="L2216">        Objects.requireNonNull(alignment);</span>
<span class="fc" id="L2217">        return _withFont( f -&gt; f.verticalAlignment(alignment) );</span>
    }

    /**
     *  Use this to define the horizontal and vertical alignment of the default font of the component.
     *  Note that font styles will only apply if the component that is being rendered
     *  also supports displaying text, or has a custom text style (see {@link TextConf}). &lt;br&gt;
     *  Also note that not all text based components support text alignment.
     *  @param alignment The horizontal and vertical alignment of the font.
     *                   See {@link UI.Alignment} for more information.
     *  @return A new {@link ComponentStyleDelegate} with the provided font alignment.
     *  throws NullPointerException If the alignment is {@code null}.
     *          Use {@link UI.Alignment#UNDEFINED} to remove the font alignment style.
     */
    public ComponentStyleDelegate&lt;C&gt; fontAlignment( UI.Alignment alignment ) {
<span class="fc" id="L2232">        Objects.requireNonNull(alignment);</span>
<span class="fc" id="L2233">        return fontAlignment(alignment.getHorizontal()).fontAlignment(alignment.getVertical());</span>
    }

    /**
     *  Defines the minimum {@link Dimension} for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMinimumSize(Dimension)} on the underlying component,
     *  which will be called when all the other styles are applied and rendered. &lt;br&gt;
     * @param width The minimum width.
     * @param height The minimum height.
     * @return A new {@link ComponentStyleDelegate} with the provided minimum {@link Dimension} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; minSize( int width, int height ) {
<span class="fc" id="L2246">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMinWidth(width)._withMinHeight(height)));</span>
    }

    /**
     *  Defines the minimum size for this {@link JComponent} in the form of a {@link Size} object. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMinimumSize(Dimension)} on the underlying component,
     *  which will be called when all the other styles are applied and rendered. &lt;br&gt;
     * @param size The minimum {@link Size}.
     * @return A new {@link ComponentStyleDelegate} with the provided minimum {@link Size} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; minSize( Size size ) {
<span class="fc" id="L2258">        Objects.requireNonNull(size);</span>
<span class="fc" id="L2259">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMinSize(size)));</span>
    }

    /**
     *  Defines the minimum width for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMinimumSize(Dimension)} on the underlying component,
     *  which will be called when all the other styles are applied and rendered. &lt;br&gt;
     * @param minWidth The minimum width.
     * @return A new {@link ComponentStyleDelegate} with the provided minimum width set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; minWidth( int minWidth ) {
<span class="fc" id="L2271">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMinWidth(minWidth)));</span>
    }

    /**
     *  Defines the minimum height for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMinimumSize(Dimension)} on the underlying component,
     *  which will be called when all the other styles are applied and rendered. &lt;br&gt;
     * @param minHeight The minimum height.
     * @return A new {@link ComponentStyleDelegate} with the provided minimum height set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; minHeight( int minHeight ) {
<span class="fc" id="L2283">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMinHeight(minHeight)));</span>
    }

    /**
     *  Defines the maximum {@link Dimension} for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed {@link Dimension} will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param width The maximum width.
     * @param height The maximum height.
     * @return A new {@link ComponentStyleDelegate} with the provided maximum {@link Dimension} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; maxSize( int width, int height ) {
<span class="fc" id="L2297">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMaxWidth(width)._withMaxHeight(height)));</span>
    }

    /**
     *  Defines the maximum {@link Size} for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed {@link Size} will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param maxSize The maximum {@link Size}.
     * @return A new {@link ComponentStyleDelegate} with the provided maximum {@link Size} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; maxSize( Size maxSize ) {
<span class="fc" id="L2310">        Objects.requireNonNull(maxSize);</span>
<span class="fc" id="L2311">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMaxSize(maxSize)));</span>
    }

    /**
     *  Defines the maximum width for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed width will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param maxWidth The maximum width.
     * @return A new {@link ComponentStyleDelegate} with the provided maximum width set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; maxWidth( int maxWidth ) {
<span class="fc" id="L2324">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMaxWidth(maxWidth)));</span>
    }

    /**
     *  Defines the maximum height for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setMaximumSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed height will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param maxHeight The maximum height.
     * @return A new {@link ComponentStyleDelegate} with the provided maximum height set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; maxHeight( int maxHeight ) {
<span class="fc" id="L2337">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withMaxHeight(maxHeight)));</span>
    }

    /**
     *  Defines the preferred {@link Size} for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed {@link Size} will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param preferredSize The preferred {@link Size}.
     * @return A new {@link ComponentStyleDelegate} with the provided preferred {@link Size} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; prefSize( Size preferredSize ) {
<span class="fc" id="L2350">        Objects.requireNonNull(preferredSize);</span>
<span class="fc" id="L2351">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withPreferredSize(preferredSize)));</span>
    }

    /**
     *  Defines the preferred {@link Dimension} for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed {@link Dimension} will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param width The preferred width.
     * @param height The preferred height.
     * @return A new {@link ComponentStyleDelegate} with the provided preferred {@link Dimension} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; prefSize( int width, int height ) {
<span class="fc" id="L2365">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withPreferredWidth(width)._withPreferredHeight(height)));</span>
    }

    /**
     *  Defines the preferred width for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed width will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param preferredWidth The preferred width.
     * @return A new {@link ComponentStyleDelegate} with the provided preferred width set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; prefWidth( int preferredWidth ) {
<span class="fc" id="L2378">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withPreferredWidth(preferredWidth)));</span>
    }

    /**
     *  Defines the preferred height for this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setPreferredSize(Dimension)} on the underlying component. &lt;br&gt;
     *  The passed height will be applied when all the other styles are applied and rendered. &lt;br&gt;
     *
     * @param preferredHeight The preferred height.
     * @return A new {@link ComponentStyleDelegate} with the provided preferred height set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; prefHeight( int preferredHeight ) {
<span class="fc" id="L2391">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withPreferredHeight(preferredHeight)));</span>
    }

    /**
     *  Defines the size of this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param size The width and height size {@link Dimension}.
     * @return A new {@link ComponentStyleDelegate} with the provided {@link Size} (width and height) set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; size( Size size ) {
<span class="fc" id="L2402">        Objects.requireNonNull(size);</span>
<span class="fc" id="L2403">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withSize(size)));</span>
    }

    /**
     *  Defines the size of this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The width.
     * @param height The height.
     * @return A new {@link ComponentStyleDelegate} with the provided size (width and height) {@link Dimension} set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; size( int width, int height ) {
<span class="fc" id="L2415">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withWidth(width)._withHeight(height)));</span>
    }


    /**
     *  Defines the width of this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param width The width.
     * @return A new {@link ComponentStyleDelegate} with the provided width set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; width( int width ) {
<span class="fc" id="L2427">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withWidth(width)));</span>
    }

    /**
     *  Defines the height of this {@link JComponent}. &lt;br&gt;
     *  This ultimately translates to {@link JComponent#setSize(Dimension)} on the underlying component. &lt;br&gt;
     * @param height The height.
     * @return A new {@link ComponentStyleDelegate} with the provided height set to be later
     *          applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; height( int height ) {
<span class="fc" id="L2438">        return _withStyle(_styleConf._withDimensionality(_styleConf.dimensionality()._withHeight(height)));</span>
    }

    /**
     *  Defines the cursor type for this {@link JComponent} based on
     *  the predefined {@link UI.Cursor} values. &lt;br&gt;
     *  If you want to specify a custom cursor implementation,
     *  use {@link #cursor(Cursor)} instead. &lt;br&gt;
     *
     * @param cursor The {@link UI.Cursor} value.
     * @return A new {@link ComponentStyleDelegate} with the provided cursor type set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; cursor( UI.Cursor cursor ) {
<span class="fc" id="L2451">        Objects.requireNonNull(cursor);</span>
<span class="fc" id="L2452">        return this.cursor(cursor.toAWTCursor());</span>
    }

    /**
     *  Defines the cursor type for this {@link JComponent} based on
     *  the provided {@link Cursor} value. &lt;br&gt;
     *  Use this method if you want to specify a custom cursor implementation,
     *  in case you merely want to pick one of the many predefined {@link UI.Cursor} values,
     *  use {@link #cursor(UI.Cursor)} instead. &lt;br&gt;
     *
     * @param cursor The {@link Cursor} value.
     * @return A new {@link ComponentStyleDelegate} with the provided cursor type set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; cursor( Cursor cursor ) {
<span class="fc" id="L2466">        Objects.requireNonNull(cursor);</span>
<span class="fc" id="L2467">        return _withStyle(_styleConf._withBase(_styleConf.base().cursor(cursor)));</span>
    }

    /**
     *  Determines how the component is oriented, typically with respect to
     *  the text direction and where content originates. &lt;br&gt;
     *  This translates to {@link JComponent#setComponentOrientation(ComponentOrientation)}
     *  on the underlying component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that although all components support this property, it may not always
     *  have a noticeable effect on the component. &lt;br&gt;
     *  How this property is interpreted depends heavily on the component, it's layout manager
     *  and the look and feel implementation. &lt;br&gt;
     * @param orientation The {@link UI.ComponentOrientation}, which maps 1:1 to the AWT {@link ComponentOrientation} constants.
     * @return A new {@link ComponentStyleDelegate} with the provided {@link UI.ComponentOrientation} set to be later
     *         applied to the underlying component when the final {@link StyleConf} is applied.
     */
    public ComponentStyleDelegate&lt;C&gt; orientation( UI.ComponentOrientation orientation ) {
<span class="fc" id="L2485">        Objects.requireNonNull(orientation);</span>
<span class="fc" id="L2486">        return _withStyle(_styleConf._withBase(_styleConf.base().orientation(orientation)));</span>
    }

    /**
     *  Use this to define the layout manager for this {@link JComponent}
     *  using a {@link Layout} object. &lt;br&gt;
     *  Checkout the factory methods in {@link Layout} for creating
     *  different types of layout managers like {@link Layout#flow()}, {@link Layout#mig(String)}
     *  or {@link Layout#grid(int, int)}. &lt;br&gt;
     *
     * @param installer The {@link Layout} to use for installing the layout.
     * @return A new {@link ComponentStyleDelegate} with the provided {@link Layout} set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; layout( Layout installer ) {
<span class="fc" id="L2500">        return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(installer)));</span>
    }

    /**
     *  Defines the layout {@link net.miginfocom.swing.MigLayout} constraints for
     *  this {@link JComponent} in the form of a {@link String}. &lt;br&gt;
     *  This ultimately translates to {@link net.miginfocom.swing.MigLayout#setLayoutConstraints(Object)}
     *  on the underlying component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if this property is specified, the style engine will automatically
     *  install a {@link net.miginfocom.swing.MigLayout} on the component if it does not already have one. &lt;br&gt;
     *
     * @param constraints The layout constraints as a {@link String}.
     * @return A new {@link ComponentStyleDelegate} with the provided layout constraints set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; layout( String constraints ) {
<span class="nc" id="L2516">        Objects.requireNonNull(constraints);</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">        if ( _styleConf.layout().layout() instanceof Layout.ForMigLayout ) {</span>
<span class="nc" id="L2518">            Layout.ForMigLayout migInstaller = (Layout.ForMigLayout) _styleConf.layout().layout();</span>
<span class="nc" id="L2519">            migInstaller = migInstaller.withConstraint(constraints);</span>
<span class="nc" id="L2520">            return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(migInstaller)));</span>
        }
<span class="nc" id="L2522">        return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(Layout.mig(constraints, &quot;&quot;, &quot;&quot;))));</span>
    }

    /**
     *  Defines the {@link net.miginfocom.swing.MigLayout} based layout constraints
     *  and column layout constraints of this {@link JComponent} in the form of a {@link String}. &lt;br&gt;
     *  This ultimately translates to {@link net.miginfocom.swing.MigLayout#setLayoutConstraints(Object)}
     *  as well as {@link net.miginfocom.swing.MigLayout#setColumnConstraints(Object)}
     *  on the layout manager of the underlying component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if this property is specified, the style engine will automatically
     *  install a {@link net.miginfocom.swing.MigLayout} on the component if it does not already have one. &lt;br&gt;
     *
     * @param constraints The layout constraints as a {@link String}.
     * @param columnConstraints The column constraints as a {@link String}.
     * @return A new {@link ComponentStyleDelegate} with the provided layout constraints set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; layout( String constraints, String columnConstraints ) {
<span class="nc" id="L2540">        Objects.requireNonNull(constraints);</span>
<span class="nc" id="L2541">        Objects.requireNonNull(columnConstraints);</span>
<span class="nc bnc" id="L2542" title="All 2 branches missed.">        if ( _styleConf.layout().layout() instanceof Layout.ForMigLayout) {</span>
<span class="nc" id="L2543">            Layout.ForMigLayout migInstaller = (Layout.ForMigLayout) _styleConf.layout().layout();</span>
<span class="nc" id="L2544">            migInstaller = migInstaller.withConstraint(constraints).withColumnConstraint(columnConstraints);</span>
<span class="nc" id="L2545">            return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(migInstaller)));</span>
        }
<span class="nc" id="L2547">        return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(Layout.mig(constraints, columnConstraints, &quot;&quot;))));</span>
    }

    /**
     *  Defines the {@link net.miginfocom.swing.MigLayout} based layout constraints
     *  column layout constraints and row layout constraints of this {@link JComponent} in the form of a {@link String}. &lt;br&gt;
     *  This ultimately translates to {@link net.miginfocom.swing.MigLayout#setLayoutConstraints(Object)}
     *  as well as {@link net.miginfocom.swing.MigLayout#setColumnConstraints(Object)}
     *  and {@link net.miginfocom.swing.MigLayout#setRowConstraints(Object)}
     *  on the layout manager of the underlying component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if this property is specified, the style engine will automatically
     *  install a {@link net.miginfocom.swing.MigLayout} on the component if it does not already have one. &lt;br&gt;
     *
     * @param constraints The layout constraints as a {@link String}.
     * @param columnConstraints The column constraints as a {@link String}.
     * @param rowConstraints The row constraints as a {@link String}.
     * @return A new {@link ComponentStyleDelegate} with the provided layout constraints set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; layout( String constraints, String columnConstraints, String rowConstraints ) {
<span class="fc" id="L2567">        Objects.requireNonNull(constraints);</span>
<span class="fc" id="L2568">        Objects.requireNonNull(columnConstraints);</span>
<span class="fc" id="L2569">        Objects.requireNonNull(rowConstraints);</span>
<span class="fc" id="L2570">        return _withStyle(_styleConf._withLayout(_styleConf.layout().layout(Layout.mig(constraints, columnConstraints, rowConstraints))));</span>
    }

    /**
     *  Defines the component constraints of this component with respect to the parent component
     *  and its layout manager, in the form of a {@link String}. &lt;br&gt;
     *  This ultimately translates to {@link net.miginfocom.swing.MigLayout#setComponentConstraints(Component, Object)}
     *  on the layout manager of the parent component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if this property is specified, the style engine will automatically
     *  install a {@link net.miginfocom.swing.MigLayout} on the parent component if it does not already have one. &lt;br&gt;
     *
     * @param constraints The component constraints as a {@link String}.
     * @return A new {@link ComponentStyleDelegate} with the provided component constraints set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; addConstraint( Object constraints ) {
<span class="fc" id="L2586">        return _withStyle(_styleConf._withLayout(_styleConf.layout().constraint(constraints)));</span>
    }

    /**
     *  Defines the layout {@link net.miginfocom.swing.MigLayout} constraints for
     *  this {@link JComponent} in the form of a {@link LayoutConstraint}
     *  (see {@link UI#FILL}, {@link UI#FILL_X}, {@link UI#FILL_Y}...). &lt;br&gt;
     *  This ultimately translates to {@link net.miginfocom.swing.MigLayout#setLayoutConstraints(Object)}
     *  on the underlying component. &lt;br&gt;
     *  &lt;br&gt;
     *  Note that if this property is specified, the style engine will automatically
     *  install a {@link net.miginfocom.swing.MigLayout} on the component if it does not already have one. &lt;br&gt;
     *
     * @param constraintAttr The layout constraints as a {@link LayoutConstraint}.
     * @return A new {@link ComponentStyleDelegate} with the provided layout constraints set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; layout( LayoutConstraint constraintAttr ) {
<span class="nc" id="L2603">        Objects.requireNonNull(constraintAttr);</span>
<span class="nc" id="L2604">        return layout(constraintAttr.toString());</span>
    }

    /**
     *  Defines the alignment percentage alongside the X axis for a component (see {@link JComponent#setAlignmentX(float)}). &lt;br&gt;
     *  Note that the alignment may not have an effect on all components
     *  as it depends on the layout manager of the component. &lt;br&gt;
     *
     * @param percentage The alignment percentage in terms of a number between 0 and 1 alongside the X axis.
     * @return A new {@link ComponentStyleDelegate} with the provided alignment percentage alongside the X axis set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; alignmentX( float percentage ) {
<span class="fc" id="L2616">        return _withStyle(_styleConf._withLayout(_styleConf.layout().alignmentX(percentage)));</span>
    }

    /**
     *  Defines the alignment percentage alongside the Y axis for a component (see {@link JComponent#setAlignmentY(float)}). &lt;br&gt;
     *  Note that the alignment may not have an effect on all components
     *  as it depends on the layout manager of the component. &lt;br&gt;
     *
     * @param percentage The alignment percentage in terms of a number between 0 and 1 alongside the Y axis.
     * @return A new {@link ComponentStyleDelegate} with the provided alignment percentage alongside the Y axis set to be later
     */
    public ComponentStyleDelegate&lt;C&gt; alignmentY( float percentage ) {
<span class="fc" id="L2628">        return _withStyle(_styleConf._withLayout(_styleConf.layout().alignmentY(percentage)));</span>
    }

    /**
     *  A convenient delegate method to {@link UI#scale()} which exposes the current UI scale factor
     *  that is used to scale the UI for high resolution displays (high dots-per-inch, or DPI).
     *  Use this scale factor when writing custom rendering code against the {@link Graphics2D} API.
     *
     * @return The current UI scale factor, which is used to scale the UI
     *         for high resolution displays (high dots-per-inch, or DPI).
     */
<span class="nc" id="L2639">    public float getScale() { return UI.scale(); }</span>

    /**
     *  A convenient delegate method to {@link UI#scale()} which exposes the current UI scale factor
     *  that is used to scale the UI for high resolution displays (high dots-per-inch, or DPI).
     *  Use this scale factor when writing custom rendering code against the {@link Graphics2D} API.
     *
     * @return The current UI scale factor, which is used to scale the UI
     *         for high resolution displays (high dots-per-inch, or DPI).
     */
<span class="nc" id="L2649">    public float scale() { return UI.scale(); }</span>

    /**
     *  Use this method inside custom {@link swingtree.api.Painter} implementations (see {@link #painter(UI.Layer, swingtree.api.Painter)})
     *  to scale an {@code int} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code int} value to scale.
     *  @return The scaled {@code int} value.
     */
<span class="nc" id="L2658">    public int scale( int value ) { return UI.scale(value); }</span>

    /**
     *  Use this method inside custom {@link swingtree.api.Painter} implementations (see {@link #painter(UI.Layer, swingtree.api.Painter)})
     *  to scale a {@code float} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code float} value to scale.
     *  @return The scaled {@code float} value.
     */
<span class="nc" id="L2667">    public float scale( float value ) { return UI.scale(value); }</span>

    /**
     *  Use this method inside custom {@link swingtree.api.Painter} implementations (see {@link #painter(UI.Layer, Painter)})
     *  to scale a {@code double} value by the current UI scale factor to ensure
     *  that the UI is scaled properly for high resolution displays (high dots-per-inch, or DPI).
     *  @param value The {@code double} value to scale.
     *  @return The scaled {@code double} value.
     */
<span class="nc" id="L2676">    public double scale( double value ) { return UI.scale(value); }</span>

    @Override
    public String toString() {
        try {
<span class="nc" id="L2681">            return this.getClass().getSimpleName() + &quot;[&quot; +</span>
                        &quot;styleConf=&quot; + _styleConf + &quot;, &quot; +
                        &quot;component=&quot; + _component + &quot;, &quot; +
                    &quot;]&quot;;
<span class="nc" id="L2685">        } catch ( Exception e ) {</span>
<span class="nc" id="L2686">            return this.getClass().getSimpleName() + &quot;[toString() failed: &quot; + e + &quot;]&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>