<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicTableModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.api.model</a> &gt; <span class="el_source">BasicTableModel.java</span></div><h1>BasicTableModel.java</h1><pre class="source lang-java linenums">package swingtree.api.model;

import org.jspecify.annotations.Nullable;
import sprouts.Observable;
import sprouts.Event;
import sprouts.Tuple;
import swingtree.UI;
import swingtree.api.Buildable;

import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;
import java.util.Objects;

/**
 *  This interface defines a basic table model which can be used to create a table model using lambda expressions.
 *  Implementations of this are typically created declarative like so: &lt;br&gt;
 *  &lt;pre&gt;{@code
 *      UI.table( conf -&gt; conf
 *          .colNames(&quot;A&quot;, &quot;B&quot;)
 *          .colCount(()-&gt;2)
 *          .rowCount(()-&gt;3)
 *          .getsEntryAt((int row, int col)-&gt;
 *              vm.getDataAt(row, col)
 *          )
 *      )
 *  }&lt;/pre&gt;
 */
public interface BasicTableModel extends TableModel
{
    /** {@inheritDoc} */
    @Override int getRowCount();
    /** {@inheritDoc} */
    @Override int getColumnCount();
    /** {@inheritDoc} */
    @Override Object getValueAt(int rowIndex, int columnIndex);
    /** {@inheritDoc} */
    @Override void setValueAt(Object aValue, int rowIndex, int columnIndex);
    /** {@inheritDoc} */
<span class="nc" id="L40">    @Override default Class&lt;?&gt; getColumnClass(int columnIndex) { return Object.class; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L42">    @Override default String getColumnName(int columnIndex) { return null; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L44">    @Override default boolean isCellEditable(int rowIndex, int columnIndex) { return false; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L46">    @Override default void addTableModelListener(TableModelListener l) {throw new IllegalStateException(&quot;Not implemented&quot;);}</span>
    /** {@inheritDoc} */
<span class="nc" id="L48">    @Override default void removeTableModelListener(TableModelListener l) {throw new IllegalStateException(&quot;Not implemented&quot;);}</span>

    /**
     *  Implementations of this functional interface translate to the {@link TableModel#getRowCount()} method.
     */
    @FunctionalInterface interface RowCount { int get(); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#getColumnCount()} method.
     */
    @FunctionalInterface interface ColumnCount { int get(); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#getValueAt(int, int)} method.
     */
    @FunctionalInterface interface EntryGetter&lt;E&gt; { E get(int rowIndex, int colIndex); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#setValueAt(Object, int, int)} method.
     */
    @FunctionalInterface interface EntrySetter&lt;E&gt; { void set(int rowIndex, int colIndex, E aValue); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#getColumnClass(int)} method.
     */
    @FunctionalInterface interface ColumnClass&lt;E&gt; { Class&lt;? extends E&gt; get(int colIndex); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#isCellEditable(int, int)} method.
     */
    @FunctionalInterface interface CellEditable { boolean is(int rowIndex, int colIndex); }
    /**
     *  Implementations of this functional interface translate to the {@link TableModel#getColumnName(int)} method.
     */
    @FunctionalInterface interface ColumnName { String get(int colIndex); }

    /**
     *  The class below is a functional builder for creating a lambda based implementation of the {@link BasicTableModel}.
     *  This allows fo a boilerplate free functional API.
     *
     * @param &lt;E&gt; Common type for all entry items in the table.
     */
     class Builder&lt;E&gt; implements Buildable&lt;BasicTableModel&gt;
     {
         private static class FixedColumnNames implements ColumnName {
            final Tuple&lt;String&gt; names;
<span class="fc" id="L89">             private FixedColumnNames(String... names) {</span>
<span class="fc" id="L90">                 this.names = Tuple.of(String.class, names);</span>
<span class="fc" id="L91">             }</span>
             @Override
             public String get(int colIndex) {
<span class="pc bpc" id="L94" title="2 of 4 branches missed.">                 return colIndex &lt; 0 || colIndex &gt;= names.size() ? &quot;&quot; : names.get(colIndex);</span>
             }
         }

         private static class FixedColumnClasses implements ColumnClass {
             private final Class&lt;?&gt; commonEntryType;
             final Tuple&lt;Class&gt; classes;
<span class="nc" id="L101">             private FixedColumnClasses(Class&lt;?&gt; commonEntryType, Class&lt;?&gt;... names) {</span>
<span class="nc" id="L102">                 this.commonEntryType = commonEntryType;</span>
<span class="nc" id="L103">                 this.classes = Tuple.of(Class.class, names);</span>
<span class="nc" id="L104">             }</span>
             @Override
             public Class get(int colIndex) {
<span class="nc bnc" id="L107" title="All 4 branches missed.">                 return colIndex &lt; 0 || colIndex &gt;= classes.size() ? commonEntryType : classes.get(colIndex);</span>
             }
         }

        private final Class&lt;E&gt;       commonEntryType;
        private final @Nullable RowCount       rowCount;
        private final @Nullable ColumnCount    colCount;
        private final @Nullable EntryGetter&lt;E&gt; entryGetter;
        private final @Nullable EntrySetter&lt;E&gt; entrySetter;
        private final @Nullable ColumnClass&lt;E&gt; columnClass;
        private final @Nullable CellEditable   cellEditable;
        private final @Nullable ColumnName     columnName;
        private final @Nullable Observable     observableEvent;

         public Builder( Class&lt;E&gt; commonEntryType ) {
<span class="fc" id="L122">             this(</span>
<span class="fc" id="L123">                 Objects.requireNonNull(commonEntryType),</span>
                 null,
                 null,
                 null,
                 null,
                 null,
                 null,
                 null,
                 null
             );
<span class="fc" id="L133">         }</span>

         private Builder(
             Class&lt;E&gt;                 commonEntryType,
             @Nullable RowCount       rowCount,
             @Nullable ColumnCount    colCount,
             @Nullable EntryGetter&lt;E&gt; entryGetter,
             @Nullable EntrySetter&lt;E&gt; entrySetter,
             @Nullable ColumnClass&lt;E&gt; columnClass,
             @Nullable CellEditable   cellEditable,
             @Nullable ColumnName     columnName,
             @Nullable Observable     observableEvent
<span class="fc" id="L145">         ) {</span>
<span class="fc" id="L146">             this.commonEntryType = Objects.requireNonNull(commonEntryType);</span>
<span class="fc" id="L147">             this.rowCount        = rowCount;</span>
<span class="fc" id="L148">             this.colCount        = colCount;</span>
<span class="fc" id="L149">             this.entryGetter     = entryGetter;</span>
<span class="fc" id="L150">             this.entrySetter     = entrySetter;</span>
<span class="fc" id="L151">             this.columnClass     = columnClass;</span>
<span class="fc" id="L152">             this.cellEditable    = cellEditable;</span>
<span class="fc" id="L153">             this.columnName      = columnName;</span>
<span class="fc" id="L154">             this.observableEvent = observableEvent;</span>
<span class="fc" id="L155">         }</span>

         /**
          *  Use this to define the lambda which dynamically determines the row count of the table model.
          * @param rowCount The lambda which will be used to determine the row count of the table model.
          * @return This builder instance.
          */
        public Builder&lt;E&gt; rowCount( RowCount rowCount ) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if ( rowCount == null ) throw new IllegalArgumentException(&quot;rowCount cannot be null&quot;);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if ( this.rowCount != null ) throw new IllegalStateException(RowCount.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L165">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Use this to define the lambda which dynamically determines the column count of the table model.
         * @param columnCount The lambda which will be used to determine the column count of the table model.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; colCount( ColumnCount columnCount ) {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if ( columnCount == null ) throw new IllegalArgumentException(&quot;columnCount cannot be null&quot;);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if ( this.colCount != null ) throw new IllegalStateException(ColumnCount.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L178">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, columnCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Accepts a lambda allowing the {@link javax.swing.JTable} to dynamically determines the value at a given row and column.
         * @param entryGetter The lambda which will be used to determine the value at a given row and column.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; getsEntryAt(EntryGetter&lt;E&gt; entryGetter) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if ( entryGetter == null ) throw new IllegalArgumentException(&quot;valueAt cannot be null&quot;);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            if ( this.entryGetter != null ) throw new IllegalStateException(EntryGetter.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L191">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Accepts a lambda allowing lambda which allows the user of the {@link javax.swing.JTable} to set the value at a given row and column.
         * @param entrySetter The lambda which will be used to set the value at a given row and column.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; setsEntryAt(EntrySetter&lt;E&gt; entrySetter) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if ( entrySetter == null ) throw new IllegalArgumentException(&quot;setValueAt cannot be null&quot;);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if ( this.entrySetter != null ) throw new IllegalStateException(EntrySetter.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="nc" id="L204">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Accepts a lambda which allows the {@link javax.swing.JTable} to determine the class of the column at a given index.
         * @param columnClass The lambda which will be used to determine the class of the column at a given index.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; colClass( ColumnClass&lt;E&gt; columnClass ) {
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if ( columnClass == null ) throw new IllegalArgumentException(&quot;columnClass cannot be null&quot;);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if ( this.columnClass != null ) throw new IllegalStateException(ColumnClass.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="nc" id="L217">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Use this to define a fixed array of column classes.
         * @param classes An array of column classes.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; colClasses( Class&lt;? extends E&gt;... classes ) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if ( classes == null ) throw new IllegalArgumentException(&quot;classes cannot be null&quot;);</span>
<span class="nc" id="L229">            return colClass(new FixedColumnClasses(commonEntryType, classes));</span>
        }
        /**
         *  Accepts a lambda allowing the {@link javax.swing.JTable} to determine if the cell at a given row and column is editable.
         * @param cellEditable The lambda which will be used to determine if the cell at a given row and column is editable.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; isEditableIf( CellEditable cellEditable ) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            if ( cellEditable == null ) throw new IllegalArgumentException(&quot;cellEditable cannot be null&quot;);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if ( this.cellEditable != null ) throw new IllegalStateException(CellEditable.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L239">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
         /**
          *  Use this to define the lambda which allows the {@link javax.swing.JTable} to determine the name of the column at a given index.
          * @param columnName The lambda which will be used to determine the name of the column at a given index.
          * @return This builder instance.
          */
        public Builder&lt;E&gt; colName( ColumnName columnName ) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            if ( columnName == null ) throw new IllegalArgumentException(&quot;columnName cannot be null&quot;);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (this.columnName != null)</span>
<span class="nc" id="L252">                throw new IllegalStateException(ColumnName.class.getSimpleName() + &quot; already set&quot;);</span>
<span class="fc" id="L253">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, observableEvent
                );
        }
        /**
         *  Use this to define a fixed array of column names.
         * @param names An array of column names.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; colNames( String... names ) {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if ( names == null ) throw new IllegalArgumentException(&quot;names cannot be null&quot;);</span>
<span class="fc" id="L265">            return colName(new FixedColumnNames(names));</span>
        }
        /**
         *  Use this to define the event which will be fired when the table model is updated.
         * @param updateEvent The event which will be fired when the table model is updated.
         * @return This builder instance.
         */
        public Builder&lt;E&gt; updateOn( Observable updateEvent ) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if ( updateEvent == null ) throw new IllegalArgumentException(&quot;updateEvent cannot be null&quot;);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            if ( this.observableEvent != null ) throw new IllegalStateException(Event.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L275">            return new Builder&lt;&gt;(</span>
                    commonEntryType, rowCount, colCount, entryGetter, entrySetter,
                    columnClass, cellEditable, columnName, updateEvent
                );
        }
        /**
         *  Use this to build the {@link BasicTableModel} instance.
         * @return The {@link BasicTableModel} instance.
         */
        @Override public BasicTableModel build() {
<span class="fc" id="L285">            FunTableModel tm = new FunTableModel();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            if ( observableEvent != null )</span>
<span class="fc" id="L287">                observableEvent.subscribe(()-&gt; UI.run(()-&gt;{</span>
                    // We want the table model update to be as thorough as possible, so we
                    // will fire a table structure changed event, followed by a table data
                    // changed event.
<span class="fc" id="L291">                    tm.fireTableStructureChanged();</span>
<span class="fc" id="L292">                    tm.fireTableDataChanged();</span>
<span class="fc" id="L293">                }));</span>
<span class="fc" id="L294">            return tm;</span>
        }

<span class="fc" id="L297">         private class FunTableModel extends AbstractTableModel implements BasicTableModel {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">             @Override public int getRowCount() { return rowCount == null ? 0 : rowCount.get(); }</span>
             @Override public int getColumnCount() {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                 if (colCount == null) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                     if ( columnClass instanceof FixedColumnClasses ) {</span>
<span class="nc" id="L302">                         return ((FixedColumnClasses)columnClass).classes.size();</span>
                     }
<span class="nc bnc" id="L304" title="All 2 branches missed.">                     if ( columnName instanceof FixedColumnNames ) {</span>
<span class="nc" id="L305">                         return ((FixedColumnNames)columnName).names.size();</span>
                     }
                 }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                 return colCount == null ? 0 : colCount.get();</span>
             }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">             @Override public Object getValueAt(int rowIndex, int colIndex) { return entryGetter == null ? null : entryGetter.get(rowIndex, colIndex); }</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">             @Override public void setValueAt(Object value, int rowIndex, int colIndex) { if ( entrySetter != null ) entrySetter.set(rowIndex, colIndex, (E) value); }</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">             @Override public Class&lt;?&gt; getColumnClass(int colIndex) { return columnClass == null ? super.getColumnClass(colIndex) : columnClass.get(colIndex); }</span>
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">             @Override public boolean isCellEditable(int rowIndex, int colIndex) { return cellEditable != null &amp;&amp; cellEditable.is(rowIndex, colIndex); }</span>
             @Override public String getColumnName(int colIndex) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">                 if (columnName == null) {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                     if ( columnClass instanceof FixedColumnClasses ) {</span>
<span class="nc" id="L317">                         return ((FixedColumnClasses)columnClass).get(colIndex).getSimpleName();</span>
                     }
                 }
<span class="fc bfc" id="L320" title="All 2 branches covered.">                 return columnName == null ? super.getColumnName(colIndex) : columnName.get(colIndex);</span>
             }
         }

     }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>