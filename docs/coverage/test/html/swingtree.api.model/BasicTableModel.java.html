<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicTableModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swing-tree</a> &gt; <a href="index.source.html" class="el_package">swingtree.api.model</a> &gt; <span class="el_source">BasicTableModel.java</span></div><h1>BasicTableModel.java</h1><pre class="source lang-java linenums">package swingtree.api.model;

import swingtree.api.Buildable;

import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;

public interface BasicTableModel extends TableModel
{
    /** {@inheritDoc} */
    int getRowCount();
    /** {@inheritDoc} */
    int getColumnCount();
    /** {@inheritDoc} */
    Object getValueAt(int rowIndex, int columnIndex);
    /** {@inheritDoc} */
    void setValueAt(Object aValue, int rowIndex, int columnIndex);
    /** {@inheritDoc} */
<span class="nc" id="L20">    @Override default Class&lt;?&gt; getColumnClass(int columnIndex) { return Object.class; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L22">    @Override default String getColumnName(int columnIndex) { return null; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L24">    @Override default boolean isCellEditable(int rowIndex, int columnIndex) { return false; }</span>
    /** {@inheritDoc} */
<span class="nc" id="L26">    @Override default void addTableModelListener(TableModelListener l) {throw new IllegalStateException(&quot;Not implemented&quot;);}</span>
    /** {@inheritDoc} */
<span class="nc" id="L28">    @Override default void removeTableModelListener(TableModelListener l) {throw new IllegalStateException(&quot;Not implemented&quot;);}</span>

    @FunctionalInterface interface RowCount { int get(); }
    @FunctionalInterface interface ColumnCount { int get(); }
    @FunctionalInterface interface ValueAt { Object get(int rowIndex, int colIndex); }
    @FunctionalInterface interface SetValueAt { void set(int rowIndex, int colIndexx, Object aValue); }
    @FunctionalInterface interface ColumnClass { Class&lt;?&gt; get(int colIndex); }
    @FunctionalInterface interface CellEditable { boolean is(int rowIndex, int colIndex); }
    @FunctionalInterface interface ColumnName { String get(int colIndex); }

    /**
     *  The class below is a functional builder for creating a lambda based implementation of the {@link BasicTableModel}.
     *  This allows fo a boilerplate free functional API.
     */
<span class="fc" id="L42">     class Builder implements Buildable&lt;BasicTableModel&gt;</span>
     {
        private RowCount rowCount;
        private ColumnCount colCount;
        private ValueAt valueAt;
        private SetValueAt setValueAt;
        private ColumnClass columnClass;
        private CellEditable cellEditable;
        private ColumnName columnName;

         /**
          *  Use this to define the lambda which dynamically determines the row count of the table model.
          * @param rowCount The lambda which will be used to determine the row count of the table model.
          * @return This builder instance.
          */
        public Builder onRowCount(RowCount rowCount) {
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">            if ( rowCount == null ) throw new IllegalArgumentException(&quot;rowCount cannot be null&quot;);</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            if ( this.rowCount != null ) throw new IllegalStateException(RowCount.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L60">            this.rowCount = rowCount;</span>
<span class="fc" id="L61">            return this;</span>
        }
        /**
         *  Use this to define the lambda which dynamically determines the column count of the table model.
         * @param columnCount The lambda which will be used to determine the column count of the table model.
         * @return This builder instance.
         */
        public Builder onColCount(ColumnCount columnCount) {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">            if ( columnCount == null ) throw new IllegalArgumentException(&quot;columnCount cannot be null&quot;);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            if ( this.colCount != null ) throw new IllegalStateException(ColumnCount.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L71">            this.colCount = columnCount;</span>
<span class="fc" id="L72">            return this;</span>
        }
        /**
         *  Use this to define the lambda which dynamically determines the value at a given row and column.
         * @param valueAt The lambda which will be used to determine the value at a given row and column.
         * @return This builder instance.
         */
        public Builder onGet(ValueAt valueAt) {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">            if ( valueAt == null ) throw new IllegalArgumentException(&quot;valueAt cannot be null&quot;);</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if ( this.valueAt != null ) throw new IllegalStateException(ValueAt.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="fc" id="L82">            this.valueAt = valueAt;</span>
<span class="fc" id="L83">            return this;</span>
        }
        /**
         *  Use this to define the lambda which allows the user of the {@link javax.swing.JTable} to set the value at a given row and column.
         * @param setValueAt The lambda which will be used to set the value at a given row and column.
         * @return This builder instance.
         */
        public Builder onSet(SetValueAt setValueAt) {
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if ( setValueAt == null ) throw new IllegalArgumentException(&quot;setValueAt cannot be null&quot;);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">            if ( this.setValueAt != null ) throw new IllegalStateException(SetValueAt.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="nc" id="L93">            this.setValueAt = setValueAt;</span>
<span class="nc" id="L94">            return this;</span>
        }
        /**
         *  Use this to define the lambda which allows the {@link javax.swing.JTable} to determine the class of the column at a given index.
         * @param columnClass The lambda which will be used to determine the class of the column at a given index.
         * @return This builder instance.
         */
        public Builder onColClass(ColumnClass columnClass) {
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if ( columnClass == null ) throw new IllegalArgumentException(&quot;columnClass cannot be null&quot;);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if ( this.columnClass != null ) throw new IllegalStateException(ColumnClass.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="nc" id="L104">            this.columnClass = columnClass;</span>
<span class="nc" id="L105">            return this;</span>
        }
        /**
         *  Use this to define a fixed array of column classes.
         * @param classes An array of column classes.
         * @return This builder instance.
         */
        public Builder colClasses(Class&lt;?&gt;... classes) {
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if ( classes == null ) throw new IllegalArgumentException(&quot;classes cannot be null&quot;);</span>
<span class="nc" id="L114">            return onColClass((colIndex) -&gt; classes[colIndex]);</span>
        }
        /**
         *  Use this to define the lambda which allows the {@link javax.swing.JTable} to determine if the cell at a given row and column is editable.
         * @param cellEditable The lambda which will be used to determine if the cell at a given row and column is editable.
         * @return This builder instance.
         */
        public Builder onIsEditable(CellEditable cellEditable) {
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if ( cellEditable == null ) throw new IllegalArgumentException(&quot;cellEditable cannot be null&quot;);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">            if ( this.cellEditable != null ) throw new IllegalStateException(CellEditable.class.getSimpleName()+&quot; already set&quot;);</span>
<span class="nc" id="L124">            this.cellEditable = cellEditable;</span>
<span class="nc" id="L125">            return this;</span>
        }
         /**
          *  Use this to define the lambda which allows the {@link javax.swing.JTable} to determine the name of the column at a given index.
          * @param columnName The lambda which will be used to determine the name of the column at a given index.
          * @return This builder instance.
          */
        public Builder onColName(ColumnName columnName) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            if ( columnName == null ) throw new IllegalArgumentException(&quot;columnName cannot be null&quot;);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            if (this.columnName != null)</span>
<span class="nc" id="L135">                throw new IllegalStateException(ColumnName.class.getSimpleName() + &quot; already set&quot;);</span>
<span class="fc" id="L136">            this.columnName = columnName;</span>
<span class="fc" id="L137">            return this;</span>
        }
        public Builder colNames(String... names) {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            if ( names == null ) throw new IllegalArgumentException(&quot;names cannot be null&quot;);</span>
<span class="fc" id="L141">            return onColName((colIndex) -&gt; names[colIndex]);</span>
        }
        /**
         *  Use this to build the {@link BasicTableModel} instance.
         * @return The {@link BasicTableModel} instance.
         */
<span class="fc" id="L147">        @Override public BasicTableModel build() { return new FunTableModel(); }</span>

<span class="fc" id="L149">         private class FunTableModel extends AbstractTableModel implements BasicTableModel {</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">             @Override public int getRowCount() { return rowCount == null ? 0 : rowCount.get(); }</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">             @Override public int getColumnCount() { return colCount == null ? 0 : colCount.get(); }</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">             @Override public Object getValueAt(int rowIndex, int colIndex) { return valueAt == null ? null : valueAt.get(rowIndex, colIndex); }</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">             @Override public void setValueAt(Object value, int rowIndex, int colIndex) { if ( setValueAt != null ) setValueAt.set(rowIndex, colIndex, value); }</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">             @Override public Class&lt;?&gt; getColumnClass(int colIndex) { return columnClass == null ? super.getColumnClass(colIndex) : columnClass.get(colIndex); }</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">             @Override public boolean isCellEditable(int rowIndex, int colIndex) { return cellEditable != null &amp;&amp; cellEditable.is(rowIndex, colIndex); }</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">             @Override public String getColumnName(int colIndex) { return columnName == null ? super.getColumnName(colIndex) : columnName.get(colIndex); }</span>
         }

     }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>