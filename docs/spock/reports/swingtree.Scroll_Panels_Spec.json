{
  "className":"swingtree.Scroll_Panels_Spec",
  "title":"Scroll Panels",
  "narrative":"This specification is dedicated to showing how to use the\n    `JScrollPanels` class, a custom SwingTree component that\n    is designed to display a list of scrollable panels\n    which can be populated with any kind of interactive UI\n    based on any kind of sub-view model type.",
  "subjects":["swingtree.components.JScrollPanels"],
  "statistics":{
    "runs":"23",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The `JScrollPanels` instance can visually represent a view model consisting of sub-view models.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that we use a pre-made example view model here.\n            Feel free to look at the source code of the view model\n            to see what it is doing.\n            All you need to know is that it is a view model\n            that contains a `Vars` based property list of sub-view models.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the view model.","code":["var vm = new ScrollPanelsViewModel()"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui =","    UI.panel(\"fill, wrap 1\")","    .add( UI.label(\"Something to scroll:\") )","    .add( UI.separator() )","    .add(","        UI.scrollPanels().addAll(vm.entries(), evm ->","            UI.panel(\"fill\").id(\"sub-view\")","            .add(\"pushx\", UI.label(evm.text()))","            .add(UI.label(evm.position().viewAs(String.class, s -> \"Position: \" + s)))","            .add(UI.label(evm.position().viewAs(String.class, s -> \"Selected: \" + s)))","            .add(UI.button(\"Delete me!\").onClick(it -> {","                System.out.println(\"Deleting \" + evm.text().get());","                int i = evm.entries().indexOf(evm);","                evm.entries().removeAt(i);","                if ( i != evm.position().get() )","                    throw new IllegalStateException(\"Index mismatch: \" + i + \" != \" + evm.position().get());","            }))","            .add(UI.button(\"Duplicate\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                evm.entries().addAt(i, evm.createNew(evm.text().get() + \" (copy)\"));","            }))","            .add(UI.button(\"up\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                if ( i > 0 ) {","                    evm.entries().removeAt(i);","                    evm.entries().addAt(i - 1, evm);","                }","            }))","            .add(UI.button(\"down\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                if ( i < evm.entries().size() - 1 ) {","                    evm.entries().removeAt(i);","                    evm.entries().addAt(i + 1, evm);","                }","            }))","            .add(UI.button(\"replace\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                evm.entries().setAt(i, evm.createNew(\"Replaced!\"));","            }))","        )","    )","    .add( UI.separator() )"]},

        {"kind":"and","text":"We build the root component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"then","text":"It was successfully created.","code":["panel != null"]},

        {"kind":"and","text":"The view contains as many sub-views as the view model has entries.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == vm.entries().size()"]},

        {"kind":"when","text":"We remove an item from the entry list.","code":["vm.entries().removeAt(2)","UI.sync()"]},

        {"kind":"then","text":"The view is updated accordingly.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == vm.entries().size()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use a simple property list of Strings to populate a scroll panel.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Instead of using a view model, we use simple String instances\n            to create views from each of the items in the list\n            and populate a scroll panel with them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A simple property list of Strings.","code":["var list = Vars.of(\"One\", \"Two\", \"Three\", \"Four\", \"Five\")"]},

        {"kind":"when","text":"We create a view for our list...","code":["var ui =","    UI.panel(\"fill, wrap 1\")","    .add( UI.label(\"Something to scroll:\") )","    .add( UI.separator() )","    .add(","        UI.scrollPanels().addAll(list, item ->","            UI.panel(\"fill\").id(\"sub-view\")","            .add(\"pushx\", UI.label(item))","            .add(UI.button(\"Delete me!\").onClick(it -> {","                System.out.println(\"Deleting \" + item);","                list.remove(item);","            }))","            .add(UI.button(\"Duplicate\").onClick( it -> {","                int i = list.indexOf(item);","                list.addAt(i, item + \" (copy)\");","            }))","            .add(UI.button(\"up\").onClick( it -> {","                int i = list.indexOf(item);","                if ( i > 0 ) {","                    list.remove(item);","                    list.addAt(i - 1, item);","                }","            }))","            .add(UI.button(\"down\").onClick( it -> {","                int i = list.indexOf(item);","                if ( i < list.size() - 1 ) {","                    list.remove(item);","                    list.addAt(i + 1, item);","                }","            }))","            .add(UI.button(\"replace\").onClick( it -> {","                int i = list.indexOf(item);","                list.setAt(i, \"Replaced!\");","            }))","        )","    )","    .add( UI.separator() )"]},

        {"kind":"and","text":"We build the root component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"then","text":"The view was successfully created.","code":["panel != null"]},

        {"kind":"and","text":"The view contains as many sub-views as the list has items.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]},

        {"kind":"when","text":"We remove an item from the list.","code":["list.removeAt(2)","UI.sync()"]},

        {"kind":"then","text":"The view is updated.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]},

        {"kind":"when","text":"We add an item to the list.","code":["list.add(\"Six\")","UI.sync()"]},

        {"kind":"then","text":"The view is updated.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
