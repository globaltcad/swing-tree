{
  "className":"swingtree.Scroll_Panels_Spec",
  "title":"Scroll Panels",
  "narrative":"This specification is dedicated to showing how to use the\n    `JScrollPanels` class, a custom SwingTree component that\n    is designed to display a list of scrollable panels\n    which can be populated with any kind of interactive UI\n    based on any kind of sub-view model type.",
  "subjects":["swingtree.components.JScrollPanels"],
  "statistics":{
    "runs":"38",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The `JScrollPanels` instance can visually represent a view model consisting of sub-view models.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that we use a pre-made example view model here.\n            Feel free to look at the source code of the view model\n            to see what it is doing.\n            All you need to know is that it is a view model\n            that contains a `Vars` based property list of sub-view models.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the view model.","code":["var vm = new ScrollPanelsViewModel()"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui =","    UI.panel(\"fill, wrap 1\")","    .add( UI.label(\"Something to scroll:\") )","    .add( UI.separator() )","    .add(","        UI.scrollPanels().addAll(vm.entries(), evm ->","            UI.panel(\"fill\").id(\"sub-view\")","            .add(\"pushx\", UI.label(evm.text()))","            .add(UI.label(evm.position().viewAs(String.class, s -> \"Position: \" + s)))","            .add(UI.label(evm.position().viewAs(String.class, s -> \"Selected: \" + s)))","            .add(UI.button(\"Delete me!\").onClick(it -> {","                System.out.println(\"Deleting \" + evm.text().get());","                int i = evm.entries().indexOf(evm);","                evm.entries().removeAt(i);","                if ( i != evm.position().get() )","                    throw new IllegalStateException(\"Index mismatch: \" + i + \" != \" + evm.position().get());","            }))","            .add(UI.button(\"Duplicate\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                evm.entries().addAt(i, evm.createNew(evm.text().get() + \" (copy)\"));","            }))","            .add(UI.button(\"up\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                if ( i > 0 ) {","                    evm.entries().removeAt(i);","                    evm.entries().addAt(i - 1, evm);","                }","            }))","            .add(UI.button(\"down\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                if ( i < evm.entries().size() - 1 ) {","                    evm.entries().removeAt(i);","                    evm.entries().addAt(i + 1, evm);","                }","            }))","            .add(UI.button(\"replace\").onClick( it -> {","                int i = evm.entries().indexOf(evm);","                evm.entries().setAt(i, evm.createNew(\"Replaced!\"));","            }))","        )","    )","    .add( UI.separator() )"]},

        {"kind":"and","text":"We build the root component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"then","text":"It was successfully created.","code":["panel != null"]},

        {"kind":"and","text":"The view contains as many sub-views as the view model has entries.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == vm.entries().size()"]},

        {"kind":"when","text":"We remove an item from the entry list.","code":["vm.entries().removeAt(2)","UI.sync()"]},

        {"kind":"then","text":"The view is updated accordingly.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == vm.entries().size()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use a simple property list of Strings to populate a scroll panel.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Instead of using a view model, we use simple String instances\n            to create views from each of the items in the list\n            and populate a scroll panel with them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A simple property list of Strings.","code":["var list = Vars.of(\"One\", \"Two\", \"Three\", \"Four\", \"Five\")"]},

        {"kind":"when","text":"We create a view for our list...","code":["var ui =","    UI.panel(\"fill, wrap 1\")","    .add( UI.label(\"Something to scroll:\") )","    .add( UI.separator() )","    .add(","        UI.scrollPanels().addAll(list, item ->","            UI.panel(\"fill\").id(\"sub-view\")","            .add(\"pushx\", UI.label(item))","            .add(UI.button(\"Delete me!\").onClick(it -> {","                System.out.println(\"Deleting \" + item);","                list.remove(item);","            }))","            .add(UI.button(\"Duplicate\").onClick( it -> {","                int i = list.indexOf(item);","                list.addAt(i, item + \" (copy)\");","            }))","            .add(UI.button(\"up\").onClick( it -> {","                int i = list.indexOf(item);","                if ( i > 0 ) {","                    list.remove(item);","                    list.addAt(i - 1, item);","                }","            }))","            .add(UI.button(\"down\").onClick( it -> {","                int i = list.indexOf(item);","                if ( i < list.size() - 1 ) {","                    list.remove(item);","                    list.addAt(i + 1, item);","                }","            }))","            .add(UI.button(\"replace\").onClick( it -> {","                int i = list.indexOf(item);","                list.setAt(i, \"Replaced!\");","            }))","        )","    )","    .add( UI.separator() )"]},

        {"kind":"and","text":"We build the root component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"then","text":"The view was successfully created.","code":["panel != null"]},

        {"kind":"and","text":"The view contains as many sub-views as the list has items.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]},

        {"kind":"when","text":"We remove an item from the list.","code":["list.removeAt(2)","UI.sync()"]},

        {"kind":"then","text":"The view is updated.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]},

        {"kind":"when","text":"We add an item to the list.","code":["list.add(\"Six\")","UI.sync()"]},

        {"kind":"then","text":"The view is updated.","code":["new Utility.Query(panel).findAll(\"sub-view\").size() == list.size()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a scroll panel compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Vars.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, -1, -1, -1, -1]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.clear() }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a scroll panel compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panels.getContentPanel().getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a scroll panel bi-directionally and compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title.view(\"\", {it}))","var panels =","            UI.scrollPanels()","            .addAll(models, supplier)","            .get(JScrollPanels)","var panel = panels.getViewport().getComponent(0)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"expect","text":"The components have the correct initial text displayed on them:","code":["panel.getComponents().collect({it.getComponent(0).text}) == [\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\"]"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"when","text":"We unpack the panel contents:","code":["var viewedTexts = panel.getComponents().collect({it.getComponent(0).text})"]},

        {"kind":"then","text":"The view texts a equal to the string representations of the tuple elements.","code":["viewedTexts == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A scroll panels widget maintains the correct state after a series of operations applied to a bound property list.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This unit test demonstrates a scenario where a `Vars` based property list\n            bound to a scroll panels widget goes through a series of operations.\n            After every operation, the state of the scroll panels widget changes\n            accordingly and we also observe that sub-views are also re-used\n            when possible.\n\n            We are going to use the following class declaration as\n            property list item type:\n            ```java\n                public class SimpleEntry implements swingtree.api.mvvm.EntryViewModel {\n                    private final Var<Boolean> selected = Var.of(false);\n                    private final Var<Integer> position = Var.of(0);\n                    private final Var<String> text = Var.of(\"Hello world!\");\n\n                    public SimpleEntry(String text) { this.text.set(text); }\n\n                    public Var<String> text() { return text; }\n                    @Override public Var<Boolean> isSelected() { return selected; }\n                    @Override public Var<Integer> position() { return position; }\n                    @Override public String toString() { return \"Entry@\"+Integer.toHexString(this.hashCode())+\"[\"+this.text.get()+\"]\"; }\n                }\n            ```\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create some constants for the test.","code":["final var ABURAAGE = new SimpleEntry(\"Aburaage\")","final var TEMPEH = new SimpleEntry(\"Tempeh\")","final var TOFU = new SimpleEntry(\"Tofu\")","final var SEITAN = new SimpleEntry(\"Seitan\")","final var MISO = new SimpleEntry(\"Miso\")"]},

        {"kind":"and","text":"A property list of strings and a scroll panels widget.","code":["var list = Vars.of(ABURAAGE, TEMPEH, TOFU, SEITAN, MISO)","var panels = UI.scrollPanels().addAll(list, it -> UI.label(it.text())).get(JScrollPanels)"]},

        {"kind":"and","text":"We unpack the content panel and the initial components:","code":["var contentPanel = panels.getContentPanel()","var iniComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"and","text":"","code":["final var ABURAAGE_LABEL = iniComps[0]","final var TEMPEH_LABEL = iniComps[1]","final var TOFU_LABEL = iniComps[2]","final var SEITAN_LABEL = iniComps[3]","final var MISO_LABEL = iniComps[4]"]},

        {"kind":"expect","text":"The initial components are correctly displayed.","code":["iniComps.collect({it.text}) == [ABURAAGE, TEMPEH, TOFU, SEITAN, MISO].collect({it.text().get()})"]},

        {"kind":"when","text":"We remove the third item from the list.","code":["list.removeAt(2)","UI.sync()","var updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"The third component is removed from the view.","code":["updatedComps.collect({it.text}) == [ABURAAGE, TEMPEH, SEITAN, MISO].collect({it.text().get()})"]},

        {"kind":"and","text":"The labels are re-used.","code":["updatedComps[0] === ABURAAGE_LABEL","updatedComps[1] === TEMPEH_LABEL","updatedComps[2] === SEITAN_LABEL","updatedComps[3] === MISO_LABEL"]},

        {"kind":"when","text":"We now re-add the third item to the list to be at an earlier position.","code":["list.addAt(1, TOFU)","UI.sync()","updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"The third component is re-added to the view.","code":["updatedComps.collect({it.text}) == [ABURAAGE, TOFU, TEMPEH, SEITAN, MISO].collect({it.text().get()})"]},

        {"kind":"and","text":"The labels are re-used, except for the new one.","code":["updatedComps[0] === ABURAAGE_LABEL","updatedComps[1] !== TOFU_LABEL","updatedComps[2] === TEMPEH_LABEL","updatedComps[3] === SEITAN_LABEL","updatedComps[4] === MISO_LABEL"]},

        {"kind":"when","text":"We now replace a single item with itself.","code":["list.setAt(2, TEMPEH)","UI.sync()","updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"Nothing changes in the view.","code":["updatedComps.collect({it.text}) == [ABURAAGE, TOFU, TEMPEH, SEITAN, MISO].collect({it.text().get()})"]},

        {"kind":"and","text":"The labels are re-used except for the tofu label, which remains a new one.","code":["updatedComps[0] === ABURAAGE_LABEL","updatedComps[1] !== TOFU_LABEL","updatedComps[2] === TEMPEH_LABEL","updatedComps[3] === SEITAN_LABEL","updatedComps[4] === MISO_LABEL"]},

        {"kind":"when","text":"We now replace all the items with themselves.","code":["list.setAllAt(0, ABURAAGE, TOFU, TEMPEH, SEITAN, MISO)","UI.sync()","updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"Nothing changes in the view.","code":["updatedComps.collect({it.text}) == [ABURAAGE, TOFU, TEMPEH, SEITAN, MISO].collect({it.text().get()})"]},

        {"kind":"and","text":"The labels are re-used except for the tofu label, which remains a new one.","code":["updatedComps[0] === ABURAAGE_LABEL","updatedComps[1] !== TOFU_LABEL","updatedComps[2] === TEMPEH_LABEL","updatedComps[3] === SEITAN_LABEL","updatedComps[4] === MISO_LABEL"]},

        {"kind":"when","text":"We now add a completely new item to the list.","code":["var natto = new SimpleEntry(\"Natto\")","list.add(natto)","UI.sync()","updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"The new item is added to the view.","code":["updatedComps.collect({it.text}) == [ABURAAGE, TOFU, TEMPEH, SEITAN, MISO, natto].collect({it.text().get()})"]},

        {"kind":"and","text":"The labels are re-used except for the new one.","code":["updatedComps[0] === ABURAAGE_LABEL","updatedComps[1] !== TOFU_LABEL","updatedComps[2] === TEMPEH_LABEL","updatedComps[3] === SEITAN_LABEL","updatedComps[4] === MISO_LABEL","updatedComps[5].text == \"Natto\""]},

        {"kind":"when","text":"We now reverse the order of the list.","code":["list.reversed()","UI.sync()","updatedComps = (0..<contentPanel.getComponentCount()).collect({contentPanel.getComponent(it).getComponent(0)})"]},

        {"kind":"then","text":"The list is reversed in the view.","code":["updatedComps.collect({it.text}) == [natto, MISO, SEITAN, TEMPEH, TOFU, ABURAAGE].collect({it.text().get()})"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
