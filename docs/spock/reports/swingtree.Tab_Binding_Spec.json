{
  "className":"swingtree.Tab_Binding_Spec",
  "title":"Binding Tabs to Properties",
  "narrative":"Tabs are a way to efficiently group related content in a single container.\n    The tabs can be bound to a property, so that the selected tab is always\n    the one that corresponds to the value of the property.\n    You can also model other aspects of a tab using properties, such as\n    whether it is enabled, visible, or has a tooltip.",
  "subjects":[],
  "statistics":{
    "runs":"36",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The selection state of tabs can be modelled through various properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind an integer property to the selected tab index, \n            and multiple boolean properties to the selected state of each tab.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"4 different properties, 1 for each tab and then the selected index property.","code":["var tab1Selected = Var.of(false)","var tab2Selected = Var.of(false)","var tab3Selected = Var.of(false)","var selectedIndex = Var.of(-1)"]},

        {"kind":"and","text":"We create a tabbed pane UI node and attach tabs with custom tab header components to it.","code":["def tabbedPane =","    UI.tabbedPane(UI.Side.TOP).withSelectedIndex(selectedIndex)","    .add(UI.tab(\"Tab 1\").isSelectedIf(tab1Selected))","    .add(UI.tab(\"Tab 2\").isSelectedIf(tab2Selected))","    .add(UI.tab(\"Tab 3\").isSelectedIf(tab3Selected))","    .get(JTabbedPane)"]},

        {"kind":"expect","text":"","code":["tabbedPane.getSelectedIndex() == -1","tabbedPane.getTabCount() == 3"]},

        {"kind":"when","text":"We select the first tab.","code":["tabbedPane.selectedIndex = 0"]},

        {"kind":"then","text":"All properties reflect this change.","code":["selectedIndex.get() == 0","tab1Selected.get() == true","tab2Selected.get() == false","tab3Selected.get() == false"]},

        {"kind":"when","text":"We select the second tab.","code":["tabbedPane.selectedIndex = 1"]},

        {"kind":"then","text":"The selected index property is updated, and the boolean properties are correct too.","code":["selectedIndex.get() == 1","tab2Selected.get() == true","tab1Selected.get() == false","tab3Selected.get() == false"]},

        {"kind":"when","text":"We select the third tab using the boolean property.","code":["tab3Selected.set(true)","UI.sync()"]},

        {"kind":"then","text":"The boolean property is updated, and the selected index property is correct too.","code":["selectedIndex.get() == 2","tab3Selected.get() == true","tab1Selected.get() == false","tab2Selected.get() == false"]},

        {"kind":"when","text":"We change the selected index property to a valid selection.","code":["selectedIndex.set(1)","UI.sync()"]},

        {"kind":"then","text":"All boolean properties are false.","code":["tabbedPane.selectedIndex == 1","tab1Selected.get() == false","tab2Selected.get() == true","tab3Selected.get() == false"]},

        {"kind":"when","text":"We change the selected index property to an invalid selection (not tab selected).","code":["selectedIndex.set(-1)","UI.sync()"]},

        {"kind":"then","text":"All boolean properties are false and the selected index property is -1.","code":["tabbedPane.selectedIndex == -1","tab1Selected.get() == false","tab2Selected.get() == false","tab3Selected.get() == false"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The selection states of tabs can be modelled through boolean properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"3 different properties, 1 for each tab.","code":["var tab1Selected = Var.of(false)","var tab2Selected = Var.of(false)","var tab3Selected = Var.of(false)"]},

        {"kind":"and","text":"We create a tabbed pane UI node and attach tabs with custom tab header components to the properties.","code":["def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(\"Tab 1\").isSelectedIf(tab1Selected))","    .add(UI.tab(\"Tab 2\").isSelectedIf(tab2Selected))","    .add(UI.tab(\"Tab 3\").isSelectedIf(tab3Selected))","    .get(JTabbedPane)"]},

        {"kind":"expect","text":"","code":["tabbedPane.getSelectedIndex() == -1","tabbedPane.getTabCount() == 3"]},

        {"kind":"when","text":"We select the first tab.","code":["tabbedPane.selectedIndex = 0"]},

        {"kind":"then","text":"The properties reflect this change.","code":["tab1Selected.get() == true","tab2Selected.get() == false","tab3Selected.get() == false"]},

        {"kind":"when","text":"We select the second tab.","code":["tabbedPane.selectedIndex = 1"]},

        {"kind":"then","text":"The properties reflect this change, only the second tab is selected.","code":["tab1Selected.get() == false","tab2Selected.get() == true","tab3Selected.get() == false"]},

        {"kind":"when","text":"We select the third tab using the boolean property.","code":["tab3Selected.set(true)","UI.sync()"]},

        {"kind":"then","text":"The boolean properties change to match the selected tab.","code":["tab1Selected.get() == false","tab2Selected.get() == false","tab3Selected.get() == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An unbound tabbed pane has the expect initial state.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a tabbed pane UI node and attach tabs with custom tab header components to it.","code":["def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(\"Tab 1\"))","    .add(UI.tab(\"Tab 2\"))","    .add(UI.tab(\"Tab 3\"))","    .get(JTabbedPane)"]},

        {"kind":"expect","text":"","code":["tabbedPane.getSelectedIndex() == 0","tabbedPane.getTabCount() == 3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A string property can model the title of a tab!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string property to the title of a tab.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string property and a tabbed pane UI node.","code":["var title = Var.of(\"Tab 1\")","def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(title))","    .get(JTabbedPane)"]},

        {"kind":"when","text":"We change the title.","code":["title.set(\"Tab 2\")","UI.sync()"]},

        {"kind":"then","text":"The title of the tab is updated.","code":["tabbedPane.getTitleAt(0) == \"Tab 2\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Icons can be bound to tab headers dynamically.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind an icon property to the icon of a tab.\n            But note that you may not use the `Icon` or `ImageIcon` classes directly,\n            instead you must use implementations of the `IconDeclaration` interface,\n            which merely models the resource location of the icon.\n\n            The reason for this distinction is the fact that traditional Swing icons\n            are heavy objects whose loading may or may not succeed, and so they are\n            not suitable for direct use in a property as part of your view model.\n            Instead, you should use the `IconDeclaration` interface, which is a\n            lightweight value object that merely models the resource location of the icon\n            even if it is not yet loaded or even does not exist at all.\n\n            This is especially useful in case of unit tests for you view model,\n            where the icon may not be available at all, but you still want to test\n            the behaviour of your view model.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an `IconDeclaration`, which is essentially just a resource location value object.","code":["IconDeclaration iconDeclaration = IconDeclaration.of(\"swing.png\")"]},

        {"kind":"and","text":"An icon property and a tabbed pane UI node.","code":["var icon = Var.of(iconDeclaration)","def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(\"Tab 1\").withIcon(icon))","    .get(JTabbedPane)"]},

        {"kind":"when","text":"We change the icon.","code":["IconDeclaration newIcon = IconDeclaration.of(\"seed.png\")","icon.set(newIcon)","UI.sync()"]},

        {"kind":"then","text":"The icon of the tab is updated.","code":["tabbedPane.getIconAt(0) == newIcon.find().get()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Properties allow you to enable or disable individual tabs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a boolean property to the enabled state of a tab.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"2 properties and a tabbed pane UI node.","code":["var enabled1 = Var.of(true)","var enabled2 = Var.of(true)","def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(\"Tab 1\").isEnabledIf(enabled1))","    .add(UI.tab(\"Tab 2\").isEnabledIf(enabled2))","    .get(JTabbedPane)"]},

        {"kind":"when","text":"We disable the first tab.","code":["enabled1.set(false)","UI.sync()"]},

        {"kind":"then","text":"The first tab is disabled.","code":["tabbedPane.isEnabledAt(0) == false"]},

        {"kind":"when","text":"We disable the second tab.","code":["enabled2.set(false)","UI.sync()"]},

        {"kind":"then","text":"The second tab is disabled.","code":["tabbedPane.isEnabledAt(1) == false"]},

        {"kind":"when","text":"We enable the first tab.","code":["enabled1.set(true)","UI.sync()"]},

        {"kind":"then","text":"The first tab is enabled.","code":["tabbedPane.isEnabledAt(0) == true"]},

        {"kind":"when","text":"We enable the second tab.","code":["enabled2.set(true)","UI.sync()"]},

        {"kind":"then","text":"The second tab is enabled.","code":["tabbedPane.isEnabledAt(1) == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Modelling the tooltip of a tab is also possible.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string property to the tooltip of a tab.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string property and a tabbed pane UI node.","code":["var tooltip = Var.of(\"I am a tooltip!\")","def tabbedPane =","    UI.tabbedPane(UI.Side.TOP)","    .add(UI.tab(\"Tab 1\").withTip(tooltip))","    .get(JTabbedPane)"]},

        {"kind":"when","text":"We change the tooltip.","code":["tooltip.set(\"I am a new tooltip!\")","UI.sync()"]},

        {"kind":"then","text":"The tooltip of the tab is updated.","code":["tabbedPane.getToolTipTextAt(0) == \"I am a new tooltip!\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Content rich tabs can be represented dynamically from property lists.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case it is useful\n            to represent your view models as property lists, especially if \n            one view consists of multiple sub views.\n\n            This is also true for the tabbed pane, whose sub-views\n            are the tabs!\n            To make this possible implement the 'TabSupplier' interface so\n            you can bind it to a view using the \"Vars\" class wrapping your tabs.\n            When the property list changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> address = Var.of(\"123 Main Street\")","Var<String> title = Var.of(\"Mr.\")","Var<Integer> price = Var.of(1000000)","Var<DayOfWeek> day = Var.of(DayOfWeek.MONDAY)"]},

        {"kind":"and","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","TabSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.tab(\"T1\").add(","                            UI.panel().id(\"sub-1\")","                            .add(UI.label(\"Address:\"))","                            .add(UI.textField(address))","                            .add(UI.button(\"Update\").onClick( it -> address.set(\"456 Main Street\") ))","                        )","        case \"Dummy View Model 2\":","                return UI.tab(\"T2\").add(","                            UI.panel().id(\"sub-2\")","                            .add(UI.label(\"Title:\"))","                            .add(UI.textField(title))","                            .add(UI.button(\"Update\").onClick( it -> title.set(\"Mrs.\") ))","                        )","        case \"Dummy View Model 3\":","                return UI.tab(\"T3\").add(","                            UI.panel().id(\"sub-3\")","                            .add(UI.label(\"Price:\"))","                            .add(UI.slider(UI.Align.HORIZONTAL).withValue(price))","                            .add(UI.button(\"Update\").onClick( it -> price.set(2000000.0) ))","                        )","        case \"Dummy View Model 4\":","                    return UI.tab(\"T4\").add(","                            UI.panel().id(\"sub-4\")","                            .add(UI.label(\"Option:\"))","                            .add(UI.comboBox(day, DayOfWeek.values()))","                            .add(UI.button(\"Update\").onClick( it -> day.set(DayOfWeek.WEDNESDAY) ))","                        )","                }","            }"]},

        {"kind":"and","text":"A property list storing the view models.","code":["var vms = Vars.of(vm1, vm2, vm3, vm4)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property list.","code":["var ui = UI.panel()","        .add(UI.label(\"Dynamic Super View:\"))","        .add(UI.tabbedPane().id(\"super\").addAll(vms, viewer))"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We remove something from the view model property list.","code":["vms.remove(vm2)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.removeAt(2) // vm4","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" and \"sub-4\" views.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We reintroduce \"vm2\"...","code":["vms.add(vm2)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-4\" view.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We clear the view model property list.","code":["vms.clear()","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Content rich tabs can be represented dynamically from a tuple property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case it is useful\n            to represent your view models as property lists, especially if \n            one view consists of multiple sub views.\n\n            This is also true for the tabbed pane, whose sub-views\n            are the tabs!\n            To make this possible implement the 'TabSupplier' interface so\n            you can bind it to a view using a `Tuple` based `Val` property wrapping your tabs.\n            When the tuple property changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> address = Var.of(\"123 Main Street\")","Var<String> title = Var.of(\"Mr.\")","Var<Integer> price = Var.of(1000000)","Var<DayOfWeek> day = Var.of(DayOfWeek.MONDAY)"]},

        {"kind":"and","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","TabSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.tab(\"T1\").add(","                            UI.panel().id(\"sub-1\")","                            .add(UI.label(\"Address:\"))","                            .add(UI.textField(address))","                            .add(UI.button(\"Update\").onClick( it -> address.set(\"456 Main Street\") ))","                        )","        case \"Dummy View Model 2\":","                return UI.tab(\"T2\").add(","                            UI.panel().id(\"sub-2\")","                            .add(UI.label(\"Title:\"))","                            .add(UI.textField(title))","                            .add(UI.button(\"Update\").onClick( it -> title.set(\"Mrs.\") ))","                        )","        case \"Dummy View Model 3\":","                return UI.tab(\"T3\").add(","                            UI.panel().id(\"sub-3\")","                            .add(UI.label(\"Price:\"))","                            .add(UI.slider(UI.Align.HORIZONTAL).withValue(price))","                            .add(UI.button(\"Update\").onClick( it -> price.set(2000000.0) ))","                        )","        case \"Dummy View Model 4\":","                    return UI.tab(\"T4\").add(","                            UI.panel().id(\"sub-4\")","                            .add(UI.label(\"Option:\"))","                            .add(UI.comboBox(day, DayOfWeek.values()))","                            .add(UI.button(\"Update\").onClick( it -> day.set(DayOfWeek.WEDNESDAY) ))","                        )","                }","            }"]},

        {"kind":"and","text":"A tuple property storing the view models.","code":["var models = Tuple.of(vm1, vm2, vm3, vm4)","var vms = Var.of(models)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property list.","code":["var ui = UI.panel()","        .add(UI.label(\"Dynamic Super View:\"))","        .add(UI.tabbedPane().id(\"super\").addAll(vms, viewer))"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We remove something from the view model property list.","code":["vms.update( it -> it.remove(vm2) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.update( it -> it.removeAt(2) ) // vm4","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" and \"sub-4\" views.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We reintroduce \"vm2\"...","code":["vms.update( it -> it.add(vm2) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-4\" view.","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We clear the view model property list.","code":["vms.update( it -> it.clear() )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["new Utility.Query(panel).find(JTabbedPane, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can bind a property list and a tab supplier to dynamically add or remove tabs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string property list and a tab supplier to dynamically add or remove tabs.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string property list, a tab supplier and a tabbed pane UI node.","code":["Vars<String> tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def tabbedPane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"when","text":"We remove the tab at index 1.","code":["tabs.removeAt(1)","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab removed.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 3\"","tabbedPane.getTitleAt(2) == \"Tab 4\"","tabbedPane.getTitleAt(3) == \"Tab 5\""]},

        {"kind":"when","text":"We remove 2 tabs starting from index 1.","code":["tabs.removeAt(1, 2)","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs removed.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 5\""]},

        {"kind":"when","text":"We update the tab at index 1.","code":["tabs.setAt(1, \"Tab 2\")","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab updated.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\""]},

        {"kind":"when","text":"We add a tab.","code":["tabs.add(\"Tab 3\")","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab added.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\""]},

        {"kind":"when","text":"We add 2 tabs.","code":["tabs.addAll(\"Tab 4\", \"Tab 5\")","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs added.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\"","tabbedPane.getTitleAt(3) == \"Tab 4\"","tabbedPane.getTitleAt(4) == \"Tab 5\""]},

        {"kind":"when","text":"We insert 1 tab.","code":["tabs.addAt(0, \"Tab 0\")","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs inserted.","code":["tabbedPane.getTabCount() == tabs.size()","tabbedPane.getTitleAt(0) == \"Tab 0\"","tabbedPane.getTitleAt(1) == \"Tab 1\"","tabbedPane.getTitleAt(2) == \"Tab 2\"","tabbedPane.getTitleAt(3) == \"Tab 3\"","tabbedPane.getTitleAt(4) == \"Tab 4\"","tabbedPane.getTitleAt(5) == \"Tab 5\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can bind a tuple property and a tab supplier to dynamically add or remove tabs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs.\n        ","\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def tabbedPane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"when","text":"We remove the tab at index 1.","code":["tabs.update( it -> it.removeAt(1) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 3\"","tabbedPane.getTitleAt(2) == \"Tab 4\"","tabbedPane.getTitleAt(3) == \"Tab 5\""]},

        {"kind":"when","text":"We remove 2 tabs starting from index 1.","code":["tabs.update( it -> it.removeAt(1, 2) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 5\""]},

        {"kind":"when","text":"We update the tab at index 1.","code":["tabs.update( it -> it.setAt(1, \"Tab 2\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab updated.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\""]},

        {"kind":"when","text":"We add a tab.","code":["tabs.update( it -> it.add(\"Tab 3\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\""]},

        {"kind":"when","text":"We add 2 tabs.","code":["tabs.update( it -> it.addAll(\"Tab 4\", \"Tab 5\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\"","tabbedPane.getTitleAt(3) == \"Tab 4\"","tabbedPane.getTitleAt(4) == \"Tab 5\""]},

        {"kind":"when","text":"We insert 1 tab.","code":["tabs.update( it -> it.addAt(0, \"Tab 0\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs inserted.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 0\"","tabbedPane.getTitleAt(1) == \"Tab 1\"","tabbedPane.getTitleAt(2) == \"Tab 2\"","tabbedPane.getTitleAt(3) == \"Tab 3\"","tabbedPane.getTitleAt(4) == \"Tab 4\"","tabbedPane.getTitleAt(5) == \"Tab 5\"","reportInfo \"\"\"","    You can bind a string based tuple property and a tab supplier","    to dynamically add or remove tabs.","\"\"\""]},

        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def tabbedPane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"when","text":"We remove the tab at index 1.","code":["tabs.update( it -> it.removeAt(1) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 3\"","tabbedPane.getTitleAt(2) == \"Tab 4\"","tabbedPane.getTitleAt(3) == \"Tab 5\""]},

        {"kind":"when","text":"We remove 2 tabs starting from index 1.","code":["tabs.update( it -> it.removeAt(1, 2) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 5\""]},

        {"kind":"when","text":"We update the tab at index 1.","code":["tabs.update( it -> it.setAt(1, \"Tab 2\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab updated.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\""]},

        {"kind":"when","text":"We add a tab.","code":["tabs.update( it -> it.add(\"Tab 3\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\""]},

        {"kind":"when","text":"We add 2 tabs.","code":["tabs.update( it -> it.addAll(\"Tab 4\", \"Tab 5\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\"","tabbedPane.getTitleAt(3) == \"Tab 4\"","tabbedPane.getTitleAt(4) == \"Tab 5\""]},

        {"kind":"when","text":"We insert 1 tab.","code":["tabs.update( it -> it.addAt(0, \"Tab 0\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs inserted.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 0\"","tabbedPane.getTitleAt(1) == \"Tab 1\"","tabbedPane.getTitleAt(2) == \"Tab 2\"","tabbedPane.getTitleAt(3) == \"Tab 3\"","tabbedPane.getTitleAt(4) == \"Tab 4\"","tabbedPane.getTitleAt(5) == \"Tab 5\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property list is bound to a tabbed pane compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a tab supplier and a tabbed pane UI node.","code":["var tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["operation(tabs)","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == tabs.size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0, -1, 2, 3, 4]","[0, -1, -1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can bind a tuple property and a tab supplier to dynamically add or remove tabs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def tabbedPane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"when","text":"We remove the tab at index 1.","code":["tabs.update( it -> it.removeAt(1) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 3\"","tabbedPane.getTitleAt(2) == \"Tab 4\"","tabbedPane.getTitleAt(3) == \"Tab 5\""]},

        {"kind":"when","text":"We remove 2 tabs starting from index 1.","code":["tabs.update( it -> it.removeAt(1, 2) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 5\""]},

        {"kind":"when","text":"We update the tab at index 1.","code":["tabs.update( it -> it.setAt(1, \"Tab 2\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab updated.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\""]},

        {"kind":"when","text":"We add a tab.","code":["tabs.update( it -> it.add(\"Tab 3\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\""]},

        {"kind":"when","text":"We add 2 tabs.","code":["tabs.update( it -> it.addAll(\"Tab 4\", \"Tab 5\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\"","tabbedPane.getTitleAt(3) == \"Tab 4\"","tabbedPane.getTitleAt(4) == \"Tab 5\""]},

        {"kind":"when","text":"We insert 1 tab.","code":["tabs.update( it -> it.addAt(0, \"Tab 0\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs inserted.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 0\"","tabbedPane.getTitleAt(1) == \"Tab 1\"","tabbedPane.getTitleAt(2) == \"Tab 2\"","tabbedPane.getTitleAt(3) == \"Tab 3\"","tabbedPane.getTitleAt(4) == \"Tab 4\"","tabbedPane.getTitleAt(5) == \"Tab 5\"","reportInfo \"\"\"","    You can bind a string based tuple property and a tab supplier","    to dynamically add or remove tabs.","\"\"\""]},

        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def tabbedPane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(tabs, supplier)","                .get(JTabbedPane)"]},

        {"kind":"when","text":"We remove the tab at index 1.","code":["tabs.update( it -> it.removeAt(1) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 3\"","tabbedPane.getTitleAt(2) == \"Tab 4\"","tabbedPane.getTitleAt(3) == \"Tab 5\""]},

        {"kind":"when","text":"We remove 2 tabs starting from index 1.","code":["tabs.update( it -> it.removeAt(1, 2) )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs removed.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 5\""]},

        {"kind":"when","text":"We update the tab at index 1.","code":["tabs.update( it -> it.setAt(1, \"Tab 2\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab updated.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\""]},

        {"kind":"when","text":"We add a tab.","code":["tabs.update( it -> it.add(\"Tab 3\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tab added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\""]},

        {"kind":"when","text":"We add 2 tabs.","code":["tabs.update( it -> it.addAll(\"Tab 4\", \"Tab 5\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs added.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 1\"","tabbedPane.getTitleAt(1) == \"Tab 2\"","tabbedPane.getTitleAt(2) == \"Tab 3\"","tabbedPane.getTitleAt(3) == \"Tab 4\"","tabbedPane.getTitleAt(4) == \"Tab 5\""]},

        {"kind":"when","text":"We insert 1 tab.","code":["tabs.update( it -> it.addAt(0, \"Tab 0\") )","UI.sync()"]},

        {"kind":"then","text":"The tabbed pane is updated and the tabs inserted.","code":["tabbedPane.getTabCount() == tabs.get().size()","tabbedPane.getTitleAt(0) == \"Tab 0\"","tabbedPane.getTitleAt(1) == \"Tab 1\"","tabbedPane.getTitleAt(2) == \"Tab 2\"","tabbedPane.getTitleAt(3) == \"Tab 3\"","tabbedPane.getTitleAt(4) == \"Tab 4\"","tabbedPane.getTitleAt(5) == \"Tab 5\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a tabbed pane compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a tab supplier \n            to dynamically add or remove tabs. The GUI will only update the\n            tabs that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a tab supplier and a tabbed pane UI node.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var models = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> UI.tab(title)","def pane =","        UI.tabbedPane(UI.Side.TOP)","                .addAll(models, supplier)","                .get(JTabbedPane)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<pane.getTabCount()).collect({pane.getComponentAt(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["pane.getTabCount() == models.get().size()","pane.getTabCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Tab X\") }","{ it.add(\"Tab X\") }","{ it.addAll(\"Tab X\", \"Tab Y\") }","{ it.addAt(0, \"Tab X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ it.clear().addAll(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\") }","{ Tuple.of(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }","{ it.clear().addAll(\"Tab a\", \"Tab b\", \"Tab c\", \"Tab d\", \"Tab e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An exception in the tab supplier for a model property list, produces an error tab instead.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A fundamental requirement when it comes to binding a list of models to\n            a set of UI components is that the number of models and the number of\n            UI components must match. If they do not, the list change listeners \n            will not know which model corresponds to which UI component.\n\n            This is why in case of an exception, a sort of dummy tab is created.\n            It indicates that something went wrong and the tab could not be created.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A property list and a tab supplier that throws an exception.","code":["Vars<String> tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> {","    if ( title == \"Tab 3\" ) {","        throw new RuntimeException(\"This tab could not be created!\")","    }","    return UI.tab(title)","}"]},

        {"kind":"and","text":"A UI declaration with a tabbed pane bound to the property list and the tab supplier.","code":["def ui = UI.tabbedPane(UI.Side.TOP).addAll(tabs, supplier)"]},

        {"kind":"when","text":"We build the component.","code":["var tabbedPane = ui.get(JTabbedPane)"]},

        {"kind":"then","text":"First of all, the exception does not leak to the outside.","code":["noExceptionThrown()"]},

        {"kind":"and","text":"We expect the tabbed pane to have 5 tabs, even though one of them is an error tab.","code":["tabbedPane.getTabCount() == 5"]},

        {"kind":"and","text":"We expect the error tab to have the correct title.","code":["tabbedPane.getTitleAt(2).contains(\"Error\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An exception in the tab supplier for a model tuple property, produces an error tab instead.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A fundamental requirement when it comes to binding a tuple of models to\n            a set of UI components is that the number of models and the number of\n            UI components must match. If they do not, the tuple property change listeners \n            will not know which model corresponds to which UI component.\n\n            This is why in case of an exception, a sort of dummy tab is created.\n            It indicates that something went wrong and the tab could not be created.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property and a tab supplier that throws an exception.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> {","    if ( title == \"Tab 3\" ) {","        throw new RuntimeException(\"This tab could not be created!\")","    }","    return UI.tab(title)","}"]},

        {"kind":"and","text":"A UI declaration with a tabbed pane bound to the tuple property and the tab supplier.","code":["def ui = UI.tabbedPane(UI.Side.TOP).addAll(tabs, supplier)"]},

        {"kind":"when","text":"We build the component.","code":["var tabbedPane = ui.get(JTabbedPane)"]},

        {"kind":"then","text":"First of all, the exception does not leak to the outside.","code":["noExceptionThrown()"]},

        {"kind":"and","text":"We expect the tabbed pane to have 5 tabs, even though one of them is an error tab.","code":["tabbedPane.getTabCount() == 5"]},

        {"kind":"and","text":"We expect the error tab to have the correct title.","code":["tabbedPane.getTitleAt(2).contains(\"Error\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"If the tab supplier for a model property list returns `null`, a null tab is shown instead",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A fundamental requirement when it comes to binding a list of models to\n            a set of UI components is that the number of models and the number of\n            UI components must match. If they do not, the list change listeners \n            will not know which model corresponds to which UI component.\n\n            So in case of a `null` return value, a sort of dummy tab is created and\n            added to the tabbed pane. \n            It indicates that something went wrong and the tab could not be created.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A property list and a tab supplier that returns `null`.","code":["Vars<String> tabs = Vars.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","TabSupplier<String> supplier = (String title) -> {","    if ( title == \"Tab 3\" ) {","        return null","    }","    return UI.tab(title)","}"]},

        {"kind":"and","text":"A UI declaration with a tabbed pane bound to the property list and the tab supplier.","code":["def ui = UI.tabbedPane(UI.Side.TOP).addAll(tabs, supplier)"]},

        {"kind":"when","text":"We build the component.","code":["var tabbedPane = ui.get(JTabbedPane)"]},

        {"kind":"then","text":"We expect the tabbed pane to have 5 tabs, even though one of them is a null tab.","code":["tabbedPane.getTabCount() == 5"]},

        {"kind":"and","text":"We expect the null tab to have a title which indicates that content is missing.","code":["tabbedPane.getTitleAt(2).contains(\"Empty\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"If the tab supplier for a model tuple property returns `null`, a null tab is shown instead",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A fundamental requirement when it comes to binding a tuple of models to\n            a set of UI components is that the number of models and the number of\n            UI components must match. If they do not, the tuple property change listeners \n            will not know which model corresponds to which UI component.\n\n            So in case of a `null` return value, a sort of dummy tab is created and\n            added to the tabbed pane so that the number of tabs and models match.\n            It also indicates that something went wrong and the tab could not be created.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property and a tab supplier that returns `null`.","code":["var tuple = Tuple.of(\"Tab 1\", \"Tab 2\", \"Tab 3\", \"Tab 4\", \"Tab 5\")","var tabs = Var.of(tuple)","TabSupplier<String> supplier = (String title) -> {","    if ( title == \"Tab 3\" ) {","        return null","    }","    return UI.tab(title)","}"]},

        {"kind":"and","text":"A UI declaration with a tabbed pane bound to the property list and the tab supplier.","code":["def ui = UI.tabbedPane(UI.Side.TOP).addAll(tabs, supplier)"]},

        {"kind":"when","text":"We build the component.","code":["var tabbedPane = ui.get(JTabbedPane)"]},

        {"kind":"then","text":"We expect the tabbed pane to have 5 tabs, even though one of them is a null tab.","code":["tabbedPane.getTabCount() == 5"]},

        {"kind":"and","text":"We expect the null tab to have a title which indicates that content is missing.","code":["tabbedPane.getTitleAt(2).contains(\"Empty\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
