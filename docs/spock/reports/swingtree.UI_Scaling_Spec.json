{
  "className":"swingtree.UI_Scaling_Spec",
  "title":"High IPD Scaling",
  "narrative":"Higher resolution displays with higher pixel density\n    (measured in pixels per inch (PPI) or dots per inch (DPI)) have become the norm.\n    This is especially true for mobile devices, but it is also true for desktop displays.\n\n    Vanilla Swing does not handle this well unfortunately, even with the introduction of\n    the HiDPI support in Java 9, which allows us to determine the DPI of the display.\n    Because although we calculate the scaling factor, there is no way to apply it to the UI.\n    Instead the task is left to the Look and Feel implementations which may or may not\n    scale the UI.\n    The problem is that older Look and Feels do not scale the UI, and even newer ones\n    may not scale the UI at all.\n    In fact none of the Look and Feels included in the JDK scale the UI.\n\n    SwingTree can hardly solve this problem entirely, but it can help by scaling the UI\n    where the Look and Feel does not.\n    In this specification you will find out how to adjust the SwingTree scaling factor\n    and how it affects the properties of the UI components.",
  "subjects":[],
  "statistics":{
    "runs":"25",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The dimensionality of components will be scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"when","text":"We build a simple panel with a number of various components and custom dimensions","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(","        UI.button(\"Button\")","        .withPrefSize(100, 50)","        .withMinSize(75, 25)","        .withMaxSize(70, 50)","        .withSize(150, 50)","    )","    .add(","        UI.toggleButton(\"Toggle Button\")","        .withPrefSize(Size.of(111, 52))","        .withMinSize(Size.of(86, 23))","        .withMaxSize(Size.of(90, 67))","        .withSize(Size.of(121, 44))","    )","    .add(","        UI.slider(UI.Align.HORIZONTAL)","        .withPrefSize(new Dimension(60, 20))","        .withMinSize(new Dimension(70, 80))","        .withMaxSize(new Dimension(80, 42))","        .withSize(new Dimension(120, 40))","    )","    .add(","        UI.label(\"Label\")","        .withPrefWidth(142)","        .withMinWidth(110)","        .withMaxWidth(90)","        .withWidth(284)","    )","    .add(","        UI.textField(\"TextField\")","        .withPrefHeight(30)","        .withMinHeight(36)","        .withMaxHeight(40)","        .withHeight(60)","    )","    .add(","        UI.textArea(\"TextArea\")","        .withSizeExactly(Size.of(55, 88))","    )","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button       = panel.components[0]","var toggleButton = panel.components[1]","var slider       = panel.components[2]","var label        = panel.components[3]","var textField    = panel.components[4]","var textArea     = panel.components[5]"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(200, 100)","button.minimumSize == new Dimension(150, 50)","button.maximumSize == new Dimension(140, 100)","button.size == new Dimension(300, 100)","toggleButton.preferredSize == new Dimension(222, 104)","toggleButton.minimumSize == new Dimension(172, 46)","toggleButton.maximumSize == new Dimension(180, 134)","toggleButton.size == new Dimension(242, 88)","slider.preferredSize == new Dimension(120, 40)","slider.minimumSize == new Dimension(140, 160)","slider.maximumSize == new Dimension(160, 84)","slider.size == new Dimension(240, 80)","label.preferredSize.width == 284","label.minimumSize.width == 220","label.maximumSize.width == 180","label.size.width == 568","textField.preferredSize.height == 60","textField.minimumSize.height == 72","textField.maximumSize.height == 80","textField.size.height == 120","textArea.preferredSize == new Dimension(110, 176)","textArea.minimumSize == new Dimension(110, 176)","textArea.maximumSize == new Dimension(110, 176)","textArea.size == new Dimension(0, 0)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The dimensionality specified in the styling API are scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The preferred API for changing how a component looks is the styling API of SwingTree.\n            The styling API allows you to style components based on functional styler lambdas\n            which are executed eagerly before every repaint.\n            That means that you can determine the dimensions of a component based on \n            some current context (e.g. the size of the parent component) dynamically. \n            How cool is that? :) \n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"when","text":"We build a simple panel with a number of various components and custom dimensions","code":["var panel =","    UI.panel()","    .add(","        UI.textArea(\"TextArea\").withStyle( it -> it","            .prefSize(75, 25)","            .minSize(70, 30)","            .maxSize(60, 22)","            .size(150, 40)","        )","    )","    .add(","        UI.toggleButton(\"ToggleButton\").withStyle( it -> it","            .prefSize(Size.of(60, 20))","            .minSize(Size.of(70, 80))","            .maxSize(Size.of(80, 42))","            .size(Size.of(120, 40))","        )","    )","    .add(","        UI.comboBox(\"ComboBox\").withStyle( it -> it","            .prefWidth(142)","            .minWidth(110)","            .maxWidth(90)","            .width(284)","        )","    )","    .add(","        UI.passwordField().withStyle( it -> it","            .prefHeight(30)","            .minHeight(36)","            .maxHeight(40)","            .height(60)","        )","    )","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var textArea = panel.components[0]","var toggleButton = panel.components[1]","var comboBox = panel.components[2]","var passwordField = panel.components[3]"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["textArea.preferredSize == new Dimension(150, 50)","textArea.minimumSize == new Dimension(140, 60)","textArea.maximumSize == new Dimension(120, 44)","textArea.size == new Dimension(300, 80)","toggleButton.preferredSize == new Dimension(120, 40)","toggleButton.minimumSize == new Dimension(140, 160)","toggleButton.maximumSize == new Dimension(160, 84)","toggleButton.size == new Dimension(240, 80)","comboBox.preferredSize.width == 284","comboBox.minimumSize.width == 220","comboBox.maximumSize.width == 180","comboBox.size.width == 568","passwordField.preferredSize.height == 60","passwordField.minimumSize.height == 72","passwordField.maximumSize.height == 80","passwordField.size.height == 120"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Dimensionality scaling also works for bound properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            SwingTree supports MVI, MVL and MVVM (Model-View-ViewModel) and therefore allows you to bind\n            properties of the UI components to properties of a view model.\n            The values of properties modeling the dimensionality of the components are also scaled by the\n            scaling factor when applied to the UI components dynamically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 2.0","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"and","text":"We create a whole lot of properties:","code":["var prefSize = Var.of(Size.of(70, 50))","var minSize  = Var.of(Size.of(75, 25))","var maxSize  = Var.of(Size.of(80, 45))","var size     = Var.of(Size.of(20, 22))","var prefWidth  = Var.of(142)","var minWidth   = Var.of(110)","var maxWidth   = Var.of(90)","var width      = Var.of(284)","var prefHeight = Var.of(30)","var minHeight  = Var.of(36)","var maxHeight  = Var.of(40)","var height     = Var.of(66)"]},

        {"kind":"and","text":"We create a UI with a button where all of these properties are bound to:","code":["var panel =","    UI.panel()","    .add(","        UI.button(\"Button\")","        .withPrefSize(prefSize)","        .withMinSize(minSize)","        .withMaxSize(maxSize)","        .withSize(size)","        .withPrefWidth(prefWidth)","        .withMinWidth(minWidth)","        .withMaxWidth(maxWidth)","        .withWidth(width)","        .withPrefHeight(prefHeight)","        .withMinHeight(minHeight)","        .withMaxHeight(maxHeight)","        .withHeight(height)","    )","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0]"]},

        {"kind":"expect","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(284, 60)","button.minimumSize == new Dimension(220, 72)","button.maximumSize == new Dimension(180, 80)","button.size == new Dimension(568, 132)"]},

        {"kind":"when","text":"We change the first set of properties...","code":["prefSize.set(Size.of(200, 100))","minSize.set(Size.of(150, 50))","maxSize.set(Size.of(140, 100))","size.set(Size.of(300, 100))","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(400, 200)","button.minimumSize == new Dimension(300, 100)","button.maximumSize == new Dimension(280, 200)","button.size == new Dimension(600, 200)"]},

        {"kind":"when","text":"We change the second set of properties...","code":["prefWidth.set(200)","minWidth.set(150)","maxWidth.set(140)","width.set(300)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(400, 200)","button.minimumSize == new Dimension(300, 100)","button.maximumSize == new Dimension(280, 200)","button.size == new Dimension(600, 200)"]},

        {"kind":"when","text":"We change the third set of properties...","code":["prefHeight.set(60)","minHeight.set(72)","maxHeight.set(80)","height.set(120)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(400, 120)","button.minimumSize == new Dimension(300, 144)","button.maximumSize == new Dimension(280, 160)","button.size == new Dimension(600, 240)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Dimensionality scaling works for properties bound to `withSizeExactly`, `withWidthExactly` and `withHeightExactly`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            SwingTree supports MVI, MVL and MVVM (Model-View-ViewModel) and therefore allows you to bind\n            properties of the UI components to properties of a view model.\n            The values of properties modeling the dimensionality of the components are also scaled by the\n            scaling factor when applied to the UI components dynamically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 2.0","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"and","text":"We create a whole lot of properties:","code":["var size   = Var.of(Size.of(73, 42))","var width  = Var.of(128)","var height = Var.of(52)"]},

        {"kind":"and","text":"We create a UI with a button where all of these properties are bound to:","code":["var panel =","    UI.panel()","    .add(","        UI.button(\"Button\")","        .withSizeExactly(size)","        .withWidthExactly(width)","        .withHeightExactly(height)","    )","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0]"]},

        {"kind":"expect","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(256, 104)","button.minimumSize == new Dimension(256, 104)","button.maximumSize == new Dimension(256, 104)","button.size == new Dimension(0, 0)"]},

        {"kind":"when","text":"We change the first set of properties...","code":["size.set(Size.of(300, 100))","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(600, 200)","button.minimumSize == new Dimension(600, 200)","button.maximumSize == new Dimension(600, 200)","button.size == new Dimension(0, 0)"]},

        {"kind":"when","text":"We change the second set of properties...","code":["width.set(777)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(1554, 200)","button.minimumSize == new Dimension(1554, 200)","button.maximumSize == new Dimension(1554, 200)","button.size == new Dimension(0, 0)"]},

        {"kind":"when","text":"We change the third set of properties...","code":["height.set(120)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(1554, 240)","button.minimumSize == new Dimension(1554, 240)","button.maximumSize == new Dimension(1554, 240)","button.size == new Dimension(0, 0)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Dimensionality scaling works for properties bound to `withSizeExactly(Val,Val)`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            SwingTree supports MVI, MVL and MVVM (Model-View-ViewModel) and therefore allows you to bind\n            properties of the UI components to properties of a view model.\n            The values of properties modeling the dimensionality of the components are also scaled by the\n            scaling factor when applied to the UI components dynamically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 2.0","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"and","text":"We create a whole lot of properties:","code":["var width  = Var.of(128)","var height = Var.of(52)"]},

        {"kind":"and","text":"We create a UI with a button where all of these properties are bound to:","code":["var panel =","    UI.panel()","    .add(","        UI.button(\"Button\")","        .withSizeExactly(width,height)","    )","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0]"]},

        {"kind":"expect","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(256, 104)","button.minimumSize == new Dimension(256, 104)","button.maximumSize == new Dimension(256, 104)","button.size == new Dimension(0, 0)"]},

        {"kind":"when","text":"We change the widths of the component...","code":["width.set(777)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(1554, 104)","button.minimumSize == new Dimension(1554, 104)","button.maximumSize == new Dimension(1554, 104)","button.size == new Dimension(0, 0)"]},

        {"kind":"when","text":"We change the heights of the component through the property...","code":["height.set(120)","UI.sync() // We need to wait for the UI thread to update the UI"]},

        {"kind":"then","text":"The specified dimensions of the components will be scaled by the scaling factor","code":["button.preferredSize == new Dimension(1554, 240)","button.minimumSize == new Dimension(1554, 240)","button.maximumSize == new Dimension(1554, 240)","button.size == new Dimension(0, 0)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can get a reactive view on the current UI scale to update you components dynamically!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The UI scale factor built into the SwingTree library\n            can be viewed reactively and without fearing memory leaks.\n            This is done by getting a reactive property view from\n            the SwingTree library context.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"Then we create a reactive property and a list acting as change listener trace...","code":["var trace = []","var reactiveScale = SwingTree.get().createAndGetUiScaleView().onChange(From.ALL, {","    trace.add(it.currentValue().orElseThrow())","})"]},

        {"kind":"when","text":"","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"then","text":"","code":["trace == [2f]"]},

        {"kind":"when","text":"","code":["SwingTree.get().setUiScaleFactor(1.234567f)"]},

        {"kind":"then","text":"","code":["trace == [2f, 1.25f] // rounded"]},

        {"kind":"when","text":"","code":["SwingTree.get().setUiScaleFactor(42f)"]},

        {"kind":"then","text":"","code":["trace == [2f, 1.25f, 42f]"]},

        {"kind":"when","text":"We set the reactive property to null, to indicate that we no longer need to listen to it!","code":["reactiveScale = null","waitForGarbageCollection()","SwingTree.get().setUiScaleFactor(3.456f)"]},

        {"kind":"then","text":"The trace has not grown, despite setting a new scale globally!","code":["trace == [2f, 1.25f, 42f]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Component dimensions update reactively when UI scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"A button with fixed dimensions","code":["var button =","    UI.button(\"Scale Me!\")","    .withPrefSize(100, 50)","    .withMinSize(75, 25)","    .withMaxSize(150, 75)","    .get(JButton)"]},

        {"kind":"expect","text":"Initial dimensions are at 1x scale","code":["button.preferredSize == new Dimension(100, 50)","button.minimumSize == new Dimension(75, 25)","button.maximumSize == new Dimension(150, 75)"]},

        {"kind":"when","text":"UI scale changes to 2x","code":["SwingTree.get().setUiScaleFactor(2.0f)","UI.sync() // Wait for UI updates"]},

        {"kind":"then","text":"Dimensions are scaled by 2x","code":["button.preferredSize == new Dimension(200, 100)","button.minimumSize == new Dimension(150, 50)","button.maximumSize == new Dimension(300, 150)"]},

        {"kind":"when","text":"UI scale changes to 1.5x","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"Dimensions are scaled by 1.5x","code":["button.preferredSize == new Dimension(150, 75)","button.minimumSize == new Dimension(113, 38) // 75*1.5=112.5 -> 113, 25*1.5=37.5 -> 38","button.maximumSize == new Dimension(225, 113) // 150*1.5=225, 75*1.5=112.5 -> 113"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Individual width and height properties update reactively with scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"A text field with individual dimension properties","code":["var textField =","    UI.textField(\"Responsive Field\")","    .withPrefWidth(200)","    .withMinWidth(150)","    .withMaxWidth(300)","    .withPrefHeight(30)","    .withMinHeight(25)","    .withMaxHeight(40)","    .get(JTextField)"]},

        {"kind":"expect","text":"Initial dimensions at 1x scale","code":["textField.preferredSize.width == 200","textField.minimumSize.width == 150","textField.maximumSize.width == 300","textField.preferredSize.height == 30","textField.minimumSize.height == 25","textField.maximumSize.height == 40"]},

        {"kind":"when","text":"Scale changes to 1.25x","code":["SwingTree.get().setUiScaleFactor(1.25f)","UI.sync()"]},

        {"kind":"then","text":"Dimensions scale appropriately","code":["textField.preferredSize.width == 250 // 200 * 1.25","textField.minimumSize.width == 188  // 150 * 1.25 = 187.5 -> 188","textField.maximumSize.width == 375  // 300 * 1.25","textField.preferredSize.height == 38 // 30 * 1.25 = 37.5 -> 38","textField.minimumSize.height == 31  // 25 * 1.25 = 31.25 -> 31","textField.maximumSize.height == 50  // 40 * 1.25"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Size-exactly properties update reactively across all component types",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"Various components with exact size constraints","code":["var panel =","        UI.panel(\"wrap 1\")","        .add(UI.button(\"Button\").withSizeExactly(120, 40))","        .add(UI.label(\"Label\").withWidthExactly(180))","        .add(UI.textArea(\"Text\").withHeightExactly(60))","        .add(UI.comboBox([\"A\", \"B\"]).withSizeExactly(Size.of(160, 30)))","        .get(JPanel)","var button = panel.components[0] as JButton","var label = panel.components[1] as JLabel","var textArea = panel.components[2] as JTextArea","var comboBox = panel.components[3] as JComboBox"]},

        {"kind":"expect","text":"Initial sizes at 1x scale","code":["button.preferredSize == button.minimumSize","button.preferredSize == button.maximumSize","label.preferredSize.width == label.minimumSize.width","label.preferredSize.width == label.maximumSize.width","textArea.preferredSize.height == textArea.minimumSize.height","textArea.preferredSize.height == textArea.maximumSize.height","comboBox.preferredSize == comboBox.minimumSize","comboBox.preferredSize == comboBox.maximumSize","button.preferredSize == new Dimension(120, 40)","label.preferredSize.width == 180","textArea.preferredSize.height == 60","comboBox.preferredSize == new Dimension(160, 30)"]},

        {"kind":"when","text":"Scale changes to 1.75x","code":["SwingTree.get().setUiScaleFactor(1.75f)","UI.sync()"]},

        {"kind":"then","text":"All components scale their exact sizes","code":["button.preferredSize == new Dimension(210, 70) // 120*1.75=210, 40*1.75=70","label.preferredSize.width == 315 // 180*1.75=315","textArea.preferredSize.height == 105 // 60*1.75=105","comboBox.preferredSize == new Dimension(280, 53) // 160*1.75=280, 30*1.75=52.5 -> 53"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Bound property dimensions update reactively with scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"Properties controlling component dimensions","code":["var prefSize = Var.of(Size.of(80, 35))","var minWidth = Var.of(60)","var maxHeight = Var.of(45)"]},

        {"kind":"and","text":"A toggle button bound to these properties","code":["var toggleButton =","    UI.toggleButton(\"Dynamic Size\")","    .withPrefSize(prefSize)","    .withMinWidth(minWidth)","    .withMaxHeight(maxHeight)","    .get(JToggleButton)"]},

        {"kind":"expect","text":"Initial dimensions at 1x scale","code":["toggleButton.preferredSize == new Dimension(80, 35)","toggleButton.minimumSize.width == 60","toggleButton.maximumSize.height == 45"]},

        {"kind":"when","text":"Scale changes to 2x and properties update","code":["SwingTree.get().setUiScaleFactor(2.0f)","UI.sync()"]},

        {"kind":"then","text":"Dimensions scale with new factor","code":["toggleButton.preferredSize == new Dimension(160, 70)","toggleButton.minimumSize.width == 120","toggleButton.maximumSize.height == 90"]},

        {"kind":"when","text":"Properties change AND scale remains at 2x","code":["prefSize.set(Size.of(100, 50))","minWidth.set(80)","maxHeight.set(60)","UI.sync()"]},

        {"kind":"then","text":"New property values are also scaled","code":["toggleButton.preferredSize == new Dimension(200, 100)","toggleButton.minimumSize.width == 160","toggleButton.maximumSize.height == 120"]},

        {"kind":"when","text":"Scale changes back to 1x","code":["SwingTree.get().setUiScaleFactor(1.0f)","UI.sync()"]},

        {"kind":"then","text":"Dimensions reflect property values at 1x scale","code":["toggleButton.preferredSize == new Dimension(100, 50)","toggleButton.minimumSize.width == 80","toggleButton.maximumSize.height == 60"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Complex nested layouts maintain proper scaling relationships",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"A complex panel with nested components and mixed sizing strategies","code":["var mainPanel = UI.panel(\"wrap 2, insets 10\")","    .add(UI.label(\"Name:\").withPrefWidth(80))","    .add(UI.textField().withPrefWidth(200))","    .add(UI.label(\"Description:\").withPrefWidth(80))","    .add(UI.textArea(\"\").withPrefSize(200, 60))","    .add(\"span 2, center\",","        UI.panel()","        .add(UI.button(\"OK\").withSizeExactly(90, 30))","        .add(UI.button(\"Cancel\").withSizeExactly(90, 30))","    )","    .get(JPanel)","var nameLabel = mainPanel.components[0] as JLabel","var nameField = mainPanel.components[1] as JTextField","var descLabel = mainPanel.components[2] as JLabel","var descArea = mainPanel.components[3] as JTextArea","var buttonPanel = mainPanel.components[4] as JPanel","var okButton = buttonPanel.components[0] as JButton","var cancelButton = buttonPanel.components[1] as JButton"]},

        {"kind":"expect","text":"Initial layout proportions at 1x scale","code":["nameLabel.preferredSize.width == 80","nameField.preferredSize.width == 200","descLabel.preferredSize.width == 80","descArea.preferredSize == new Dimension(200, 60)","okButton.preferredSize == new Dimension(90, 30)","cancelButton.preferredSize == new Dimension(90, 30)"]},

        {"kind":"when","text":"Scale changes to 1.5x for better readability","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"All components scale proportionally maintaining layout relationships","code":["nameLabel.preferredSize.width == 120 // 80 * 1.5","nameField.preferredSize.width == 300 // 200 * 1.5","descLabel.preferredSize.width == 120 // 80 * 1.5","descArea.preferredSize == new Dimension(300, 90) // 200*1.5=300, 60*1.5=90","okButton.preferredSize == new Dimension(135, 45) // 90*1.5=135, 30*1.5=45","cancelButton.preferredSize == new Dimension(135, 45)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Style-based dimensions update reactively with scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"Components with dimensions defined through styling API","code":["var styledButton =","    UI.button(\"Styled Button\")","    .withStyle(it -> it","        .prefSize(120, 40)","        .minSize(100, 30)","        .maxSize(150, 50)","    )","    .get(JButton)","var styledField =","    UI.textField()","    .withStyle( it -> it","        .prefWidth(180)","        .minWidth(150)","        .maxWidth(220)","        .prefHeight(28)","    )","    .get(JTextField)"]},

        {"kind":"expect","text":"Initial styled dimensions at 1x scale","code":["styledButton.preferredSize == new Dimension(120, 40)","styledButton.minimumSize == new Dimension(100, 30)","styledButton.maximumSize == new Dimension(150, 50)","styledField.preferredSize == new Dimension(180, 28)","styledField.minimumSize.width == 150","styledField.maximumSize.width == 220"]},

        {"kind":"when","text":"Scale changes to 1.25x","code":["SwingTree.get().setUiScaleFactor(1.25f)","UI.sync()"]},

        {"kind":"then","text":"Styled dimensions scale appropriately","code":["styledButton.preferredSize == new Dimension(150, 50) // 120*1.25=150, 40*1.25=50","styledButton.minimumSize == new Dimension(125, 38) // 100*1.25=125, 30*1.25=37.5 -> 38","styledButton.maximumSize == new Dimension(188, 63) // 150*1.25=187.5 -> 188, 50*1.25=62.5 -> 63","styledField.preferredSize == new Dimension(225, 35) // 180*1.25=225, 28*1.25=35","styledField.minimumSize.width == 188 // 150*1.25=187.5 -> 188","styledField.maximumSize.width == 275 // 220*1.25=275"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Mixed static and bound dimensions all scale reactively",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"A combination of static and property-bound dimensions","code":["var dynamicWidth = Var.of(140)","var dynamicHeight = Var.of(35)","var panel = UI.panel(\"wrap 2\")","    .add(UI.button(\"Static\").withPrefSize(100, 30))","    .add(UI.button(\"Dynamic\").withPrefWidth(dynamicWidth).withPrefHeight(dynamicHeight))","    .add(UI.button(\"Mixed\").withPrefSize(110, 25).withMinWidth(dynamicWidth))","    .get(JPanel)","var staticBtn = panel.components[0] as JButton","var dynamicBtn = panel.components[1] as JButton","var mixedBtn = panel.components[2] as JButton"]},

        {"kind":"expect","text":"Initial sizes at 1x scale","code":["staticBtn.preferredSize == new Dimension(100, 30)","dynamicBtn.preferredSize == new Dimension(140, 35)","mixedBtn.preferredSize == new Dimension(110, 25)","mixedBtn.minimumSize.width == 140"]},

        {"kind":"when","text":"Scale changes to 1.8x","code":["SwingTree.get().setUiScaleFactor(1.8f)","UI.sync()"]},

        {"kind":"then","text":"All dimensions scale including bound properties","code":["staticBtn.preferredSize == new Dimension(175, 53)","dynamicBtn.preferredSize == new Dimension(245, 61)","mixedBtn.preferredSize == new Dimension(193, 44)","mixedBtn.minimumSize.width == 245"]},

        {"kind":"when","text":"Bound properties change at 1.8x scale","code":["dynamicWidth.set(160)","dynamicHeight.set(40)","UI.sync()"]},

        {"kind":"then","text":"New property values are scaled","code":["dynamicBtn.preferredSize == new Dimension(280, 70)","mixedBtn.minimumSize.width == 280"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Component size constraints work correctly with fractional scaling factors",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We first reset the UI scale to a simple default!","code":["SwingTree.get().setUiScaleFactor(1f)"]},

        {"kind":"and","text":"A component with precise dimensions","code":["var preciseComponent =","            UI.textArea(\"Precise Sizing\")","            .withPrefSize(133, 77)","            .withMinSize(111, 55)","            .withMaxSize(155, 99)","            .withSizeExactly(144, 88)","            .get(JTextArea)"]},

        {"kind":"expect","text":"Initial precise dimensions at 1x scale","code":["preciseComponent.preferredSize == new Dimension(144, 88)","preciseComponent.minimumSize == new Dimension(144, 88)","preciseComponent.maximumSize == new Dimension(144, 88)"]},

        {"kind":"when","text":"Scale changes to 1.333x (common for 125% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.333f)","UI.sync()"]},

        {"kind":"then","text":"Dimensions scale with fractional factors maintaining proportions","code":["preciseComponent.preferredSize == new Dimension(180, 110)","preciseComponent.minimumSize == new Dimension(180, 110)","preciseComponent.maximumSize == new Dimension(180, 110)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Font sizes specified with `withFontSize(int)` are scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Just like dimensional properties, font sizes also need to scale appropriately\n            when the UI scale factor changes. This ensures that text remains readable and\n            properly proportioned relative to other UI elements at different DPI settings.\n\n            The `withFontSize(int)` method allows setting a static font size that will\n            be automatically scaled by the current UI scale factor.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 2.0","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"when","text":"We create components with different font sizes","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Button\").withFontSize(12))","    .add(UI.label(\"Label\").withFontSize(14))","    .add(UI.textField(\"TextField\").withFontSize(16))","    .add(UI.textArea(\"TextArea\").withFontSize(18))","    .add(UI.comboBox([\"Item 1\", \"Item 2\"]).withFontSize(20))","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField","var textArea = panel.components[3] as JTextArea","var comboBox = panel.components[4] as JComboBox"]},

        {"kind":"then","text":"The font sizes are scaled by the scaling factor","code":["button.font.size == 24  // 12 * 2.0","label.font.size == 28   // 14 * 2.0","textField.font.size == 32 // 16 * 2.0","textArea.font.size == 36  // 18 * 2.0","comboBox.font.size == 40  // 20 * 2.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Font sizes specified with `withFontSize(Val<Integer>)` are scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            For dynamic applications where font sizes might change based on user preferences\n            or application state, SwingTree supports binding font sizes to reactive properties.\n            These bound font sizes are also automatically scaled by the UI scale factor,\n            providing a consistent reading experience across different display configurations.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 1.5f","code":["SwingTree.get().setUiScaleFactor(1.5f)"]},

        {"kind":"and","text":"We create reactive properties for font sizes","code":["var buttonFontSize = Var.of(12)","var labelFontSize = Var.of(14)","var fieldFontSize = Var.of(16)"]},

        {"kind":"when","text":"We create components with bound font sizes","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Button\").withFontSize(buttonFontSize))","    .add(UI.label(\"Label\").withFontSize(labelFontSize))","    .add(UI.textField(\"TextField\").withFontSize(fieldFontSize))","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"then","text":"The initial font sizes are scaled by the scaling factor","code":["button.font.size == 18  // 12 * 1.5","label.font.size == 21   // 14 * 1.5","textField.font.size == 24 // 16 * 1.5"]},

        {"kind":"when","text":"We update the font size properties","code":["buttonFontSize.set(16)","labelFontSize.set(18)","fieldFontSize.set(20)","UI.sync() // Wait for UI updates"]},

        {"kind":"then","text":"The updated font sizes are also scaled by the scaling factor","code":["button.font.size == 24  // 16 * 1.5","label.font.size == 27   // 18 * 1.5","textField.font.size == 30 // 20 * 1.5"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Font sizes update reactively when UI scale factor changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            One of the key features of SwingTree's scaling system is that it reacts\n            dynamically to changes in the UI scale factor. When the scale factor changes\n            (for example, when a user moves an application between different DPI displays),\n            all font sizes are automatically recalculated and updated.\n\n            This ensures that text remains properly sized and readable regardless of\n            the current display configuration.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We start with a scale factor of 1.0","code":["SwingTree.get().setUiScaleFactor(1.0f)"]},

        {"kind":"and","text":"Components with various font sizes","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Button\").withFontSize(12))","    .add(UI.label(\"Label\").withFontSize(16))","    .add(UI.textField(\"Field\").withFontSize(20))","    .get(JPanel)","var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"expect","text":"Initial font sizes at 1x scale","code":["button.font.size == 12","label.font.size == 16","textField.font.size == 20"]},

        {"kind":"when","text":"Scale changes to 1.25x (125% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.25f)","UI.sync()"]},

        {"kind":"then","text":"Font sizes scale appropriately","code":["button.font.size == 15  // 12 * 1.25","label.font.size == 20   // 16 * 1.25","textField.font.size == 25 // 20 * 1.25"]},

        {"kind":"when","text":"Scale changes to 1.5x (150% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"Font sizes scale to the new factor","code":["button.font.size == 18  // 12 * 1.5","label.font.size == 24   // 16 * 1.5","textField.font.size == 30 // 20 * 1.5"]},

        {"kind":"when","text":"Scale changes to 2.0x (200% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(2.0f)","UI.sync()"]},

        {"kind":"then","text":"Font sizes double from original","code":["button.font.size == 24  // 12 * 2.0","label.font.size == 32   // 16 * 2.0","textField.font.size == 40 // 20 * 2.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Bound font sizes update reactively with both property and scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates the powerful combination of reactive properties\n            and UI scaling. When both the underlying font size property AND the\n            UI scale factor change, the component's font size updates appropriately\n            to reflect both changes.\n\n            This is particularly useful for applications that need to support both\n            user-configurable font sizes and automatic DPI scaling.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We start with scale factor 1.0 and a reactive font size","code":["SwingTree.get().setUiScaleFactor(1.0f)","var fontSize = Var.of(14)"]},

        {"kind":"and","text":"A component with bound font size","code":["var label = UI.label(\"Dynamic Font\").withFontSize(fontSize).get(JLabel)"]},

        {"kind":"expect","text":"Initial font size","code":["label.font.size == 14"]},

        {"kind":"when","text":"Only the scale factor changes to 1.5x","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"Font size scales with the factor","code":["label.font.size == 21  // 14 * 1.5"]},

        {"kind":"when","text":"Only the font size property changes to 18","code":["fontSize.set(18)","UI.sync()"]},

        {"kind":"then","text":"Font size updates with new property value at current scale","code":["label.font.size == 27  // 18 * 1.5"]},

        {"kind":"when","text":"Both scale factor and property change","code":["SwingTree.get().setUiScaleFactor(2.0f)","fontSize.set(16)","UI.sync()"]},

        {"kind":"then","text":"Font size reflects both changes","code":["label.font.size == 32  // 16 * 2.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Font size scaling works correctly with fractional scaling factors",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Real-world scaling factors are often fractional values like 1.25, 1.33, or 1.75\n            that correspond to common DPI scaling percentages (125%, 133%, 175%).\n            This test ensures that font sizes are calculated correctly with these\n            fractional factors, maintaining readability and visual consistency.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We start with scale factor 1.0","code":["SwingTree.get().setUiScaleFactor(1.0f)"]},

        {"kind":"and","text":"A component with a specific font size","code":["var label = UI.label(\"Fractional Scaling Test\").withFontSize(15).get(JLabel)"]},

        {"kind":"expect","text":"Initial font size","code":["label.font.size == 15"]},

        {"kind":"when","text":"Scale changes to 1.25x (125% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.25f)","UI.sync()"]},

        {"kind":"then","text":"Font size scales with fractional factor","code":["label.font.size == 19  // 15 * 1.25 = 18.75 -> rounded to 19"]},

        {"kind":"when","text":"Scale changes to 1.333x (133% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.333f)","UI.sync()"]},

        {"kind":"then","text":"Font size scales with repeating decimal factor","code":["label.font.size == 19"]},

        {"kind":"when","text":"Scale changes to 1.75x (175% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.75f)","UI.sync()"]},

        {"kind":"then","text":"Font size scales with larger fractional factor","code":["label.font.size == 26  // 15 * 1.75 = 26.25 -> rounded to 26"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Mixed static and bound font sizes all scale appropriately",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In real applications, you'll often have a mix of static and dynamically\n            bound font sizes. This test verifies that both approaches work correctly\n            together and scale appropriately when the UI scale factor changes.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set scale factor to 1.0 and create a reactive property","code":["SwingTree.get().setUiScaleFactor(1.0f)","var dynamicSize = Var.of(16)"]},

        {"kind":"when","text":"We create a panel with mixed font size approaches","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Static Small\").withFontSize(12))","    .add(UI.label(\"Dynamic\").withFontSize(dynamicSize))","    .add(UI.textField(\"Static Large\").withFontSize(20))","    .get(JPanel)","var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"then","text":"Initial font sizes","code":["button.font.size == 12","label.font.size == 16","textField.font.size == 20"]},

        {"kind":"when","text":"Scale changes to 1.5x","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"All font sizes scale appropriately","code":["button.font.size == 18  // 12 * 1.5","label.font.size == 24   // 16 * 1.5","textField.font.size == 30 // 20 * 1.5"]},

        {"kind":"when","text":"Dynamic property changes at scaled factor","code":["dynamicSize.set(18)","UI.sync()"]},

        {"kind":"then","text":"Dynamic font size updates while static ones remain scaled","code":["button.font.size == 18  // unchanged static size at scale","label.font.size == 27   // 18 * 1.5","textField.font.size == 30 // unchanged static size at scale"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Fonts specified with `withFont(Font)` are scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            For maximum flexibility in font customization, SwingTree allows setting\n            complete Font objects using the `withFont(Font)` method. When a custom font\n            is provided this way, its size is automatically scaled by the current UI \n            scale factor, ensuring consistent typography across different display configurations.\n\n            This is particularly useful when you need to use specific font families or styles\n            while still benefiting from automatic DPI scaling.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 2.0","code":["SwingTree.get().setUiScaleFactor(2.0f)"]},

        {"kind":"when","text":"We create components with different custom fonts","code":["var boldFont = new Font(\"Arial\", Font.BOLD, 12)","var italicFont = new Font(\"Serif\", Font.ITALIC, 14)","var plainFont = new Font(\"Monospaced\", Font.PLAIN, 16)","var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Bold Button\").withFont(boldFont))","    .add(UI.label(\"Italic Label\").withFont(italicFont))","    .add(UI.textField(\"Plain Field\").withFont(plainFont))","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"then","text":"The font sizes are scaled by the scaling factor while preserving font family and style","code":["button.font.style == Font.BOLD","button.font.size == 24  // 12 * 2.0","label.font.style == Font.ITALIC","label.font.size == 28   // 14 * 2.0","textField.font.style == Font.PLAIN","textField.font.size == 32 // 16 * 2.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Fonts specified with `withFont(Val<Font>)` are scaled by the scaling factor",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            For dynamic applications where fonts might change based on user preferences,\n            theme switching, or other application state, SwingTree supports binding\n            complete Font objects to reactive properties. \n\n            When a Font property is bound to a component, the font size is automatically\n            scaled by the current UI scale factor. This allows for complex font customization\n            while maintaining proper DPI scaling across different displays.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set the scaling factor to 1.5f","code":["SwingTree.get().setUiScaleFactor(1.5f)"]},

        {"kind":"and","text":"We create reactive properties for fonts","code":["var buttonFont = Var.of(new Font(\"Arial\", Font.BOLD, 12))","var labelFont = Var.of(new Font(\"Serif\", Font.ITALIC, 14))","var fieldFont = Var.of(new Font(\"Monospaced\", Font.PLAIN, 16))"]},

        {"kind":"when","text":"We create components with bound fonts","code":["var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Button\").withFont(buttonFont))","    .add(UI.label(\"Label\").withFont(labelFont))","    .add(UI.textField(\"TextField\").withFont(fieldFont))","    .get(JPanel)"]},

        {"kind":"and","text":"We unpack the tree of components:","code":["var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"then","text":"The initial fonts are scaled by the scaling factor","code":["button.font.size == 18  // 12 * 1.5","label.font.size == 21   // 14 * 1.5","textField.font.size == 24 // 16 * 1.5"]},

        {"kind":"when","text":"We update the font properties with new sizes","code":["buttonFont.set(new Font(\"Arial\", Font.BOLD, 16))","labelFont.set(new Font(\"Serif\", Font.ITALIC, 18))","fieldFont.set(new Font(\"Monospaced\", Font.PLAIN, 20))","UI.sync() // Wait for UI updates"]},

        {"kind":"then","text":"The updated font sizes are also scaled by the scaling factor","code":["button.font.size == 24  // 16 * 1.5","label.font.size == 27   // 18 * 1.5","textField.font.size == 30 // 20 * 1.5"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Custom fonts update reactively when UI scale factor changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            One of the key advantages of SwingTree's scaling system is that it works\n            seamlessly with custom fonts. When the UI scale factor changes, all custom\n            fonts automatically adjust their sizes while preserving their family and style.\n\n            This ensures that applications using specialized typography maintain visual\n            consistency and readability across different display DPI settings.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We start with a scale factor of 1.0","code":["SwingTree.get().setUiScaleFactor(1.0f)"]},

        {"kind":"and","text":"Components with various custom fonts","code":["var customFont1 = new Font(\"Georgia\", Font.BOLD, 14)","var customFont2 = new Font(\"Courier New\", Font.ITALIC, 16)","var customFont3 = new Font(\"Verdana\", Font.PLAIN, 18)","var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Georgia Bold\").withFont(customFont1))","    .add(UI.label(\"Courier Italic\").withFont(customFont2))","    .add(UI.textField(\"Verdana Plain\").withFont(customFont3))","    .get(JPanel)","var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField"]},

        {"kind":"expect","text":"Initial font sizes and styles at 1x scale","code":["button.font.style == Font.BOLD","button.font.size == 14","label.font.style == Font.ITALIC","label.font.size == 16","textField.font.style == Font.PLAIN","textField.font.size == 18"]},

        {"kind":"when","text":"Scale changes to 1.25x (125% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.25f)","UI.sync()"]},

        {"kind":"then","text":"Custom font sizes scale appropriately while preserving family and style","code":["button.font.style == Font.BOLD","button.font.size == 18  // 14 * 1.25 -> rounded to 18","label.font.style == Font.ITALIC","label.font.size == 20   // 16 * 1.25","textField.font.style == Font.PLAIN","textField.font.size == 23 // 18 * 1.25 = 22.5 -> rounded to 23"]},

        {"kind":"when","text":"Scale changes to 1.75x (175% DPI scaling)","code":["SwingTree.get().setUiScaleFactor(1.75f)","UI.sync()"]},

        {"kind":"then","text":"Custom font sizes scale to the new factor","code":["button.font.style == Font.BOLD","button.font.size == 20","label.font.style == Font.ITALIC","label.font.size == 22","textField.font.style == Font.PLAIN","textField.font.size == 25"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Bound custom fonts update reactively with both property and scale changes",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates the powerful combination of reactive Font properties\n            and UI scaling. When both the underlying Font property AND the UI scale factor \n            change, the component's font updates appropriately to reflect both changes.\n\n            This enables sophisticated scenarios like theme switching with custom fonts\n            that automatically adapt to different display DPI settings.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We start with scale factor 1.0 and a reactive font property","code":["SwingTree.get().setUiScaleFactor(1.0f)","var dynamicFont = Var.of(new Font(\"Arial\", Font.PLAIN, 14))"]},

        {"kind":"and","text":"A component with bound custom font","code":["var label = UI.label(\"Dynamic Custom Font\").withFont(dynamicFont).get(JLabel)"]},

        {"kind":"expect","text":"Initial font properties","code":["label.font.style == Font.PLAIN","label.font.size == 14"]},

        {"kind":"when","text":"Only the scale factor changes to 1.5x","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"Font size scales with the factor while preserving family and style","code":["label.font.style == Font.PLAIN","label.font.size == 21"]},

        {"kind":"when","text":"Only the font property changes to a different font with new size","code":["dynamicFont.set(new Font(\"Times New Roman\", Font.BOLD, 16))","UI.sync()"]},

        {"kind":"then","text":"Font updates with new property value at current scale","code":["label.font.style == Font.BOLD","label.font.size == 24  // 16 * 1.5"]},

        {"kind":"when","text":"Both scale factor and font property change","code":["SwingTree.get().setUiScaleFactor(2.0f)","dynamicFont.set(new Font(\"Courier New\", Font.ITALIC, 18))","UI.sync()"]},

        {"kind":"then","text":"Font reflects both changes - new family, style, and scaled size","code":["label.font.style == Font.ITALIC","label.font.size == 36  // 18 * 2.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Mixed font specification methods all scale appropriately",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Real-world applications often use multiple methods for specifying fonts:\n            some components might use custom Font objects, others might use simple \n            font sizes, and others might use reactive properties. This test verifies\n            that all these approaches work correctly together and scale appropriately\n            when the UI scale factor changes.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We set scale factor to 1.0 and create reactive properties","code":["SwingTree.get().setUiScaleFactor(1.0f)","var dynamicFont = Var.of(new Font(\"Arial\", Font.BOLD, 16))","var dynamicSize = Var.of(14)"]},

        {"kind":"when","text":"We create a panel with mixed font specification approaches","code":["var customFont = new Font(\"Georgia\", Font.ITALIC, 18)","var panel =","    UI.panel(\"wrap 1\")","    .add(UI.button(\"Custom Font\").withFont(customFont))","    .add(UI.label(\"Dynamic Font Object\").withFont(dynamicFont))","    .add(UI.textField(\"Dynamic Font Size\").withFontSize(dynamicSize))","    .add(UI.textArea(\"Static Font Size\").withFontSize(12))","    .get(JPanel)","var button = panel.components[0] as AbstractButton","var label = panel.components[1] as JLabel","var textField = panel.components[2] as JTextField","var textArea = panel.components[3] as JTextArea"]},

        {"kind":"then","text":"Initial font properties","code":["button.font.style == Font.ITALIC","button.font.size == 18","label.font.style == Font.BOLD","label.font.size == 16","textField.font.size == 14","textArea.font.size == 12"]},

        {"kind":"when","text":"Scale changes to 1.5x","code":["SwingTree.get().setUiScaleFactor(1.5f)","UI.sync()"]},

        {"kind":"then","text":"All font sizes scale appropriately regardless of specification method","code":["button.font.style == Font.ITALIC","button.font.size == 27","label.font.style == Font.BOLD","label.font.size == 24   // 16 * 1.5","textField.font.size == 21  // 14 * 1.5","textArea.font.size == 18   // 12 * 1.5"]},

        {"kind":"when","text":"Dynamic properties change at scaled factor","code":["dynamicFont.set(new Font(\"Verdana\", Font.PLAIN, 20))","dynamicSize.set(18)","UI.sync()"]},

        {"kind":"then","text":"Dynamic fonts update while static ones remain scaled","code":["button.font.size == 27  // unchanged custom font at scale","label.font.style == Font.PLAIN","label.font.size == 30   // 20 * 1.5","textField.font.size == 27  // 18 * 1.5","textArea.font.size == 18   // unchanged static size at scale"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
