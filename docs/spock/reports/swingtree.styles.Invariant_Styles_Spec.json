{
  "className":"swingtree.styles.Invariant_Styles_Spec",
  "title":"Invariant Styles",
  "narrative":"This test demonstrates how various pairs of different styles\n    produce identical component states as well as identical\n    images when rendered into a BufferedImage.",
  "subjects":["swingtree.UI","swingtree.api.Styler"],
  "statistics":{
    "runs":"18",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Diagonally linear gradients can be invariant in certain cases. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different gradient styles \n            produce identical images when rendered into a BufferedImage.\n            More specifically we examine diagonal linear gradients.\n            Diagonally linear menus that a gradient transitions from one corner\n            of a component to the opposite corner.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Diagonally linear gradients can be invariant in certain cases. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different gradient styles \n            produce identical images when rendered into a BufferedImage.\n            More specifically we examine diagonal linear gradients.\n            Diagonally linear menus that a gradient transitions from one corner\n            of a component to the opposite corner.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Diagonally linear gradients can be invariant in certain cases. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different gradient styles \n            produce identical images when rendered into a BufferedImage.\n            More specifically we examine diagonal linear gradients.\n            Diagonally linear menus that a gradient transitions from one corner\n            of a component to the opposite corner.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Diagonally linear gradients can be invariant in certain cases. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different gradient styles \n            produce identical images when rendered into a BufferedImage.\n            More specifically we examine diagonal linear gradients.\n            Diagonally linear menus that a gradient transitions from one corner\n            of a component to the opposite corner.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Vertically and horizontally linear gradients can be invariant in certain cases. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing linear gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.LEFT_TO_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.RIGHT_TO_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.TOP_TO_BOTTOM)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.BOTTOM_TO_TOP)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Vertically and horizontally linear gradients can be invariant in certain cases. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing linear gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.LEFT_TO_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.RIGHT_TO_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.TOP_TO_BOTTOM)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.BOTTOM_TO_TOP)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Vertically and horizontally linear gradients can be invariant in certain cases. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing linear gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.LEFT_TO_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.RIGHT_TO_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.TOP_TO_BOTTOM)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.BOTTOM_TO_TOP)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Vertically and horizontally linear gradients can be invariant in certain cases. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing linear gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.RED, Color.BLUE)","                .span(UI.Span.LEFT_TO_RIGHT)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLUE, Color.RED)","                .span(UI.Span.RIGHT_TO_LEFT)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN)","                .span(UI.Span.TOP_TO_BOTTOM)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 38)","            .prefSize(280, 38)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.GREEN, Color.PINK)","                .span(UI.Span.BOTTOM_TO_TOP)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 38  * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 38  * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A diagonally aligned radial gradient with an offset focus point can be invariant in certain cases. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing radial gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A diagonally aligned radial gradient with an offset focus point can be invariant in certain cases. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing radial gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A diagonally aligned radial gradient with an offset focus point can be invariant in certain cases. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing radial gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A diagonally aligned radial gradient with an offset focus point can be invariant in certain cases. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how various pairs of different styles \n            describing radial gradients produce identical images when rendered into a BufferedImage.\n            Their invariant emerges from the order of the colors and the direction of the gradients\n            transitioning from one color to the other being reversed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first set the UI scaling factor to simulate a platform with higher DPI.\n            So when your screen has a higher pixel density then this factor\n            is used by SwingTree to ensure that the UI is upscaled accordingly! \n            Please note that the line below only exists for testing purposes, \n            SwingTree will determine a suitable \n            scaling factor for the current system automatically for you,\n            so you do not have to specify this factor manually. \n        ","code":["SwingTree.get().setUiScaleFactor(uiScale)"]},

        {"kind":"and","text":"We declare to variables for storing pairs of identical widgets with different styles.","code":["var ui1","var ui2"]},

        {"kind":"when","text":"We create two widgets with different styles.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_LEFT_TO_BOTTOM_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.BLACK, Color.CYAN, Color.GREEN, Color.MAGENTA)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_RIGHT_TO_TOP_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(26,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["var image1 = Utility.renderSingleComponent(ui1.get(JBox))","var image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"when","text":"We create another pair of widgets with opposite gradient transitions.","code":["ui1 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.BOTTOM_LEFT_TO_TOP_RIGHT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"","code":["ui2 = UI.box()","        .withStyle( it -> it","            .size(280, 138)","            .borderRadius(20)","            .margin(10)","            .gradient( gradConf -> gradConf","                .colors(Color.PINK, Color.GREEN, Color.BLUE)","                .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)","                .span(UI.Span.TOP_RIGHT_TO_BOTTOM_LEFT)","                .type(UI.GradientType.RADIAL)","                .focus(16,16)","            )","        )"]},

        {"kind":"and","text":"We render the two widgets into a BufferedImage.","code":["image1 = Utility.renderSingleComponent(ui1.get(JBox))","image2 = Utility.renderSingleComponent(ui2.get(JBox))"]},

        {"kind":"then","text":"They both have the expected size:","code":["image1.width  == Math.round( 280 * uiScale )","image1.height == Math.round( 138 * uiScale )","image2.width  == Math.round( 280 * uiScale )","image2.height == Math.round( 138 * uiScale )"]},

        {"kind":"and","text":"The images are identical even though they have different styles:","code":["Utility.similarityBetween(image1, image2) > 99.9"]},

        {"kind":"where","text":"We test this using the following scaling values:","code":{"uiScale":["1f","1.25f","1.75f","2f"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two labels with the same font style configuration will have equal font objects. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two labels with the same font style configuration","code":["var ui1 = UI.label(\"A\").withStyle(it->it.componentFont(styler))","var ui2 = UI.label(\"B\").withStyle(it->it.componentFont(styler))"]},

        {"kind":"and","text":"We build the two labels and also create a plain reference label:","code":["var label1 = ui1.get(JLabel)","var label2 = ui2.get(JLabel)","var label3 = new JLabel(\"C\")"]},

        {"kind":"when","text":"We unpack the font objects from the labels.","code":["var font1 = label1.getFont()","var font2 = label2.getFont()","var font3 = label3.getFont()"]},

        {"kind":"then","text":"The first two labels have the same font object.","code":["font1 == font2"]},

        {"kind":"and","text":"The third label on the other hand has a different font object.","code":["font3 != font1","font3 != font2"]},

        {"kind":"where","text":"We test the following font configurations:","code":{"styler":["{f -> f.size(1).family(\"Arial\").style(UI.FontStyle.BOLD)}","{f -> f.size(2).family(\"Ubuntu\").style(UI.FontStyle.BOLD_ITALIC)}","{f -> f.size(3).family(\"SansSerif\").style(UI.FontStyle.ITALIC)}","{f -> f.gradient(g->g.colors(Color.RED, Color.BLUE).span(UI.Span.TOP_TO_BOTTOM))}","{f -> f.size(82)\n           .family(\"Dialog\")\n           .weight(2.75)\n           .color(Color.WHITE)\n           .noise(noise -> noise\n                   .colors(Color.DARK_GRAY, Color.CYAN)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n           .backgroundNoise(noise -> noise\n                   .colors(Color.BLACK, Color.BLUE)\n                   .function(UI.NoiseType.CELLS)\n                   .scale(1.25)\n           )\n    }","{f -> f.size(82)\n           .family(\"Noto Sans\")\n           .weight(1.25)\n           .color(Color.BLUE)\n           .noise(noise -> noise\n               .colors(Color.DARK_GRAY, Color.CYAN)\n               .function(UI.NoiseType.SMOOTH_SPOTS)\n               .scale(1.15)\n           )\n           .backgroundGradient(grad -> grad\n               .colors(Color.GREEN, Color.MAGENTA, Color.ORANGE)\n               .boundary(UI.ComponentBoundary.CENTER_TO_CONTENT)\n               .span(UI.Span.BOTTOM_TO_TOP)\n               .type(UI.GradientType.CONIC)\n               .focus(26,16)\n           )\n    }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
