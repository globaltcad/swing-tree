{
  "className":"swingtree.Combo_Box_Spec",
  "title":"Drop Downs, aka Combo Boxes",
  "narrative":"In Swing drop downs are called combo boxes and they are used to select\n    one item from a list of options.\n\n    This specification will show you how you can create them and\n    how you can interact with them using SwingTree.",
  "subjects":["swingtree.UIForCombo"],
  "statistics":{
    "runs":"41",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Swing tree is a wrapper around Swing, which means you can create the combo box yourself.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We pass the combo box to the Swing-Tree factory method.","code":["var ui = UI.of(new JComboBox<>(new DefaultComboBoxModel<>(new String[]{\"A\", \"B\", \"C\"})))"]},

        {"kind":"and","text":"We unpack the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The underlying component is a combo box.","code":["combo instanceof JComboBox"]},

        {"kind":"and","text":"It has the expected state:","code":["combo.itemCount == 3","combo.getItemAt(0) == \"A\"","combo.getItemAt(1) == \"B\"","combo.getItemAt(2) == \"C\"","combo.model instanceof DefaultComboBoxModel","combo.model.size == 3","combo.model.getElementAt(0) == \"A\"","combo.model.getElementAt(1) == \"B\"","combo.model.getElementAt(2) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The \"comboBox\" factory method allows you to easily create a combo box from an array.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We pass the combo box to the Swing-Tree factory method.","code":["var ui = UI.comboBox(\"A\", \"B\", \"C\")"]},

        {"kind":"and","text":"We unpack the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The underlying component is a combo box.","code":["combo instanceof JComboBox"]},

        {"kind":"and","text":"It has the expected state:","code":["combo.itemCount == 3","combo.getItemAt(0) == \"A\"","combo.getItemAt(1) == \"B\"","combo.getItemAt(2) == \"C\""]},

        {"kind":"and","text":"It is backed by a built in model.","code":["!(combo.model instanceof DefaultComboBoxModel)","combo.model.size == 3","combo.model.getElementAt(0) == \"A\"","combo.model.getElementAt(1) == \"B\"","combo.model.getElementAt(2) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A combo box created by Swing-Tree uses the provided item array as data model.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           You don't have to create a ComboBoxModel implementation to model the state\n           of your combo box! If you pass an array or a list to a combo box\n           factory method it will serve as a model of your combo box items.  \n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an array and pass it to the combo box factory method.","code":["var items = new String[]{\"A\" , \"B\" , \"C\"}","var ui = UI.comboBox(items)"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"when","text":"We modify the array...","code":["items[0] = \"D\""]},

        {"kind":"then","text":"The combo box is updated as well.","code":["combo.itemCount == 3","combo.getItemAt(0) == \"D\"","combo.getItemAt(1) == \"B\"","combo.getItemAt(2) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A combo box created by Swing-Tree uses the provided item list as data model.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           You don't have to create a ComboBoxModel implementation to model the state\n           of your combo box! If you pass an array or a list to a combo box\n           factory method it will serve as a model of your combo box items.  \n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an array and pass it to the combo box factory method.","code":["var items = [\"A\" , \"B\" , \"C\"]","var ui = UI.comboBox(items)"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"when","text":"We modify the list by adding an element in the middle...","code":["items.add(1, \"D\")"]},

        {"kind":"then","text":"The combo box is updated as well.","code":["combo.itemCount == 4","combo.getItemAt(0) == \"A\"","combo.getItemAt(1) == \"D\"","combo.getItemAt(2) == \"B\"","combo.getItemAt(3) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A combo box can be made editable in a declarative way.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box and make it editable.","code":["var ui = UI.comboBox(\"A\", \"B\", \"C\")","                .isEditableIf(true)","                .withSelectedItem(\"B\")"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is editable.","code":["combo.isEditable()"]},

        {"kind":"and","text":"The selected item is set.","code":["combo.getSelectedItem() == \"B\""]},

        {"kind":"when","text":"We simulate the user typing \"XY\" into the combo box.","code":["UI.runNow( () -> combo.editor.item = \"XY\" )","UI.sync()"]},

        {"kind":"then","text":"The combo box is updated.","code":["combo.getSelectedItem() == \"XY\""]},

        {"kind":"and","text":"This change is reflected in the model.","code":["combo.model.size == 3","combo.model.getElementAt(0) == \"A\"","combo.model.getElementAt(1) == \"XY\"","combo.model.getElementAt(2) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The options of an editable combo box are only editable if their items list is modifyable.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box and make it editable.","code":["var ui = UI.comboBox(Collections.unmodifiableList([\"A\", \"B\", \"C\"]))","                .isEditableIf(true)","                .withSelectedItem(\"B\")"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is editable.","code":["combo.isEditable()"]},

        {"kind":"and","text":"The selected item is set.","code":["combo.getSelectedItem() == \"B\""]},

        {"kind":"when","text":"We simulate the user typing \"XY\" into the combo box.","code":["UI.runNow( () -> combo.editor.item = \"XY\" )","UI.sync()"]},

        {"kind":"then","text":"The combo box is updated.","code":["combo.getSelectedItem() == \"XY\""]},

        {"kind":"and","text":"This change is NOT reflected in the model.","code":["combo.model.size == 3","combo.model.getElementAt(0) == \"A\"","combo.model.getElementAt(1) == \"B\"","combo.model.getElementAt(2) == \"C\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can model both the current selection state as well as options of your combo box using a property and an array.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           In essence, the state of a combo box consists of the current selection, and\n           the options that are available for selection. You can model both of these\n           aspects using a property and a list. The property will be used to model\n           the current selection, and the list will be used to model the options.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create our \"model\", a property and an array.","code":["var selection = Var.of(42)","var options = new Integer[]{ 73 , 42 , 17 }"]},

        {"kind":"and","text":"We create a combo box that is bound to the property and the list.","code":["var ui = UI.comboBox(selection, options)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"and","text":"The there are all 3 options available.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change the selection.","code":["selection.set(17)"]},

        {"kind":"then","text":"This change translates from the property to the UI element.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"and","text":"The combo box options are still the same.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change one of the options.","code":["options[0] = 99"]},

        {"kind":"and","text":"We select this option...","code":["combo.setSelectedItem(99)"]},

        {"kind":"then","text":"The selection is updated.","code":["selection.get() == 99"]},

        {"kind":"and","text":"The combo box also reports the correct selection index!","code":["combo.getSelectedIndex() == 0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can model both the current selection state as well as options of your combo box using a property and a list.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           In essence, the state of a combo box consists of the current selection, and\n           the options that are available for selection. You can model both of these\n           aspects using a property and a list. The property will be used to model\n           the current selection, and the list will be used to model the options.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create our \"model\", a property and a list.","code":["var selection = Var.of(42)","var options = [73, 42, 17]"]},

        {"kind":"and","text":"We create a combo box that is bound to the property and the list.","code":["var ui = UI.comboBox(selection, options)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"and","text":"The there are all 3 options available.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change the selection.","code":["selection.set(17)"]},

        {"kind":"then","text":"This change translates from the property to the UI element.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"and","text":"The combo box options are still the same.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We add another option somewhere in the middle.","code":["options.add(1, 99)"]},

        {"kind":"then","text":"The combo box options are updated.","code":["combo.itemCount == 4","combo.getItemAt(0) == 73","combo.getItemAt(1) == 99","combo.getItemAt(2) == 42","combo.getItemAt(3) == 17"]},

        {"kind":"and","text":"The selection is still the same.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"and","text":"The combo box also reports the correct selection index!","code":["combo.getSelectedIndex() == 3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can model both the current selection state as well as options of your combo box using 2 properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           In essence, the state of a combo box consists of the current selection, and\n           the options that are available for selection. You can model both of these\n           aspects using 2 properties. One modelling the current selection, and another one\n           storing an array to model all available options. \n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create our \"model\", 2 properties.","code":["var selection = Var.of(42)","var options = Var.of(Tuple.of(73, 42, 17))"]},

        {"kind":"and","text":"We create a combo box that is bound to the property and the list.","code":["var ui = UI.comboBox(selection, options)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"and","text":"The there are all 3 options available.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change the selection.","code":["selection.set(17)"]},

        {"kind":"then","text":"This change translates from the property to the UI element.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"when","text":"We change the options property.","code":["options.set(Tuple.of(99, 17))"]},

        {"kind":"then","text":"The combo box options are updated.","code":["combo.itemCount == 2","combo.getItemAt(0) == 99","combo.getItemAt(1) == 17"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can model the selection state and options of your combo box using 2 properties and a display function.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           In essence, the state of a combo box consists of the current selection, and\n           the options that are available for selection. You can model both of these\n           aspects using 2 properties. One modelling the current selection, and another one\n           storing an array to model all available options. \n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create our \"model\", 2 properties.","code":["var selection = Var.of(42)","var options = Var.of(Tuple.of(73, 42, 17))"]},

        {"kind":"and","text":"We create a combo box that is bound to the property and the list.","code":["var ui = UI.comboBox(selection, options, it -> \"Value: \" + it)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"and","text":"The there are all 3 options available.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change the selection.","code":["selection.set(17)"]},

        {"kind":"then","text":"This change translates from the property to the UI element.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"when","text":"We change the options property.","code":["options.set(Tuple.of(99, 17))"]},

        {"kind":"then","text":"The combo box options are updated.","code":["combo.itemCount == 2","combo.getItemAt(0) == 99","combo.getItemAt(1) == 17"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can model the options of your combo boxes using \"Vars\".",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n           In essence, the state of a combo box consists of the current selection, and\n           the options that are available for selection. You can model both of these\n           aspects using a standalone property as well as a \"Vars\" instance\n           representing multiple properties. \n           The single property models the current selection, and the \"Vars\"\n           store a list of all available options. \n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create our \"model\", a property and a \"Vars\" instance.","code":["var selection = Var.of(42)","var options = Vars.of(73, 42, 17)"]},

        {"kind":"and","text":"We create a combo box that is bound to the property and the list.","code":["var ui = UI.comboBox(selection, options)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"and","text":"The there are all 3 options available.","code":["combo.itemCount == 3","combo.getItemAt(0) == 73","combo.getItemAt(1) == 42","combo.getItemAt(2) == 17"]},

        {"kind":"when","text":"We change the selection.","code":["selection.set(17)"]},

        {"kind":"then","text":"This change translates from the property to the UI element.","code":["combo.getSelectedItem() == 17"]},

        {"kind":"when","text":"We change the options property.","code":["options.clear().addAll(99, 17)"]},

        {"kind":"then","text":"The combo box options are updated.","code":["combo.itemCount == 2","combo.getItemAt(0) == 99","combo.getItemAt(1) == 17"]},

        {"kind":"when","text":"We add another option somewhere in the middle.","code":["options.addAll(16, 42)"]},

        {"kind":"then","text":"The combo box options are updated.","code":["combo.itemCount == 4","combo.getItemAt(0) == 99","combo.getItemAt(1) == 17","combo.getItemAt(2) == 16","combo.getItemAt(3) == 42"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse user input to match bound properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a property of type Integer.","code":["var selection = Var.of(42)"]},

        {"kind":"and","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, 73, 42, 17)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == 42"]},

        {"kind":"and","text":"It also reports the correct selection index.","code":["combo.getSelectedIndex() == 1"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["combo.setSelectedItem('99')"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == 99"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An editable combo box will try to parse any kind of user input to match bound properties. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you bind a selection property to an editable combo box, the combo box\n            will try to parse user input so that it can be converted to the type of the\n            selection property. \n            If the String can be parsed, the combo box will update the selection property\n            to the parsed value.\n            On the other hand, if the String cannot be parsed, the combo box will not\n            update the selection property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box that is bound to the property.","code":["var ui =","            UI.comboBox(selection, items)","            .isEditableIf(true)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"The combo box is initialized with the current selection.","code":["combo.getSelectedItem() == selection.get()"]},

        {"kind":"when","text":"We simulate the user editing the combo box.","code":["UI.runNow(()->combo.setSelectedItem(input))","UI.sync()"]},

        {"kind":"then","text":"The combo box updates the selection property to the parsed value.","code":["selection.get() == expectedSelection"]},

        {"kind":"where","text":"We use the following data table to populate the used variables:","code":{"input":["'99'","'42'","'true'","'false'","'yes'","'no'","'3.14'","'2.71'","'foo'","'bar'","'666L'","'777L'"],"selection":["Var.of(42)","Var.of(42)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(false)","Var.of(3.14)","Var.of(3.14)","Var.of('foo')","Var.of('foo')","Var.of(666L)","Var.of(666L)"],"items":["[73, 42, 17]","[73, 42, 17]","[true, false]","[true, false]","[true, false]","[true, false]","[3.14, 2.71]","[3.14, 2.71]","['foo', 'bar']","['foo', 'bar']","[666L, 777L]","[666L, 777L]"],"expectedSelection":["99","42","true","false","true","false","3.14","2.71","'foo'","'bar'","666L","777L"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Changing properties in you view model automatically updates the combo box.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var selected = Var.of(4);","var options = Vars.of(1, 2, 4, 6, 8, 12, 16)"]},

        {"kind":"and","text":"","code":["            var ui =","                comboBox(options)","\t\t\t\t.withSelectedItem(selected)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"when","text":"We change the selected property to 1...","code":["\t\t    selected.set(1)","UI.sync()"]},

        {"kind":"then","text":"The combo box has been updated as expected!","code":["\t\t    combo.selectedItem == 1","\t\t    combo.editor.item == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Changing properties in you view model automatically updates an editable combo box.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var selected = Var.of(4);","var options = Vars.of(1, 2, 4, 6, 8, 12, 16)"]},

        {"kind":"and","text":"","code":["            var ui =","                comboBox(options).isEditableIf(true)","\t\t\t\t.withSelectedItem(selected)"]},

        {"kind":"and","text":"We get the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"when","text":"We change the selected property to 1...","code":["\t\t    selected.set(1)","UI.sync()"]},

        {"kind":"then","text":"The combo box has been updated as expected!","code":["\t\t    combo.selectedItem == 1","\t\t    combo.editor.item == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Create combo box UIs with simple text render functions. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The type of items a combo box holds need to be presented\n            to the user in a human readable way. The most common and convenient\n            way to do this is to use a simple text representation of the items.\n            This can be achieved by providing a function that converts the items\n            to strings.\n\n            In this example we are using the following enum type\n            to model the items of the combo box:\n            ```\n            enum Animal {\n                CAT, DOG, COW, PIG\n            }\n            ```\n            We are going to use these constant to\n            as a basis for various kinds of ways to model the combo box\n            state and also how to render them.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box from the UI supplier.","code":["var ui = uiSupplier.get()"]},

        {"kind":"and","text":"We build a combo box component.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"expect","text":"There are all 4 options available.","code":["combo.itemCount == 4","combo.getItemAt(0) == Animal.CAT","combo.getItemAt(1) == Animal.DOG","combo.getItemAt(2) == Animal.COW","combo.getItemAt(3) == Animal.PIG"]},

        {"kind":"and","text":"We check if the renderer exists and is working.","code":["combo.renderer != null"]},

        {"kind":"when","text":"We call the renderer for each item.","code":["var renderer = combo.renderer","var fakeJList = new JList<Animal>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"cat\"","rendered[1] == \"dog\"","rendered[2] == \"cow\"","rendered[3] == \"pig\""]},

        {"kind":"when","text":"We do not record the rendered results, but the components...","code":["rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Animal.CAT, 0, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.DOG, 1, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.COW, 2, false, false),","    renderer.getListCellRendererComponent(fakeJList, Animal.PIG, 3, false, false)","])"]},

        {"kind":"then","text":"All components will report the last rendered text.","code":["rendered[0].text == \"pig\"","rendered[1].text == \"pig\"","rendered[2].text == \"pig\"","rendered[3].text == \"pig\""]},

        {"kind":"and","text":"That is because they are all the same component instance.","code":["rendered[0] === rendered[1]","rendered[1] === rendered[2]","rendered[2] === rendered[3]"]},

        {"kind":"where","text":"\n            We are using the following factory methods from the `UI` namespace.\n            Note that the `UI.comboBox` method is overloaded and can take\n            all kinds of arguments to model the state of the combo box.\n        ","code":{"uiSupplier":["{ UI.comboBox(Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values() as List, a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Animal.values(), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vars.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Vals.of(Animal.CAT, Animal.DOG, Animal.COW, Animal.PIG), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Var.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }","{ UI.comboBox(Var.of(Animal.CAT), Val.of(Tuple.of(Animal, Animal.values())), a -> a.name().toLowerCase()) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `withCells(Configurator)` to configure both a renderer and editor for your combobox.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withCells(Configurator)` method constitutes a useful API point\n            which exposes you to a fluent API for configuring which kind of item\n            should be rendered using which kind of renderer and editor.\n\n            The `Configurator` lambda passed to the `withCell` method receives\n            a fluent API for defining which kind of item should be rendered\n            using which kind of renderer and editor.\n\n            So this may look like this:\n            ```java\n                .when(Animal.class).as( cell -> ... )\n                .when(String.class).as( cell -> ... )\n                //...\n            ```\n            And inside this inner `Configurator` lambda you are exposed\n            to a delegate object of a particular cell in the combo box.\n            You may update and return this cell with a view component\n            used for either rendering, editing or both.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for the days of the week and a custom cell configuration.","code":["var ui =","            UI.comboBox(DayOfWeek.values())","            .withCells(it -> it","                .when(DayOfWeek.class).as( cell -> cell","                    .updateView( comp -> comp","                        .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.MAGENTA)})","                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                        .updateIf(JLabel.class, label -> {","                            label.text = \"Day: \" + cell.entryAsString()","                            return label","                        })","                    )","                )","            )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer and editor supplier.","code":["var renderer = combo.renderer","var editor = combo.editor"]},

        {"kind":"expect","text":"","code":["renderer != null","editor != null"]},

        {"kind":"and","text":"The editor was initialized with the text field having a magenta background.","code":["editor.getEditorComponent() instanceof JTextField","editor.getEditorComponent().background == Color.MAGENTA"]},

        {"kind":"and","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<DayOfWeek>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.MONDAY, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.TUESDAY, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.WEDNESDAY, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.THURSDAY, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.FRIDAY, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SATURDAY, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SUNDAY, 6, false, false).text","])"]},

        {"kind":"and","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Day: MONDAY\"","rendered[1] == \"Day: TUESDAY\"","rendered[2] == \"Day: WEDNESDAY\"","rendered[3] == \"Day: THURSDAY\"","rendered[4] == \"Day: FRIDAY\"","rendered[5] == \"Day: SATURDAY\"","rendered[6] == \"Day: SUNDAY\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Multiple calls to `withCells(Configurator)` will not override each other!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withCells(Configurator)` method is used to configure both\n            how the drop-down options of a combo box ought to be rendered,\n            and then also how the editor of a combo-box should behave and\n            look like (if the combo box is editable).\n            More specifically, the `withCells` method is different\n            to `withCell` in that it gives you an API for configuring\n            the cell for specific types of items.\n\n            The `Configurator` lambda passed to the `withCells` method receives\n            a delegate object of a particular cell in the combo box.\n            You may update and return this cell with a view component\n            used for either rendering, editing or both.\n\n            In this test however, we will focus on verifying that\n            this method can be called multiple times without\n            your configurations being lost. Instead, they accumulate.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for the days of the week and a custom cell configuration.","code":["var ui =","            UI.comboBox(DayOfWeek.values())","            .withCells(it -> it","                .when(DayOfWeek.class).as( cell -> cell","                    .updateView( comp -> comp","                        .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.MAGENTA)})","                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                    )","                )","            )","            .withCells(it -> it","                .when(DayOfWeek.class).as( cell -> cell","                    .updateView( comp -> comp","                        .updateIf(JLabel.class, label -> {","                            label.text = \"Day: \" + cell.entryAsString()","                            return label","                        })","                    )","                )","            )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer and editor supplier.","code":["var renderer = combo.renderer","var editor = combo.editor"]},

        {"kind":"expect","text":"","code":["renderer != null","editor != null"]},

        {"kind":"and","text":"The editor was initialized with the text field having a magenta background.","code":["editor.getEditorComponent() instanceof JTextField","editor.getEditorComponent().background == Color.MAGENTA"]},

        {"kind":"and","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<DayOfWeek>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.MONDAY, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.TUESDAY, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.WEDNESDAY, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.THURSDAY, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.FRIDAY, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SATURDAY, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SUNDAY, 6, false, false).text","])"]},

        {"kind":"and","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Day: MONDAY\"","rendered[1] == \"Day: TUESDAY\"","rendered[2] == \"Day: WEDNESDAY\"","rendered[3] == \"Day: THURSDAY\"","rendered[4] == \"Day: FRIDAY\"","rendered[5] == \"Day: SATURDAY\"","rendered[6] == \"Day: SUNDAY\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `withCell(Configurator)` to configure both a renderer and editor for your combobox.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withCell(Configurator)` method constitutes a useful API point\n            which exposes you to a fluent API for configuring how a particular cell\n            should be displayed.\n\n            The `Configurator` lambda passed to the `withCell` method receives\n            a delegate object of a particular cell in the combo box.\n            You may update and return this cell with a view component\n            used for either rendering, editing or both.\n\n            So this may look like this:\n            ```java\n                .withCell( cell -> cell\n                    .view( comp -> comp\n                        .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.MAGENTA)})\n                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})\n                        .updateIf(JLabel.class, label -> {\n                            label.text = \"Day: \" + cell.valueAsString().orElse(\"\")\n                            return label\n                        })\n                    )\n                )\n            ```\n            Here you can see that the `Configurator` lambda receives a `cell` object\n            which is a delegate object of a particular cell in the combo box.\n            The view of this cell is updated with a text field or a label depending\n            on whether the cell is currently being edited or not.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for the days of the week and a custom cell configuration.","code":["var ui =","            UI.comboBox(DayOfWeek.values())","            .withCell(cell -> cell","                .updateView( comp -> comp","                    .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.MAGENTA)})","                    .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                    .updateIf(JLabel.class, label -> {","                        label.text = \"Day: \" + cell.entryAsString()","                        return label","                    })","                )","            )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer and editor supplier.","code":["var renderer = combo.renderer","var editor = combo.editor"]},

        {"kind":"expect","text":"","code":["renderer != null","editor != null"]},

        {"kind":"and","text":"The editor was initialized with the text field having a magenta background.","code":["editor.getEditorComponent() instanceof JTextField","editor.getEditorComponent().background == Color.MAGENTA"]},

        {"kind":"when","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<DayOfWeek>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.MONDAY, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.TUESDAY, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.WEDNESDAY, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.THURSDAY, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.FRIDAY, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SATURDAY, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SUNDAY, 6, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Day: MONDAY\"","rendered[1] == \"Day: TUESDAY\"","rendered[2] == \"Day: WEDNESDAY\"","rendered[3] == \"Day: THURSDAY\"","rendered[4] == \"Day: FRIDAY\"","rendered[5] == \"Day: SATURDAY\"","rendered[6] == \"Day: SUNDAY\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Multiple calls to `withCell(Configurator)` will not override each other!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withCell(Configurator)` method is used to configure both\n            how the drop-down options of a combo box ought to be rendered,\n            and then also how the editor of a combo-box should behave and\n            look like (if the combo box is editable).\n\n            The `Configurator` lambda passed to the `withCell` method receives\n            a delegate object of a particular cell in the combo box.\n            You may update and return this cell with a view component\n            used for either rendering, editing or both.\n\n            In this test however, we will focus on verifying that\n            this method can be called multiple times without\n            your configurations being lost. Instead, they accumulate.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for the days of the week and multiple cell configurations.","code":["var ui =","            UI.comboBox(DayOfWeek.values())","            .withCell(cell -> cell","                .updateView( comp -> comp","                    .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.MAGENTA)})","                    .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                )","            )","            .withCell(cell -> cell","                .updateView( comp -> comp","                    .updateIf(JLabel.class, label -> {","                        label.text = \"Day: \" + cell.entryAsString()","                        return label","                    })","                )","            )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer and editor supplier.","code":["var renderer = combo.renderer","var editor = combo.editor"]},

        {"kind":"expect","text":"","code":["renderer != null","editor != null"]},

        {"kind":"and","text":"The editor was initialized with the text field having a magenta background.","code":["editor.getEditorComponent() instanceof JTextField","editor.getEditorComponent().background == Color.MAGENTA"]},

        {"kind":"when","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<DayOfWeek>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.MONDAY, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.TUESDAY, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.WEDNESDAY, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.THURSDAY, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.FRIDAY, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SATURDAY, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, DayOfWeek.SUNDAY, 6, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Day: MONDAY\"","rendered[1] == \"Day: TUESDAY\"","rendered[2] == \"Day: WEDNESDAY\"","rendered[3] == \"Day: THURSDAY\"","rendered[4] == \"Day: FRIDAY\"","rendered[5] == \"Day: SATURDAY\"","rendered[6] == \"Day: SUNDAY\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `withCells(Configurator)` method allows you to configure cells for specific combo-box item types.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withCells(Configurator)` method exposes a fluent API \n            for configuring which kind of item\n            should be rendered using which kind of renderer and editor.\n\n            The `Configurator` lambda passed to the `withCell` method receives\n            a fluent API for defining which kind of item should be rendered\n            using which kind of renderer and editor.\n\n            So this may look like this:\n            ```java\n                .when(Rectangle.class).as( cell -> ... )\n                .when(Circle.class).as( cell -> ... )\n                .when(Line.class).as( cell -> ... )\n                //...\n            ```\n            And inside this inner `Configurator` lambda you are exposed\n            to a delegate object of a particular cell in the combo box.\n            You may update and return this cell with a view component\n            used for either rendering, editing or both.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for different kinds of numbers and a custom cell configuration.","code":["var ui =","            UI.comboBox(Var.of(Number, 42), Var.of(Tuple.of(Number, 0.2f, 42, 54L, 6.9d, 3, 6 as Byte, 4f)))","            .withCells(it -> it","                .when(Float.class).as( cell -> cell","                    .updateView( comp -> comp","                        .orGetUiIf(cell.isEditing(), {UI.textArea(\"\").withBackground(Color.RED)})","                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                        .updateIf(JLabel.class, label -> {","                            label.text = \"Float: \" + cell.entryAsString()","                            return label","                        })","                    )","                )","                .when(Double.class).as( cell -> cell","                    .updateView( comp -> comp","                        .orGetUiIf(cell.isEditing(), {UI.formattedTextField().withBackground(Color.BLUE)})","                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                        .updateIf(JLabel.class, label -> {","                            label.text = \"Double: \" + cell.entryAsString()","                            return label","                        })","                    )","                )","                .when(Number.class).as( cell -> cell","                    .updateView( comp -> comp","                        .orGetUiIf(cell.isEditing(), {UI.textField().withBackground(Color.GREEN)})","                        .orGetUiIf(!cell.isEditing(), {UI.label(\"\")})","                        .updateIf(JLabel.class, label -> {","                            label.text = \"Number: \" + cell.entryAsString()","                            return label","                        })","                    )","                )","            )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer and editor supplier.","code":["var renderer = combo.renderer"]},

        {"kind":"when","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<Number>()","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, 0.2f, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 42, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 54L, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 6.9d, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 3, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 6 as Byte, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, 4f, 6, false, false).text","])"]},

        {"kind":"then","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Float: 0.2\"","rendered[1] == \"Number: 42\"","rendered[2] == \"Number: 54\"","rendered[3] == \"Double: 6.9\"","rendered[4] == \"Number: 3\"","rendered[5] == \"Number: 6\"","rendered[6] == \"Float: 4.0\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `withTooltips(Function<E,String>)` to configure tooltips for individual combo-box options.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `withTooltips(Function<E,String>)` method maps each\n            available combo-box item to a tooltip string. When hovering over\n            the items in the drop-down, then the tooltips will be displayed\n            next to the mouse cursor after some time.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a combo box for all months of a year and a custom cell configuration.","code":["var ui =","            UI.comboBox(Month.values(), month -> \"Month: \"+month)","            .withTooltips( month -> \"Choose ${month.toString().toLowerCase(Locale.ENGLISH)}\" )"]},

        {"kind":"and","text":"We build the combo box.","code":["var combo = ui.get(JComboBox)"]},

        {"kind":"and","text":"We get the renderer supplier.","code":["var renderer = combo.renderer"]},

        {"kind":"expect","text":"","code":["renderer != null"]},

        {"kind":"when","text":"The renderer was initialized with a label showing the day of the week.","code":["var fakeJList = new JList<Month>()","var tooltips = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Month.JANUARY, 0, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.FEBRUARY, 1, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.MARCH, 2, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.APRIL, 3, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.MAY, 4, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.JUNE, 5, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.JULY, 6, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.AUGUST, 7, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.SEPTEMBER, 8, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.OCTOBER, 9, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.NOVEMBER, 10, false, false).getToolTipText(),","    renderer.getListCellRendererComponent(fakeJList, Month.DECEMBER, 11, false, false).getToolTipText()","])","var rendered = UI.runAndGet(()->[","    renderer.getListCellRendererComponent(fakeJList, Month.JANUARY, 0, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.FEBRUARY, 1, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.MARCH, 2, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.APRIL, 3, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.MAY, 4, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.JUNE, 5, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.JULY, 6, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.AUGUST, 7, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.SEPTEMBER, 8, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.OCTOBER, 9, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.NOVEMBER, 10, false, false).text,","    renderer.getListCellRendererComponent(fakeJList, Month.DECEMBER, 11, false, false).text","])"]},

        {"kind":"then","text":"","code":["tooltips[0] == \"Choose january\"","tooltips[1] == \"Choose february\"","tooltips[2] == \"Choose march\"","tooltips[3] == \"Choose april\"","tooltips[4] == \"Choose may\"","tooltips[5] == \"Choose june\"","tooltips[6] == \"Choose july\"","tooltips[7] == \"Choose august\"","tooltips[8] == \"Choose september\"","tooltips[9] == \"Choose october\"","tooltips[10] == \"Choose november\"","tooltips[11] == \"Choose december\""]},

        {"kind":"and","text":"The renderer returns the expected text representations.","code":["rendered[0] == \"Month: JANUARY\"","rendered[1] == \"Month: FEBRUARY\"","rendered[2] == \"Month: MARCH\"","rendered[3] == \"Month: APRIL\"","rendered[4] == \"Month: MAY\"","rendered[5] == \"Month: JUNE\"","rendered[6] == \"Month: JULY\"","rendered[7] == \"Month: AUGUST\"","rendered[8] == \"Month: SEPTEMBER\"","rendered[9] == \"Month: OCTOBER\"","rendered[10] == \"Month: NOVEMBER\"","rendered[11] == \"Month: DECEMBER\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
