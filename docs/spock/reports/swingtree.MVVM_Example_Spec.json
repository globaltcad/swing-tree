{
  "className":"swingtree.MVVM_Example_Spec",
  "title":"MVVM Introduction",
  "narrative":"Swing-Tree allows you to create a Model-View-ViewModel (MVVM) architecture\n    based on 2 simple property interfaces: `Val`, and `Var`!\n\n    `Val` is a read-only property, and `Var` is a read-write property.\n\n    The state of both properties can be observed by the view using simple listeners.\n    This happens automatically when you pass them to the Swing-Tree view.\n    If you want to trigger an action when the property changes, you\n    have to pass the `Var` property to the view and define a action\n    for it inside of your view model.",
  "subjects":[],
  "statistics":{
    "runs":"175",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"We can create a property based view model and build a view for it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that we use a pre-made example view model here.\n            Feel free to look at the source code of the view model\n            to see what it is doing.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the view model.","code":["var vm = new LoginViewModel()"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui =","    UI.panel(\"fill, wrap 2\")","    .add( UI.label( \"Username:\" ) )","    .add( \"grow\", UI.textField(vm.username()))","    .add( UI.label( \"Password:\" ) )","    .add( \"grow\", UI.passwordField(vm.password()))","    .add( \"span\",","        UI.label(vm.feedback())","    )","    .add( \"span\",","        UI.button( \"Login\" )","        .isEnabledIf(vm.buttonEnabled())","        .onClick( it -> vm.login() )","    )"]},

        {"kind":"and","text":"Build the root component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"then","text":"The view was successfully created.","code":["panel instanceof JPanel"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can bind a boolean property to a button, and when the user presses it, we notice it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property.","code":["var pressedStates = []","Var<Boolean> buttonPressed = Var.of(false).onChange(From.VIEW, {pressedStates.add(it.currentValue().orElseThrowUnchecked()) })"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.button(\"Press me!\").isPressedIf(buttonPressed)"]},

        {"kind":"and","text":"Build the root component:","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The view was successfully created.","code":["button != null"]},

        {"kind":"when","text":"We press the button.","code":["UI.runNow({","    button.model.setPressed(true)","})"]},

        {"kind":"then","text":"\n                The property was updated a single time.\n            ","code":["pressedStates == [true]"]},

        {"kind":"when","text":"We release the button.","code":["UI.runNow({","    button.model.setPressed(false)","})"]},

        {"kind":"then","text":"\n                The property was updated a single time.\n            ","code":["pressedStates == [true, false]"]},

        {"kind":"when","text":"\n            We release a second time...\n        ","code":["UI.runNow({","    button.model.setPressed(false)","})"]},

        {"kind":"then","text":"\n            The property was not updated a second time,\n            because the model already knows that the button is not pressed.\n        ","code":["pressedStates == [true, false]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Binding to the selection state of a button does nothing, because a JButton can only be pressed.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property.","code":["boolean actionPerformed = false","Var<Boolean> buttonPressed = Var.of(false).onChange(From.VIEW, {actionPerformed = true})"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.button(\"Press me!\").isSelectedIf(buttonPressed)"]},

        {"kind":"and","text":"Build the button component:","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The view button was successfully created.","code":["button != null"]},

        {"kind":"when","text":"We press the button.","code":["button.doClick()"]},

        {"kind":"then","text":"The property was not updated because a JButton can only be pressed.","code":["actionPerformed == false"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can bind a boolean property to a checkbox, and when the user presses it, we notice it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property.","code":["Var<Boolean> checkBoxSelected = Var.of(false)"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.checkBox(\"Press me!\").isSelectedIf(checkBoxSelected)"]},

        {"kind":"and","text":"Build the root component:","code":["var checkBox = ui.get(JCheckBox)"]},

        {"kind":"then","text":"The view was successfully created.","code":["checkBox != null"]},

        {"kind":"when","text":"We click the check box.","code":["checkBox.doClick()"]},

        {"kind":"then","text":"The property was updated.","code":["checkBoxSelected.orElseNull() == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can bind a boolean property to a radio button, and when the user presses it, we notice it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property.","code":["Var<Boolean> radioButtonSelected = Var.of(false)"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.radioButton(\"Press me!\").isSelectedIf(radioButtonSelected)"]},

        {"kind":"and","text":"Now we build the root component:","code":["var radioButton = ui.get(JRadioButton)"]},

        {"kind":"then","text":"The view radio button was successfully created.","code":["radioButton != null"]},

        {"kind":"when","text":"We press the radio button.","code":["radioButton.doClick()"]},

        {"kind":"then","text":"The property was updated.","code":["radioButtonSelected.orElseNull() == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can bind a boolean property to a toggle button, and when the user presses it, we notice it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property.","code":["Var<Boolean> isToggled = Var.of(false)"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.toggleButton(\"Toggle me!\").isSelectedIf(isToggled)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var toggleButton = ui.get(JToggleButton)"]},

        {"kind":"then","text":"The view button was successfully created.","code":["toggleButton != null"]},

        {"kind":"when","text":"We press the toggle button.","code":["toggleButton.doClick()"]},

        {"kind":"then","text":"The property was updated.","code":["isToggled.orElseNull() == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can bind a enum property to a combo box and when the user selects an item, we notice it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can conveniently bind a combo box to any type of property, \n            but there are 2 types of properties which should be used preferably:\n            Enums and Strings. \n            And among these 2 you should always prefer enums over strings, because \n            they have a more manageable room of possible states...\n            Only if the possible states are too many\n            and not predictable during compile time, should you use strings.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property holding an example enum.","code":["boolean actionPerformed = false","Var<Size> selected = Var.of(Size.SMALL).onChange(From.VIEW, {actionPerformed = true})"]},

        {"kind":"expect","text":"The enum we use for demonstration has the following values.","code":["Size.values() == [Size.SMALL, Size.MEDIUM, Size.LARGE]"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.comboBox(Size.values()).withSelectedItem(selected)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The view component was successfully created.","code":["comboBox != null"]},

        {"kind":"when","text":"We select an item in the combo box.","code":["comboBox.setSelectedIndex(1)"]},

        {"kind":"then","text":"The property was updated.","code":["selected.orElseNull() == Size.MEDIUM"]},

        {"kind":"and","text":"The action was triggered.","code":["actionPerformed == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An enum based combo box can infer its possible states directly from the binding property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can conveniently bind a combo box to any type of property, \n            but there are 2 types of properties which should be used preferably:\n            Enums and Strings. \n            And among these 2 you should always prefer enums over strings, because \n            they have a more manageable room of possible states...\n            Only if the possible states are too many\n            and not predictable during compile time, should you use strings.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property holding an example enum.","code":["boolean actionPerformed = false","Var<Option> selected = Var.of(Option.YES).onChange(From.VIEW, {actionPerformed = true})"]},

        {"kind":"expect","text":"The enum we use for demonstration has the following values.","code":["Option.values() == [Option.YES, Option.NO, Option.MAYBE]"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.comboBox(selected)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The view component was successfully created.","code":["comboBox != null"]},

        {"kind":"when","text":"We select an item in the combo box.","code":["comboBox.setSelectedItem(Option.MAYBE)"]},

        {"kind":"then","text":"The property was updated.","code":["selected.orElseNull() == Option.MAYBE"]},

        {"kind":"and","text":"The action was triggered.","code":["actionPerformed == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A string property can be bound to a combo box holding string elements.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can conveniently bind a combo box to any type of property, \n            but there are 2 types of properties which should be used preferably:\n            Enums and Strings. \n            And among these 2 you should always prefer enums over strings, because \n            they have a more manageable room of possible states...\n            Only if the possible states are too many\n            and not predictable during compile time, should you use strings.\n            In the example below you can see how the usage of a string property\n            makes sense, because there might be requirements to add new food items\n            to the combo box at runtime.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We instantiate the \"view model\" in the form of a single property holding a string.","code":["boolean actionPerformed = false","Var<String> selected = Var.of(\"Tofu\").onChange(From.VIEW, {actionPerformed = true})"]},

        {"kind":"when","text":"We create a view for our view model...","code":["var ui = UI.comboBox(\"Tofu\", \"Tempeh\", \"Seitan\").withSelectedItem(selected)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The view component was successfully created.","code":["comboBox != null && !actionPerformed"]},

        {"kind":"when","text":"We select an item in the combo box.","code":["comboBox.setSelectedIndex(1)"]},

        {"kind":"then","text":"The property was updated.","code":["selected.orElseNull() == \"Tempeh\""]},

        {"kind":"and","text":"The action was triggered.","code":["actionPerformed == true"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A simple list of elements can be used as a data model for a combo box.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Always prefer Enums over Strings but if you have to model generic data\n            you can always bind a simple list of elements as a data model to a combo box.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple list, holding the data.","code":["List<String> data = [\"Tofu\", \"Tempeh\", \"Seitan\"]"]},

        {"kind":"when","text":"We create a combo box and bind it to the data.","code":["var ui = UI.comboBox(data)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The combo box was successfully created.","code":["comboBox instanceof JComboBox"]},

        {"kind":"and","text":"The combo box contains the data.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data.get(0)","comboBox.getItemAt(1) == data.get(1)","comboBox.getItemAt(2) == data.get(2)"]},

        {"kind":"when","text":"We modify the list...","code":["data.add(\"Soy Milk\")"]},

        {"kind":"then","text":"The combo box is updated.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data.get(0)","comboBox.getItemAt(1) == data.get(1)","comboBox.getItemAt(2) == data.get(2)","comboBox.getItemAt(3) == data.get(3)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A simple array of elements can be used as a data model for a combo box.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Always prefer Enums over Strings but if you have to model generic data\n            you can always bind a simple array of elements as a data model to a combo box.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple array, holding the data.","code":["String[] data = [\"Tofu\", \"Tempeh\", \"Seitan\"]"]},

        {"kind":"when","text":"We create a combo box and bind it to the data.","code":["var ui = UI.comboBox(data)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The combo box was successfully created.","code":["comboBox instanceof JComboBox"]},

        {"kind":"and","text":"The combo box contains the data.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data[0]","comboBox.getItemAt(1) == data[1]","comboBox.getItemAt(2) == data[2]"]},

        {"kind":"when","text":"We modify the array...","code":["data[1] = \"Soy Milk\""]},

        {"kind":"then","text":"The combo box is updated.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data[0]","comboBox.getItemAt(1) == data[1]","comboBox.getItemAt(2) == data[2]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can bind a property as the current selection as well as list of elements as options to a combo box.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple list, holding the data.","code":["List<String> data = [\"Tofu\", \"Tempeh\", \"Seitan\"]"]},

        {"kind":"and","text":"We create a property holding the current selection.","code":["Var<String> selected = Var.of(\"Tofu\")"]},

        {"kind":"when","text":"We create a combo box and bind it to the data.","code":["var ui = UI.comboBox(selected, data)"]},

        {"kind":"and","text":"We then also build the view component:","code":["var comboBox = ui.get(JComboBox)"]},

        {"kind":"then","text":"The combo box was successfully created.","code":["comboBox instanceof JComboBox"]},

        {"kind":"and","text":"The combo box contains the data.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data.get(0)","comboBox.getItemAt(1) == data.get(1)","comboBox.getItemAt(2) == data.get(2)"]},

        {"kind":"and","text":"The combo box has the correct selection.","code":["comboBox.selectedItem == selected.orElseNull()"]},

        {"kind":"when","text":"We modify the list...","code":["data.add(\"Soy Milk\")"]},

        {"kind":"then","text":"The combo box is updated.","code":["comboBox.itemCount == data.size()","comboBox.getItemAt(0) == data.get(0)","comboBox.getItemAt(1) == data.get(1)","comboBox.getItemAt(2) == data.get(2)","comboBox.getItemAt(3) == data.get(3)"]},

        {"kind":"and","text":"The combo box has the correct selection.","code":["comboBox.selectedItem == selected.orElseNull()"]},

        {"kind":"when","text":"We modify the selection...","code":["selected.set(\"Seitan\")"]},

        {"kind":"then","text":"The combo box has the correct selection.","code":["comboBox.selectedItem == selected.orElseNull()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"View Models can be represented by properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case it is useful\n            to represent your view models as properties. \n            Simply implement the 'Viewable' interface in your view model and\n            you can bind it to a view.\n            When the property changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> name = Var.of(\"Tofu\")","Var<Integer> population = Var.of(4)","var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","ViewSupplier<String> viewer = viewModel -> {","    switch (viewModel) {","        case \"Dummy View Model 1\":","                return UI.panel().id(\"sub-1\")","                        .add(UI.label(\"Name:\"))","                        .add(UI.textField(name))","                        .add(UI.button(\"Update\").onClick { name.set(\"Tempeh\") })","        case \"Dummy View Model 2\":","                return UI.panel().id(\"sub-2\")","                        .add(UI.label(\"Population:\"))","                        .add(UI.slider(UI.Align.HORIZONTAL).withValue(population))","                        .add(UI.button(\"Update\").onClick { population.set(5) })","    }","}"]},

        {"kind":"and","text":"A property storing the first view model.","code":["Var<String> vm = Var.of(vm1)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property.","code":["var ui = UI.panel()","        .add(UI.label(\"Dynamic Super View:\"))","        .add(UI.panel().id(\"super\").add(vm, viewer))"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()"]},

        {"kind":"when","text":"We update the view model property.","code":["vm.set(vm2)","UI.sync()"]},

        {"kind":"then","text":"The \"sub-1\" view is removed and the \"sub-2\" view is added.","code":["!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()"]},

        {"kind":"and","text":"The \"super\" view is still present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"View Models can be represented by property lists.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case it is useful\n            to represent your view models as property lists, especially if \n            one view consists of multiple sub views.\n            Simply implement the 'Viewable' interface in your view model and\n            you can bind it to a view using the \"Vars\" class wrapping your viewables.\n            When the property list changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> address = Var.of(\"123 Main Street\")","Var<String> title = Var.of(\"Mr.\")","Var<Integer> price = Var.of(1000000)","Var<Option> option = Var.of(Option.YES)"]},

        {"kind":"and","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","ViewSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.panel().id(\"sub-1\")","                        .add(UI.label(\"Address:\"))","                        .add(UI.textField(address))","                        .add(UI.button(\"Update\").onClick { address.set(\"456 Main Street\") })","        case \"Dummy View Model 2\":","                return UI.panel().id(\"sub-2\")","                        .add(UI.label(\"Title:\"))","                        .add(UI.textField(title))","                        .add(UI.button(\"Update\").onClick { title.set(\"Mrs.\") })","        case \"Dummy View Model 3\":","                return UI.panel().id(\"sub-3\")","                        .add(UI.label(\"Price:\"))","                        .add(UI.slider(UI.Align.HORIZONTAL).withValue(price))","                        .add(UI.button(\"Update\").onClick { price.set(2000000.0) })","        case \"Dummy View Model 4\":","                    return UI.panel().id(\"sub-4\")","                        .add(UI.label(\"Option:\"))","                        .add(UI.comboBox(option, Option.values()))","                        .add(UI.button(\"Update\").onClick { option.set(Option.NO) })","                }","            }"]},

        {"kind":"and","text":"A property list storing the view models.","code":["var vms = Vars.of(vm1, vm2, vm3, vm4)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property list.","code":["var ui = UI.panel()","        .add(UI.label(\"Dynamic Super View:\"))","        .add(UI.panel().id(\"super\").addAll(vms, viewer))"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We remove something from the view model property list.","code":["vms.remove(vm2)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.removeAt(2) // vm4","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" and \"sub-4\" views.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We reintroduce \"vm2\"...","code":["vms.add(vm2)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-4\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We clear the view model property list.","code":["vms.clear()","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()","new Utility.Query(panel).find(JPanel, \"super\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"View Models can be represented by tuples of models.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case of value based view models\n            it is useful to represent your view models as a tuple, especially if \n            one view consists of multiple sub views.\n            Simply implement the functional 'Viewable' interface to supply a view\n            for each model in the tuple and you can bind it to a view using the \"Tuple\" class.\n            When the tuple changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> address = Var.of(\"123 Main Street\")","Var<String> title = Var.of(\"Mr.\")","Var<Integer> price = Var.of(1000000)","Var<Option> option = Var.of(Option.YES)"]},

        {"kind":"and","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","ViewSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.panel().id(\"sub-1\")","                        .add(UI.label(\"Address:\"))","                        .add(UI.textField(address))","                        .add(UI.button(\"Update\").onClick { address.set(\"456 Main Street\") })","        case \"Dummy View Model 2\":","                return UI.panel().id(\"sub-2\")","                        .add(UI.label(\"Title:\"))","                        .add(UI.textField(title))","                        .add(UI.button(\"Update\").onClick { title.set(\"Mrs.\") })","        case \"Dummy View Model 3\":","                return UI.panel().id(\"sub-3\")","                        .add(UI.label(\"Price:\"))","                        .add(UI.slider(UI.Align.HORIZONTAL).withValue(price))","                        .add(UI.button(\"Update\").onClick { price.set(2000000.0) })","        case \"Dummy View Model 4\":","                    return UI.panel().id(\"sub-4\")","                        .add(UI.label(\"Option:\"))","                        .add(UI.comboBox(option, Option.values()))","                        .add(UI.button(\"Update\").onClick { option.set(Option.NO) })","                }","            }"]},

        {"kind":"and","text":"A tuple storing the view models and a property storing the tuple.","code":["var models = Tuple.of(vm1, vm2, vm3, vm4)","var vms = Var.of(models)"]},

        {"kind":"and","text":"Finally a view which binds to the tuple of view models.","code":["var ui = UI.panel()","        .add(UI.label(\"Dynamic Super View:\"))","        .add(UI.panel().id(\"super\").addAll(vms, viewer))"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We remove something from the tuple.","code":["vms.update( tuple -> tuple.remove(vm2) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.update( tuple -> tuple.removeAt(2) ) // vm4","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" and \"sub-4\" views.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We reintroduce \"vm2\"...","code":["vms.update( tuple -> tuple.add(vm2) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-4\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We clear the view model tuple.","code":["vms.update( tuple -> tuple.clear() )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()","new Utility.Query(panel).find(JPanel, \"super\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A dynamic property list based UI declaration can have layout constraints.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case it is useful\n            to represent your view models as property lists, especially if \n            one view consists of multiple sub views.\n            Simply implement the 'Viewable' interface in your view model and\n            you can bind it to a view using the \"Vars\" class wrapping your viewables.\n            When the property list changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","ViewSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.panel().id(\"sub-1\")","        case \"Dummy View Model 2\":","                return UI.panel().id(\"sub-2\")","        case \"Dummy View Model 3\":","                return UI.panel().id(\"sub-3\")","        case \"Dummy View Model 4\":","                    return UI.panel().id(\"sub-4\")","    }","}"]},

        {"kind":"and","text":"A property list storing the view models.","code":["var vms = Vars.of(vm1, vm2, vm3, vm4)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property list.","code":["var ui = UI.panel()","            .add(UI.label(\"Dynamic Super View:\"))","            .add(","                UI.panel(\"wrap 1\").id(\"super\")","                .addAll(\"growx\", vms, viewer)","            )"]},

        {"kind":"and","text":"We build the component and get its layout.","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We unpack the layout manager for the \"super\" view.","code":["var layout = (MigLayout) new Utility.Query(panel).find(JPanel, \"super\").get().getLayout()"]},

        {"kind":"then","text":"Each sub view has the layout constraints \"growx\".","code":["layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-1\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-3\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We remove something from the view model property list.","code":["vms.remove(vm1)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"The layout manager was updated accordingly:","code":["layout.constraintMap.size() == 3","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-3\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.removeAt(1) // vm3","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-1\" and \"sub-3\" views.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"Again, as expected, the layout manager was updated accordingly:","code":["layout.constraintMap.size() == 2","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We reintroduce \"vm1\"...","code":["vms.add(vm1)","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-3\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"The layout manager also knows about the new constraint:","code":["layout.constraintMap.size() == 3","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-1\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We clear the view model property list.","code":["vms.clear()","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()","new Utility.Query(panel).find(JPanel, \"super\").isPresent()"]},

        {"kind":"and","text":"The layout manager reports no constraints.","code":["layout.constraintMap.size() == 0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A dynamic tuple based UI declaration can have layout constraints.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you want to\n            be able to swap out sub views at runtime. In this case of value based modelling, \n            it is useful to represent your view models as tuples, especially if \n            one view consists of multiple sub views.\n            Simply implement the functional 'Viewable' interface and\n            supply a view for individual values in the tuple.\n            When the tuple changes, the view will be updated automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create 4 view models with 4 locally created views:","code":["var vm1 = \"Dummy View Model 1\"","var vm2 = \"Dummy View Model 2\"","var vm3 = \"Dummy View Model 3\"","var vm4 = \"Dummy View Model 4\"","ViewSupplier<String> viewer = viewModel -> {","    switch ( viewModel ) {","        case \"Dummy View Model 1\":","                return UI.panel().id(\"sub-1\")","        case \"Dummy View Model 2\":","                return UI.panel().id(\"sub-2\")","        case \"Dummy View Model 3\":","                return UI.panel().id(\"sub-3\")","        case \"Dummy View Model 4\":","                    return UI.panel().id(\"sub-4\")","    }","}"]},

        {"kind":"and","text":"A property storing a tuple of view models.","code":["var models = Tuple.of(vm1, vm2, vm3, vm4)","var vms = Var.of(models)"]},

        {"kind":"and","text":"Finally a view which binds to the view model property list.","code":["var ui = UI.panel()","            .add(UI.label(\"Dynamic Super View:\"))","            .add(","                UI.panel(\"wrap 1\").id(\"super\")","                .addAll(\"growx\", vms, viewer)","            )"]},

        {"kind":"and","text":"We build the component and get its layout.","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"when","text":"We unpack the layout manager for the \"super\" view.","code":["var layout = (MigLayout) new Utility.Query(panel).find(JPanel, \"super\").get().getLayout()"]},

        {"kind":"then","text":"Each sub view has the layout constraints \"growx\".","code":["layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-1\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-3\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We remove something from the view model property list.","code":["vms.update( tuple -> tuple.remove(vm1) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-2\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"The layout manager was updated accordingly:","code":["layout.constraintMap.size() == 3","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-3\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We remove something else from the view model property list but this time, for a change, use the index.","code":["vms.update( tuple -> tuple.removeAt(1) )// vm3","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-1\" and \"sub-3\" views.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"Again, as expected, the layout manager was updated accordingly:","code":["layout.constraintMap.size() == 2","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We reintroduce \"vm1\"...","code":["vms.update( tuple -> tuple.add(vm1) )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present except for the \"sub-3\" view.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()"]},

        {"kind":"and","text":"The layout manager also knows about the new constraint:","code":["layout.constraintMap.size() == 3","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-1\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-2\").get()) == \"growx\"","layout.getComponentConstraints(new Utility.Query(panel).find(JPanel, \"sub-4\").get()) == \"growx\""]},

        {"kind":"when","text":"We clear the view model property list.","code":["vms.update( tuple -> tuple.clear() )","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be removed. (except for the \"super\" view)","code":["!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-2\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-3\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-4\").isPresent()","new Utility.Query(panel).find(JPanel, \"super\").isPresent()"]},

        {"kind":"and","text":"The layout manager reports no constraints.","code":["layout.constraintMap.size() == 0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A panel bound tuple property will be zoomed into correctly. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub view bound to: \"+property.type().getSimpleName())","}","var panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["panel.components.every({it.text == \"I am the sub view bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A menu bound tuple property will be zoomed into correctly. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind any kind of tuple property and a view supplier \n            to dynamically bind to sub-views. These sub views will\n            be bound to a zoomed in property bound to a specific index in\n            the tuple of the parent property...\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A tuple property, a view supplier and a panel UI node.","code":["var trace = []","var models = Var.of(tuple)","BoundViewSupplier<Object> supplier = { Var<Object> property ->","    trace.add(property)","    return UI.label(\"I am the sub menu bound to: \"+property.type().getSimpleName())","}","var menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"expect","text":"","code":["trace.size() == tuple.size()","trace.every({it.type() == tuple.type()})","trace.every({it.allowsNull() == tuple.allowsNull()})"]},

        {"kind":"and","text":"","code":["menu.menuComponents.every({it.text == \"I am the sub menu bound to: \"+tuple.type().getSimpleName()})"]},

        {"kind":"where","text":"We test the following operations:","code":{"tuple":["Tuple.of(\"A\", \"B\", \"C\")","Tuple.of(\"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.of(2, 3, 5, 7, 11)","Tuple.of(0.47d, 3.5d, -2.22d, 84.3d)","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.SATURDAY, DayOfWeek.THURSDAY, DayOfWeek.WEDNESDAY)","Tuple.ofNullable(String, \"A\", null, \"B\", \"C\", null)","Tuple.ofNullable(String, \"watch\", \"dominion\", \"or\" ,\"earthlings\")","Tuple.ofNullable(Integer, null, 2, 3, 5, null, 7, 11)","Tuple.ofNullable(Double, 0.47d, null, 3.5d, null, -2.22d, 84.3d)","Tuple.ofNullable(DayOfWeek, DayOfWeek.MONDAY, null, DayOfWeek.SATURDAY, null)",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a panel compute efficiently. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated to match th expected pattern.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property is bound to a `JMenu` compute efficiently. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","ViewSupplier<String> supplier = (String title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a panel bi-directionally and compute efficiently. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<panel.getComponentCount()).collect({panel.getComponent(it)})"]},

        {"kind":"then","text":"The panel is updated.","code":["panel.getComponentCount() == models.get().size()","panel.getComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple property can be bound to a `JMenu` bi-directionally and compute efficiently. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a menu UI node.","code":["var tuple = Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\")","var models = Var.of(tuple)","BoundViewSupplier<String> supplier = (Var<String> title) -> UI.button(title)","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We unpack the pane and the expected differences:","code":["var iniComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We unpack the updated components:","code":["var updatedComps = (0..<menu.getMenuComponentCount()).collect({menu.getMenuComponent(it)})"]},

        {"kind":"then","text":"The menu is updated.","code":["menu.getMenuComponentCount() == models.get().size()","menu.getMenuComponentCount() == diff.findAll( it -> it == _ || it >= 0 ).size()"]},

        {"kind":"and","text":"","code":["diff.findAll({it == _ || it >= 0}).indexed().every({","    it.value == _ || iniComps[it.value] === updatedComps[it.key]","})"]},

        {"kind":"and","text":"The components at `-1` are totally new.","code":["diff.indexed().every({","    it.value == _ || it.value >= 0 || !(iniComps[it.key] in updatedComps)","})"]},

        {"kind":"where","text":"We test the following operations:","code":{"diff":["[0,-1, 2, 3, 4]","[0,-1,-1, 3, 4]","[0, _, 2, 3, 4]","[0, 2, 1, 3, 4]","[3, 2, 1, 0, 4]","[0, 3, 2, 1, 4]","[0, 1, 2, 4, 3]","[0, 1, 2, 3, 4, _]","[0, 1, 2, 3, 4, _, _]","[_, 0, 1, 2, 3, 4]","[-1, 1, 2, 3, -1]","[0, 1, -1, -1, -1]","[-1, -1, 2, 3, 4]","[-1, -1, -1, -1, -1]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]","[_, _, _, _, _]"],"operation":["{ it.removeAt(1) }","{ it.removeAt(1, 2) }","{ it.setAt(1, \"Comp X\") }","{ it.setAllAt(1, \"Comp 3\", \"Comp 2\") }","{ it.setAllAt(0, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 1\") }","{ it.setAllAt(1, \"Comp 4\", \"Comp 3\", \"Comp 2\", \"Comp 5\") }","{ it.setAllAt(3, \"Comp 5\", \"Comp 4\") }","{ it.add(\"Comp X\") }","{ it.addAll(\"Comp X\", \"Comp Y\") }","{ it.addAt(0, \"Comp X\") }","{ it.slice(1, 4) }","{ it.sliceFirst(2) }","{ it.sliceLast(3) }","{ it.clear() }","{ Tuple.of(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ it.clear().addAll(\"Comp 1\", \"Comp 2\", \"Comp 3\", \"Comp 4\", \"Comp 5\") }","{ Tuple.of(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }","{ it.clear().addAll(\"Comp a\", \"Comp b\", \"Comp c\", \"Comp d\", \"Comp e\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property will be reused efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property bi-directionally, will be reused efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a panel UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"JMenus bound to a tuple property bi-directionally, will be reused efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based tuple property and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string tuple property, a view supplier and a `JMenu` UI node.","code":["var models = Var.of(initialModels)","BoundViewSupplier<Object> supplier = (Var<Object> aThing) -> UI.button(aThing.itemAsString())","def menu =","            UI.menu()","            .addAll(models, supplier)","            .get(JMenu)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = menu.menuComponents as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the tuple...","code":["models.update( it -> operation(it) )","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = menu.menuComponents as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.get().contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.get().mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"initialModels":["Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(\"a\", \"b\")","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)","Tuple.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Tuple.of(\"X\", \"a\", \"z\") }","{ Tuple.of(-1, 2, -3) }","{ Tuple.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Binding a tuple property through `addAll` assumes full ownership over all sub-components.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Binding multiple sub-views to a component using the tuple property `addAll(..)`\n            method assumes full ownership over all sub-components. This means that you may not add\n            anything else to the bound component.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["Var<Team> team = Var.of(new Team(\"My Team\",","        Tuple.of(","            new Person(UUID.randomUUID(), \"\", \"\", new Address(\"\", 0)),","            new Person(UUID.randomUUID(), \"\", \"\", new Address(\"\", 0)),","            new Person(UUID.randomUUID(), \"\", \"\", new Address(\"\", 0)),","            new Person(UUID.randomUUID(), \"\", \"\", new Address(\"\", 0))","        )","    ))"]},

        {"kind":"and","text":"","code":["Var<String>        name    = team.zoomTo(Team::name,    Team::withName);","Var<Tuple<Person>> members = team.zoomTo(Team::members, Team::withMembers);"]},

        {"kind":"and","text":"","code":["var view =","        UI.panel().withLayout(UI.FILL.and(UI.WRAP(2)))","        .add(UI.GROW,","            UI.label(\"Team - \"),","            UI.textField(name)","        )","        .addAll(UI.GROW, members, (Var<Person> person)->{","            Var<String>  forename   = person.zoomTo(Person::forename, Person::withForename);","            Var<String>  surname    = person.zoomTo(Person::surname,  Person::withSurname);","            Var<Address> address    = person.zoomTo(Person::address,  Person::withAddress);","            Var<String>  street     = address.zoomTo(Address::street,     Address::withStreet);","            Var<Integer> postalCode = address.zoomTo(Address::postalCode, Address::withPostalCode);","            return UI.panel().withLayout(UI.FILL.and(UI.WRAP(2)))","                    .add(UI.SPAN, UI.label(\"Name:\"))","                    .add(UI.GROW, UI.textField(forename), UI.textField(surname))","                    .add(UI.SPAN, UI.label(\"Address:\"))","                    .add(UI.GROW, UI.textField(street), UI.numericTextField(postalCode));","        })","        .get(JPanel);"]},

        {"kind":"expect","text":"It is only 4 sub-components because the first two were removed!","code":["view.getComponentCount() == 4"]},

        {"kind":"and","text":"They are all JPanel instances (No team name or label).","code":["view.components.every({it instanceof JPanel})"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a tuple property can zoom further into its elements.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var trace = [:]"]},

        {"kind":"and","text":"","code":["Var<Team> team = Var.of(new Team(\"Awesome-Crew\",","        Tuple.of(","            new Person(UUID.randomUUID(), \"Ed\", \"Smith\", new Address(\"street 1\", 1)),","            new Person(UUID.randomUUID(), \"Sal\", \"Colin\", new Address(\"street 2\", 2)),","            new Person(UUID.randomUUID(), \"Cel\", \"Doe\", new Address(\"street 3\", 3)),","            new Person(UUID.randomUUID(), \"Sam\", \"Mill\", new Address(\"street 4\", 4))","        )","    ))"]},

        {"kind":"and","text":"","code":["Var<String>        name    = team.zoomTo(Team::name,    Team::withName);","Var<Tuple<Person>> members = team.zoomTo(Team::members, Team::withMembers);"]},

        {"kind":"and","text":"","code":["var view =","        UI.panel().withLayout(UI.FILL.and(UI.WRAP(2)))","        .addAll(UI.GROW, members, (Var<Person> person)->{","            Var<String>  forename   = person.zoomTo(Person::forename, Person::withForename);","            Var<String>  surname    = person.zoomTo(Person::surname,  Person::withSurname);","            Var<Address> address    = person.zoomTo(Person::address,  Person::withAddress);","            Var<String>  street     = address.zoomTo(Address::street,     Address::withStreet);","            Var<Integer> postalCode = address.zoomTo(Address::postalCode, Address::withPostalCode);","            trace[person.get().id()] = [","                    id: person.zoomTo(Person::id, Person::withId),","                    forename: forename, // We track this for simulating user input programmatically","                    surname: surname,","                    street: street,","                    postalCode: postalCode","                ]","            return UI.panel().withLayout(UI.FILL.and(UI.WRAP(2)))","                    .add(UI.SPAN, UI.label(\"Name:\"))","                    .add(UI.GROW, UI.textField(forename), UI.textField(surname))","                    .add(UI.SPAN, UI.label(\"Address:\"))","                    .add(UI.GROW, UI.textField(street), UI.numericTextField(postalCode));","        })","        .get(JPanel);","var initialComponents = view.components as List"]},

        {"kind":"expect","text":"","code":["view.getComponentCount() == 4"]},

        {"kind":"and","text":"","code":["view.components[0].components.collect({ it.text }) == [\"Name:\", \"Ed\", \"Smith\", \"Address:\", \"street 1\", \"1\"]","view.components[1].components.collect({ it.text }) == [\"Name:\", \"Sal\", \"Colin\", \"Address:\", \"street 2\", \"2\"]","view.components[2].components.collect({ it.text }) == [\"Name:\", \"Cel\", \"Doe\", \"Address:\", \"street 3\", \"3\"]","view.components[3].components.collect({ it.text }) == [\"Name:\", \"Sam\", \"Mill\", \"Address:\", \"street 4\", \"4\"]"]},

        {"kind":"when","text":"","code":["trace[team.get().members().get(0).id()].forename.set(\"Eddy\")","UI.sync()"]},

        {"kind":"then","text":"","code":["initialComponents == view.components as List","view.components[0].components.collect({ it.text }) == [\"Name:\", \"Eddy\", \"Smith\", \"Address:\", \"street 1\", \"1\"]","view.components[1].components.collect({ it.text }) == [\"Name:\", \"Sal\", \"Colin\", \"Address:\", \"street 2\", \"2\"]","view.components[2].components.collect({ it.text }) == [\"Name:\", \"Cel\", \"Doe\", \"Address:\", \"street 3\", \"3\"]","view.components[3].components.collect({ it.text }) == [\"Name:\", \"Sam\", \"Mill\", \"Address:\", \"street 4\", \"4\"]"]},

        {"kind":"when","text":"","code":["trace[team.get().members().get(1).id()].surname.set(\"Goodman\")","trace[team.get().members().get(2).id()].street.set(\"cherry-alley\")","UI.sync()"]},

        {"kind":"then","text":"","code":["initialComponents == view.components as List","view.components[0].components.collect({ it.text }) == [\"Name:\", \"Eddy\", \"Smith\", \"Address:\", \"street 1\", \"1\"]","view.components[1].components.collect({ it.text }) == [\"Name:\", \"Sal\", \"Goodman\", \"Address:\", \"street 2\", \"2\"]","view.components[2].components.collect({ it.text }) == [\"Name:\", \"Cel\", \"Doe\", \"Address:\", \"cherry-alley\", \"3\"]","view.components[3].components.collect({ it.text }) == [\"Name:\", \"Sam\", \"Mill\", \"Address:\", \"street 4\", \"4\"]"]},

        {"kind":"when","text":"","code":["trace[team.get().members().get(2).id()].id.set(UUID.randomUUID())","UI.sync()"]},

        {"kind":"then","text":"","code":["initialComponents != view.components as List","view.components[0] === initialComponents[0]","view.components[1] === initialComponents[1]","view.components[2] !== initialComponents[2]","view.components[3] === initialComponents[3]","view.components[0].components.collect({ it.text }) == [\"Name:\", \"Eddy\", \"Smith\", \"Address:\", \"street 1\", \"1\"]","view.components[1].components.collect({ it.text }) == [\"Name:\", \"Sal\", \"Goodman\", \"Address:\", \"street 2\", \"2\"]","view.components[2].components.collect({ it.text }) == [\"Name:\", \"Cel\", \"Doe\", \"Address:\", \"cherry-alley\", \"3\"]","view.components[3].components.collect({ it.text }) == [\"Name:\", \"Sam\", \"Mill\", \"Address:\", \"street 4\", \"4\"]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Views bound to a property list will be reused efficiently. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can bind a string based property list and a view supplier \n            to dynamically add or remove sub views. The GUI will only update the\n            views that have changed and it will reuse views for items that\n            existed in the previous tuple.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A string based property list, a view supplier and a panel UI node.","code":["var initialModels = models.toList()","ViewSupplier<Object> supplier = (Object aThing) -> UI.button(Objects.toString(aThing))","def panel =","            UI.panel()","            .addAll(models, supplier)","            .get(JPanel)"]},

        {"kind":"and","text":"We get a list of the current views.","code":["var initialComponents = panel.components as List<JComponent>"]},

        {"kind":"when","text":"We run the operation on the list...","code":["operation(models)","UI.sync()"]},

        {"kind":"and","text":"We evaluate the situation after the change:","code":["var newComponents = panel.components as List<JComponent>","var whichViewReused = initialComponents.collect({newComponents.contains(it)})","var whichModelsReused = initialModels.collect({models.contains(it)})"]},

        {"kind":"then","text":"The tabbed pane is updated.","code":["whichModelsReused == whichViewReused"]},

        {"kind":"and","text":"The new components are buttons with the expected text.","code":["newComponents.collect({it.text}) == models.mapTo(String, it -> Objects.toString(it)).toList()"]},

        {"kind":"where","text":"We test the following operations:","code":{"models":["Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(\"a\", \"b\")","Vars.of(1, 2, 3)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)","Vars.of(1, 2, 3, 4, 5, 6)"],"operation":["{ Vars.of(\"X\", \"a\", \"z\") }","{ Vars.of(-1, 2, -3) }","{ Vars.of(-1, 2, -3, 4, 5, 42) }","{ it.reversed() }","{ it.reversed() }","{ it.reversed() }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeFirst(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.removeLast(1) }","{ it.setAt(1, 42) }","{ it.setAllAt(2, 42, 73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A view model property may or may not exist, meaning its view may or may not be provided.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In larger GUIs usually consist views which themselves consist of multiple\n            sub views. This is also true for their view models which are usually\n            structured in the same tree like fashion. \n            Often times however, your views are highly dynamic and you not only want to\n            be able to swap out but also enable or disable a sub view (and its underlying view model) at runtime. \n            You can for example wrap your view model in a property and if it implements the \"Viewable\" interface\n            the view can bind to it to dynamically regenerate the view. \n            If the property is empty, the view will not be provided.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a view model.","code":["Var<String> username = Var.of(\"123 Main Street\")","Var<String> password = Var.of(\"Mr.\")","Var<String> moreUI = Var.ofNullable(String, null)"]},

        {"kind":"and","text":"A view which binds to the view model and a viewer which provides the view.","code":["var ui = UI.panel(\"fill, wrap 1\")","        .add(\"shrink\", UI.label(\"Dynamic Super View:\"))","        .add(\"grow\",","                UI.panel(\"fill\").id(\"super\")","                .add(UI.label(\"Username:\"))","                .add(UI.textField(username))","                .add(UI.label(\"Password:\"))","                .add(UI.textField(password))","                .add(moreUI, subViewModel ->","                    UI.panel().id(\"sub-1\")","                    .add(UI.label(\"Admin Status Code: xyz\"))","                    .add(UI.button(\"Do admin stuff!\"))","                )","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"We query the UI for the views and verify that the \"super\" and \"sub-1\" views are present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","!new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()"]},

        {"kind":"when","text":"We set the \"moreUI\" property to a view model which implements the \"Viewable\" interface (a \"view provider\").","code":["moreUI.set(\"I am a dummy view model!\")","UI.sync()"]},

        {"kind":"then","text":"We expect all views to be present.","code":["new Utility.Query(panel).find(JPanel, \"super\").isPresent()","new Utility.Query(panel).find(JPanel, \"sub-1\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A boolean property can be used to switch between 2 foreground colors.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withForegroundIf(Val<Boolean>, Color, Color)' method,\n            you can switch between 2 foreground colors of a Swing component set dynamically\n            if the boolean property is true or false.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a property modelling the color switch.","code":["Var<Boolean> isRed = Var.of(true)"]},

        {"kind":"and","text":"We create a 2 colors.","code":["Color red = Color.RED","Color green = Color.GREEN"]},

        {"kind":"and","text":"We declare a label with a red foreground color.","code":["var ui = UI.label(\"Hello World!\").withForegroundIf(isRed, red, green)"]},

        {"kind":"and","text":"Then we build the component:","code":["var label = ui.get(JLabel)"]},

        {"kind":"expect","text":"The label should have a red foreground color.","code":["label.foreground == red"]},

        {"kind":"when","text":"We change the boolean property to false.","code":["isRed.set(false)","UI.sync()"]},

        {"kind":"then","text":"The label should have a green foreground color.","code":["label.foreground == green"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A boolean property can be used to switch between 2 background colors.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withBackgroundIf(Val<Boolean>, Color, Color)' method,\n            you can switch between 2 background colors of a Swing component set dynamically\n            if the boolean property is true or false.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a property modelling the color switch.","code":["Var<Boolean> isRed = Var.of(true)"]},

        {"kind":"and","text":"We create a 2 colors.","code":["Color red   = Color.RED","Color green = Color.GREEN"]},

        {"kind":"and","text":"We declare a label with a red background color.","code":["var ui = UI.label(\"Hello World!\").withBackgroundIf(isRed, red, green)"]},

        {"kind":"and","text":"Then we build the label component:","code":["var label = ui.get(JLabel)"]},

        {"kind":"expect","text":"The label should have a red background color.","code":["label.background == red"]},

        {"kind":"when","text":"We change the boolean property to false.","code":["isRed.set(false)","UI.sync()"]},

        {"kind":"then","text":"The label should have a green background color.","code":["label.background == green"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A boolean property can be used to set or reset a foreground color.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withForegroundIf(Val<Boolean>, Color)' method,\n            you can set or reset the foreground color of a Swing component dynamically\n            if the boolean property is true or false.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a property modelling the color switch.","code":["Var<Boolean> isRed = Var.of(false)"]},

        {"kind":"and","text":"We create a label with a yellow background color.","code":["var ui = UI.label(\"Hello World!\").withForegroundIf(isRed, Color.YELLOW)"]},

        {"kind":"and","text":"Now we build the component:","code":["var label = ui.get(JLabel)"]},

        {"kind":"and","text":"We remember the original foreground color.","code":["Color originalColor = label.foreground"]},

        {"kind":"expect","text":"The label should have the original foreground color.","code":["label.foreground == originalColor"]},

        {"kind":"when","text":"We change the boolean property to true.","code":["isRed.set(true)","UI.sync()"]},

        {"kind":"then","text":"The label should have a yellow foreground color because the boolean property is true.","code":["label.foreground == Color.YELLOW"]},

        {"kind":"when","text":"We change the boolean property to false.","code":["isRed.set(false)","UI.sync()"]},

        {"kind":"then","text":"Again, the label should have the original foreground color.","code":["label.foreground == originalColor"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A boolean property can be used to set or reset a background color.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withBackgroundIf(Val<Boolean>, Color)' method,\n            you can set or reset the background color of a Swing component dynamically\n            if the boolean property is true or false.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a property modelling the color switch.","code":["Var<Boolean> isRed = Var.of(false)"]},

        {"kind":"and","text":"We declare a label with a yellow background color.","code":["var ui = UI.label(\"Hello World!\").withBackgroundIf(isRed, Color.YELLOW)"]},

        {"kind":"and","text":"Then we actually build the component:","code":["var label = ui.get(JLabel)"]},

        {"kind":"and","text":"We remember the original background color.","code":["Color originalColor = label.background"]},

        {"kind":"expect","text":"The label should have the original background color.","code":["label.background == originalColor"]},

        {"kind":"when","text":"We change the boolean property to true.","code":["isRed.set(true)","UI.sync()"]},

        {"kind":"then","text":"The label should have a yellow background color because the boolean property is true.","code":["label.background == Color.YELLOW"]},

        {"kind":"when","text":"We change the boolean property to false.","code":["isRed.set(false)","UI.sync()"]},

        {"kind":"then","text":"Again, the label should have the original background color.","code":["label.background == originalColor"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The foreground color of a Swing component can be modelled using a boolean and a Color property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withForegroundIf(Val<Boolean>, Val<Color>)' method,\n            the foreground color of a Swing component is set dynamically\n            if the boolean property is true.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A boolean property.","code":["var displayColor = Var.of(false)"]},

        {"kind":"and","text":"A color property.","code":["var color = Var.of(Color.RED)"]},

        {"kind":"and","text":"A Swing UI with a simple label bound to the properties:","code":["var ui = UI.panel()","        .add(","            UI.label(\"Hi!\").id(\"XYZ\")","            .withForeground(Color.GREEN) // default color","            .withForegroundIf(displayColor, color)","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"The label should have the default foreground color.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getForeground() == Color.GREEN"]},

        {"kind":"when","text":"We set the boolean property to true.","code":["displayColor.set(true)","UI.sync()"]},

        {"kind":"then","text":"The label should have a foreground color.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getForeground() == Color.RED"]},

        {"kind":"when","text":"We set the color property to blue.","code":["color.set(Color.BLUE)","UI.sync()"]},

        {"kind":"then","text":"The label should have a foreground color of blue.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getForeground() == Color.BLUE"]},

        {"kind":"when","text":"We set the boolean property to false.","code":["displayColor.set(false)","UI.sync()"]},

        {"kind":"then","text":"The label should have the default foreground color, green.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getForeground() == Color.GREEN"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The background color of a Swing component can be modelled using a boolean and a Color property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withBackgroundIf(Val<Boolean>, Val<Color>)' method,\n            the background color of a Swing component is set dynamically\n            if the boolean property is true.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A boolean property.","code":["var displayColor = Var.of(false)"]},

        {"kind":"and","text":"A color property.","code":["var color = Var.of(Color.RED)"]},

        {"kind":"and","text":"A Swing UI with a simple label bound to the properties:","code":["var ui = UI.panel()","        .add(","            UI.label(\"Hi!\").id(\"XYZ\")","            .withBackground(Color.GREEN) // default color","            .withBackgroundIf(displayColor, color)","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"The label should have the default background color.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getBackground() == Color.GREEN"]},

        {"kind":"when","text":"We set the boolean property to true.","code":["displayColor.set(true)","UI.sync()"]},

        {"kind":"then","text":"The label should have a background color.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getBackground() == Color.RED"]},

        {"kind":"when","text":"We set the color property to blue.","code":["color.set(Color.BLUE)","UI.sync()"]},

        {"kind":"then","text":"The label should have a background color of blue.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getBackground() == Color.BLUE"]},

        {"kind":"when","text":"We set the boolean property to false.","code":["displayColor.set(false)","UI.sync()"]},

        {"kind":"then","text":"The label should have the default background color, green.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getBackground() == Color.GREEN"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tooltip of a component can be modelled using a String property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withTooltip(Val<String>)' method,\n            the tooltip of a Swing component is set dynamically\n            if the String property changes.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A String property.","code":["var tooltip = Var.of(\"Hello World!\")"]},

        {"kind":"and","text":"A Swing UI with a simple label bound to the property:","code":["var ui = UI.panel()","        .add(","            UI.label(\"Hi!\").id(\"XYZ\")","            .withTooltip(tooltip)","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"The label should have the default tooltip.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getToolTipText() == \"Hello World!\""]},

        {"kind":"when","text":"We set the String property to \"Hello Universe!\".","code":["tooltip.set(\"Hello Universe!\")","UI.sync()"]},

        {"kind":"then","text":"The label should have a tooltip.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getToolTipText() == \"Hello Universe!\""]},

        {"kind":"when","text":"We set the String property to an empty String.","code":["tooltip.set(\"\")","UI.sync()"]},

        {"kind":"then","text":"The label should have no tooltip.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().getToolTipText() == null"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A border title can be modelled using properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withBorderTitle(Val<String>)' method,\n            the title of a Swing component's border is set dynamically\n            if the String property changes.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A String property.","code":["var title = Var.of(\"Hello World!\")"]},

        {"kind":"and","text":"A Swing UI with a simple label bound to the property:","code":["var ui = UI.panel().id(\"My-Panel\")","        .withBorderTitled(title)","        .add(","            UI.label(\"Hi!\")","            //... some other stuff","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"The panel should have the expected default border title.","code":["((TitledBorder)new Utility.Query(panel).find(JPanel, \"My-Panel\").get().border).getTitle() == \"Hello World!\""]},

        {"kind":"when","text":"We set the String property to \"Hello Universe!\".","code":["title.set(\"Hello Universe!\")","UI.sync()"]},

        {"kind":"then","text":"The panel should have a border title.","code":["((TitledBorder)new Utility.Query(panel).find(JPanel, \"My-Panel\").get().border).getTitle() == \"Hello Universe!\""]},

        {"kind":"when","text":"We set the String property to an empty String.","code":["title.set(\"\")","UI.sync()"]},

        {"kind":"then","text":"The panel should have no border title.","code":["((TitledBorder)new Utility.Query(panel).find(JPanel, \"My-Panel\").get().border).getTitle() == \"\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The type of cursor displayed over a component can be modelled using properties.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the 'withCursor(Val<Cursor>)' method,\n            the cursor displayed over a Swing component is set dynamically\n            if the Cursor property changes.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A Cursor property.","code":["var cursor = Var.of(UI.Cursor.DEFAULT)"]},

        {"kind":"and","text":"A Swing UI with a simple label bound to the property:","code":["var ui = UI.panel()","        .add(","            UI.label(\"Hi!\").id(\"XYZ\")","            .withCursor(cursor)","        )"]},

        {"kind":"and","text":"We build the component:","code":["var panel = ui.get(JPanel)"]},

        {"kind":"expect","text":"The label should have the default cursor.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().cursor.type == UI.Cursor.DEFAULT.type"]},

        {"kind":"when","text":"We set the Cursor property to a crosshair cursor.","code":["cursor.set(UI.Cursor.CROSS)","UI.sync()"]},

        {"kind":"then","text":"The label should have a crosshair cursor.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().cursor.type == UI.Cursor.CROSS.type"]},

        {"kind":"when","text":"We set the Cursor property to a hand cursor.","code":["cursor.set(UI.Cursor.HAND)","UI.sync()"]},

        {"kind":"then","text":"The label should have a hand cursor.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().cursor.type == UI.Cursor.HAND.type"]},

        {"kind":"when","text":"We set the Cursor property to a text cursor.","code":["cursor.set(UI.Cursor.TEXT)","UI.sync()"]},

        {"kind":"then","text":"The label should have a text cursor.","code":["new Utility.Query(panel).find(JLabel, \"XYZ\").get().cursor.type == UI.Cursor.TEXT.type"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
