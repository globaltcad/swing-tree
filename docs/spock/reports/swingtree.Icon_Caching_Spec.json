{
  "className":"swingtree.Icon_Caching_Spec",
  "title":"SwingTree Icon Caching",
  "narrative":"SwingTree does a lot of heavy lifting for\n    you when it comes to image asset management.\n    It can load, instantiate, cache and unload\n    image resources for you fully automatically.\n\n    This is possible through instances of the `IconDeclaration`,\n    which is a meta-data holder that can tell you where and\n    how to obtain an image.\n    Typically, this is a path to a png/jpg/svg but it\n    may also be an SVG string...\n    Instead of loading and instantiating `ImageIcon`s yourself,\n    you only need to create a declaration pointing to the resource:\n\n    `var cancel = IconDeclaration.of(path/to/cancel.svg);`\n\n    You can then pass this declaration to a SwingTree GUI,\n    and the heavy lifting will be done under the hood for you.\n    This is especially powerful because SwingTree uses these icon\n    declarations as weak cache keys for icons. So when you no longer\n    need an icon, you simply get rid of a strong reference to an icon\n    declaration! Under the hood these `IconDeclaration`s are also pooled,\n    so you can create and hold them in multiple places of your project\n    with the guarantee that the cache will be hit and not cleared prematurely.",
  "subjects":["swingtree.api.IconDeclaration","swingtree.SwingTree","swingtree.UI"],
  "statistics":{
    "runs":"2",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"SwingTree maintains a resourceful and robust image cache.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            SwingTree has a weak hash map in its library\n            context object which uses `IconDeclaration`s as keys.\n            Since these icon declarations are automatically pooled\n            when created through factory methods like `IconDeclaration.of(..)`\n            the cache is both reliable in terms of hit rate, while also\n            being resourceful, since unused entries get cleared automatically.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"First we clear the library context so that there is no state leftover from other tests:","code":["SwingTree.initialize()"]},

        {"kind":"and","text":"We creat a bunch of different icon declarations.","code":["var icon1 = IconDeclaration.of(\"img/trees.png\")","var icon2 = IconDeclaration.of(\"img/plus.svg\")","var icon3 = IconDeclaration.of(Size.unknown(), \"img/a-window-svg\")","var icon4 = IconDeclaration.of(Size.of(-1, 32), \"img/seed.png\")","var icon5 = IconDeclaration.ofSvg(\"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 16 16\\\"><circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"6\\\" fill=\\\"red\\\"/></svg>\")"]},

        {"kind":"expect","text":"Initially the cache is empty!","code":["SwingTree.get().getIconCache().isEmpty()"]},

        {"kind":"when","text":"We use the icons in various ways.","code":["var icon1CustomLoad = UI.findIcon(icon1)","var icon2CustomLoad = UI.findSvgIcon(icon2)","var icon3Button = UI.toggleButton(icon3).get(JToggleButton)","var icon4InStyle = UI.panel().withStyle(it->it.image(i->i.image(icon4))).get(JPanel)","var icon5InStyle = UI.panel().withStyle(it->it.image(i->i.svg(icon5.source()))).get(JPanel)"]},

        {"kind":"then","text":"The cache now contains 5 entries, which are our icons!","code":["SwingTree.get().getIconCache().size() == 5"]},

        {"kind":"when","text":"We reuse the icons...","code":["var icon1Reused = UI.findIcon(icon1)","var icon2Reused = UI.findIcon(icon2)","var icon3Reused = UI.box().withStyle(it->it.image(i->i.image(icon3))).get(JBox)","var icon4Reused = UI.findIcon(icon4)","var icon5Reused = UI.button(icon5).get(JButton)"]},

        {"kind":"then","text":"The cache does not increase in size because icons are reused.","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 5)"]},

        {"kind":"when","text":"We set all the usages to `null`...","code":["icon1CustomLoad = null","icon2CustomLoad = null","icon3Button = null","icon4InStyle = null","icon5InStyle = null","icon1Reused = null","icon2Reused = null","icon3Reused = null","icon4Reused = null","icon5Reused = null"]},

        {"kind":"then","text":"The cache still full, since we hold on to the declarations:","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 5)"]},

        {"kind":"when","text":"We replace the existing declarations with the same contents:","code":["icon1 = IconDeclaration.of(\"img/trees.png\")","icon2 = IconDeclaration.of(\"img/plus.svg\")","icon3 = IconDeclaration.of(Size.unknown(), \"img/a-window-svg\")","icon4 = IconDeclaration.of(Size.of(-1, 32), \"img/seed.png\")","icon5 = IconDeclaration.ofSvg(\"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 16 16\\\"><circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"6\\\" fill=\\\"red\\\"/></svg>\")"]},

        {"kind":"then","text":"The cache is still not cleared, since we are still holding on to the same (pooled) declarations!","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 5)"]},

        {"kind":"when","text":"We set the first icon declaration to `null` and wait...","code":["icon1 = null"]},

        {"kind":"then","text":"The cache finally shrinks by 1:","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 4)"]},

        {"kind":"when","text":"We set the second icon declaration to `null` and wait...","code":["icon2 = null"]},

        {"kind":"then","text":"The cache shrinks again:","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 3)"]},

        {"kind":"when","text":"We do the third icon declaration...","code":["icon3 = null"]},

        {"kind":"then","text":"The cache got smaller again:","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 2)"]},

        {"kind":"when","text":"We do the fourth icon declaration...","code":["icon4 = null"]},

        {"kind":"then","text":"Only one icon left:","code":["eventually(10, ()->SwingTree.get().getIconCache().size() == 1)"]},

        {"kind":"when","text":"We finally clear the last icon declaration...","code":["icon5 = null"]},

        {"kind":"then","text":"The cache is empty again!","code":["eventually(10, ()->SwingTree.get().getIconCache().isEmpty())"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `IconDeclaration` factory methods produce pooled objects.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var path1 = \"img/dandelion.png\"","var path2 = \"img/seed.png\"","var svg1 = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 16 16\\\"><circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"6\\\" fill=\\\"red\\\"/></svg>\"","var svg2 = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 16 16\\\"><circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"6\\\" fill=\\\"green\\\"/></svg>\""]},

        {"kind":"expect","text":"","code":["IconDeclaration.of(path1) == IconDeclaration.of(path1)","IconDeclaration.of(path1) === IconDeclaration.of(path1)","IconDeclaration.of(path1) != IconDeclaration.of(path2)","IconDeclaration.of(path1) !== IconDeclaration.of(path2)"]},

        {"kind":"and","text":"","code":["IconDeclaration.of(Size.of(-1, 8), path1) == IconDeclaration.of(Size.of(-1, 8), path1)","IconDeclaration.of(Size.of(-1, 8), path1) === IconDeclaration.of(Size.of(-1, 8), path1)","IconDeclaration.of(Size.of(4, 6), path1) != IconDeclaration.of(Size.of(-1, 8), path1)","IconDeclaration.of(Size.of(4, 6), path1) !== IconDeclaration.of(Size.of(-1, 8), path1)"]},

        {"kind":"and","text":"","code":["IconDeclaration.of(Size.unknown(), path1) == IconDeclaration.of(path1)","IconDeclaration.of(Size.unknown(), path1) === IconDeclaration.of(path1)"]},

        {"kind":"and","text":"","code":["IconDeclaration.ofSvg(svg1) == IconDeclaration.ofSvg(svg1)","IconDeclaration.ofSvg(svg1) === IconDeclaration.ofSvg(svg1)","IconDeclaration.ofSvg(svg1) != IconDeclaration.ofSvg(svg2)","IconDeclaration.ofSvg(svg1) !== IconDeclaration.ofSvg(svg2)"]},

        {"kind":"and","text":"","code":["IconDeclaration.ofAutoScaledSvg(svg1) == IconDeclaration.ofAutoScaledSvg(svg1)","IconDeclaration.ofAutoScaledSvg(svg1) === IconDeclaration.ofAutoScaledSvg(svg1)","IconDeclaration.ofAutoScaledSvg(svg1) != IconDeclaration.ofAutoScaledSvg(svg2)","IconDeclaration.ofAutoScaledSvg(svg1) !== IconDeclaration.ofAutoScaledSvg(svg2)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
