{
  "project": "Swing-Tree",
  "version": "0.2.0",
  "created": "Tue Jun 27 22:33:42 CEST 2023",
  "statistics":{
    "runs":"38",
    "passed":"37",
    "failed":"1",
    "featureFailures":"0",
    "successRate":"0.9736842105263158",
    "duration":"?"
  },
  "specifications": [{
      "className":"swingtree.button.JButton_Example_Spec",
      "title":"",
      "narrative":"",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A button will delegate its siblings within actions:","extraInfo":[]},{"id":"We can easily create a button with an associated action:","extraInfo":[]},{"id":"We can go through the entire siblinghood, including the current button!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.combo.Combo_Box_Specification",
      "title":"Drop Downs, aka Combo Boxes",
      "narrative":"In Swing drop downs are called combo boxes, which\n    is what they will be referred to in this specification as well.  \n    This specification will show you how you can create them and\n    how you can interact with them.",
      "featureCount":"14",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A combo box can be made editable in a declarative way.","extraInfo":[]},{"id":"A combo box created by Swing-Tree uses the provided item array as data model.","extraInfo":[]},{"id":"A combo box created by Swing-Tree uses the provided item list as data model.","extraInfo":[]},{"id":"An editable combo box will try to parse any kind of user input to match bound properties.","extraInfo":[]},{"id":"An editable combo box will try to parse user input to match bound properties.","extraInfo":[]},{"id":"Changing properties in you view model automatically updates an editable combo box.","extraInfo":[]},{"id":"Changing properties in you view model automatically updates the combo box.","extraInfo":[]},{"id":"Swing tree is a wrapper around Swing, which means you can create the combo box yourself.","extraInfo":[]},{"id":"The \"comboBox\" factory method allows you to easily create a combo box from an array.","extraInfo":[]},{"id":"The options of an editable combo box are only editable if their items list is modifyable.","extraInfo":[]},{"id":"You can model both the current selection state as well as options of your combo box using 2 properties.","extraInfo":[]},{"id":"You can model both the current selection state as well as options of your combo box using a property and a list.","extraInfo":[]},{"id":"You can model both the current selection state as well as options of your combo box using a property and an array.","extraInfo":[]},{"id":"You can model the options of your combo boxes using \"Vars\".","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.common.Basic_UI_Builder_Examples_Spec",
      "title":"Swing tree makes UI building fun again!",
      "narrative":"The Swing-Tree library allows you to build UIs using declarative code, \n    which you can think of as a more dynamic type of HTML but for swing.\n    It is inspired by frameworks like Jetpack Compose, Flutter, React and SwiftUI\n    which are also based on nested builder patterns to design your UI.\n    In this specification we cover the utter most basics of swing tree.",
      "featureCount":"16",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A tabbed pane can be created and populated in a declarative way.","extraInfo":[]},{"id":"An enum based combo box can have custom cell rendering.","extraInfo":[]},{"id":"Component events can be registered on swing tree nodes.","extraInfo":[]},{"id":"Swing tree nests all kinds of components (trough builder nodes).","extraInfo":[]},{"id":"Tab header components can be passed to the \"tab\" factory method instead of the title.","extraInfo":[]},{"id":"The tab buttons of a tabbed pane can have custom components.","extraInfo":[]},{"id":"Use the \"peek( c -> {} )\" method to access the wrapped Swing component in your Swing-Tree.","extraInfo":[]},{"id":"We can add a list of components to the swing tree API and get a builder node in return.","extraInfo":[]},{"id":"We can create a border layout based Swing tree.","extraInfo":[]},{"id":"We can easily define the cursor on a wrapped UI component","extraInfo":[]},{"id":"We can nest JPanel UI nodes to structure UIs.","extraInfo":[]},{"id":"We can register different UI focus event handlers to swing tree nodes.","extraInfo":[]},{"id":"We can register list selection events on a JList based swing tree node.","extraInfo":[]},{"id":"We can register various kinds of different keyboard event handlers to swing tree frame builder.","extraInfo":[]},{"id":"We can register various kinds of different keyboard event handlers to swing tree nodes.","extraInfo":[]},{"id":"We can use the `box()` factory to group UIs seemlesly.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.common.Basic_UI_Exception_Spec",
      "title":"How Not To Use",
      "narrative":"This specification shows you how NOT to use the Swing-Tree API.",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Certain Swing-Tree UI builder, do not allow you to use nullable properties.","extraInfo":[]},{"id":"The given factory methods do not accept null arguments.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.common.UI_Query_Spec",
      "title":"Swing Tree UI Query",
      "narrative":"The Swing-Tree UI builder allows you to easily build UIs and query them for\n    specific components inside component event action lambdas! \n    This allows you to easily build UIs that are event driven and react to\n    user input in a very flexible way.\n    Note that this should be used with care as it can lead to very complex\n    UIs that are hard to maintain.\n    Please consider modelling your UIs logic using MVVM based on \n    property bindings (See the properties specification).",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"We can query the swing tree within an action lambda.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.common.UI_Updates_Spec",
      "title":"Dynamic UI Updates",
      "narrative":"The Swing-Tree UI builder allows you to easily build UI with periodic updates.\n    This is useful for example when you want to build animated UIs or UIs that\n    perform some sort of refreshes periodically.",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"We can register periodically called UI updates!","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.events.Event_Handling_Spec",
      "title":"Registering Event Handlers",
      "narrative":"In this specification you can see how to register different kinds of event handlers\n    on Swing components.",
      "featureCount":"13",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"In a formatted text field, the \"onEnter\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onChange\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onClick\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onContentChange\" event handler of a text area is triggered when the text area content changes.","extraInfo":[]},{"id":"The \"onEnter\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onResize\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onSelection\" event handlers of a combo box are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onShown\" event handlers are triggered in the same order as they were registered.","extraInfo":[]},{"id":"The \"onTextChange\" event handler of a text area is triggered when the text area content changes.","extraInfo":[]},{"id":"The \"onTextInsert\" event handler of a text area is triggered when the text area content changes.","extraInfo":[]},{"id":"The \"onTextRemove\" event handler of a text area is triggered when the text area content changes.","extraInfo":[]},{"id":"The \"onTextReplace\" event handler of a text area is triggered when the text area content changes.","extraInfo":[]},{"id":"The \"onTextReplace\" event handlers will be triggered in the correct order.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.examples.Examples_Spec",
      "title":"Examples UIs",
      "narrative":"This is an overview of the various example UIs\n    in the test suite.\n\n    This specification also ensures that the\n    various UI examples in the test suite, \n    run successfully and also produce\n    UIs with expected state and appearance.",
      "featureCount":"19",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"The \"MadeWithSwingTree\" example UI defined in the examples can be created.","extraInfo":[]},{"id":"The \"Well rounded\" style example UI defined in the examples can be created.","extraInfo":[]},{"id":"The advanced UI define in the examples has the expected state.","extraInfo":[]},{"id":"The animated buttons view examples UI defined in the examples looks as expected.","extraInfo":[]},{"id":"The animation example view can be created.","extraInfo":[]},{"id":"The box shadow picker example UI defined in the examples can be created.","extraInfo":[]},{"id":"The calculator UI defined in the examples has the expected state and looks.","extraInfo":[]},{"id":"The form UI defined in the examples has the expected state.","extraInfo":[]},{"id":"The list examples UI defined in the examples can be created.","extraInfo":[]},{"id":"The list rendering example UI defined in the examples can be created.","extraInfo":[]},{"id":"The login example UI defined in the examples, a good MVVM demonstration.","extraInfo":[]},{"id":"The note guesser example UI defined in the examples can be created.","extraInfo":[]},{"id":"The settings example UI defined in the examples looks as expected.","extraInfo":[]},{"id":"The simple Table-UI example has the expected state.","extraInfo":[]},{"id":"The soft example UI is rendered as expected.","extraInfo":[]},{"id":"The spinners example UI defined in the examples can be created.","extraInfo":[]},{"id":"The symbol guesser example UI defined in the examples can be created.","extraInfo":[]},{"id":"The todo app UI defined in the examples has the expected state.","extraInfo":[]},{"id":"The user registration example UI defined in the examples, a good MVVM demonstration.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Button_Binding_Spec",
      "title":"Button Binding",
      "narrative":"As a developer, I want to bind a button to a property so \n    that is is updated when the property changes.\n    Binding is a powerful feature that allows us to create\n    UIs which are not only decoupled from the business logic of\n    an application, but also make it easy to create UIs which\n    are dynamic and reactive.",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A button group will not only synchronize the selection state of radio buttons, but also bound properties.","extraInfo":[]},{"id":"Bind the \"isSelected\" flag of a button to the equality between an enum and a enum property","extraInfo":[]},{"id":"Bind the \"isSelected\" flag of a button to the inequality between an enum and a enum property","extraInfo":[]},{"id":"We can bind to the text of a button.","extraInfo":[]},{"id":"You can bind to the enabled state of a button.","extraInfo":[]},{"id":"You can bind to the selection state of a button.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Label_Binding_Spec",
      "title":"Label Binding",
      "narrative":"As a developer, I want to bind a label to a property so \n    that the label is updated when the property changes.\n    Binding is a powerful feature that allows us to create\n    UIs which are not only decoupled from the business logic of\n    an application, but also make it easy to create UIs which\n    are dynamic and reactive.",
      "featureCount":"9",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A property can define the horizontal and vertical alignment of a label.","extraInfo":[]},{"id":"A property can define the image relative horizontal and vertical alignment of a label.","extraInfo":[]},{"id":"It is possible to bind to the minimum, maximum and preferred size of a label","extraInfo":[]},{"id":"We can bind to the foreground and background color of a UI node.","extraInfo":[]},{"id":"We can bind to the text of a label.","extraInfo":[]},{"id":"We can store icons inside properties and then bind them to labels.","extraInfo":[]},{"id":"You can bind a variable to the \"enable\" flag of a label.","extraInfo":[]},{"id":"You can bind a variable to the \"visible\" flag of a label.","extraInfo":[]},{"id":"You can dynamically model the font size of your labels using an integer based property.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.MVVM_Example_Spec",
      "title":"MVVM Introduction",
      "narrative":"Swing-Tree allows you to create a Model-View-ViewModel (MVVM) architecture\n    based on 2 simple property interfaces: `Val`, and `Var`!\n\n    `Val` is a read-only property, and `Var` is a read-write property.\n\n    The state of both properties can be observed by the view using simple listeners.\n    This happens automatically when you pass them to the Swing-Tree view.\n    If you want to trigger an action when the property changes, you \n    have to pass the `Var` property to the view and define a action\n    for it inside of your view model.",
      "featureCount":"24",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A boolean property can be used to set or reset a background color.","extraInfo":[]},{"id":"A boolean property can be used to set or reset a foreground color.","extraInfo":[]},{"id":"A boolean property can be used to switch between 2 background colors.","extraInfo":[]},{"id":"A boolean property can be used to switch between 2 foreground colors.","extraInfo":[]},{"id":"A border title can be modelled using properties.","extraInfo":[]},{"id":"A simple array of elements can be used as a data model for a combo box.","extraInfo":[]},{"id":"A simple list of elements can be used as a data model for a combo box.","extraInfo":[]},{"id":"A string property can be bound to a combo box holding string elements.","extraInfo":[]},{"id":"A view model property may or may not exist, meaning its view may or may not be provided.","extraInfo":[]},{"id":"An enum based combo box can infer its possible states directly from the binding property.","extraInfo":[]},{"id":"Binding to the selection state of a button does nothing, because a JButton can only be pressed.","extraInfo":[]},{"id":"The background color of a Swing component can be modelled using a boolean and a Color property.","extraInfo":[]},{"id":"The foreground color of a Swing component can be modelled using a boolean and a Color property.","extraInfo":[]},{"id":"The tooltip of a component can be modelled using a String property.","extraInfo":[]},{"id":"The type of cursor displayed over a component can be modelled using properties.","extraInfo":[]},{"id":"View Models can be represented by properties lists.","extraInfo":[]},{"id":"View Models can be represented by properties.","extraInfo":[]},{"id":"We can bind a boolean property to a button, and when the user presses it, we notice it.","extraInfo":[]},{"id":"We can bind a boolean property to a checkbox, and when the user presses it, we notice it.","extraInfo":[]},{"id":"We can bind a boolean property to a radio button, and when the user presses it, we notice it.","extraInfo":[]},{"id":"We can bind a boolean property to a toggle button, and when the user presses it, we notice it.","extraInfo":[]},{"id":"We can bind a enum property to a combo box and when the user selects an item, we notice it.","extraInfo":[]},{"id":"We can create a property based view model and build a view for it.","extraInfo":[]},{"id":"You can bind a property as the current selection as well as list of elements as options to a combo box.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Properties_Spec",
      "title":"Properties",
      "narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Swing-Tree library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components.",
      "featureCount":"18",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A property can be converted to an Optional.","extraInfo":[]},{"id":"A property constructed using the \"of\" factory method, does not allow null items.","extraInfo":[]},{"id":"Changing the value of a property through the \"act\" method will also affect its views","extraInfo":[]},{"id":"Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","extraInfo":[]},{"id":"Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","extraInfo":[]},{"id":"Properties are simple wrappers around a value","extraInfo":[]},{"id":"Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","extraInfo":[]},{"id":"Properties not only have a value but also a type and id!","extraInfo":[]},{"id":"The \"get\" method will throw an exception if there is no element present.","extraInfo":[]},{"id":"The \"ifPresent\" method allows us to see if a property has a value or not.","extraInfo":[]},{"id":"The \"withID(..)\" method produces a new property with all bindings inherited.","extraInfo":[]},{"id":"The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","extraInfo":[]},{"id":"The equality and hash code of a property are based on its value, type and id!","extraInfo":[]},{"id":"The string representation of a property will give you all the information you need.","extraInfo":[]},{"id":"There are 2 types of properties, an immutable property, and its mutable sub-type.","extraInfo":[]},{"id":"There are various kinds of convenience methods for creating live view of properties.","extraInfo":[]},{"id":"They can be bound to the UI by passing them to a builder node.","extraInfo":[]},{"id":"Use the \"viewAs\" method to create a dynamically updated view of a property.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Property_Binding_Spec",
      "title":"Property Binding",
      "narrative":"This specification shows you how to bind properties to \n    the states of common types UI components.",
      "featureCount":"16",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Bind the foreground of a component to a conditional property and 2 color properties.","extraInfo":[]},{"id":"Bind to both width and height independently if you want to.","extraInfo":[]},{"id":"Enable or disable the split items of a JSplitButton through properties.","extraInfo":[]},{"id":"Minimum as well as maximum height of UI components can be modelled using integer properties.","extraInfo":[]},{"id":"Simple integer properties can be bound to the width or height of components.","extraInfo":[]},{"id":"The enabled/disabled state of a UI component can be modelled using an enum property.","extraInfo":[]},{"id":"The focusability of a UI component can be modelled dynamically using boolean properties.","extraInfo":[]},{"id":"The focusability of a UI component can be modelled using an enum property.","extraInfo":[]},{"id":"The visibility of a UI component can be modelled dynamically using boolean properties.","extraInfo":[]},{"id":"The visibility of a UI component can be modelled using an enum property.","extraInfo":[]},{"id":"The width and height of UI components can be modelled using integer properties.","extraInfo":[]},{"id":"We can bind a property to the size of a swing component.","extraInfo":[]},{"id":"We can bind to the color of a component.","extraInfo":[]},{"id":"We can bind to the text of a component.","extraInfo":[]},{"id":"We can enable and disable a UI component dynamically through property binding.","extraInfo":[]},{"id":"We can select or unselect a UI component dynamically through properties.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Scroll_Pane_Binding_Spec",
      "title":"Scroll Pane Binding",
      "narrative":"Although a scroll pane does not hold information\n    that is relevant to your core business logic, it certainly has certain properties\n    relevant to the view and its usability. \n    For example, the scroll pane can be enabled or disabled, or it\n    can have certain kinds of scroll policies.\n    This specifications shows how to bind `Val` properties to scroll panes.",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A property holding a vertical scroll bar policy can be bound to the UI.","extraInfo":[]},{"id":"You can model the horizontal scroll bar policy us ing a view model property dynamically.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.panel.Panel_Spec",
      "title":"Panels",
      "narrative":"Just like in regular Swing, the JPanel is the most basic \n    yet most important type of component in Swing-Tree\n    and you can create one using the `UI.panel()` factory method. \n    Don't hesitate to use as the main tool for grouping and structuring\n    your UI, just like you would use the 'div' tag in HTML.",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A panel can be created with a layout manager.","extraInfo":[]},{"id":"A panel node can be created using the UI.panel() factory method.","extraInfo":[]},{"id":"A transparent panel can be created with a custom flow layout manager.","extraInfo":[]},{"id":"All of the \"box(..)\" factory methods will create transparent panels without insets.","extraInfo":[]},{"id":"The default layout manager is always a MigLayout","extraInfo":[]},{"id":"The dimensions of a panel can be bound to a property.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.renderer.Table_Renderer_Spec",
      "title":"Rendering Table Cells",
      "narrative":"Swing-Tree exposes a user friendly API for rendering table cells.\n    For simple table UIs none of this is necessary, but it\n    is important when you want to populate your table with more complex data.\n    The renderer is a simple function that takes a value and returns a UI node.\n    The UI node is then rendered as a table cell.",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A map based table can have a custom cell renderer.","extraInfo":[]},{"id":"We can attach a simple table cell renderer to a JTable in just a few lines of code.","extraInfo":[]},{"id":"We can create a simple column major table cell renderer through a UI factory method.","extraInfo":[]},{"id":"We can create a simple table cell renderer through a UI factory method.","extraInfo":[]},{"id":"You can render the cells of a table as text by using the \"asText\" method.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.splitbutton.JSplitButton_Examples_Spec",
      "title":"A Button of Buttons",
      "narrative":"The Swing-Tree split button component allows \n    you to easily create split buttons in your UIs.\n    A split button is a button that has a drop down menu attached to it.\n    This allows you to easily add additional functionality to your buttons.\n    The split button component is a wrapper around the AlexAndria Software\n    JSplitButton component.",
      "featureCount":"10",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A JSplitButton and all of its options can be bound to and created from a simple enum property and bound to an event.","extraInfo":[]},{"id":"A JSplitButton and all of its options can be created from a simple enum property.","extraInfo":[]},{"id":"A button item can undo any multi-selection.","extraInfo":[]},{"id":"It is possible to select more than 1 item.","extraInfo":[]},{"id":"The most simple kind of split button can be built like so:","extraInfo":[]},{"id":"We can build a JSplitButton and add components to it.","extraInfo":[]},{"id":"We can easily build a split button where only one item text will have its text displayed:","extraInfo":[]},{"id":"We can easily build a split button whose text becomes the current user selection:","extraInfo":[]},{"id":"We can register button click events for button items as well as the split button as a whole.","extraInfo":[]},{"id":"We can specify which item should be initially selected.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.splitbutton.JSplitButton_Exception_Spec",
      "title":"",
      "narrative":"",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A JSplitButton does not accept null actions.","extraInfo":[]},{"id":"Split button items do not take null as an answer.","extraInfo":[]},{"id":"Split buttons do not take null as an answer.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.tabs.Tab_Binding_Spec",
      "title":"Binding Tabs to Properties",
      "narrative":"Tabs are a way to efficiently group related content in a single container.\n    The tabs can be bound to a property, so that the selected tab is always\n    the one that corresponds to the value of the property.\n    You can also model other aspects of a tab using properties, such as\n    whether it is enabled, visible, or has a tooltip.",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A string property can model the title of a tab!","extraInfo":[]},{"id":"Icons can be bound to tab headers dynamically.","extraInfo":[]},{"id":"Modelling the tooltip of a tab is also possible.","extraInfo":[]},{"id":"Properties allow you to enable or disable individual tabs.","extraInfo":[]},{"id":"The selection state of tabs can be modelled through various properties.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.threading.Thread_Mode_Spec",
      "title":"Thread Modes",
      "narrative":"Swing only knows 1 thread, the Event Dispatch Thread (EDT)\n    which performs both the UIs rendering as well as event handling.\n    This is a problem for Swing applications that need to perform\n    long running tasks in the background, as the EDT will be blocked\n    until the task is complete.\n    SwingTree provides a mechanism for creating UIs which \n    dispatch events to a custom application thread as well as ensure that all UI related \n    operations are performed on the event dispatch thread!\n    Not only does this allow your applications to perform long running tasks\n    in the background without blocking the UI, it improves\n    the performance and responsiveness of you desktop application as a whole.",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Accessing the UI from something other than the UI thread, leads to an exception when in decoupled thread mode.","extraInfo":[]},{"id":"Inside an event lambda we can not access the UI from a background thread.","extraInfo":[]},{"id":"The application thread can safely effect the state of the UI by using the \"UI.run(()->{..})\" method.","extraInfo":[]},{"id":"The default \"coupled\" thread mode will use the AWT thread for event handling.","extraInfo":[]},{"id":"We can use the decoupled thread mode to queue backend events.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.other.OptionalUI_Spec",
      "title":"OptionalUI, a Swing-Tree Monad",
      "narrative":"The OptionalUI is a monadic container object for AWT Component types\n    which may or may not contain a non-null value.",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"An OptionalUI can be mapped to a regular non-empty optional.","extraInfo":[]},{"id":"An empty OptionalUI will return a default value when orElse is called.","extraInfo":[]},{"id":"An empty OptionalUI will return a default value when orElseGet is called.","extraInfo":[]},{"id":"An empty OptionalUI will throw an exception when orElseThrow is called.","extraInfo":[]},{"id":"OptionalUI can be mapped to a regular empty optional.","extraInfo":[]},{"id":"OptionalUI wraps AWT components exclusively.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.OptionalUI_Spec",
      "title":"OptionalUI, a Swing-Tree Monad",
      "narrative":"The OptionalUI is a monadic container object for AWT Component types\n    which may or may not contain a non-null value.",
      "featureCount":"1",
      "failures":"0",
      "errors":"1",
      "skipped":"0" ,
      "successRate":"0.0",
      "duration":"?",
      "executedFeatures":[{"id":"OptionalUI wraps AWT components exclusively.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Properties_List_Spec",
      "title":"Lists of Properties",
      "narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable).",
      "featureCount":"18",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","extraInfo":[]},{"id":"A list of properties can be turned into lists, sets or maps using various convenience methods.","extraInfo":[]},{"id":"Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","extraInfo":[]},{"id":"Change listeners registered on a property list will be called when the list is sorted.","extraInfo":[]},{"id":"Just like a regular \"Var\" property you can register change listeners on \"Vars\".","extraInfo":[]},{"id":"Lists of properties can be sorted based on their natural order through the \"sort\" method.","extraInfo":[]},{"id":"Lists of properties can be sorted using a custom comparator through the \"sort\" method.","extraInfo":[]},{"id":"Map a \"Vals\" instance from one type of properties to another.","extraInfo":[]},{"id":"Map a \"Vars\" instance from one type of properties to another.","extraInfo":[]},{"id":"Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","extraInfo":[]},{"id":"The \"Vars\" is a list of properties which can grow and shrink.","extraInfo":[]},{"id":"The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","extraInfo":[]},{"id":"The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","extraInfo":[]},{"id":"The listeners registered in property lists will be informed what type of modification occurred.","extraInfo":[]},{"id":"The properties of one property list can be added to another property list.","extraInfo":[]},{"id":"You can create a \"Vars\" list from a regular List of properties.","extraInfo":[]},{"id":"You can create the \"Vars\"/\"Vals\" property lists from property instances.","extraInfo":[]},{"id":"You can remove n leading or trailing entries from a property list.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Property_Safety_Spec",
      "title":"Property Null and Mutability Safety",
      "narrative":"Properties are a core concept in Swing-Tree. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    immutable only when they need to be.\n\n    Furthermore, using nullable properties in Swing-Tree\n    will be prohibited it is does not make sense.\n    For example, you may not use null to model the text of a label,\n    instead, the empty String \"\" must be used!",
      "featureCount":"9",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"\"Vals\", a list of properties, is immutable.","extraInfo":[]},{"id":"A \"Val\" instance is immutable.","extraInfo":[]},{"id":"A \"Var\" may only wrap null if it is created as nullable.","extraInfo":[]},{"id":"A property can only wrap null if we specify a type class.","extraInfo":[]},{"id":"An empty property will throw an exception if you try to access its value.","extraInfo":[]},{"id":"Swing-Tree will not allow you to model a check box selection using a nullable properties.","extraInfo":[]},{"id":"The \"get\" method of a property throws an exception if the property is null.","extraInfo":[]},{"id":"The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","extraInfo":[]},{"id":"You may not model the text of a \"JLabel\" using a nullable property.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.testing.MVVM_Unit_Test_Spec",
      "title":"Writing Unit Tests for View Models",
      "narrative":"Not only is Swing-Tree a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite.",
      "featureCount":"2",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"The register button does nothing if the inputs are not all valid.","extraInfo":[]},{"id":"The registration view model will display feedback about invalid inputs.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.splitpane.Split_Pane_Spec",
      "title":"Split Panes",
      "narrative":"In this specification you can can not only see how to use the Swing-Tree API to \n   create and configure split panes but also how to bind them to your view model model.\n   The alignment of a split pane for example can be bound to a property in your view model.",
      "featureCount":"10",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A horizontally aligned split pane can be configured with a divider location as a percentage.","extraInfo":[]},{"id":"A horizontally aligned split pane can be created through the \"splitPane\" factory method.","extraInfo":[]},{"id":"A split pane can be configured with a divider location.","extraInfo":[]},{"id":"A split pane can be configured with a divider size.","extraInfo":[]},{"id":"A vertically aligned split pane can be configured with a divider location as a percentage.","extraInfo":[]},{"id":"A vertically aligned split pane can be created through the \"splitPane\" factory method.","extraInfo":[]},{"id":"An alignment property can be used to dynamically model the alignment of your split pane.","extraInfo":[]},{"id":"The divider location of a split pane can dynamically be modelled using an integer property.","extraInfo":[]},{"id":"The division of a split pane can dynamically be configured through a double property.","extraInfo":[]},{"id":"You can dynamically model the divider size of a split pane in your view model.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.mvvm.Scroll_Panels_Spec",
      "title":"",
      "narrative":"",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"We can instantiate the scroll panels view model and build a view for it.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.threading.Async_MVVM_Spec",
      "title":"Asynchronous MVVM",
      "narrative":"Swing only knows 1 thread, the Event Dispatch Thread (EDT)\n    which performs both the UIs rendering as well as event handling.\n    This is a problem for Swing applications that need to perform\n    long running tasks in the background, as the EDT will be blocked\n    until the task is complete.\n\n    SwingTree provides a mechanism for creating UIs which \n    dispatch events to a custom application thread as well as ensure that all UI related \n    operations are performed on the event dispatch thread!\n    Not only does this allow your applications to perform long running tasks\n    in the background without blocking the UI, it improves\n    the performance and responsiveness of you desktop application as a whole.\n\n    This specification demonstrates how this feature interacts with the MVVM pattern\n    and the binding of properties to UI components.",
      "featureCount":"1",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"The order in which the states of properties change is preserved when applied to the UI.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.scrollpane.Scroll_Pane_Spec",
      "title":"The Scroll Pane",
      "narrative":"Just like for any other main component in Swing,\n    Swing-Tree also supports a nice API for \n    building UIs with scroll panes.\n\n    A scroll pane is a component that allows\n    the user to scroll through a larger view\n    of a component. It is a container that\n    contains a single component, called the\n    viewport. The viewport is the area that\n    is actually visible to the user. \n\n    The scroll pane also contains a set of\n    scrollbars that allow the user to scroll\n    the viewport. \n\n    In this specification, we will see how\n    to build a scroll pane with Swing-Tree.",
      "featureCount":"6",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Configure both the horizontal and vertical scroll policy individually.","extraInfo":[]},{"id":"Configure the block scroll increment for both scroll bars in one line.","extraInfo":[]},{"id":"The horizontal as well as vertical block scroll increment can be configured easily.","extraInfo":[]},{"id":"Use the `UI.ScrollBarPolicy` enum to configure the scroll pane scroll bars.","extraInfo":[]},{"id":"We can configure the general scroll increment of the scroll pane scroll bars.","extraInfo":[]},{"id":"We can configure the vertical and horizontal scroll bar scroll increment of a scroll pane.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.animations.Animations_Spec",
      "title":"Animations",
      "narrative":"Animations are a great way to make your application more interactive and more fun to use.",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Animate the color of a label when it is clicked.","extraInfo":[]},{"id":"Implement the \"finish\" method in your animation to ensure that it is called at least once.","extraInfo":[]},{"id":"The event delegation object of a user event can be used to register animations.","extraInfo":[]},{"id":"Use the API exposed by \"UI.schedule(..)\" to schedule animations","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.common.Configuring_UI_Components_Spec",
      "title":"Configuring UI withMethod Chaining",
      "narrative":"The declarative nature of Swing-Tree is enabled by 1 fundamental\n    design patterns:\n\n    > Composition and Method Chaining!\n\n    So every method on a Swing-Tree UI builder node returns the node\n    instance itself. \n    This is especially useful when you want to configure a UI component.\n\n    In this specification we will see what this looks like.",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"The visibility of a component can be configured using various methods.","extraInfo":[]},{"id":"Use the \"makeDefaultButton()\" method to make a button the default button.","extraInfo":[]},{"id":"We can configure a button to have no border.","extraInfo":[]},{"id":"We can make a UI component grab the current input focus.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.styles.Individual_Component_Styling_Spec",
      "title":"Styling Components",
      "narrative":"This specification demonstrates how you can use the styling\n    API to style Swing components in a functional and declarative fashion.",
      "featureCount":"12",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Create a soft UI slider that sinks into the background if you wish.","extraInfo":[]},{"id":"Make a text area look like it is sunken in the background using a shadow going inwards.","extraInfo":[]},{"id":"Styling components is based on a functional styler lambda.","extraInfo":[]},{"id":"SwingTree will re-install any borders overridden by the style API.","extraInfo":[]},{"id":"SwingTree will un-install any custom border if no styles are found.","extraInfo":[]},{"id":"The Styling API will make sure that the layout manager accounts for the border width!","extraInfo":[]},{"id":"The insets of the layout manager are based on the sum of the margin and padding for a given edge of the component bounds.","extraInfo":[]},{"id":"The look of a component, like a button for example, will be preserved if possible, when doing custom styling.","extraInfo":[]},{"id":"The margins defined in the style API will be applied to the layout manager through the border insets.","extraInfo":[]},{"id":"This is how you can create a JPanel with a shaded border.","extraInfo":[]},{"id":"This is how you can create a rounded green label with a border at the bottom.","extraInfo":[]},{"id":"You can style a toggle button to have a custom selection shading.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.styles.Style_Sheet_Spec",
      "title":"Creating Style Sheets",
      "narrative":"No, SwingTree does not have a CSS parser.  \n    It does, however, have something better, which is similar to CSS.\n    An API for configuring styles in a declarative and type-safe way.\n\n    The main class for creating style sheets is the `StyleSheet` class,\n    an abstract class that you can extend to create your own styles like so:\n    ```java\n        class MyStyleSheet {\n           @Override\n           protected void build() {\n                add(id(\"some unique id!\"), it ->\n                    it.borderRadius(3)\n                );\n                add(type(JPanel.class), it ->\n                   it.borderColor(Color.GREEN)\n                );\n                add(type(JButton.class), it ->\n                    it.borderWidth(7)\n                );\n            }\n        }\n    ```\n    You can then easily apply this style sheet to you SinwgTree views like so:\n    ```java\n        UI.use(new MyStyleSheet(), () -> new MyView());\n    ```\n    The style sheet will be applied to all UI components created within the scope of the `use` method.",
      "featureCount":"11",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A StyleSheet can be created with a default style.","extraInfo":[]},{"id":"Duplicate style trait declaration will throw an exception!","extraInfo":[]},{"id":"Nonsensical style trait group inheritance rules will throw an exception!","extraInfo":[]},{"id":"The `group` style trait allows for inheritance, meaning a group can inherit from other ones.","extraInfo":[]},{"id":"The `type` style trait allows you to specify how a style trait applies to a component types.","extraInfo":[]},{"id":"The order of inherited style traits determines the order in which they are applied.","extraInfo":[]},{"id":"Use the `group` style trait to classify components.","extraInfo":[]},{"id":"Use the power of `Graphics2D` to render custom backgrounds inside you styles.","extraInfo":[]},{"id":"Write custom style sheet classes by extending the StyleSheet class.","extraInfo":[]},{"id":"You can define complex group inheritance graphs inside your style sheets.","extraInfo":[]},{"id":"You can style the font of a component inside your style sheet.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.styles.Styles_Spec",
      "title":"Style Properties",
      "narrative":"This specification demonstrates how the `Style` type\n    can be used to define how Swing components ought to be\n    rendered.",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Style objects are value based (with respect to equality and hash code).","extraInfo":[]},{"id":"The String representation of a Style will tell you everything about it!","extraInfo":[]},{"id":"Various kinds of String expressions can be parsed as colors by various style properties.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.windows.Showing_UI_Spec",
      "title":"Showing UIs",
      "narrative":"Any user interface needs a way to be shown to the user. \n    In Swing, this is done through various kinds of classes, \n    namely, the JFrame, JDialog and JWindow classes.\n\n    Swing-Tree allows you to instantiate and configure these\n    instances in a declarative fashion, and then show them\n    to the user.",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"The \"show\" method causes a JDialog to be displayed to the user.","extraInfo":[]},{"id":"The \"show\" method causes a JFrame to be displayed to the user.","extraInfo":[]},{"id":"Use the \"dialog()\" factory method to build a JDialog.","extraInfo":[]},{"id":"Use the \"frame()\" factory method to build a JFrame.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.tabs.Tab_Event_Handling_Spec",
      "title":"Tab Event Handling",
      "narrative":"When building a tabbed pane using SwingTree, you often want to react to\n    events that occur on the tabs of a `JTabbedPane`. \n    For example, you may want trigger some action when a tab is selected.\n\n    In this specification, we will see how to handle events on tabs.",
      "featureCount":"5",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Notice when the mouse enters a tab using the \"onTabMouseEnter\" event handler.","extraInfo":[]},{"id":"Notice when the mouse exits a tab using the \"onTabMouseExit\" event handler.","extraInfo":[]},{"id":"The \"onTabMousePress\" event handler is called when the mouse is pressed on a tab.","extraInfo":[]},{"id":"The \"onTabMouseRelease\" event handler can be used to notice when the mouse press is released on a tab.","extraInfo":[]},{"id":"Use the \"onTabMouseClick\" to receive mouse click events on tabs.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.tables.Declarative_Tables_Spec",
      "title":"Creating Tables",
      "narrative":"Swing-Tree exposes a user friendly API for defining tables in a declarative manner.\n    You don't necessarily have to implement your own table model, because the Swing-Tree\n    API allows you to supply simple collection based data as a data source for your table.",
      "featureCount":"4",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"A map can be used as a data source for tables.","extraInfo":[]},{"id":"We can create a column major table based on a list of lists as a data model.","extraInfo":[]},{"id":"We can pass an Event to the table model to trigger updates.","extraInfo":[]},{"id":"We need to attach a update Event to our table when the table data is list based and its data changes.","extraInfo":[]}],
      "ignoredFeatures":[]
    },{
      "className":"swingtree.styles.Style_Animations.Style_Animations_Spec",
      "title":"Style Animations",
      "narrative":"Styles in SwingTree are based on a functional style engine\n    which reevaluates your styles whenever your component is\n    repainted. \n    This makes them a perfect fit for animations.\n    Continue reading to learn how to animate your styles.",
      "featureCount":"3",
      "failures":"0",
      "errors":"0",
      "skipped":"0" ,
      "successRate":"1.0",
      "duration":"?",
      "executedFeatures":[{"id":"Advanced style animations will override the Look and Feel of a component temporarily","extraInfo":[]},{"id":"An `onMouseClick` event style animation is only temporary.","extraInfo":[]},{"id":"SwingTree will uninstall any custom border after an animation has completed.","extraInfo":[]}],
      "ignoredFeatures":[]
    }
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}