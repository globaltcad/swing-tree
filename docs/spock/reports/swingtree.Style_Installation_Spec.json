{
  "className":"swingtree.Style_Installation_Spec",
  "title":"Style Installation",
  "narrative":"**This specification covers the behaviour of the style installation process!**\n    Which means that the contents of this may not be relevant to you.\n    Keep reading however if you are interested in some of the obscure details\n    of the SwingTree library internals.\n\n    SwingTree offers advanced styling options as part of **the style API**,\n    which is most commonly used through the `withStyle(Styler)` method\n    on any declarative builder node.\n\n   The installation of styles is a complex process that involves\n   the partial override of the component's UI delegate, the application of\n   the style's properties to the component and the installation of\n   a custom border, all depending on the style configuration.\n\n   This is a very finicky process that requires a lot of\n   testing to ensure that the styles are applied correctly.\n   Here you will find most of the tests that ensure that after the\n   installation of a style, the component has the expected plugin installed.",
  "subjects":["swingtree.UI","swingtree.api.Styler"],
  "statistics":{
    "runs":"206",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [44]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [45]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [46]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [47]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [48]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [49]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [50]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [51]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [52]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom UI. [53]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the custom UI was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and should give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom UI may or may not be installed:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            We re-install the component UI, to check that if \n            SwingTree style is robust enough to survive look and feel switches.\n        ","code":["button.updateUI()"]},

        {"kind":"then","text":"The condition remains unchanged, the style survived:","code":["!(button.getUI() instanceof MetalButtonUI) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former UI to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"The original UI should be installed because the component is no longer styled","code":["button.getUI() instanceof MetalButtonUI"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","false","false","false","true","false","false","false","false","false","false","true","true","false","false","false","false","false","false","true","false","false","false","false","false","true","false","false","false","false","false","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [44]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [45]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [46]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [47]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [48]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [49]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [50]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [51]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [52]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not lead to the installation of a custom Border. [53]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if a custom border was installed.\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler","code":["var applyStyle = true","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"The custom `Border` may or may not be installed:","code":["(button.getBorder() instanceof swingtree.style.StyleAndAnimationBorder) == isCustom"]},

        {"kind":"when","text":"\n            The style is deactivated and updated, then we expect the\n            former border to be reinstalled.\n            We test this by deactivating the style\n            and then simulating a repaint of the button.\n        ","code":["applyStyle = false","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())"]},

        {"kind":"then","text":"\n            The standard look and feel border based border should be installed\n            because the component is no longer styled.\n            We test this by comparing the border of the button with the border\n            of a new button.\n        ","code":["button.getBorder() == new JButton().getBorder()"]},

        {"kind":"where","text":"","code":{"isCustom":["false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","false","false","false","false","false","false","true","true","true","true","false","false","false","false","true","true","true","true","false","false","true","true","true","true","false","false","true","true","true","true","false","false","false","false"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [44]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [45]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [46]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [47]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [48]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [49]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [50]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [51]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [52]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Different `Styler`s may or may not override the `JButton.setContentAreaFilled(boolean)` property. [53]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data driven test that takes a `Styler` \n            which will be applied to a `JButton` by passing it to the\n            `withStyle(Styler)` method.\n            Then we build the component and check if the \"isContentAreaFilled\" property\n            of a button was or was not modified.\n\n            Although not intuitive from the outside perspective, but internally\n            SwingTree sometimes needs to set this flag to false in order to\n            prevent the look and feel from rendering it so that SwingTree can take over\n            and paint its style instead!\n\n            This specification may not be relevant to you if you are not interested\n            in the details of the SwingTree library internals.\n            But it demonstrates the complexity of the style installation process\n            and can give you a good idea of what it took to build the SwingTree library.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a button UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.button()","        .withSize(80,50)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"when","text":"We build the button","code":["var button = ui.get(JButton)"]},

        {"kind":"then","text":"Initially, the `isContentAreaFilled` is set to true:","code":["button.isContentAreaFilled()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"\n            The flag has the expected value:\n        ","code":["button.isContentAreaFilled() == isFilled"]},

        {"kind":"when","text":"We now turn off the style and update the component...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The `isContentAreaFilled` is set to true like it was initially:","code":["button.isContentAreaFilled()"]},

        {"kind":"where","text":"","code":{"isFilled":["true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","false","false","true","true","true","false","true","true","true","true","true","true","false","false","true","true","true","true","true","true","false","true","true","true","true","true","false","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.foundationColor(Color.GREEN) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"blue\").shadowBlurRadius(5) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.CONTENT, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BORDER, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"black\").offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).offset(1,2).blurRadius(5)) }","{ it.shadow(UI.Layer.BACKGROUND, \"myShadow\", conf->conf.color(UI.Color.UNDEFINED).spreadRadius(7).isOutset(true)) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.FOREGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.CONTENT, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.scale(1,2).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors(Color.GREEN, Color.RED)) }","{ it.noise(UI.Layer.BACKGROUND, \"myNoise\", conf->conf.colors([] as Color[])) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.CONTENT, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BACKGROUND, UI.ComponentArea.EXTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.FOREGROUND, UI.ComponentArea.INTERIOR, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.CONTENT, UI.ComponentArea.ALL, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BODY, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(1) ) }","{ it.parentFilter( conf -> conf.blur(0.75) ) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Style sheets can be dynamically reconfigured at runtime to switch between different visual themes.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test demonstrates how to create a dynamic style sheet that can switch between\n            different visual themes at runtime. This is achieved by:\n\n            1. Creating a custom StyleSheet implementation with a configure() method that\n               uses a switch statement to apply different styles based on a current theme\n            2. Binding a SwingTree GUI to this style sheet using UI.use(StyleSheet, Supplier)\n            3. Calling reconfigure() on the style sheet to switch themes\n            4. Verifying that components receive the new styles\n\n            This powerful feature allows you to create applications with dynamic theming\n            capabilities, similar to what you might find in modern web applications.\n\n            The style sheet in this test switches between three themes:\n            - LIGHT: Bright colors with dark text\n            - DARK: Dark colors with light text  \n            - RAINBOW: A colorful, playful theme\n\n            Each theme applies distinct styles to JButton and JLabel components,\n            demonstrating how different visual identities can be achieved through\n            style sheet reconfiguration.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A custom style sheet with theme switching capability","code":["var currentTheme = \"LIGHT\"","var styleSheet = new StyleSheet() {","    @Override","    protected void configure() {","        switch (currentTheme) {","            case \"LIGHT\":","                add(type(JButton.class), it -> it","                    .backgroundColor(Color.WHITE)","                    .foregroundColor(Color.BLACK)","                    .border(2, \"darkgray\")","                    .borderRadius(8)","                    .fontBold(true)","                )","                add(type(JLabel.class), it -> it","                    .backgroundColor(new Color(240, 240, 240))","                    .foregroundColor(Color.DARK_GRAY)","                    .fontSize(14)","                    .padding(5)","                )","                break","            case \"DARK\":","                add(type(JButton.class), it -> it","                    .backgroundColor(new Color(45, 45, 45))","                    .foregroundColor(Color.WHITE)","                    .border(2, \"lightgray\")","                    .borderRadius(8)","                    .fontBold(true)","                    .shadowColor(\"white\")","                    .shadowBlurRadius(3)","                )","                add(type(JLabel.class), it -> it","                    .backgroundColor(new Color(30, 30, 30))","                    .foregroundColor(Color.LIGHT_GRAY)","                    .fontSize(14)","                    .padding(5)","                )","                break","            case \"RAINBOW\":","                add(type(JButton.class), it -> it","                    .gradient(UI.Layer.BACKGROUND, \"rainbow\", grad -> grad","                        .colors(Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.MAGENTA)","                        .span(UI.Span.LEFT_TO_RIGHT)","                    )","                    .backgroundColor(Color.PINK)","                    .foregroundColor(Color.BLACK)","                    .borderRadius(12)","                    .fontBold(true)","                    .padding(10)","                )","                add(type(JLabel.class), it -> it","                    .backgroundColor(Color.PINK)","                    .foregroundColor(Color.DARK_GRAY)","                    .fontSize(16)","                    .borderRadius(5)","                    .padding(8)","                )","                break","        }","    }","}"]},

        {"kind":"and","text":"A SwingTree GUI bound to our custom style sheet","code":["var panel = UI.use(styleSheet) { ->","                        UI.panel(\"fill, wrap 1\")","                            .add(UI.button(\"Test Button\"))","                            .add(UI.label(\"Test Label\"))","                            .get(JPanel)","                    }"]},

        {"kind":"when","text":"We build the UI components with the initial LIGHT theme","code":["var button = panel.getComponent(0) as JButton","var label = panel.getComponent(1) as JLabel"]},

        {"kind":"then","text":"The components should have the LIGHT theme styles","code":["button.background == Color.WHITE","button.foreground == Color.BLACK","label.foreground == Color.DARK_GRAY"]},

        {"kind":"when","text":"We switch to DARK theme and reconfigure the style sheet","code":["currentTheme = \"DARK\"","styleSheet.reconfigure()","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())","label.paint(image.createGraphics())"]},

        {"kind":"then","text":"The components should now have the DARK theme styles","code":["button.background == new Color(45, 45, 45)","button.foreground == Color.WHITE","label.foreground == Color.LIGHT_GRAY"]},

        {"kind":"when","text":"We switch to RAINBOW theme and reconfigure again","code":["currentTheme = \"RAINBOW\"","styleSheet.reconfigure()","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())","label.paint(image.createGraphics())"]},

        {"kind":"then","text":"The components should now have the RAINBOW theme styles","code":["!(button.getUI() instanceof MetalButtonUI)","label.foreground == Color.DARK_GRAY"]},

        {"kind":"and","text":"The style configurations reflect the theme changes","code":["var buttonStyle = ComponentExtension.from(button).getStyle()","var labelStyle = ComponentExtension.from(label).getStyle()","buttonStyle.base().backgroundColor().get() == Color.PINK // Gradient primer color","labelStyle.base().backgroundColor().get() == Color.PINK"]},

        {"kind":"when","text":"We switch back to LIGHT theme to complete the cycle","code":["currentTheme = \"LIGHT\"","styleSheet.reconfigure()","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","button.paint(image.createGraphics())","label.paint(image.createGraphics())"]},

        {"kind":"then","text":"The components should return to their original LIGHT theme styles","code":["button.background == Color.WHITE","button.foreground == Color.BLACK","label.foreground == Color.DARK_GRAY"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A SwingTree can install as well as uninstall a custom font defined in the style API. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is a data-driven test verifying that fonts defined via the style API\n            are properly installed and uninstalled when styles are toggled.\n            It ensures that activating the style changes the font as expected,\n            and deactivating the style restores the original font.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a text field UI with the given styler turned off initially!","code":["var applyStyle = false","var ui =","        UI.textField(\"I am simply text... :)\")","        .withSize(110,32)","        .withStyle( it -> applyStyle ? styler(it) : it )"]},

        {"kind":"and","text":"We build the text field...","code":["var textField = ui.get(JTextField)"]},

        {"kind":"and","text":"We get the initial font installed on the text field:","code":["var initialFont = textField.getFont()"]},

        {"kind":"when","text":"\n            The style is activated and updated, then we expect\n            SwingTree to evaluate if it is necessary to override the look and feel\n            as well as the font property of the component.\n        ","code":["applyStyle = true","BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The font may or may not be changed:","code":["( initialFont != textField.getFont() ) == fontChanged"]},

        {"kind":"when","text":"We now turn off the style and update the text field...","code":["applyStyle = false","image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB)","textField.paint(image.createGraphics()) // We need to simulate the component being painted"]},

        {"kind":"then","text":"The text field has the initial font again:","code":["initialFont == textField.getFont()"]},

        {"kind":"where","text":"","code":{"fontChanged":["false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","false","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true","true"],"styler":["{ it }","{ it.backgroundColor(Color.BLACK) }","{ it.foregroundColor(Color.BLUE) }","{ it.cursor(UI.Cursor.HAND) }","{ it.margin(5) }","{ it.padding(5).margin(5) }","{ it.border(2, \"black\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS) }","{ it.shadowColor(\"green\") }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7) }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)) }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}) }","{ it.parentFilter( conf -> conf.blur(0.0) ) }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ) }","{ it.fontColor(\"oak\").fontBackgroundColor(\"orange\") }","{ it.backgroundColor(Color.BLACK).fontColor(\"oak\") }","{ it.foregroundColor(Color.BLUE).fontSize(42) }","{ it.cursor(UI.Cursor.HAND).fontSize(42) }","{ it.margin(5).fontWeight(73).fontColor(\"oak\") }","{ it.border(2, \"black\").fontBackgroundColor(\"orange\") }","{ it.margin(5).border(3, \"red\").cursor(UI.Cursor.CROSS).fontBackgroundColor(\"orange\") }","{ it.shadow(UI.Layer.FOREGROUND, \"myShadow\", conf->conf.color(\"red\").spreadRadius(1).blurRadius(5)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.gradient(UI.Layer.BACKGROUND, \"myGradient\", conf->conf.colors([] as Color[])).fontSize(42) }","{ it.gradient(UI.Layer.BORDER, \"myGradient\", conf->conf.colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.noise(UI.Layer.FOREGROUND, \"myNoise\", conf->conf.rotation(102).colors(Color.RED, Color.BLUE)).fontColor(\"oak\") }","{ it.painter(UI.Layer.BACKGROUND, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.kernel(Size.of(2, 1), 1,0) ).fontBackgroundColor(\"orange\") }","{ it.painter(UI.Layer.BORDER, \"myPainter\", g2d -> {}).fontColor(\"oak\") }","{ it.parentFilter( conf -> conf.blur(0.0) ).fontWeight(73) }","{ it.padding(5).margin(5).fontWeight(73) }","{ it.shadowColor(\"green\").fontSpacing(24) }","{ it.shadowColor(\"green\").fontSpacing(-13) }","{ it.shadowColor(\"pink\").shadowBlurRadius(2).shadowSpreadRadius(7).fontSpacing(42) }","{ it.noise(UI.Layer.BORDER, \"myNoise\", conf->conf.colors(Color.RED, Color.BLUE)).fontWeight(73) }","{ it.painter(UI.Layer.BORDER, UI.ComponentArea.BORDER, \"myPainter\", g2d -> {}).fontWeight(73) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
