{
  "className":"com.globaltcad.swingtree.threading.Thread_Mode_Spec",
  "title":"Thread Modes",
  "narrative":"Swing only knows 1 thread, the Event Dispatch Thread (EDT)m\n    which performs both the UIs rendering as well as event handling.\n    This is a problem for Swing applications that need to perform\n    long running tasks in the background, as the EDT will be blocked\n    until the task is complete.\n    SwingTree provides a mechanism for creating UIs which\n    dispatch events to a custom thread as well as ensure that all UI related\n    operations are performed on the event dispatch thread!\n    This allows SwingTree applications to perform long running tasks\n    in the background without blocking the UI.",
  "subjects":[],
  "statistics":{
    "runs":"2",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"0.145 seconds"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"We can use the decoupled thread mode to queue backend events.",
      "result":"PASS",
      "duration":"0.072 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that Swing-Tree will not create a new thread for you,\n            you must process the events yourself using the \"UI.processEvents()\" method\n            preferably by a custom thread or the main thread of your application.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A UI built with the decoupled thread mode.","code":["var eventWasHandled = false","var node =","        UI.use(ThreadMode.DECOUPLED,","            ()-> UI.button(\"Click Me\")","                    .onClick({ eventWasHandled = true })","        )"]},

        {"kind":"when","text":"We click the button.","code":["node.component.doClick()"]},

        {"kind":"then","text":"The event is queued up, waiting to be handled.","code":["!eventWasHandled"]},

        {"kind":"when","text":"\n                We process the event queue, which in a real world\n                application would be done by a custom thread, or the main thread\n                of your application (everything but your GUI thread really).\n            ","code":["UI.processEvents()"]},

        {"kind":"then","text":"The event is handled.","code":["eventWasHandled"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The default \"coupled\" thread mode will use the AWT thread for event handling.",
      "result":"PASS",
      "duration":"0.069 seconds",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This is the default thread mode, which means that\n            the explicit specification of \n            `UI.use(ThreadMode.COUPLED, ...)` is not required.\n            However, note that in this thread mode the UI will be blocked \n            until the event is handled. \n        "]
      },
      "blocks":[
        {"kind":"given","text":"A UI built with the coupled thread mode.","code":["var eventWasHandled = false","var node =","        UI.use(ThreadMode.COUPLED,","            ()-> UI.button(\"Click Me\")","                    .onClick({ eventWasHandled = true })","        )"]},

        {"kind":"when","text":"We click the button.","code":["node.component.doClick()"]},

        {"kind":"then","text":"The event is handled immediately by the swing thread.","code":["eventWasHandled"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}