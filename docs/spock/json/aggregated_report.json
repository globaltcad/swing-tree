{"swingtree.animations.Animations_Spec":{"executedFeatures":["Animate the color of a label when it is clicked.","Implement the \"finish\" method in your animation to ensure that it is called at least once.","The event delegation object of a user event can be used to register animations.","Use the API exposed by `UI.animateFor(..)` to schedule animations","Use the API exposed by `UI.animateFor(..)` to schedule regressive animations (whose progress goes from 1 to 0)"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":4436},"title":"Animations","narrative":"Animations are a great way to improve the UX of your application.\n    Swing-Tree has a built in animation scheduler that can execute animations \n    given that you have at least specified the duration of the animation.\n    Internally the animation scheduler is a \"Timer\" that will regularly update\n    your animations and then remove them from the scheduler once they are finished."},"swingtree.button.JButton_Example_Spec":{"executedFeatures":["A button will delegate its siblings within actions:","In a button event we can go through the entire siblinghood, including the current button!","We can easily create a button with an associated action:"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":275},"title":"Using JButton in SwingTree","narrative":"This specification demonstrates how the SwingTree API\n    can be used to create `JButton`s and how to register event handlers\n    on them while still being able to integrate them\n    in a declarative UI."},"swingtree.combo.Combo_Box_Specification":{"executedFeatures":["A combo box can be made editable in a declarative way.","A combo box created by Swing-Tree uses the provided item array as data model.","A combo box created by Swing-Tree uses the provided item list as data model.","An editable combo box will try to parse any kind of user input to match bound properties.","An editable combo box will try to parse user input to match bound properties.","Changing properties in you view model automatically updates an editable combo box.","Changing properties in you view model automatically updates the combo box.","Create combo box UIs with simple text render functions.","Swing tree is a wrapper around Swing, which means you can create the combo box yourself.","The \"comboBox\" factory method allows you to easily create a combo box from an array.","The options of an editable combo box are only editable if their items list is modifyable.","You can model both the current selection state as well as options of your combo box using 2 properties.","You can model both the current selection state as well as options of your combo box using a property and a list.","You can model both the current selection state as well as options of your combo box using a property and an array.","You can model the options of your combo boxes using \"Vars\"."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":15,"passed":33,"successRate":1.0,"time":339},"title":"Drop Downs, aka Combo Boxes","narrative":"In Swing drop downs are called combo boxes and they are used to select\n    one item from a list of options.\n     \n    This specification will show you how you can create them and\n    how you can interact with them using SwingTree."},"swingtree.common.Basic_UI_Builder_Examples_Spec":{"executedFeatures":["A tabbed pane can be created and populated in a declarative way.","An enum based combo box can have custom cell rendering.","Component events can be registered on swing tree nodes.","Swing tree nests all kinds of components (trough builder nodes).","Tab header components can be passed to the \"tab\" factory method instead of the title.","The tab buttons of a tabbed pane can have custom components.","Use the \"peek( c -> {} )\" method to access the wrapped Swing component in your Swing-Tree.","We can add a list of components to the swing tree API and get a builder node in return.","We can create a border layout based Swing tree.","We can easily define the cursor on a wrapped UI component","We can nest JPanel UI nodes to structure UIs.","We can register different UI focus event handlers to swing tree nodes.","We can register list selection events on a JList based swing tree node.","We can register various kinds of different keyboard event handlers to swing tree frame builder.","We can register various kinds of different keyboard event handlers to swing tree nodes.","We can use the `box()` factory to group UIs seemlesly."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":163},"title":"Writing Declarative GUI Code","narrative":"Imperative code is code that describes how you want to achieve something,\n    typically a procedure or a sequence of steps that needs to be executed.\n    Declarative code on the other hand is code that \n    describes **what you want to achieve**,\n    typically a state or data structure that you want to create.\n    This is why declarative code is the perfect fit for UI code,\n    and making it possible to write declarative UI code is the \n    main purpose and core motivation of Swing-Tree.\n    \n    Its API is designed so that the code you write with it looks \n    and feels a little bit like HTML, CSS and JavaScript.\n    \n    It is inspired by frameworks like \n    [Jetpack Compose](https://developer.android.com/jetpack/compose), [SwiftUI](https://developer.apple.com/xcode/swiftui/), \n    [Flutter](https://flutter.dev) and \n    [JetBrain's UI DSL](https://plugins.jetbrains.com/docs/intellij/kotlin-ui-dsl-version-2.html#ui-dsl-basics)\n    which are also based on using declarative builder patterns to design your UI.\n    \n    In this specification we cover the utter most basics of SwingTree,\n    so that you can get a feeling for how it works and what it can do for you."},"swingtree.common.Basic_UI_Exception_Spec":{"executedFeatures":["A builder node may not be reused to ensure that SwingTree code remains declarative.","A disposed builder node will indicate that it should not be used in its String representation.","Certain Swing-Tree UI builder, do not allow you to use nullable properties.","The given factory methods do not accept null arguments."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":127,"totalFeatures":4,"passed":127,"successRate":1.0,"time":294},"title":"How Not To Use","narrative":"This specification shows you how NOT to use the Swing-Tree API."},"swingtree.common.Builder_Modes_Spec":{"executedFeatures":["A regular builder is a factory builder","Builder instances created using an `of(..)` factory method are declarative only wrappers."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":2,"passed":12,"successRate":1.0,"time":56},"title":"Builder, Factory or Wrapper?","narrative":"SwingTree offers a fluent API for assembling Swing components\n    into a GUI tree, hence the name SwingTree. \n    It is designed around the idea of using method chaining \n    and statement nesting to facilitate the creation of a GUI tree.\n    This is a common pattern in many libraries, and is often referred to as a\n    Builder pattern, which is ruffly the what SwingTree consists of.\n    \n    But you may be surprised to hear that one SwingTree builder\n    is not like the other. There are actually three different\n    builder modes! Although they all look the same and their declarations\n    will lead to the creation of the same GUI tree, they differ in terms\n    of their purpose and how they ought not to be used.\n    \n    The three modes are:\n\n    * Declarative Only Factory Builder Mode\n    * Declarative Only Builder Mode\n    * Free Builder Mode\n    \n    Sounds confusing! So let's break it down.\n    \n    The first two modes are declarative only, which means that the\n    methods designed for chaining first dispose of the current builder and\n    then return a new instance of the builder. This disposed builder\n    is then disabled and can no longer be used to build the GUI tree.\n    This is done to prevent the builder from being used in any other way\n    than for building the GUI tree declaratively.\n    \n    The difference between the two declarative modes is that the\n    factory builder mode behaves very similar to the stream API\n    in that all of the operations defined by the chain of method \n    calls are composed into a single function that is executed\n    when the component is being accessed. \n    Every time the component is accessed, a new component is created\n    and then sent through the chain of build operations.\n    Most builders in SwingTree are factory builders, \n    given that they are not created with a component instance\n    passed to their constructor.\n    \n    The last mode is the free builder mode, which is the most unrestricted\n    of the three modes. It is spanned when switching to procedural\n    code using the various `apply` methods on the builder.\n    Make sure not to overuse this mode, as writing\n    GUI code procedurally is usually messier than declarative design.\n    \n    If this is still confusing, don't worry.\n    The following examples will make it clear \n    where each mode is used and how they differ.\n    \n    You actually do not need to know about the different modes\n    to use SwingTree, but it is good to know about them\n    to understand the design of the library."},"swingtree.common.Configuring_UI_Components_Spec":{"executedFeatures":["The visibility of a component can be configured using various methods.","Use the \"makeDefaultButton()\" method to make a button the default button.","We can configure a button to have no border.","We can make a UI component grab the current input focus."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":1046},"title":"Configuring UI withMethod Chaining","narrative":"The declarative nature of Swing-Tree is enabled by 1 fundamental\n    design patterns:\n    \n    > Composition and Method Chaining!\n    \n    So every method on a Swing-Tree UI builder node returns the node\n    instance itself. \n    This is especially useful when you want to configure a UI component.\n    \n    In this specification we will see what this looks like."},"swingtree.common.UI_Query_Spec":{"executedFeatures":["We can query the swing tree using the String id (name) of components.","We cane query a swing three using the group tags of components."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":148},"title":"Swing Tree UI Query","narrative":"The Swing-Tree UI builder allows you to easily build UIs and query them for\n    specific components inside component event action lambdas! \n    This allows you to easily build UIs that are event driven and react to\n    user input in a very flexible way.\n    Note that this should be used with care as it can lead to very complex\n    UIs that are hard to maintain.\n    Please consider modelling your UIs logic using MVVM based on \n    property bindings (See the properties specification)."},"swingtree.common.UI_Updates_Spec":{"executedFeatures":["We can register periodically called UI updates!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":206},"title":"Dynamic UI Updates","narrative":"The Swing-Tree UI builder allows you to easily build UI with periodic updates.\n    This is useful for example when you want to build animated UIs or UIs that\n    perform some sort of refreshes periodically."},"swingtree.events.Event_Handling_Spec":{"executedFeatures":["In a formatted text field, the \"onEnter\" event handlers are triggered in the same order as they were registered.","The \"onChange\" event handlers are triggered in the same order as they were registered.","The \"onClick\" event handlers are triggered in the same order as they were registered.","The \"onContentChange\" event handler of a text area is triggered when the text area content changes.","The \"onEnter\" event handlers are triggered in the same order as they were registered.","The \"onResize\" event handlers are triggered in the same order as they were registered.","The \"onSelection\" event handlers of a combo box are triggered in the same order as they were registered.","The \"onShown\" event handlers are triggered in the same order as they were registered.","The \"onTextChange\" event handler of a text area is triggered when the text area content changes.","The \"onTextInsert\" event handler of a text area is triggered when the text area content changes.","The \"onTextRemove\" event handler of a text area is triggered when the text area content changes.","The \"onTextReplace\" event handler of a text area is triggered when the text area content changes.","The \"onTextReplace\" event handlers will be triggered in the correct order.","Turn your view model `Event`s into custom component events.","Turn your view model properties into custom component events."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":220},"title":"Registering Event Handlers","narrative":"An important part of a UI declaration is the ability to hook up event handlers\n    to your components. In SwingTree you do not need to unpack the underlying Swing\n    component to register a particular event listener, but instead you can register\n    event handlers directly on the UI declaration.    \n    This specification demonstrates how different types of event handlers for different\n    types of events and components can be registered using simple lambda expressions."},"swingtree.examples.Examples_Spec":{"executedFeatures":["Declare table components using a list of list as data source.","How SwingTree compares to a GUI Editor based implementation.","The \"Well rounded\" style example UI defined in the examples can be created.","The Kana-Picker is an example game which teaches you the Japanese Kana symbols.","The `ListTestExample` class can be created.","The `ListTestExample` class can be created.","The `NamedFieldsView` example UI defined in the examples can be created.","The advanced UI define in the examples has the expected state.","The animated buttons view examples UI defined in the examples looks as expected.","The animation example view can be created.","The box shadow picker example UI defined in the examples can be created.","The calculator UI defined in the examples has the expected state and looks.","The form UI defined in the examples has the expected state.","The glass view example UI defined in the examples can be created.","The list examples UI defined in the examples can be created.","The list rendering example UI defined in the examples can be created.","The login example UI defined in the examples, a good MVVM demonstration.","The note guesser example UI defined in the examples can be created.","The settings example UI defined in the examples looks as expected.","The soft example UI is rendered as expected.","The spinners example UI defined in the examples can be created.","The todo app UI defined in the examples has the expected state.","The transitional style animation example view can be created.","The user registration example UI defined in the examples, a good MVVM demonstration."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":24,"totalFeatures":24,"passed":24,"successRate":1.0,"time":3062},"title":"Examples UIs","narrative":"This is an overview of the various example UIs\n    in the test suite.\n   \n    This specification also ensures that the\n    various UI examples in the test suite, \n    run successfully and also produce\n    UIs with expected state and appearance."},"swingtree.label.Label_Spec":{"executedFeatures":["A label UI can be created using the UI.label(..) factory method.","Create labels with custom horizontal and vertical alignment.","Create labels with custom horizontal and vertical text position.","The icon of a label may be specified using an `IconDeclaration`."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Labels","narrative":"This spec demonstrates the use of labels\n    in Swing-Tree."},"swingtree.mvvm.Auto_Cleaning_Spec":{"executedFeatures":["The properties of a view model will loose the bindings to garbage collected views."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":178},"title":"Automatic Unbinding and Cleaning","narrative":"When a view, alongside all of the components it consists of, gets garbage collected,\n    the view model should be unbound from the view and cleaned up in order to prevent memory leaks.\n    Doing this manually is tedious and error-prone, which is why SwingTree does it automatically for you.\n    \n    This spec tests whether the automatic unbinding and cleaning works as expected\n    when the view is garbage collected."},"swingtree.mvvm.Button_Binding_Spec":{"executedFeatures":["A button group will not only synchronize the selection state of radio buttons, but also bound properties.","Bind the \"isSelected\" flag of a button to the equality between an enum and a enum property","Bind the \"isSelected\" flag of a button to the inequality between an enum and a enum property","Directly bind an enum based property to the selection state of a radio button.","Directly bind any property to the selection state of a radio button.","We can bind to the text of a button.","You can bind to the enabled state of a button.","You can bind to the selection state of a button."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":22},"title":"Button Binding","narrative":"As a developer, I want to bind a button to a property so \n    that is is updated when the property changes.\n    Binding is a powerful feature that allows us to create\n    UIs which are not only decoupled from the business logic of\n    an application, but also make it easy to create UIs which\n    are dynamic and reactive.\n    \n    A typical use case for button types is to bind\n    their selection state to a property in the view model.\n    This property may be boolean based, or something entirely\n    different."},"swingtree.mvvm.Label_Binding_Spec":{"executedFeatures":["A property can define the horizontal and vertical alignment of a label.","A property can define the image relative horizontal and vertical alignment of a label.","It is possible to bind to the minimum, maximum and preferred size of a label","We can bind to the foreground and background color of a UI node.","We can bind to the text of a label.","We can store icons inside properties and then bind them to labels.","You can bind a variable to the \"enable\" flag of a label.","You can bind a variable to the \"visible\" flag of a label.","You can dynamically model the font size of your labels using an integer based property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":9,"passed":11,"successRate":1.0,"time":29},"title":"Label Binding","narrative":"As a developer, I want to bind a label to a property so \n    that the label is updated when the property changes.\n    Binding is a powerful feature that allows us to create\n    UIs which are not only decoupled from the business logic of\n    an application, but also make it easy to create UIs which\n    are dynamic and reactive."},"swingtree.mvvm.MVVM_Example_Spec":{"executedFeatures":["A boolean property can be used to set or reset a background color.","A boolean property can be used to set or reset a foreground color.","A boolean property can be used to switch between 2 background colors.","A boolean property can be used to switch between 2 foreground colors.","A border title can be modelled using properties.","A dynamic property list based UI declaration can have layout constraints.","A simple array of elements can be used as a data model for a combo box.","A simple list of elements can be used as a data model for a combo box.","A string property can be bound to a combo box holding string elements.","A view model property may or may not exist, meaning its view may or may not be provided.","An enum based combo box can infer its possible states directly from the binding property.","Binding to the selection state of a button does nothing, because a JButton can only be pressed.","The background color of a Swing component can be modelled using a boolean and a Color property.","The foreground color of a Swing component can be modelled using a boolean and a Color property.","The tooltip of a component can be modelled using a String property.","The type of cursor displayed over a component can be modelled using properties.","View Models can be represented by properties.","View Models can be represented by property lists.","We can bind a boolean property to a button, and when the user presses it, we notice it.","We can bind a boolean property to a checkbox, and when the user presses it, we notice it.","We can bind a boolean property to a radio button, and when the user presses it, we notice it.","We can bind a boolean property to a toggle button, and when the user presses it, we notice it.","We can bind a enum property to a combo box and when the user selects an item, we notice it.","We can create a property based view model and build a view for it.","You can bind a property as the current selection as well as list of elements as options to a combo box."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":25,"totalFeatures":25,"passed":25,"successRate":1.0,"time":366},"title":"MVVM Introduction","narrative":"Swing-Tree allows you to create a Model-View-ViewModel (MVVM) architecture\n    based on 2 simple property interfaces: `Val`, and `Var`!\n    \n    `Val` is a read-only property, and `Var` is a read-write property.\n\n    The state of both properties can be observed by the view using simple listeners.\n    This happens automatically when you pass them to the Swing-Tree view.\n    If you want to trigger an action when the property changes, you \n    have to pass the `Var` property to the view and define a action\n    for it inside of your view model."},"swingtree.mvvm.Observing_Properties_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be listened to by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Change Listeners","narrative":"A core motivation behind the creation of the SwingTree library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"swingtree.mvvm.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":51},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"swingtree.mvvm.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a mutable property is based on its identity!","The equality and hash code of an immutable property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":25},"title":"Properties","narrative":"SwingTree includes support for writing UIs using the MVVM pattern,\n    by shipping with a set of observable property types as part of the \n    included **Sprouts property API**,\n    which is designed from the ground up to be used for modelling Swing UIs.\n    \n    Properties are a powerful tool because they make it possible to\n    model the state and logic of your UIs without actually depending on them,\n    which is especially useful for testing, debugging and refactoring.\n    \n    This specification introduces you to their API and shows you how to use them.\n    \n    (For more information about the raw properties themselves\n    check out their [repository](https://github.com/globaltcad/sprouts))"},"swingtree.mvvm.Property_Binding_Spec":{"executedFeatures":["Bind the foreground of a component to a conditional property and 2 color properties.","Bind to both width and height independently if you want to.","Enable or disable the split items of a JSplitButton through properties.","Minimum as well as maximum height of UI components can be modelled using integer properties.","Simple integer properties can be bound to the width or height of components.","The enabled/disabled state of a UI component can be modelled using an enum property.","The focusability of a UI component can be modelled dynamically using boolean properties.","The focusability of a UI component can be modelled using an enum property.","The visibility of a UI component can be modelled dynamically using boolean properties.","The visibility of a UI component can be modelled using an enum property.","The width and height of UI components can be modelled using integer properties.","We can bind a property to the size of a swing component.","We can bind to the color of a component.","We can bind to the text of a component.","We can enable and disable a UI component dynamically through property binding.","We can select or unselect a UI component dynamically through properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":26,"totalFeatures":16,"passed":26,"successRate":1.0,"time":79},"title":"Binding Properties to UI Components","narrative":"SwingTree includes support for writing UIs using the MVVM pattern,\n    by shipping with a set of properties that can be bound to UI components\n    to model their state.\n    This specification demonstrates how to bind the properties of\n    you view model to the SwingTree UI."},"swingtree.mvvm.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","Swing-Tree will not allow you to model a check box selection using a nullable properties.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","You may not model the text of a \"JLabel\" using a nullable property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":9,"passed":14,"successRate":1.0,"time":19},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Swing-Tree. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    immutable only when they need to be.\n    \n    Furthermore, using nullable properties in Swing-Tree\n    will be prohibited it is does not make sense.\n    For example, you may not use null to model the text of a label,\n    instead, the empty String \"\" must be used!"},"swingtree.mvvm.Scroll_Pane_Binding_Spec":{"executedFeatures":["A property holding a vertical scroll bar policy can be bound to the UI.","You can model the horizontal scroll bar policy us ing a view model property dynamically."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":7},"title":"Scroll Pane Binding","narrative":"Although a scroll pane does not hold information\n    that is relevant to your core business logic, it certainly has certain properties\n    relevant to the view and its usability. \n    For example, the scroll pane can be enabled or disabled, or it\n    can have certain kinds of scroll policies.\n    This specifications shows how to bind `Val` properties to scroll panes."},"swingtree.mvvm.Scroll_Panels_Spec":{"executedFeatures":["The `JScrollPanels` instance can visually represent a view model consisting of sub-view models.","Use a simple property list of Strings to populate a scroll panel."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":1027},"title":"Scroll Panels","narrative":"This specification is dedicated to showing how to use the\n    `JScrollPanels` class, a custom SwingTree component that\n    is designed to display a list of scrollable panels\n    which can be populated with any kind of interactive UI\n    based on any kind of sub-view model type."},"swingtree.other.OptionalUI_Spec":{"executedFeatures":["An OptionalUI can be mapped to a regular non-empty optional.","An empty OptionalUI will return a default value when orElse is called.","An empty OptionalUI will return a default value when orElseGet is called.","An empty OptionalUI will throw an exception when orElseThrow is called.","OptionalUI can be mapped to a regular empty optional.","OptionalUI wraps AWT components exclusively."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":10},"title":"OptionalUI, a Swing-Tree Monad","narrative":"The OptionalUI is a monadic container object for AWT Component types\n    which may or may not contain a non-null value."},"swingtree.other.Options_Pane_Spec":{"executedFeatures":["Call `UI.info(String)` to easily summon a message dialog with an information icon.","Call `UI.info(String, String)` to easily summon a titled info message dialog.","If you want to present a titled error message dialog, use `UI.error(String, String)`.","If you want to summon an error message dialog, use `UI.error(String)`.","Invoking `UI.warn(String)` summons a warning message dialog.","Invoking `UI.warn(String, String)` summons a titled warning message dialog.","Pass a lambda to the show method of an options dialog to create unique option presentations.","The convenience method `UI.confirm(String,String) summons a confirm dialog right away!","The factory method `UI.message(String)` allows for the configuration and summoning of a message dialog.","Use `UI.choice(String, Enum[])` for building an options dialog for a set of enum based options.","Use `UI.choice(String, Var)` for accessing the options dialog builder API.","Use `confirmation(String)` to build a simple conformation dialog returning a simple answer enum.","Use the `UI.ask(String,String,Icon,Var)` factory method to get answers from the user through a dialog.","Use the `UI.ask(String,String,Var)` factory method to get answers from the user through a dialog.","Use the `UI.ask(String,Var)` factory method to get answers from the user through a dialog."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":46},"title":"Summoning Simple Dialogs","narrative":"In raw Swing a common way to present a simple message or a set of options to the user is to\n    the static methods of the `JOptionPane` API to summon and display a dialog.\n    SwingTree makes this API more intuitive and declarative through the `UI` API.\n    \n    This specification demonstrates the use of this API."},"swingtree.other.Render_Cache_Spec":{"executedFeatures":["The cache can be created and used for painting."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":71},"title":"Internal Render Caching","narrative":"**This specification covers the behaviour of an internal class!\n    Which means that the contents of this may not be relevant to.\n    Keep reading however if you are interested in some of the obscure details\n    of the SwingTree library internals.**\n\n    SwingTree offers advanced styling options as part of **the style API**,\n    which is most commonly used using the `withStyle(Styler)` method\n    on any builder node.\n    The rendering of these styles can get rather compute intensive,\n    especially in cases where repaints are called frequently.\n    This is not really a problem for modern CPUs/GPUs, which can handle the \n    rendering of UI effortlessly, but nonetheless, we do not want to waste\n    precious clock cycles and energy on meaningfully repaints of things that were already\n    painted many many times before.\n    This is especially important for mobile devices, which should not burn through \n    your battery just because of a few shaded buttons...\n    \n    ---\n    \n    **So how does SwingTree solve this issue?**\n    \n    The answer is caching based rendering where the cache keys are the\n    immutable style configurations. And whenever the style configuration\n    object changes a different cache area is being hit.\n    \n    The extensive usage of immutable data inside the SwingTree style engine\n    allows us to do caching for a wide wide variety of things besides rendering,\n    like the caching of complex shapes (needed for clipping and painting).\n    \n    But I digress... Let's ensure that the caching works as expected:"},"swingtree.other.Styled_Component_Border_Inset_Spec":{"executedFeatures":["A `JMenuItem` will not loose its default Nimbus border insets when styled!","A heavily styled slider will have the correct border insets!","A heavily styled text field will have the correct border insets!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":20,"totalFeatures":3,"passed":20,"successRate":1.0,"time":209},"title":"The SwingTree Border Insets","narrative":"SwingTree uses a custom `Border` implementation to support the styling\n    of components. This includes the definition of the border, margin, padding\n    dimensions which together form the whole border insets of a component.\n    \n    The border insets are then used by Swing to determine the size of the component\n    and its children.\n    \n    In this specification we will test the border insets of components\n    that are heavily styled through the SwingTree styling API."},"swingtree.other.SvgIcon_Spec":{"executedFeatures":["A basic `SvgIcon` does not have a size.","The `String` representation of the `SvgIcon` shows its properties.","The `SvgIcon` is immutable, and its size must be specified through wither methods.","The `UI.findIcon(IconDeclaration)` method will not fail when the icon is not found.","The `UI.findSvgIcon(IconDeclaration)` method will not fail when the icon is not found.","Use `UI.findSvgIcon(IconDeclaration)` to load an SVG icon from a file."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":26},"title":"SVG Support through SvgIcon","narrative":"Swing-Tree supports SVG icons through the `SvgIcon` class,\n    which is a subclass of `javax.swing.ImageIcon`.\n    This allows for smooth integration of SVG icons into regular\n    Swing components, like buttons, labels, etc.\n    \n    In this specification we will see how to use the `SvgIcon` class."},"swingtree.panel.Panel_Spec":{"executedFeatures":["A panel can be created with a layout manager.","A panel node can be created using the UI.panel() factory method.","A transparent panel can be created with a custom flow layout manager.","All of the \"box(..)\" factory methods will create transparent panels without insets.","Panels can be nested using the `add(..) method.","The default layout manager is always a MigLayout","The dimensions of a panel can be bound to a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":7,"passed":15,"successRate":1.0,"time":27},"title":"Panels","narrative":"Just like in regular Swing, the JPanel is the most basic \n    yet most important type of component in Swing-Tree\n    and you can create one using the `UI.panel()` factory method. \n    Don't hesitate to use as the main tool for grouping and structuring\n    your UI, just like you would use the 'div' tag in HTML."},"swingtree.renderer.Table_Renderer_Spec":{"executedFeatures":["A map based table can have a custom cell renderer.","We can attach a simple table cell renderer to a JTable in just a few lines of code.","We can create a simple column major table cell renderer through a UI factory method.","We can create a simple table cell renderer through a UI factory method.","You can render the cells of a table as text by using the \"asText\" method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":36},"title":"Rendering Table Cells","narrative":"Swing-Tree exposes a user friendly API for rendering table cells.\n    For simple table UIs none of this is necessary, but it\n    is important when you want to populate your table with more complex data.\n    The renderer is a simple function that takes a value and returns a UI node.\n    The UI node is then rendered as a table cell."},"swingtree.scaling.UI_Scaling_Spec":{"executedFeatures":["Dimensionality scaling also works for bound properties.","The dimensionality of components will be scaled by the scaling factor","The dimensionality specified in the styling API are scaled by the scaling factor"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":24},"title":"High IPD Scaling","narrative":"Higher resolution displays with higher pixel density \n    (measured in pixels per inch (PPI) or dots per inch (DPI)) have become the norm.  \n    This is especially true for mobile devices, but it is also true for desktop displays.  \n    \n    Vanilla Swing does not handle this well unfortunately, even with the introduction of\n    the HiDPI support in Java 9, which allows us to determine the DPI of the display.\n    Because although we calculate the scaling factor, there is no way to apply it to the UI.\n    Instead the task is left to the Look and Feel implementations which may or may not\n    scale the UI.\n    The problem is that older Look and Feels do not scale the UI, and even newer ones\n    may not scale the UI at all. \n    In fact none of the Look and Feels included in the JDK scale the UI.\n    \n    SwingTree can hardly solve this problem entirely, but it can help by scaling the UI\n    where the Look and Feel does not.\n    In this specification you will find out how to adjust the SwingTree scaling factor\n    and how it affects the properties of the UI components."},"swingtree.scrollpane.Scroll_Pane_Spec":{"executedFeatures":["Configure both the horizontal and vertical scroll policy individually.","Configure the block scroll increment for both scroll bars in one line.","The horizontal as well as vertical block scroll increment can be configured easily.","Use the `UI.ScrollBarPolicy` enum to configure the scroll pane scroll bars.","We can configure the general scroll increment of the scroll pane scroll bars.","We can configure the vertical and horizontal scroll bar scroll increment of a scroll pane."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":17},"title":"The Scroll Pane","narrative":"Just like for any other main component in Swing,\n    Swing-Tree also supports a nice API for \n    building UIs with scroll panes.\n    \n    A scroll pane is a component that allows\n    the user to scroll through a larger view\n    of a component. It is a container that\n    contains a single component, called the\n    viewport. The viewport is the area that\n    is actually visible to the user. \n    \n    The scroll pane also contains a set of\n    scrollbars that allow the user to scroll\n    the viewport. \n    \n    In this specification, we will see how\n    to build a scroll pane with Swing-Tree."},"swingtree.splitbutton.JSplitButton_Examples_Spec":{"executedFeatures":["A JSplitButton and all of its options can be bound to and created from a simple enum property and bound to an event.","A JSplitButton and all of its options can be created from a simple enum property.","A button item can undo any multi-selection.","It is possible to select more than 1 item.","The most simple kind of split button can be built like so:","We can build a JSplitButton and add components to it.","We can easily build a split button where only one item text will have its text displayed:","We can easily build a split button whose text becomes the current user selection:","We can register button click events for button items as well as the split button as a whole.","We can specify which item should be initially selected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":1239},"title":"A Button of Buttons","narrative":"The Swing-Tree split button component allows \n    you to easily create split buttons in your UIs.\n    A split button is a button that has a drop down menu attached to it.\n    This allows you to easily add additional functionality to your buttons.\n    The split button component is a wrapper around the AlexAndria Software\n    JSplitButton component."},"swingtree.splitbutton.JSplitButton_Exception_Spec":{"executedFeatures":["A JSplitButton does not accept null actions.","Split button items do not take null as an answer.","Split buttons do not take null as an answer."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":4},"title":"","narrative":""},"swingtree.splitpane.Split_Pane_Spec":{"executedFeatures":["A horizontally aligned split pane can be configured with a divider location as a percentage.","A horizontally aligned split pane can be created through the \"splitPane\" factory method.","A split pane can be configured with a divider location.","A split pane can be configured with a divider size.","A vertically aligned split pane can be configured with a divider location as a percentage.","A vertically aligned split pane can be created through the \"splitPane\" factory method.","An alignment property can be used to dynamically model the alignment of your split pane.","The divider location of a split pane can dynamically be modelled using an integer property.","The division of a split pane can dynamically be configured through a double property.","You can dynamically model the divider size of a split pane in your view model."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":20,"totalFeatures":10,"passed":20,"successRate":1.0,"time":28},"title":"Split Panes","narrative":"In this specification you can can not only see how to use the Swing-Tree API to \n   create and configure split panes but also how to bind them to your view model model.\n   The alignment of a split pane for example can be bound to a property in your view model."},"swingtree.styles.Color_Spec":{"executedFeatures":["Use \"desaturateBy(double)\" on a SwingTree color to decrease the saturation of the color according to the HSB color space.","Use \"saturateBy(double)\" on a SwingTree color to increase the saturation of the color according to the HSB color space.","Use the \"brighterBy(double)\" on a SwingTree color to brighten the color according to the HSB color space.","Use the \"darkerBy(double)\" on a SwingTree color to darken the color according to the HSB color space."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":56,"totalFeatures":4,"passed":56,"successRate":1.0,"time":35},"title":"Yet Another Color","narrative":"The age-old `java.awt.Color` class is a bit limited in what it can do.\n    Not only are the color constants it has to offer rather limited,\n    many of them are also inconsistent with the \n    naming and RGB values of modern color palettes.\n    The `java.awt.Color.GREEN` constant for example has an RGB value of \n    `(0, 255, 0)` which is considered \"lime\" in modern color palettes.\n    \n    Furthermore, there is a lack of useful wither methods on the `Color` class\n    that are expected from a modern value based type, like in this case for example\n    `withRed(double)`, `withGreen(double)`, `withBlue(double)`, `withAlpha(double)`\n    or `withBrightness(double)`, `withSaturation(double)`, `withHue(double)`.\n    \n    SwingTree addresses these shortcomings by providing a custom `Color` type\n    in the `UI` namespace which is a subclass of `java.awt.Color` and has a number\n    of useful methods to manipulate colors in both the RGB and HSB color spaces."},"swingtree.styles.Individual_Component_Styling_Spec":{"executedFeatures":["A border can have different colors on each side.","A single image can be painted repeatedly in a panel.","A text area background can be shaded from left to right with any number of colors.","Adjust how text is styled through the API exposed in your `Styler` lambdas","An animated style transition transforms your style configuration based on its animation state.","Configure a custom paint for the font of your components.","Configure the background, foreground and selection color of a text field through the API exposed in your `Styler` lambdas","Create a button with a SVG icon based toggle mode.","Create a soft UI slider that sinks into the background if you wish.","Create a soft progress bar that looks like it is raised from the background.","Create fancy text fields with custom icons and a button.","For full styling freedom, we can add custom painters to a component on various layers.","Make a text area look like it is sunken in the background using a shadow going inwards.","Paint SVG based images as a component background through the style API.","Paint automatically stretched images as component background through the style API.","Paint images as component backgrounds using the style API.","Render conic gradients as component backgrounds using the style API.","Render custom text using the style API.","Render custom text with a custom placement and placement boundary.","Render linear gradients as component backgrounds using the style API.","Render noise gradients as component backgrounds using the style API.","Rendering a panel, styled to have round edges, will not be visible when it is flagged as non-opaque.","SwingTree will re-install any borders overridden by the style API.","SwingTree will un-install any custom border if no styles are found.","The Styling API will make sure that the layout manager accounts for the border width!","The background color of any component can be configured through the style API.","The cursor of any component can be configured through the style API.","The font style of a parent component will be inherited by its children.","The foreground color of any component can be configured through the style API.","The functional style API changes the state of raw Swing components to reflect the desired looks.","The functional style API changes the state of your components to reflect the desired looks.","The horizontal text alignment of many text based components can be configured through the style API.","The insets of the layout manager are based on the sum of the margin and padding for a given edge of the component bounds.","The look of a component, like a button for example, will be preserved if possible, when doing custom styling.","The margins defined in the style API will be applied to the layout manager through the border insets.","This is how you can create a JPanel with a gradient border.","This is how you can create a rounded green label with a border at the bottom.","Turn a panel into a card like looking panel by giving it a round border, background color and some margins.","Use the style API to design custom tabbed panes from scratch.","Use the style API to make panel edges round.","You can style a toggle button to have a custom selection shading.","You can use the style API to configure client properties for components."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":112,"totalFeatures":42,"passed":112,"successRate":1.0,"time":11472},"title":"Styling Components","narrative":"This specification demonstrates how the style API can be used to style \n    individual components declaratively.\n    You may access it on any SwingTree builder by passing a `Styler` lambda\n    to the `withStyle` method.\n    A `Styler` lambda applies style rules to a component\n    by receiving a `ComponentStyleDelegate` and returning\n    an updated version with the desired style rules applied.\n    \n    Here a typical example of how to style a button\n    using the style API:\n    ```java\n        UI.button(\"Click Me!\")\n        .withStyle( it -> it\n            .borderColor(Color.CYAN)\n            .borderWidthAt(Edge.BOTTOM, 3)\n            .borderRadius(10)\n        )\n    ```\n    \n    Here the `it` variable is the `ComponentStyleDelegate` which exposes\n    an extensive API for configuring how a particular component\n    looks and behaves."},"swingtree.styles.Invariant_Styles_Spec":{"executedFeatures":["A diagonally aligned radial gradient with an offset focus point can be invariant in certain cases.","Diagonally linear gradients can be invariant in certain cases.","Two labels with the same font style configuration will have equal font objects.","Vertically and horizontally linear gradients can be invariant in certain cases."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":4,"passed":18,"successRate":1.0,"time":141},"title":"Invariant Styles","narrative":"This test demonstrates how various pairs of different styles \n    produce identical component states as well as identical\n    images when rendered into a BufferedImage."},"swingtree.styles.Layout_Styling":{"executedFeatures":["Configure the `ComponentOrientation` of a component, through the style API.","Define a border layout for a parent component and the corresponding constraints for their child components through the style API.","If you do not want a component to be managed by a layout manager, you can set the layout manager to `Layout.none()`.","The style Allows you to configure the flow layout as layout manager for components.","The x and y alignment values of a component can be configured through the styling API","Use the style API to configure the MigLayout manager for your components."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":26},"title":"Layout Styling","narrative":"SwingTree allows you to define the layout of your components \n    through the styling API, which is a functional DSL\n    that not only allows you to define how a component should be painted,\n    like for example the background color, the font, the border widths, etc.\n    but also allows you to define the miglayout constraints for the component.\n    \n    The examples defined in this specification will demonstrate how to use the styling API\n    to define the layout of your components."},"swingtree.styles.Opaqueness_Styles_Spec":{"executedFeatures":["A check box (which typically opaque) may become non-opaque when transitioning to various styles.","A component styled to have a positive margin together with a foundation color and a border radius will stay opaque.","A component styled to have a positive margin together with a foundation color will stay opaque.","A component styled to have a transitionally positive margin together with a foundation color and a border radius will stay opaque.","A component styled to have a transitionally positive margin together with a foundation color will stay opaque.","A component styled to have round corners together with a foundation color will stay opaque.","A component styled to have round corners will no longer be opaque.","A component styled to have transitionally round corners together with a foundation color will always stay opaque.","A component styled to have transitionally round corners will only temporarily be non opaque.","A component with a border color having a transitional alpha chanel is only opaque when the color is opaque","A component with a temporarily transparent border color, opaque a foundation and background colors will not be opaque.","A component with a transparent border color and opaque a foundation and background colors will not be opaque.","A component with a transparent border color will not be opaque.","A label will become opaque when transitioning to an opaque background color.","A plain button will be opaque, even if it has a custom painter.","A slider (which typically opaque) will become non-opaque when transitioning to a transparent background color.","A slider (which typically transparent) will become opaque when transitioning to an opaque background color.","A toggle button (which typically opaque) will become non-opaque when transitioning to a transparent background color.","An otherwise opaque panel with a temporarily positive margin will be non opaque for that time.","If a component has a transparent background color, then it will not be opaque.","If a component has an opaque background color, then it will also be opaque."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":40,"totalFeatures":21,"passed":40,"successRate":1.0,"time":2735},"title":"Opaque or not Opaque","narrative":"This specification focuses on the opaqueness of Swing components and\n    how the SwingTree style engine relates to it.\n    The opaqueness flag of a component is an interesting property.\n    You might think that it merely controls whether the background of\n    the component is painted or not. \n    \n    But it is actually more than that.\n    \n    This flag is at the center of some important rendering optimizations in Swing.\n    If a component is reporting itself as opaque, then Swing assumes that a repaint\n    only needs to be done on that component and not on any of its ancestors.\n    This is a big deal because it means that Swing can avoid repainting a lot of\n    components in the hierarchy.\n    \n    This sound relatively straightforward, but it becomes a lot more complicated together\n    with the SwingTree style API and its underlying styling engine.\n    So for example, if a component has rounded corners, and no foundational background\n    color, then it is technically not opaque.\n    Leaving it opaque will cause strange rendering artifacts, due to the parent component\n    not being repainted.\n    \n    In this specification we will explore the different scenarios and how the SwingTree\n    style engine deals with them."},"swingtree.styles.Style_Animations_Spec":{"executedFeatures":["A transitory style animation always ends with a progress of 1.","Advanced style animations will override the Look and Feel of a component temporarily","An `onMouseClick` event style animation dispatched using the `animateStyleFor` method is only temporary.","An `onMouseClick` event style animation is only temporary.","SwingTree will uninstall any custom border after an animation has completed."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6866},"title":"Style Animations","narrative":"Styles in SwingTree are based on a functional style engine\n    which reevaluates your styles whenever your component is\n    repainted. \n    This makes them a perfect fit for animations.\n    Continue reading to learn how to animate your styles."},"swingtree.styles.Style_Installation_Spec":{"executedFeatures":["Different `Styler`s may or may not lead to the installation of a custom Border.","Different `Styler`s may or may not lead to the installation of a custom UI."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":108,"totalFeatures":2,"passed":108,"successRate":1.0,"time":243},"title":"Style Installation","narrative":"**This specification covers the behaviour of the style installation process!**\n    Which means that the contents of this may not be relevant to you.\n    Keep reading however if you are interested in some of the obscure details\n    of the SwingTree library internals.\n\n    SwingTree offers advanced styling options as part of **the style API**,\n    which is most commonly used through the `withStyle(Styler)` method\n    on any declarative builder node.\n   \n   The installation of styles is a complex process that involves\n   the partial override of the component's UI delegate, the application of\n   the style's properties to the component and the installation of\n   a custom border, all depending on the style configuration.\n   \n   This is a very finicky process that requires a lot of \n   testing to ensure that the styles are applied correctly.\n   Here you will find most of the tests that ensure that after the\n   installation of a style, the component has the expected plugin installed."},"swingtree.styles.Style_Sheet_Spec":{"executedFeatures":["A StyleSheet can be created with a default style.","Any kind of exception inside of the \"configure\" method of a user StyleSheet will not be fatal!","Duplicate style trait declarations will not throw an exception!","Nonsensical style trait group inheritance rules will throw an exception!","The `group` style trait allows for inheritance, meaning a group can inherit from other ones.","The `type` style trait factory method determines for which components a particular style should be applied.","The order of inherited style traits determines the order in which they are applied.","The style API of a StyleSheet has a rich set of methods for styling the border of components.","Use the `group` style trait to classify components.","Use the power of `Graphics2D` to render custom backgrounds inside you styles.","Write custom style sheet classes by extending the StyleSheet class.","You can define complex group inheritance graphs inside your style sheets.","You can style the font of a component inside your style sheet."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":13,"totalFeatures":13,"passed":13,"successRate":1.0,"time":76},"title":"Creating Style Sheets","narrative":"No, SwingTree does not have a CSS parser.  \n    It does, however, have something better, which looks similar to CSS.\n    An API for configuring styles in a declarative and type-safe way.\n    This API is also designed the concept of defining common style rules\n    withing a file called a \"style sheet\".\n    \n    The main difference to a CSS file however is that it is still plain Java code.\n    (Or any other JVM language for that matter.)\n    \n    The API for creating style sheets is primarily exposed through the `StyleSheet` class,\n    an abstract class that you can extend to create your own styles like so:\n    ```java\n        class MyStyleSheet extends StyleSheet {\n           @Override\n           protected void configure() {\n                add(id(\"some unique id!\"), it -> it\n                    .borderRadius(3)\n                    // etc...\n                );\n                add(type(JPanel.class), it -> it\n                   .borderColor(Color.GREEN)\n                   // etc...\n                );\n                add(type(JButton.class), it -> it\n                    .borderWidth(7)\n                    // etc...\n                );\n            }\n        }\n    ```\n    You can then easily apply this style sheet to you SwingTree views like so:\n    ```java\n        UI.use(new MyStyleSheet(), () -> new MyView());\n    ```\n    The style sheet will be applied to all UI components created within the scope of the `use` method."},"swingtree.styles.Styles_Spec":{"executedFeatures":["Style objects are value based (with respect to equality and hash code).","SwingTree will simplify the style configuration of a component if possible.","The String representation of a style config will tell you everything about it!","The `UI.Color.UNDEFINED` constant can be used as a safe shorthand for null for the background and foreground properties of the style API","The `UI.Color.UNDEFINED` constant can be used as a safe shorthand for null for various properties in the style API","The `UI.Font.UNDEFINED` constant can be used as a safe shorthand for null for the font property of the style API","The border style will be simplified if margin and widths are all 0.","The style API allows you to configure a custom noise paint for a component font.","The style API allows you to configure a custom paint for a component font.","Various kinds of String expressions can be parsed as colors by various style properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":63,"totalFeatures":10,"passed":63,"successRate":1.0,"time":217},"title":"The Style Configuration","narrative":"This specification demonstrates what kind of style configuration is\n    created by various usage patterns of the style API.\n    The style configuration defines how Swing components ought to be\n    placed and rendered."},"swingtree.tables.Declarative_Tables_Spec":{"executedFeatures":["A map can be used as a data source for tables.","We can create a column major table based on a list of lists as a data model.","We can pass an `Event` to the table model to trigger updates.","We need to attach an update `Event` to our table when the table data is list based and its data changes."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":10},"title":"Creating Tables","narrative":"Swing-Tree exposes a user friendly API for defining tables in a declarative manner.\n    You don't necessarily have to implement your own table model, because the Swing-Tree\n    API allows you to supply simple collection based data as a data source for your table."},"swingtree.tabs.Tab_Binding_Spec":{"executedFeatures":["A string property can model the title of a tab!","Icons can be bound to tab headers dynamically.","Modelling the tooltip of a tab is also possible.","Properties allow you to enable or disable individual tabs.","The selection state of tabs can be modelled through various properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":14},"title":"Binding Tabs to Properties","narrative":"Tabs are a way to efficiently group related content in a single container.\n    The tabs can be bound to a property, so that the selected tab is always\n    the one that corresponds to the value of the property.\n    You can also model other aspects of a tab using properties, such as\n    whether it is enabled, visible, or has a tooltip."},"swingtree.tabs.Tab_Event_Handling_Spec":{"executedFeatures":["Notice when the mouse enters a tab using the \"onTabMouseEnter\" event handler.","Notice when the mouse exits a tab using the \"onTabMouseExit\" event handler.","The \"TabMouse-Events\" will not receive events if the mouse is outside of the tab bounds!","The \"onTabMousePress\" event handler is called when the mouse is pressed on a tab.","The \"onTabMouseRelease\" event handler can be used to notice when the mouse press is released on a tab.","Use the \"onTabMouseClick\" to receive mouse click events on tabs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":33},"title":"Tab Event Handling","narrative":"When building a tabbed pane using SwingTree, you often want to react to\n    events that occur on the tabs of a `JTabbedPane`. \n    For example, you may want trigger some action when a tab is selected.\n    \n    In this specification, we will see how to handle events on tabs."},"swingtree.testing.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":5},"title":"Writing Unit Tests for View Models","narrative":"Not only is Swing-Tree a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"swingtree.threading.Async_MVVM_Spec":{"executedFeatures":["The order in which the states of properties change is preserved when applied to the UI."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":1,"passed":1,"successRate":1.0,"time":221},"title":"Asynchronous MVVM","narrative":"Swing only knows 1 thread, the Event Dispatch Thread (EDT)\n    which performs both the UIs rendering as well as event handling.\n    This is a problem for Swing applications that need to perform\n    long running tasks in the background, as the EDT will be blocked\n    until the task is complete.\n    \n    SwingTree provides a mechanism for creating UIs which \n    dispatch events to a custom application thread as well as ensure that all UI related \n    operations are performed on the event dispatch thread!\n    Not only does this allow your applications to perform long running tasks\n    in the background without blocking the UI, it improves\n    the performance and responsiveness of you desktop application as a whole.\n    \n    This specification demonstrates how this feature interacts with the MVVM pattern\n    and the binding of properties to UI components."},"swingtree.threading.Thread_Mode_Spec":{"executedFeatures":["Accessing the UI from something other than the UI thread, leads to an exception when in decoupled thread mode.","Inside an event lambda we can not access the UI from a background thread.","The application thread can safely effect the state of the UI by using the \"UI.run(()->{..})\" method.","The default \"coupled\" thread mode will use the AWT thread for event handling.","We can use the decoupled thread mode to queue backend events."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":5,"passed":10,"successRate":1.0,"time":1072},"title":"Thread Modes","narrative":"Swing only knows 1 thread, the Event Dispatch Thread (EDT)\n    which performs both the UIs rendering as well as event handling.\n    This is a problem for Swing applications that need to perform\n    long running tasks in the background, as the EDT will be blocked\n    until the task is complete.\n    SwingTree provides a mechanism for creating UIs which \n    dispatch events to a custom application thread as well as ensure that all UI related \n    operations are performed on the event dispatch thread!\n    Not only does this allow your applications to perform long running tasks\n    in the background without blocking the UI, it improves\n    the performance and responsiveness of you desktop application as a whole."},"swingtree.windows.Showing_UI_Spec":{"executedFeatures":["The \"show\" method causes a JDialog to be displayed to the user.","The \"show\" method causes a JFrame to be displayed to the user.","Use the \"dialog()\" factory method to build a JDialog.","Use the \"frame()\" factory method to build a JFrame."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":304},"title":"Showing UIs","narrative":"Any user interface needs a way to be shown to the user. \n    In Swing, this is done through various kinds of classes, \n    namely, the JFrame, JDialog and JWindow classes.\n    \n    Swing-Tree allows you to instantiate and configure these\n    instances in a declarative fashion, and then show them\n    to the user."}}