<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>UIForAnyWindow (swing-tree 0.11.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="UIForAnyWindow (swing-tree 0.11.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":6,"i4":10,"i5":10,"i6":6,"i7":6,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":6,"i14":6,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":6,"i47":10,"i48":10,"i49":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">swingtree</a></div>
<h2 title="Class UIForAnyWindow" class="title">Class UIForAnyWindow&lt;I extends UIForAnyWindow&lt;I,&#8203;W&gt;,&#8203;W extends java.awt.Window&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>swingtree.UIForAnyWindow&lt;I,&#8203;W&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>I</code> - The type of the builder itself.</dd>
<dd><code>W</code> - The type of the window which is being configured by this builder.</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="UIForJDialog.html" title="class in swingtree">UIForJDialog</a></code>, <code><a href="UIForJFrame.html" title="class in swingtree">UIForJFrame</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">UIForAnyWindow&lt;I extends UIForAnyWindow&lt;I,&#8203;W&gt;,&#8203;W extends java.awt.Window&gt;</span>
extends java.lang.Object</pre>
<div class="block">A SwingTree builder node for configuring any kind of <code>Window</code> type.
  Take a look at the <a href="UIForJDialog.html" title="class in swingtree"><code>UIForJDialog</code></a> and <a href="UIForJFrame.html" title="class in swingtree"><code>UIForJFrame</code></a> classes,
  which are specialized subtypes of this class.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">UIForAnyWindow</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected &lt;B extends swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;javax.swing.JComponent&gt;&gt;<br>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_addBuildersTo(C,B...)">_addBuildersTo</a></span>&#8203;(C&nbsp;thisComponent,
              B...&nbsp;builders)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_addBuilderTo(C,swingtree.AbstractNestedBuilder,java.lang.Object)">_addBuilderTo</a></span>&#8203;(C&nbsp;thisComponent,
             swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;?&gt;&nbsp;builder,
             java.lang.Object&nbsp;conf)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_addComponentsTo(C,E...)">_addComponentsTo</a></span>&#8203;(C&nbsp;thisComponent,
                E...&nbsp;componentsToBeAdded)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_addComponentTo(C,E,java.lang.Object)">_addComponentTo</a></span>&#8203;(C&nbsp;thisComponent,
               E&nbsp;component,
               java.lang.Object&nbsp;conf)</code></th>
<td class="colLast">
<div class="block">This builder class expects its implementations to be builder types
 for anything which can be built in a nested tree-like structure.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_childCount(C)">_childCount</a></span>&#8203;(C&nbsp;c)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_detachStrongRef()">_detachStrongRef</a></span>()</code></th>
<td class="colLast">
<div class="block">This method sets the strong reference to the component to null,
  which allows the component to be garbage collected.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected abstract java.util.Optional&lt;javax.swing.JRootPane&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_getRootPaneOf(W)">_getRootPaneOf</a></span>&#8203;(<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>&nbsp;thisWindow)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected abstract swingtree.AbstractBuilder&lt;I,&#8203;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_newBuilderWithState(swingtree.BuilderState)">_newBuilderWithState</a></span>&#8203;(swingtree.BuilderState&lt;C&gt;&nbsp;newState)</code></th>
<td class="colLast">
<div class="block">An internal wither method which creates a new builder instance with the provided
  <code>BuilderState</code> stored inside it.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected &lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_onShow(sprouts.Val,C,java.util.function.BiConsumer)">_onShow</a></span>&#8203;(sprouts.Val&lt;T&gt;&nbsp;val,
       C&nbsp;c,
       java.util.function.BiConsumer&lt;C,&#8203;T&gt;&nbsp;displayAction)</code></th>
<td class="colLast">
<div class="block">Use this to register a state change listener for the provided property
  which will be executed by the UI thread (see <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected &lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_onShow(sprouts.Vals,C,java.util.function.BiConsumer)">_onShow</a></span>&#8203;(sprouts.Vals&lt;T&gt;&nbsp;vals,
       C&nbsp;c,
       java.util.function.BiConsumer&lt;C,&#8203;sprouts.ValsDelegate&lt;T&gt;&gt;&nbsp;displayAction)</code></th>
<td class="colLast">
<div class="block">Use this to register a state change listener for the provided property list
  which will be executed by the UI thread (see <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_runInApp(java.lang.Runnable)">_runInApp</a></span>&#8203;(java.lang.Runnable&nbsp;action)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected &lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_runInApp(T,java.util.function.Consumer)">_runInApp</a></span>&#8203;(T&nbsp;value,
         java.util.function.Consumer&lt;T&gt;&nbsp;action)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_runInUI(java.lang.Runnable)">_runInUI</a></span>&#8203;(java.lang.Runnable&nbsp;action)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setTitleOf(W,java.lang.String)">_setTitleOf</a></span>&#8203;(<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>&nbsp;thisWindow,
           java.lang.String&nbsp;title)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>protected abstract swingtree.BuilderState&lt;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_state()">_state</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the state of the builder, which is a container for the wrapped component
  as well as it's type and current <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_this()">_this</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>protected swingtree.AbstractBuilder&lt;I,&#8203;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_with(java.util.function.Consumer)">_with</a></span>&#8203;(java.util.function.Consumer&lt;C&gt;&nbsp;componentMutator)</code></th>
<td class="colLast">
<div class="block">Creates a new builder with the provided component mutation applied to the wrapped component.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>protected &lt;T&gt;&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_withOnShow(sprouts.Val,java.util.function.BiConsumer)">_withOnShow</a></span>&#8203;(sprouts.Val&lt;T&gt;&nbsp;val,
           java.util.function.BiConsumer&lt;C,&#8203;T&gt;&nbsp;displayAction)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>protected &lt;T&gt;&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_withOnShow(sprouts.Vals,java.util.function.BiConsumer)">_withOnShow</a></span>&#8203;(sprouts.Vals&lt;T&gt;&nbsp;vals,
           java.util.function.BiConsumer&lt;C,&#8203;sprouts.ValsDelegate&lt;T&gt;&gt;&nbsp;displayAction)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;B extends swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;javax.swing.JComponent&gt;&gt;<br>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(B...)">add</a></span>&#8203;(B...&nbsp;builders)</code></th>
<td class="colLast">
<div class="block">This method provides the same functionality as the other "add" methods.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(E...)">add</a></span>&#8203;(E...&nbsp;components)</code></th>
<td class="colLast">
<div class="block">This builder class expects its implementations to be builder types
  for anything which can be built in a nested tree-like structure.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(java.util.List)">add</a></span>&#8203;(java.util.List&lt;E&gt;&nbsp;components)</code></th>
<td class="colLast">
<div class="block">This builder class expects its implementations to be builder types
  for anything which can be built in a nested tree-like structure.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;T extends javax.swing.JComponent&gt;<br>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(swingtree.UIForAnySwing)">add</a></span>&#8203;(<a href="UIForAnySwing.html" title="class in swingtree">UIForAnySwing</a>&lt;?,&#8203;T&gt;&nbsp;builder)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apply(java.util.function.Consumer)">apply</a></span>&#8203;(java.util.function.Consumer&lt;I&gt;&nbsp;building)</code></th>
<td class="colLast">
<div class="block">Use this to continue building UI inside a provided lambda
  if you need to introduce some imperative code in between
  the building process.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyIf(boolean,java.util.function.Consumer)">applyIf</a></span>&#8203;(boolean&nbsp;condition,
       java.util.function.Consumer&lt;I&gt;&nbsp;building)</code></th>
<td class="colLast">
<div class="block">Use this to build or not build UI, based on a boolean condition value and a consumer
  lambda which continues the building process if the previous boolean is true.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyIfPresent(java.util.Optional)">applyIfPresent</a></span>&#8203;(java.util.Optional&lt;java.util.function.Consumer&lt;I&gt;&gt;&nbsp;building)</code></th>
<td class="colLast">
<div class="block">Allows you to build declarative UI conditionally,
  meaning that the UI is only built if the provided <code>Optional</code> value is present.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="OptionalUI.html" title="class in swingtree">OptionalUI</a>&lt;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#component()">component</a></span>()</code></th>
<td class="colLast">
<div class="block">The optional component managed by this builder.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(java.lang.Object)">equals</a></span>&#8203;(java.lang.Object&nbsp;obj)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>&lt;T extends C&gt;<br>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(java.lang.Class)">get</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;type)</code></th>
<td class="colLast">
<div class="block">This method completes the building process for the wrapped
  <code>JComponent</code> type by returning it.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>C</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getComponent()">getComponent</a></span>()</code></th>
<td class="colLast">
<div class="block">The component managed by this builder.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>java.lang.Class&lt;C&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getType()">getType</a></span>()</code></th>
<td class="colLast">
<div class="block">The type class of the component managed by this builder.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashCode()">hashCode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onActivated(sprouts.Action)">onActivated</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onActivate)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowActivated(WindowEvent)</code> events
 which are invoked when the Window is set to be the active Window.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onClose(sprouts.Action)">onClose</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onClose)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowClosing(WindowEvent)</code> events
 which are invoked when a window is in the process of being closed.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onClosed(sprouts.Action)">onClosed</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onClose)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowClosed(WindowEvent)</code> events
 which are invoked when a window has been closed.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onDeactivated(sprouts.Action)">onDeactivated</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onDeactivate)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowDeactivated(WindowEvent)</code> events
 which are invoked when a Window is no longer the active Window.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onDeiconified(sprouts.Action)">onDeiconified</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onDeiconify)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowDeiconified(WindowEvent)</code> events
 which are invoked when a window is changed from a minimized
 to a normal state, usually by the user restoring it from the task bar.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onFocusGain(sprouts.Action)">onFocusGain</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.FocusEvent&gt;&gt;&nbsp;onFocus)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>FocusListener</code>
 to the component, to receive those focus events where the wrapped component gains input focus.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onFocusLoss(sprouts.Action)">onFocusLoss</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.FocusEvent&gt;&gt;&nbsp;onFocus)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a focus listener
 to receive those focus events where the wrapped component loses input focus.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onIconified(sprouts.Action)">onIconified</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onIconify)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowIconified(WindowEvent)</code> events
 which are invoked when a window is changed from a normal to a minimized state.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onInputFocusGained(sprouts.Action)">onInputFocusGained</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onFocusGained)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowFocusListener.windowGainedFocus(WindowEvent)</code> events
 which are invoked when the window is set to be gaining input focus, which means
 that the Window, or one of its subcomponents, will receive keyboard
 events.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onInputFocusLost(sprouts.Action)">onInputFocusLost</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onFocusLost)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowFocusListener.windowLostFocus(WindowEvent)</code> events
 which are invoked when the window is set to be losing input focus, which means
 that input focus is being transferred to another Window or no Window at all and
 that keyboard events will no longer be delivered to the Window or any of
 its subcomponents.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onOpened(sprouts.Action)">onOpened</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onOpen)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowOpened(WindowEvent)</code> events
 which are invoked when a window has been opened.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onPressed(swingtree.input.Keyboard.Key,sprouts.Action)">onPressed</a></span>&#8203;(<a href="input/Keyboard.Key.html" title="enum in swingtree.input">Keyboard.Key</a>&nbsp;key,
         sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.ActionEvent&gt;&gt;&nbsp;onKeyPressed)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>KeyListener</code> to the component,
 to receive key events triggered when the wrapped component receives a particular
 keyboard input matching the provided <a href="input/Keyboard.Key.html" title="enum in swingtree.input"><code>Keyboard.Key</code></a>.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onStateChanged(sprouts.Action)">onStateChanged</a></span>&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onStateChanged)</code></th>
<td class="colLast">
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowStateListener.windowStateChanged(WindowEvent)</code> events
 which are invoked when a window has been changed.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>I</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#peek(swingtree.api.Peeker)">peek</a></span>&#8203;(<a href="api/Peeker.html" title="interface in swingtree.api">Peeker</a>&lt;C&gt;&nbsp;action)</code></th>
<td class="colLast">
<div class="block">Use this if you wish to access the component wrapped by this builder directly.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#show()">show</a></span>()</code></th>
<td class="colLast">
<div class="block">Makes the window visible in the center of the screen.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withTitle(java.lang.String)">withTitle</a></span>&#8203;(java.lang.String&nbsp;title)</code></th>
<td class="colLast">
<div class="block">Adds a title to the window.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withTitle(sprouts.Val)">withTitle</a></span>&#8203;(sprouts.Val&lt;java.lang.String&gt;&nbsp;title)</code></th>
<td class="colLast">
<div class="block">Binds a text property to the window determining the title displayed in the top bar of the window.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>UIForAnyWindow</h4>
<pre>public&nbsp;UIForAnyWindow()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="withTitle(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withTitle</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;withTitle&#8203;(java.lang.String&nbsp;title)</pre>
<div class="block">Adds a title to the window. <br>
  Note that the way this is displayed depends on the window type and the
  operating system.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>title</code> - The title to be shown in the top bar of the window.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder.</dd>
</dl>
</li>
</ul>
<a id="withTitle(sprouts.Val)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withTitle</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;withTitle&#8203;(sprouts.Val&lt;java.lang.String&gt;&nbsp;title)</pre>
<div class="block">Binds a text property to the window determining the title displayed in the top bar of the window. <br>
  Note that the way this is displayed depends on the window type and the
  operating system.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>title</code> - The title property whose text will be shown in the top bar of the window.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder.</dd>
</dl>
</li>
</ul>
<a id="show()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>show</h4>
<pre class="methodSignature">public abstract&nbsp;void&nbsp;show()</pre>
<div class="block">Makes the window visible in the center of the screen.</div>
</li>
</ul>
<a id="_getRootPaneOf(java.awt.Window)">
<!--   -->
</a><a id="_getRootPaneOf(W)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_getRootPaneOf</h4>
<pre class="methodSignature">protected abstract&nbsp;java.util.Optional&lt;javax.swing.JRootPane&gt;&nbsp;_getRootPaneOf&#8203;(<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>&nbsp;thisWindow)</pre>
</li>
</ul>
<a id="_setTitleOf(java.awt.Window,java.lang.String)">
<!--   -->
</a><a id="_setTitleOf(W,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setTitleOf</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;_setTitleOf&#8203;(<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>&nbsp;thisWindow,
                                    java.lang.String&nbsp;title)</pre>
</li>
</ul>
<a id="onPressed(swingtree.input.Keyboard.Key,sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onPressed</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onPressed&#8203;(<a href="input/Keyboard.Key.html" title="enum in swingtree.input">Keyboard.Key</a>&nbsp;key,
                         sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.ActionEvent&gt;&gt;&nbsp;onKeyPressed)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>KeyListener</code> to the component,
 to receive key events triggered when the wrapped component receives a particular
 keyboard input matching the provided <a href="input/Keyboard.Key.html" title="enum in swingtree.input"><code>Keyboard.Key</code></a>.
 <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - The <a href="input/Keyboard.Key.html" title="enum in swingtree.input"><code>Keyboard.Key</code></a> which should be matched to the key event.</dd>
<dd><code>onKeyPressed</code> - The <code>Action</code> which will be executed once the wrapped component received the targeted key press.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onFocusGain(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onFocusGain</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onFocusGain&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.FocusEvent&gt;&gt;&nbsp;onFocus)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>FocusListener</code>
 to the component, to receive those focus events where the wrapped component gains input focus.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onFocus</code> - The <code>Action</code> which should be executed once the input focus was gained on the wrapped component.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onFocusLoss(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onFocusLoss</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onFocusLoss&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.FocusEvent&gt;&gt;&nbsp;onFocus)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a focus listener
 to receive those focus events where the wrapped component loses input focus.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onFocus</code> - The <code>Action</code> which should be executed once the input focus was lost on the wrapped component.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onClose(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onClose</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onClose&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onClose)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowClosing(WindowEvent)</code> events
 which are invoked when a window is in the process of being closed.
 The close operation can be overridden at this point (see <code>WindowConstants.DO_NOTHING_ON_CLOSE</code>). <br>
 Note that this kind of event is typically triggered when the user clicks
 the close button in the top bar of the window.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onClose</code> - The <code>Action</code> which should be invoked when the wrapped component is in the process of being closed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onClosed(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onClosed</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onClosed&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onClose)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowClosed(WindowEvent)</code> events
 which are invoked when a window has been closed. <br>
 Note that this kind of event is typically triggered when the user clicks
 the close button in the top bar of the window.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onClose</code> - The <code>Action</code> which should be invoked when the wrapped component has been closed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onOpened(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onOpened</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onOpened&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onOpen)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowOpened(WindowEvent)</code> events
 which are invoked when a window has been opened. <br>
 Note that this kind of event is typically triggered when the user clicks
 the close button in the top bar of the window.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onOpen</code> - The <code>Action</code> which should be invoked when the wrapped component has been opened.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onIconified(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onIconified</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onIconified&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onIconify)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowIconified(WindowEvent)</code> events
 which are invoked when a window is changed from a normal to a minimized state.
 For many platforms, a minimized window is displayed as the icon
 specified in the window's iconImage property.
 <br>
 Minification is usually triggered when the user clicks the minimize button
 in the top bar of the window. But this depends on the operating system.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onIconify</code> - The <code>Action</code> which should be invoked when the wrapped component has been iconified.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onDeiconified(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDeiconified</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onDeiconified&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onDeiconify)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowDeiconified(WindowEvent)</code> events
 which are invoked when a window is changed from a minimized
 to a normal state, usually by the user restoring it from the task bar.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onDeiconify</code> - The <code>Action</code> which should be invoked when the wrapped component has been deiconified.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onActivated(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onActivated</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onActivated&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onActivate)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowActivated(WindowEvent)</code> events
 which are invoked when the Window is set to be the active Window.
 Only a Frame or a Dialog can be the active Window.
 The native windowing system may denote the active Window or
 its children with special decorations, such as a highlighted title bar.
 The active Window is always either the focused Window,
 or the first Frame or Dialog that is an owner of the focused Window.
 So this kind of event is usually triggered when the user makes the window active
 by clicking it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onActivate</code> - The <code>Action</code> which should be invoked when the wrapped component has been activated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onDeactivated(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onDeactivated</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onDeactivated&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onDeactivate)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowListener.windowDeactivated(WindowEvent)</code> events
 which are invoked when a Window is no longer the active Window. Only a Frame or a
 Dialog can be the active Window. The native windowing system may denote
 the active Window or its children with special decorations, such as a
 highlighted title bar. The active Window is always either the focused
 Window, or the first Frame or Dialog that is an owner of the focused
 Window.
 This kind of event typically occurs when the user clicks another window
 in the task bar of the operating system.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onDeactivate</code> - The <code>Action</code> which should be invoked when the wrapped component has been deactivated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onStateChanged(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onStateChanged</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onStateChanged&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onStateChanged)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowStateListener.windowStateChanged(WindowEvent)</code> events
 which are invoked when a window has been changed. <br>
 Note that this kind of event is typically invoked when the window is
 iconified, minimized, maximized or restored.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onStateChanged</code> - The <code>Action</code> which should be invoked when the wrapped component has been changed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onInputFocusGained(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onInputFocusGained</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onInputFocusGained&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onFocusGained)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowFocusListener.windowGainedFocus(WindowEvent)</code> events
 which are invoked when the window is set to be gaining input focus, which means
 that the Window, or one of its subcomponents, will receive keyboard
 events.
 This event is typically triggered when the user clicks the window.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onFocusGained</code> - The <code>Action</code> which should be invoked when the wrapped component has gained input focus.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="onInputFocusLost(sprouts.Action)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onInputFocusLost</h4>
<pre class="methodSignature">public final&nbsp;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">I</a>&nbsp;onInputFocusLost&#8203;(sprouts.Action&lt;<a href="WindowDelegate.html" title="interface in swingtree">WindowDelegate</a>&lt;<a href="UIForAnyWindow.html" title="type parameter in UIForAnyWindow">W</a>,&#8203;java.awt.event.WindowEvent&gt;&gt;&nbsp;onFocusLost)</pre>
<div class="block">Adds the supplied <code>Action</code> wrapped in a <code>WindowListener</code>
 to the component, to receive <code>WindowFocusListener.windowLostFocus(WindowEvent)</code> events
 which are invoked when the window is set to be losing input focus, which means
 that input focus is being transferred to another Window or no Window at all and
 that keyboard events will no longer be delivered to the Window or any of
 its subcomponents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onFocusLost</code> - The <code>Action</code> which should be invoked when the wrapped component has lost input focus.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="add(java.awt.Component[])">
<!--   -->
</a><a id="add(E...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre class="methodSignature">@SafeVarargs
public final&nbsp;I&nbsp;add&#8203;(E...&nbsp;components)</pre>
<div class="block">This builder class expects its implementations to be builder types
  for anything which can be built in a nested tree-like structure.
  Implementations of this abstract method ought to enable support for nested building.
  <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>components</code> - An array of component instances which ought to be added to the wrapped component type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="_addComponentsTo(java.awt.Component,java.awt.Component[])">
<!--   -->
</a><a id="_addComponentsTo(C,E...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_addComponentsTo</h4>
<pre class="methodSignature">@SafeVarargs
protected final&nbsp;void&nbsp;_addComponentsTo&#8203;(C&nbsp;thisComponent,
                                      E...&nbsp;componentsToBeAdded)</pre>
</li>
</ul>
<a id="add(swingtree.UIForAnySwing)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre class="methodSignature">public final&nbsp;&lt;T extends javax.swing.JComponent&gt;&nbsp;I&nbsp;add&#8203;(<a href="UIForAnySwing.html" title="class in swingtree">UIForAnySwing</a>&lt;?,&#8203;T&gt;&nbsp;builder)</pre>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type of the <code>JComponent</code> which is wrapped by the provided builder.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>builder</code> - A builder for another <code>JComponent</code> instance which ought to be added to the wrapped component type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="_addComponentTo(java.awt.Component,java.awt.Component,java.lang.Object)">
<!--   -->
</a><a id="_addComponentTo(C,E,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_addComponentTo</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;_addComponentTo&#8203;(C&nbsp;thisComponent,
                                        E&nbsp;component,
                                        java.lang.Object&nbsp;conf)</pre>
<div class="block">This builder class expects its implementations to be builder types
 for anything which can be built in a nested tree-like structure.
 Implementations of this abstract method ought to enable support for nested building.
 <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thisComponent</code> - The component which is wrapped by this builder.</dd>
<dd><code>component</code> - A component instance which ought to be added to the wrapped component type.</dd>
<dd><code>conf</code> - The layout constraint which ought to be used to add the component to the wrapped component type.</dd>
</dl>
</li>
</ul>
<a id="_addBuilderTo(java.awt.Component,swingtree.AbstractNestedBuilder,java.lang.Object)">
<!--   -->
</a><a id="_addBuilderTo(C,swingtree.AbstractNestedBuilder,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_addBuilderTo</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;_addBuilderTo&#8203;(C&nbsp;thisComponent,
                                   swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;?&gt;&nbsp;builder,
                                   java.lang.Object&nbsp;conf)</pre>
</li>
</ul>
<a id="add(swingtree.AbstractNestedBuilder[])">
<!--   -->
</a><a id="add(B...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre class="methodSignature">@SafeVarargs
public final&nbsp;&lt;B extends swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;javax.swing.JComponent&gt;&gt;&nbsp;I&nbsp;add&#8203;(B...&nbsp;builders)</pre>
<div class="block">This method provides the same functionality as the other "add" methods.
  However, it bypasses the necessity to call the "get" method by
  calling it internally for you. <br>
  This helps to improve readability, especially when the degree of nesting is very low.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>B</code> - The type of the builder instances which are used to configure the components that will be added to the component wrapped by this builder.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>builders</code> - An array of builder instances whose JComponents ought to be added to the one wrapped by this builder.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="_addBuildersTo(java.awt.Component,swingtree.AbstractNestedBuilder[])">
<!--   -->
</a><a id="_addBuildersTo(C,B...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_addBuildersTo</h4>
<pre class="methodSignature">@SafeVarargs
protected final&nbsp;&lt;B extends swingtree.AbstractNestedBuilder&lt;?,&#8203;?,&#8203;javax.swing.JComponent&gt;&gt;&nbsp;void&nbsp;_addBuildersTo&#8203;(C&nbsp;thisComponent,
                                                                                                                        B...&nbsp;builders)</pre>
</li>
</ul>
<a id="add(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre class="methodSignature">public final&nbsp;I&nbsp;add&#8203;(java.util.List&lt;E&gt;&nbsp;components)</pre>
<div class="block">This builder class expects its implementations to be builder types
  for anything which can be built in a nested tree-like structure.
  Implementations of this abstract method ought to enable support for nested building.
  <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>components</code> - A list of component instances which ought to be added to the wrapped component type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="_childCount(java.awt.Component)">
<!--   -->
</a><a id="_childCount(C)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_childCount</h4>
<pre class="methodSignature">protected final&nbsp;int&nbsp;_childCount&#8203;(C&nbsp;c)</pre>
</li>
</ul>
<a id="_state()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_state</h4>
<pre class="methodSignature">protected abstract&nbsp;swingtree.BuilderState&lt;C&gt;&nbsp;_state()</pre>
<div class="block">Returns the state of the builder, which is a container for the wrapped component
  as well as it's type and current <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The state of the builder.</dd>
</dl>
</li>
</ul>
<a id="_newBuilderWithState(swingtree.BuilderState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_newBuilderWithState</h4>
<pre class="methodSignature">protected abstract&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;&nbsp;_newBuilderWithState&#8203;(swingtree.BuilderState&lt;C&gt;&nbsp;newState)</pre>
<div class="block">An internal wither method which creates a new builder instance with the provided
  <code>BuilderState</code> stored inside it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newState</code> - The new state which should be stored inside the new builder instance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new builder instance with the provided state stored inside it.</dd>
</dl>
</li>
</ul>
<a id="_with(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_with</h4>
<pre class="methodSignature">protected final&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;&nbsp;_with&#8203;(java.util.function.Consumer&lt;C&gt;&nbsp;componentMutator)</pre>
<div class="block">Creates a new builder with the provided component mutation applied to the wrapped component. <br>
  Note that the SwingTree builders are immutable, which means that this method
  does not mutate the current builder instance, but instead creates a new builder instance
  with a new <code>BuilderState</code> which contains the provided component mutation (see <code>BuilderState.withMutator(Consumer)</code>).
  Also see <a href="#_newBuilderWithState(swingtree.BuilderState)"><code>_newBuilderWithState(BuilderState)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>componentMutator</code> - A consumer lambda which receives the wrapped component and
                         is then used to apply some builder action to it.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new builder instance with the provided component mutation applied to the wrapped component.</dd>
</dl>
</li>
</ul>
<a id="_runInUI(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_runInUI</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;_runInUI&#8203;(java.lang.Runnable&nbsp;action)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>action</code> - An action which should be executed by the UI thread,
               which is determined by implementations of the <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>,
               also see <a href="UI.html#use(swingtree.threading.EventProcessor,java.util.function.Supplier)"><code>UI.use(EventProcessor, Supplier)</code></a>. <br>
               Usually the UI thread is AWT's Event Dispatch Thread (EDT).</dd>
</dl>
</li>
</ul>
<a id="_runInApp(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_runInApp</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;_runInApp&#8203;(java.lang.Runnable&nbsp;action)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>action</code> - An action which should be executed by the application thread,
               which is determined by implementations of the <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>,
               also see <a href="UI.html#use(swingtree.threading.EventProcessor,java.util.function.Supplier)"><code>UI.use(EventProcessor, Supplier)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="_runInApp(java.lang.Object,java.util.function.Consumer)">
<!--   -->
</a><a id="_runInApp(T,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_runInApp</h4>
<pre class="methodSignature">protected final&nbsp;&lt;T&gt;&nbsp;void&nbsp;_runInApp&#8203;(T&nbsp;value,
                                   java.util.function.Consumer&lt;T&gt;&nbsp;action)</pre>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type of the value.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - A value which should be captured and then passed to the provided action
              on the current application thread (see <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a> and <a href="UI.html#use(swingtree.threading.EventProcessor,java.util.function.Supplier)"><code>UI.use(EventProcessor, Supplier)</code></a>).</dd>
<dd><code>action</code> - A consumer lambda which is executed by the application thread
               and receives the provided value.</dd>
</dl>
</li>
</ul>
<a id="_onShow(sprouts.Val,java.awt.Component,java.util.function.BiConsumer)">
<!--   -->
</a><a id="_onShow(sprouts.Val,C,java.util.function.BiConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_onShow</h4>
<pre class="methodSignature">protected final&nbsp;&lt;T&gt;&nbsp;void&nbsp;_onShow&#8203;(sprouts.Val&lt;T&gt;&nbsp;val,
                                 C&nbsp;c,
                                 java.util.function.BiConsumer&lt;C,&#8203;T&gt;&nbsp;displayAction)</pre>
<div class="block">Use this to register a state change listener for the provided property
  which will be executed by the UI thread (see <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type of the item wrapped by the provided property.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>val</code> - A property whose state changes should be listened to on the UI thread.</dd>
<dd><code>c</code> - The component which is wrapped by this builder.</dd>
<dd><code>displayAction</code> - A consumer lambda receiving the provided value and
                      is then executed by the UI thread.</dd>
</dl>
</li>
</ul>
<a id="_withOnShow(sprouts.Val,java.util.function.BiConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_withOnShow</h4>
<pre class="methodSignature">protected final&nbsp;&lt;T&gt;&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;&nbsp;_withOnShow&#8203;(sprouts.Val&lt;T&gt;&nbsp;val,
                                                                     java.util.function.BiConsumer&lt;C,&#8203;T&gt;&nbsp;displayAction)</pre>
</li>
</ul>
<a id="_onShow(sprouts.Vals,java.awt.Component,java.util.function.BiConsumer)">
<!--   -->
</a><a id="_onShow(sprouts.Vals,C,java.util.function.BiConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_onShow</h4>
<pre class="methodSignature">protected final&nbsp;&lt;T&gt;&nbsp;void&nbsp;_onShow&#8203;(sprouts.Vals&lt;T&gt;&nbsp;vals,
                                 C&nbsp;c,
                                 java.util.function.BiConsumer&lt;C,&#8203;sprouts.ValsDelegate&lt;T&gt;&gt;&nbsp;displayAction)</pre>
<div class="block">Use this to register a state change listener for the provided property list
  which will be executed by the UI thread (see <a href="threading/EventProcessor.html" title="interface in swingtree.threading"><code>EventProcessor</code></a>).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type of the items wrapped by the provided property list.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vals</code> - A property list whose state changes should be listened to on the UI thread.</dd>
<dd><code>c</code> - The component which is wrapped by this builder.</dd>
<dd><code>displayAction</code> - A consumer lambda receiving the action delegate and
                      is then executed by the UI thread.</dd>
</dl>
</li>
</ul>
<a id="_withOnShow(sprouts.Vals,java.util.function.BiConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_withOnShow</h4>
<pre class="methodSignature">protected final&nbsp;&lt;T&gt;&nbsp;swingtree.AbstractBuilder&lt;I,&#8203;C&gt;&nbsp;_withOnShow&#8203;(sprouts.Vals&lt;T&gt;&nbsp;vals,
                                                                     java.util.function.BiConsumer&lt;C,&#8203;sprouts.ValsDelegate&lt;T&gt;&gt;&nbsp;displayAction)</pre>
</li>
</ul>
<a id="_this()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_this</h4>
<pre class="methodSignature">protected final&nbsp;I&nbsp;_this()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The builder instance itself based on the type parameter <code>&lt;I&gt;</code>.</dd>
</dl>
</li>
</ul>
<a id="_detachStrongRef()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_detachStrongRef</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;_detachStrongRef()</pre>
<div class="block">This method sets the strong reference to the component to null,
  which allows the component to be garbage collected.
  This is important to avoid memory leaks, as a component is typically
  part of a tree of components, and if one component is not garbage collected,
  then the whole tree is not garbage collected.</div>
</li>
</ul>
<a id="getComponent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getComponent</h4>
<pre class="methodSignature">public final&nbsp;C&nbsp;getComponent()</pre>
<div class="block">The component managed by this builder.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The component managed by this builder.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if this method is called from a thread other than the EDT
                                and this UI is configured to be decoupled from the application thread.
                                See <a href="UI.html#use(swingtree.threading.EventProcessor,java.util.function.Supplier)"><code>UI.use(EventProcessor, Supplier)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="component()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>component</h4>
<pre class="methodSignature">public final&nbsp;<a href="OptionalUI.html" title="class in swingtree">OptionalUI</a>&lt;C&gt;&nbsp;component()</pre>
<div class="block">The optional component managed by this builder.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An <a href="OptionalUI.html" title="class in swingtree"><code>OptionalUI</code></a> wrapping a component or null.
         This optional will throw an exception if the
         application has an application thread (see <a href="UI.html#use(swingtree.threading.EventProcessor,java.util.function.Supplier)"><code>UI.use(EventProcessor, Supplier)</code></a>)
         and this method is called from a thread other than the EDT.</dd>
</dl>
</li>
</ul>
<a id="getType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getType</h4>
<pre class="methodSignature">public final&nbsp;java.lang.Class&lt;C&gt;&nbsp;getType()</pre>
<div class="block">The type class of the component managed by this builder.
  See documentation for method "build" for more information.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The type class of the component managed by this builder.</dd>
</dl>
</li>
</ul>
<a id="peek(swingtree.api.Peeker)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peek</h4>
<pre class="methodSignature">public final&nbsp;I&nbsp;peek&#8203;(<a href="api/Peeker.html" title="interface in swingtree.api">Peeker</a>&lt;C&gt;&nbsp;action)</pre>
<div class="block">Use this if you wish to access the component wrapped by this builder directly.
  This is useful for more fine-grained control, like for example calling
  methods like "setName", "setTitle", and so on... <br>
  This method accepts a lambda to which the component wrapped by this builder will be supplied.
  The lambda can then call said methods or perform other tasks which
  might be relevant to the component while also not
  breaking the benefits of nesting and method chaining provided by this class...
  <br>
  The below example shows how this method allows for more fine-grained control over the wrapped component:
  <pre><code>
      UI.panel()
      peek( panel -&gt; panel.setDebugGraphicsOptions(true) );
  </code></pre>
  <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>action</code> - A Consumer lambda which simply returned the wrapped JComponent type for interacting it.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="applyIf(boolean,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyIf</h4>
<pre class="methodSignature">public final&nbsp;I&nbsp;applyIf&#8203;(boolean&nbsp;condition,
                       java.util.function.Consumer&lt;I&gt;&nbsp;building)</pre>
<div class="block">Use this to build or not build UI, based on a boolean condition value and a consumer
  lambda which continues the building process if the previous boolean is true.
  This builder instance will simply be supplied to the provided consumer lambda.
  Inside the second lambda, one can then continue building the UI while also not
  breaking the benefits of nesting and method chaining provided by this builder...
  <p>
  This is in essence a more advanced version of <a href="#apply(java.util.function.Consumer)"><code>apply(Consumer)</code></a>.
  <br>
  Here a simple usage example:
  <pre><code>
      UI.panel()
      .applyIf( userIsLoggedIn, ui -&gt; ui
          .add( UI.label("Welcome back!") )
          .add( UI.button("Logout")).onClick( () -&gt; logout() )
          .add( UI.button("Settings")).onClick( () -&gt; showSettings() )
      )
      .applyIf( !userIsLoggedIn, ui -&gt; ui
          .add( UI.label("Please login to continue.") )
          .add( UI.button("Login")).onClick( () -&gt; login() );
      );
  </code></pre>
  Here we use theis method to build a panel
  with different content depending on whether the user is logged in or not.
  <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>condition</code> - The truth value which determines if the second consumer lambda is executed or not.</dd>
<dd><code>building</code> - A <code>Consumer</code> lambda which simply consumes this builder instance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="applyIfPresent(java.util.Optional)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyIfPresent</h4>
<pre class="methodSignature">public final&nbsp;I&nbsp;applyIfPresent&#8203;(java.util.Optional&lt;java.util.function.Consumer&lt;I&gt;&gt;&nbsp;building)</pre>
<div class="block">Allows you to build declarative UI conditionally,
  meaning that the UI is only built if the provided <code>Optional</code> value is present.
  <p>
  Consider the following example:
  <pre><code>
 // In your view model:
 public Optional&lt;MySubModel&gt; getM() {
   return Optional.ofNullable(this.model);
 }

 // In your view:
 UI.panel()
 .add(UI.label("Maybe Sub Model:"))
 .applyIfPresent(vm.getM().map(m-&gt;ui-&gt;ui
   .add(UI.label("Hello Sub Model!"))
   .add(UI.label("A:")
   .add(UI.textField(m.getA()))
   .add(UI.label("B:"))
   .add(UI.textField(m.getB()))
   // ...
 ))
 .add(UI.label("Some other stuff..."));
 </code></pre>

 The <code>applyIfPresent</code> method takes an <code>Optional&lt;Consumer&lt;I&gt;&gt;</code> as parameter,
 where <code>I</code> is the type of the UI builder.
 This allows you to map the optional value to a consumer which is only executed if the value is present.
 If the optional value is present, the consumer is executed with the
 current UI builder as a parameter, which allows you to continue building the UI as usual.
 <br>
 The <code>m-&gt;ui-&gt;ui</code> may look a bit confusing at first, but it is simply a lambda expression
 which takes the optional value and returns a consumer (<code>ui-&gt;ui... </code>) which takes the UI builder
 as a parameter.
 <br>
 This is in essence a more advanced <code>Optional</code> centric version of <a href="#applyIf(boolean,java.util.function.Consumer)"><code>applyIf(boolean, Consumer)</code></a>
 and <a href="#apply(java.util.function.Consumer)"><code>apply(Consumer)</code></a>.
 <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>building</code> - An optional consumer lambda which simply consumes this builder node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="apply(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply</h4>
<pre class="methodSignature">public final&nbsp;I&nbsp;apply&#8203;(java.util.function.Consumer&lt;I&gt;&nbsp;building)</pre>
<div class="block">Use this to continue building UI inside a provided lambda
  if you need to introduce some imperative code in between
  the building process. <br>
  This is especially useful for when you need to build UI based on loops.
  The current builder instance will simply be supplied to the provided <code>Consumer</code> lambda.
  Inside the supplied lambda, you can then continue building the UI while also not
  breaking the benefits of nesting and method chaining, effectively preserving
  the declarative nature of the builder.
  <br><br>
  Here is a simple example of how this method can be used to build a panel
  with a variable amount of images displayed in a grid:
  <pre><code>
      UI.panel("wrap 3")
      .apply( ui -&gt; {
          for ( String path : imagePaths )
              ui.add( UI.label(UI.icon(path)) );
      });
  </code></pre>
  <br><br>
  Here is another example of how this method can be used to build a panel
  with a variable amount of buttons displayed in a grid:
  <pre><code>
    UI.panel("wrap 4")
    .apply( ui -&gt; {
      for ( int i = 0; i &lt; numOfButtons; i++ )
          ui.add( UI.button("Button " + i)
          .onClick( () -&gt; {...} );
    });
  </code></pre>
  <br><br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>building</code> - A Consumer lambda which simply consumes this builder instance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This very instance, which enables builder-style method chaining.</dd>
</dl>
</li>
</ul>
<a id="get(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public final&nbsp;&lt;T extends C&gt;&nbsp;T&nbsp;get&#8203;(java.lang.Class&lt;T&gt;&nbsp;type)</pre>
<div class="block">This method completes the building process for the wrapped
  <code>JComponent</code> type by returning it.
  However, it also expects the user to pass the class of the <code>JComponent</code>
  wrapped by this builder! This is not out of necessity but for better
  readability when using the builder in more extensive ways where
  the beginning and end of the method chaining and nesting of the builder does
  not fit on one screen. <br>
  In such cases the expression "<code>.get(MyJComponent.class)</code>" helps
  to identify which type of <code>JComponent</code> is currently being built on a given
  nesting layer... <br><br>
  Here is a simple example that demonstrates this technique using
  a <code>JPanel</code> and a <code>JMenuBar</code>:
  <pre><code>
      UI.panel()
      .add(
          UI.menuBar()
          .add( UI.menu("File") )
          .add( UI.menuItem("Open") )
          .add( UI.menuItem("Save") )
          // ...
          .add( UI.menuItem("Exit") )
          .get(JMenuBar.class)
      )
      .add( UI.button("Click me!") )
      .get(JPanel.class);
  </code></pre>
  As you can see, the expression "<code>.get(JMenuBar.class)</code>" as well as the expression
  "<code>.get(JPanel.class)</code>" at the end of the builder chain help to identify
  which type of <code>JComponent</code> is currently being built and returned.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type parameter of the component which this builder wraps.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The type class of the component which this builder wraps.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The result of the building process, namely: a type of JComponent.</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public final&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a id="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre class="methodSignature">public final&nbsp;int&nbsp;hashCode()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a id="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>equals</h4>
<pre class="methodSignature">public final&nbsp;boolean&nbsp;equals&#8203;(java.lang.Object&nbsp;obj)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
